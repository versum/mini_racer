(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  This mixin provides an 'ajax' method that can be used to perform ajax requests that
  respect Discourse paths and the run loop.
**/

var _trackView = false;
var _transientHeader = null;

Discourse.Ajax = Em.Mixin.create({

  setTransientHeader: function(k, v) {
    _transientHeader = {key: k, value: v};
  },

  viewTrackingRequired: function() {
    _trackView = true;
  },

  /**
    Our own $.ajax method. Makes sure the .then method executes in an Ember runloop
    for performance reasons. Also automatically adjusts the URL to support installs
    in subfolders.

    @method ajax
  **/
  ajax: function() {
    var url, args;
    var ajax;

    if (arguments.length === 1) {
      if (typeof arguments[0] === "string") {
        url = arguments[0];
        args = {};
      } else {
        args = arguments[0];
        url = args.url;
        delete args.url;
      }
    } else if (arguments.length === 2) {
      url = arguments[0];
      args = arguments[1];
    }

    if (args.success || args.error) {
      throw "Discourse.ajax should use promises";
    }

    var performAjax = function(resolve, reject) {

      args.headers = args.headers || {};

      if (_transientHeader) {
        args.headers[_transientHeader.key] = _transientHeader.value;
        _transientHeader = null;
      }

      if (_trackView && (!args.type || args.type === "GET")) {
        _trackView = false;
        // DON'T CHANGE: rack is prepending "HTTP_" in the header's name
        args.headers['Discourse-Track-View'] = "true";
      }

      args.success = function(data, textStatus, xhr) {
        if (xhr.getResponseHeader('Discourse-Readonly')) {
          Ember.run(function() {
            Discourse.Site.currentProp('isReadOnly', true);
          });
        }

        if (args.returnXHR) {
          data = { result: data, xhr: xhr };
        }

        Ember.run(null, resolve, data);
      };

      args.error = function(xhr, textStatus, errorThrown) {
        // note: for bad CSRF we don't loop an extra request right away.
        //  this allows us to eliminate the possibility of having a loop.
        if (xhr.status === 403 && xhr.responseText === "['BAD CSRF']") {
          Discourse.Session.current().set('csrfToken', null);
        }

        // If it's a parsererror, don't reject
        if (xhr.status === 200) return args.success(xhr);

        // Fill in some extra info
        xhr.jqTextStatus = textStatus;
        xhr.requestedUrl = url;

        Ember.run(null, reject, {
          jqXHR: xhr,
          textStatus: textStatus,
          errorThrown: errorThrown
        });
      };

      // We default to JSON on GET. If we don't, sometimes if the server doesn't return the proper header
      // it will not be parsed as an object.
      if (!args.type) args.type = 'GET';
      if (!args.dataType && args.type.toUpperCase() === 'GET') args.dataType = 'json';

      if (args.dataType === "script") {
        args.headers['Discourse-Script'] = true;
      }

      if (args.type === 'GET' && args.cache !== true) {
        args.cache = false;
      }

      ajax = $.ajax(Discourse.getURL(url), args);
    };

    var promise;

    // For cached pages we strip out CSRF tokens, need to round trip to server prior to sending the
    //  request (bypass for GET, not needed)
    if(args.type && args.type.toUpperCase() !== 'GET' && !Discourse.Session.currentProp('csrfToken')){
      promise = new Ember.RSVP.Promise(function(resolve, reject){
        ajax = $.ajax(Discourse.getURL('/session/csrf'), {cache: false})
           .success(function(result){
              Discourse.Session.currentProp('csrfToken', result.csrf);
              performAjax(resolve, reject);
           });
      });
    } else {
      promise = new Ember.RSVP.Promise(performAjax);
    }

    promise.abort = function(){
      if (ajax) {
        ajax.abort();
      }
    };

    return promise;
  }

});


// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/*global Favcount:true*/

var DiscourseResolver = require('discourse/ember/resolver').default;

// Allow us to import Ember
define('ember', ['exports'], function(__exports__) {
  __exports__.default = Ember;
});

var _pluginCallbacks = [];

window.Discourse = Ember.Application.extend(Discourse.Ajax, {
  rootElement: '#main',
  _docTitle: document.title,
  __TAGS_INCLUDED__: true,

  getURL: function(url) {
    if (!url) return url;

    // if it's a non relative URL, return it.
    if (url !== '/' && !/^\/[^\/]/.test(url)) return url;

    if (url.indexOf(Discourse.BaseUri) !== -1) return url;
    if (url[0] !== "/") url = "/" + url;

    return Discourse.BaseUri + url;
  },

  getURLWithCDN: function(url) {
    url = this.getURL(url);
    // only relative urls
    if (Discourse.CDN && /^\/[^\/]/.test(url)) {
      url = Discourse.CDN + url;
    } else if (Discourse.S3CDN) {
      url = url.replace(Discourse.S3BaseUrl, Discourse.S3CDN);
    }
    return url;
  },

  Resolver: DiscourseResolver,

  _titleChanged: function() {
    var title = this.get('_docTitle') || Discourse.SiteSettings.title;

    // if we change this we can trigger changes on document.title
    // only set if changed.
    if($('title').text() !== title) {
      $('title').text(title);
    }

    var notifyCount = this.get('notifyCount');
    if (notifyCount > 0 && !Discourse.User.currentProp('dynamic_favicon')) {
      title = "(" + notifyCount + ") " + title;
    }

    document.title = title;
  }.observes('_docTitle', 'hasFocus', 'notifyCount'),

  faviconChanged: function() {
    if(Discourse.User.currentProp('dynamic_favicon')) {
      var url = Discourse.SiteSettings.favicon_url;
      if (/^http/.test(url)) {
        url = Discourse.getURL("/favicon/proxied?" + encodeURIComponent(url));
      }
      new Favcount(url).set(
        this.get('notifyCount')
      );
    }
  }.observes('notifyCount'),

  // The classes of buttons to show on a post
  postButtons: function() {
    return Discourse.SiteSettings.post_menu.split("|").map(function(i) {
      return i.replace(/\+/, '').capitalize();
    });
  }.property(),

  notifyTitle: function(count) {
    this.set('notifyCount', count);
  },

  notifyBackgroundCountIncrement: function() {
    if (!this.get('hasFocus')) {
      this.set('backgroundNotify', true);
      this.set('notifyCount', (this.get('notifyCount') || 0) + 1);
    }
  },

  resetBackgroundNotifyCount: function() {
    if (this.get('hasFocus') && this.get('backgroundNotify')) {
      this.set('notifyCount', 0);
    }
    this.set('backgroundNotify', false);
  }.observes('hasFocus'),

  authenticationComplete: function(options) {
    // TODO, how to dispatch this to the controller without the container?
    var loginController = Discourse.__container__.lookup('controller:login');
    return loginController.authenticationComplete(options);
  },

  /**
    Start up the Discourse application by running all the initializers we've defined.

    @method start
  **/
  start: function() {

    $('noscript').remove();

    Object.keys(requirejs._eak_seen).forEach(function(key) {
      if (/\/pre\-initializers\//.test(key)) {
        var module = require(key, null, null, true);
        if (!module) { throw new Error(key + ' must export an initializer.'); }
        Discourse.initializer(module.default);
      }
    });

    Object.keys(requirejs._eak_seen).forEach(function(key) {
      if (/\/initializers\//.test(key)) {
        var module = require(key, null, null, true);
        if (!module) { throw new Error(key + ' must export an initializer.'); }

        var init = module.default;
        var oldInitialize = init.initialize;
        init.initialize = function(app) {
          oldInitialize.call(this, app.container, Discourse);
        };

        Discourse.instanceInitializer(init);
      }
    });

    // Plugins that are registered via `<script>` tags.
    var withPluginApi = require('discourse/lib/plugin-api').withPluginApi;
    var initCount = 0;
    _pluginCallbacks.forEach(function(cb) {
      Discourse.instanceInitializer({
        name: "_discourse_plugin_" + (++initCount),
        after: 'inject-objects',
        initialize: function() {
          withPluginApi(cb.version, cb.code);
        }
      });
    });
  },

  requiresRefresh: function(){
    var desired = Discourse.get("desiredAssetVersion");
    return desired && Discourse.get("currentAssetVersion") !== desired;
  }.property("currentAssetVersion", "desiredAssetVersion"),

  _registerPluginCode: function(version, code) {
    _pluginCallbacks.push({ version: version, code: code });
  },

  assetVersion: Ember.computed({
    get: function() {
      return this.get("currentAssetVersion");
    },
    set: function(key, val) {
      if(val) {
        if (this.get("currentAssetVersion")) {
          this.set("desiredAssetVersion", val);
        } else {
          this.set("currentAssetVersion", val);
        }
      }
      return this.get("currentAssetVersion");
    }
  })
}).create();

function RemovedObject(name) {
  this._removedName = name;
}

function methodMissing() {
  console.warn("The " + this._removedName + " object has been removed from Discourse " +
               "and your plugin needs to be updated.");
};

Discourse.RemovedObject = RemovedObject;

['reopen', 'registerButton', 'on', 'off'].forEach(function(m) { RemovedObject.prototype[m] = methodMissing; });

['discourse/views/post', 'discourse/components/post-menu'].forEach(function(moduleName) {
  define(moduleName, [], function() { return new RemovedObject(moduleName); });
});



// IIFE Wrapped Content Ends

 })(this);
define("ember-addons/utils/extract-value", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = extractValue;

    function extractValue(desc) {
      return desc.value || typeof desc.initializer === 'function' && desc.initializer();
    }
  });
define("ember-addons/utils/handle-descriptor", 
  ["ember","./extract-value","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";


    __exports__["default"] = handleDescriptor;

    var Ember = __dependency1__["default"];
    var extractValue = __dependency2__["default"];

    var computed = Ember.computed;
    var get = Ember.get;

    function handleDescriptor(target, key, desc) {
      var params = arguments.length <= 3 || arguments[3] === undefined ? [] : arguments[3];

      return {
        enumerable: desc.enumerable,
        configurable: desc.configurable,
        writeable: desc.writeable,
        initializer: function () {
          var computedDescriptor = undefined;

          if (desc.writable) {
            var val = extractValue(desc);
            if (typeof val === 'object') {
              var value = {};
              if (val.get) {
                value.get = callUserSuppliedGet(params, val.get);
              }
              if (val.set) {
                value.set = callUserSuppliedSet(params, val.set);
              }
              computedDescriptor = value;
            } else {
              computedDescriptor = callUserSuppliedGet(params, val);
            }
          } else {
            throw new Error('ember-computed-decorators does not support using getters and setters');
          }

          return computed.apply(null, params.concat(computedDescriptor));
        }
      };
    }

    function niceAttr(attr) {
      var parts = attr.split('.');
      var i = undefined;

      for (i = 0; i < parts.length; i++) {
        if (parts[i] === '@each' || parts[i] === '[]' || parts[i].indexOf('{') !== -1) {
          break;
        }
      }

      return parts.slice(0, i).join('.');
    }

    function callUserSuppliedGet(params, func) {
      params = params.map(niceAttr);
      return function () {
        var _this = this;

        var paramValues = params.map(function (p) {
          return get(_this, p);
        });

        return func.apply(this, paramValues);
      };
    }

    function callUserSuppliedSet(params, func) {
      params = params.map(niceAttr);
      return function (key, value) {
        var _this2 = this;

        var paramValues = params.map(function (p) {
          return get(_this2, p);
        });
        paramValues.unshift(value);

        return func.apply(this, paramValues);
      };
    }
  });
define("ember-addons/utils/is-descriptor", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = isDescriptor;

    function isDescriptor(item) {
      return item && typeof item === 'object' && 'writable' in item && 'enumerable' in item && 'configurable' in item;
    }
  });
define("ember-addons/decorator-alias", 
  ["./utils/extract-value","exports"],
  function(__dependency1__, __exports__) {
    "use strict";


    __exports__["default"] = decoratorAlias;
    var extractValue = __dependency1__["default"];
    function decoratorAlias(fn, errorMessage) {
      return function () {
        for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }

        // determine if user called as @computed('blah', 'blah') or @computed
        if (params.length === 0) {
          throw new Error(errorMessage);
        } else {
          return function (target, key, desc) {
            return {
              enumerable: desc.enumerable,
              configurable: desc.configurable,
              writable: desc.writable,
              initializer: function () {
                var value = extractValue(desc);
                return fn.apply(null, params.concat(value));
              }
            };
          };
        }
      };
    }
  });
define("ember-addons/macro-alias", 
  ["./utils/is-descriptor","exports"],
  function(__dependency1__, __exports__) {
    "use strict";


    __exports__["default"] = macroAlias;

    function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

    var isDescriptor = __dependency1__["default"];

    function handleDescriptor(target, property, desc, fn) {
      var params = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];

      return {
        enumerable: desc.enumerable,
        configurable: desc.configurable,
        writable: desc.writable,
        initializer: function () {
          return fn.apply(undefined, _toConsumableArray(params));
        }
      };
    }
    function macroAlias(fn) {
      return function () {
        for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }

        if (isDescriptor(params[params.length - 1])) {
          return handleDescriptor.apply(undefined, params.concat([fn]));
        } else {
          return function (target, property, desc) {
            return handleDescriptor(target, property, desc, fn, params);
          };
        }
      };
    }
  });
define("ember-addons/ember-computed-decorators", 
  ["./utils/handle-descriptor","./utils/is-descriptor","./utils/extract-value","./decorator-alias","./macro-alias","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    var _slice = Array.prototype.slice;

    __exports__["default"] = computedDecorator;

    __exports__.readOnly = readOnly;
    var handleDescriptor = __dependency1__["default"];
    var isDescriptor = __dependency2__["default"];
    var extractValue = __dependency3__["default"];

    var decoratorAlias = __dependency4__["default"];

    var macroAlias = __dependency5__["default"];

    function computedDecorator() {
      for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }

      // determine if user called as @computed('blah', 'blah') or @computed
      if (isDescriptor(params[params.length - 1])) {
        return handleDescriptor.apply(undefined, arguments);
      } else {
        return function () /* target, key, desc */{
          return handleDescriptor.apply(undefined, _slice.call(arguments).concat([params]));
        };
      }
    }

    function readOnly(target, name, desc) {
      return {
        writable: false,
        enumerable: desc.enumerable,
        configurable: desc.configurable,
        initializer: function () {
          var value = extractValue(desc);
          return value.readOnly();
        }
      };
    }

    var on = decoratorAlias(Ember.on, 'Can not `on` without event names');
    __exports__.on = on;
    var observes = decoratorAlias(Ember.observer, 'Can not `observe` without property names');__exports__.observes = observes;
    var alias = macroAlias(Ember.computed.alias);
    __exports__.alias = alias;
    var and = macroAlias(Ember.computed.and);
    __exports__.and = and;
    var bool = macroAlias(Ember.computed.bool);
    __exports__.bool = bool;
    var collect = macroAlias(Ember.computed.collect);
    __exports__.collect = collect;
    var empty = macroAlias(Ember.computed.empty);
    __exports__.empty = empty;
    var equal = macroAlias(Ember.computed.equal);
    __exports__.equal = equal;
    var filter = macroAlias(Ember.computed.filter);
    __exports__.filter = filter;
    var filterBy = macroAlias(Ember.computed.filterBy);
    __exports__.filterBy = filterBy;
    var gt = macroAlias(Ember.computed.gt);
    __exports__.gt = gt;
    var gte = macroAlias(Ember.computed.gte);
    __exports__.gte = gte;
    var lt = macroAlias(Ember.computed.lt);
    __exports__.lt = lt;
    var lte = macroAlias(Ember.computed.lte);
    __exports__.lte = lte;
    var map = macroAlias(Ember.computed.map);
    __exports__.map = map;
    var mapBy = macroAlias(Ember.computed.mapBy);
    __exports__.mapBy = mapBy;
    var match = macroAlias(Ember.computed.match);
    __exports__.match = match;
    var max = macroAlias(Ember.computed.max);
    __exports__.max = max;
    var min = macroAlias(Ember.computed.min);
    __exports__.min = min;
    var none = macroAlias(Ember.computed.none);
    __exports__.none = none;
    var not = macroAlias(Ember.computed.not);
    __exports__.not = not;
    var notEmpty = macroAlias(Ember.computed.notEmpty);
    __exports__.notEmpty = notEmpty;
    var oneWay = macroAlias(Ember.computed.oneWay);
    __exports__.oneWay = oneWay;
    var or = macroAlias(Ember.computed.or);
    __exports__.or = or;
    var readOnly = macroAlias(Ember.computed.readOnly);
    __exports__.readOnly = readOnly;
    var reads = macroAlias(Ember.computed.reads);
    __exports__.reads = reads;
    var setDiff = macroAlias(Ember.computed.setDiff);
    __exports__.setDiff = setDiff;
    var sort = macroAlias(Ember.computed.sort);
    __exports__.sort = sort;
    var sum = macroAlias(Ember.computed.sum);
    __exports__.sum = sum;
    var union = macroAlias(Ember.computed.union);
    __exports__.union = union;
    var uniq = macroAlias(Ember.computed.uniq);
    __exports__.uniq = uniq;
  });
define("discourse/lib/hash", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.hashString = hashString;
    /*eslint no-bitwise:0 */

    // Note: before changing this be aware the same algo is used server side for avatars.

    function hashString(str) {
      var hash = 0;
      for (var i = 0; i < str.length; i++) {
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash |= 0;
      }
      return hash;
    }
  });
define("discourse/lib/load-script", 
  ["exports"],
  function(__exports__) {
    "use strict";


    __exports__["default"] = loadScript;
    /* global assetPath */

    var _loaded = {};
    var _loading = {};

    function loadWithTag(path, cb) {
      var head = document.getElementsByTagName('head')[0];

      var s = document.createElement('script');
      s.src = path;
      if (Ember.Test) {
        Ember.Test.pendingAjaxRequests++;
      }
      head.appendChild(s);

      s.onload = s.onreadystatechange = function (_, abort) {
        if (Ember.Test) {
          Ember.Test.pendingAjaxRequests--;
        }
        if (abort || !s.readyState || s.readyState === "loaded" || s.readyState === "complete") {
          s = s.onload = s.onreadystatechange = null;
          if (!abort) {
            Ember.run(null, cb);
          }
        }
      };
    }
    function loadScript(url, opts) {
      opts = opts || {};

      return new Ember.RSVP.Promise(function (resolve) {
        url = Discourse.getURL(assetPath && assetPath(url) || url);

        // If we already loaded this url
        if (_loaded[url]) {
          return resolve();
        }
        if (_loading[url]) {
          return _loading[url].then(resolve);
        }

        var done;
        _loading[url] = new Ember.RSVP.Promise(function (_done) {
          done = _done;
        });

        _loading[url].then(function () {
          delete _loading[url];
        });

        var cb = function () {
          _loaded[url] = true;
          done();
          resolve();
        };

        var cdnUrl = url;

        // Scripts should always load from CDN
        if (Discourse.CDN && url[0] === "/" && url[1] !== "/") {
          cdnUrl = Discourse.CDN.replace(/\/$/, "") + url;
        }

        // Some javascript depends on the path of where it is loaded (ace editor)
        // to dynamically load more JS. In that case, add the `scriptTag: true`
        // option.
        if (opts.scriptTag) {
          loadWithTag(cdnUrl, cb);
        } else {
          Discourse.ajax({ url: cdnUrl, dataType: "script", cache: true }).then(cb);
        }
      });
    }
  });
define("discourse/lib/notification-levels", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      WATCHING: 3,
      TRACKING: 2,
      REGULAR: 1,
      MUTED: 0
    };
  });
define("discourse/lib/app-events", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Object.extend(Ember.Evented);
  });
define("discourse/lib/url", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /*global LockOn:true*/

    var _jumpScheduled = false;
    var rewrites = [];

    var DiscourseURL = Ember.Object.extend({

      // Used for matching a topic
      TOPIC_REGEXP: /\/t\/([^\/]+)\/(\d+)\/?(\d+)?/,

      isJumpScheduled: function () {
        return _jumpScheduled;
      },

      // Jumps to a particular post in the stream
      jumpToPost: function (postNumber, opts) {
        var holderId = '#post_' + postNumber;
        var offset = function () {
          var $header = $('header');
          var $title = $('#topic-title');
          var windowHeight = $(window).height() - $title.height();
          var expectedOffset = $title.height() - $header.find('.contents').height() + windowHeight / 5;

          return $header.outerHeight(true) + (expectedOffset < 0 ? 0 : expectedOffset);
        };

        Em.run.schedule('afterRender', function () {
          if (postNumber === 1) {
            $(window).scrollTop(0);
            return;
          }

          var lockon = new LockOn(holderId, { offsetCalculator: offset });
          var holder = $(holderId);

          if (holder.length > 0 && opts && opts.skipIfOnScreen) {
            // if we are on screen skip
            var elementTop = lockon.elementTop(),
                scrollTop = $(window).scrollTop(),
                windowHeight = $(window).height() - offset(),
                height = holder.height();

            if (elementTop > scrollTop && elementTop + height < scrollTop + windowHeight) {
              return;
            }
          }

          lockon.lock();
        });
      },

      /**
        Browser aware replaceState. Will only be invoked if the browser supports it.
         @method replaceState
        @param {String} path The path we are replacing our history state with.
      **/
      replaceState: function (path) {
        if (window.history && window.history.pushState && window.history.replaceState && !navigator.userAgent.match(/((iPod|iPhone|iPad).+\bOS\s+[1-4]|WebApps\/.+CFNetwork)/) && window.location.pathname !== path) {

          // Always use replaceState in the next runloop to prevent weird routes changing
          // while URLs are loading. For example, while a topic loads it sets `currentPost`
          // which triggers a replaceState even though the topic hasn't fully loaded yet!
          Em.run.next(function () {
            var location = DiscourseURL.get('router.location');
            if (location && location.replaceURL) {
              location.replaceURL(path);
            }
          });
        }
      },

      // Scroll to the same page, different anchor
      scrollToId: function (id) {
        if (Em.isEmpty(id)) {
          return;
        }

        _jumpScheduled = true;
        Em.run.schedule('afterRender', function () {
          var $elem = $(id);
          if ($elem.length === 0) {
            $elem = $("[name='" + id.replace('#', '') + "']");
          }
          if ($elem.length > 0) {
            $('html,body').scrollTop($elem.offset().top - $('header').height() - 15);
            _jumpScheduled = false;
          }
        });
      },

      routeToTag: function (a) {
        if (a && a.host !== document.location.host) {
          document.location = a.href;
          return false;
        }

        return this.routeTo(a.href);
      },

      /**
        Our custom routeTo method is used to intelligently overwrite default routing
        behavior.
         It contains the logic necessary to route within a topic using replaceState to
        keep the history intact.
      **/
      routeTo: function (path, opts) {
        if (Em.isEmpty(path)) {
          return;
        }

        if (Discourse.get('requiresRefresh')) {
          document.location.href = Discourse.getURL(path);
          return;
        }

        // Protocol relative URLs
        if (path.indexOf('//') === 0) {
          document.location = path;
          return;
        }

        // Scroll to the same page, different anchor
        if (path.indexOf('#') === 0) {
          this.scrollToId(path);
          this.replaceState(path);
          return;
        }

        var oldPath = window.location.pathname;
        path = path.replace(/(https?\:)?\/\/[^\/]+/, '');

        // handle prefixes
        if (path.match(/^\//)) {
          var rootURL = Discourse.BaseUri === undefined ? "/" : Discourse.BaseUri;
          rootURL = rootURL.replace(/\/$/, '');
          path = path.replace(rootURL, '');
        }

        // Rewrite /my/* urls
        if (path.indexOf('/my/') === 0) {
          var currentUser = Discourse.User.current();
          if (currentUser) {
            path = path.replace('/my/', '/users/' + currentUser.get('username_lower') + "/");
          } else {
            document.location.href = "/404";
            return;
          }
        }

        rewrites.forEach(function (rw) {
          return path = path.replace(rw.regexp, rw.replacement);
        });

        if (this.navigatedToPost(oldPath, path)) {
          return;
        }
        // Schedule a DOM cleanup event
        Em.run.scheduleOnce('afterRender', Discourse.Route, 'cleanDOM');

        // TODO: Extract into rules we can inject into the URL handler
        if (this.navigatedToHome(oldPath, path)) {
          return;
        }

        if (oldPath === path) {
          // If navigating to the same path send an app event. Views can watch it
          // and tell their controllers to refresh
          this.appEvents.trigger('url:refresh');
        }

        return this.handleURL(path, opts);
      },

      rewrite: function (regexp, replacement) {
        rewrites.push({ regexp: regexp, replacement: replacement });
      },

      redirectTo: function (url) {
        window.location = Discourse.getURL(url);
      },

      /**
       * Determines whether a URL is internal or not
       *
       * @method isInternal
       * @param {String} url
      **/
      isInternal: function (url) {
        if (url && url.length) {
          if (url.indexOf('//') === 0) {
            url = "http:" + url;
          }
          if (url.indexOf('#') === 0) {
            return true;
          }
          if (url.indexOf('/') === 0) {
            return true;
          }
          if (url.indexOf(this.origin()) === 0) {
            return true;
          }
          if (url.replace(/^http/, 'https').indexOf(this.origin()) === 0) {
            return true;
          }
          if (url.replace(/^https/, 'http').indexOf(this.origin()) === 0) {
            return true;
          }
        }
        return false;
      },

      /**
        @private
         If the URL is in the topic form, /t/something/:topic_id/:post_number
        then we want to apply some special logic. If the post_number changes within the
        same topic, use replaceState and instruct our controller to load more posts.
         @method navigatedToPost
        @param {String} oldPath the previous path we were on
        @param {String} path the path we're navigating to
      **/
      navigatedToPost: function (oldPath, path) {
        var _this = this;

        var newMatches = this.TOPIC_REGEXP.exec(path);
        var newTopicId = newMatches ? newMatches[2] : null;

        if (newTopicId) {
          var oldMatches = this.TOPIC_REGEXP.exec(oldPath);
          var oldTopicId = oldMatches ? oldMatches[2] : null;

          // If the topic_id is the same
          if (oldTopicId === newTopicId) {
            var _ret = (function () {
              DiscourseURL.replaceState(path);

              var container = Discourse.__container__;
              var topicController = container.lookup('controller:topic');
              var opts = {};
              var postStream = topicController.get('model.postStream');

              if (newMatches[3]) {
                opts.nearPost = newMatches[3];
              }
              if (path.match(/last$/)) {
                opts.nearPost = topicController.get('model.highest_post_number');
              }
              var closest = opts.nearPost || 1;

              opts.cancelSummary = true;

              postStream.refresh(opts).then(function () {
                topicController.setProperties({
                  'model.currentPost': closest,
                  enteredAt: new Date().getTime().toString()
                });

                var closestPost = postStream.closestPostForPostNumber(closest);
                var progress = postStream.progressIndexOfPost(closestPost);
                var progressController = container.lookup('controller:topic-progress');

                progressController.set('progressPosition', progress);
                _this.appEvents.trigger('post:highlight', closest);
              }).then(function () {
                DiscourseURL.jumpToPost(closest, { skipIfOnScreen: true });
              });

              // Abort routing, we have replaced our state.
              return {
                v: true
              };
            })();

            if (typeof _ret === 'object') return _ret.v;
          }
        }

        return false;
      },

      /**
        @private
         Handle the custom case of routing to the root path from itself.
         @param {String} oldPath the previous path we were on
        @param {String} path the path we're navigating to
      **/
      navigatedToHome: function (oldPath, path) {
        var homepage = Discourse.Utilities.defaultHomepage();

        if (window.history && window.history.pushState && (path === "/" || path === "/" + homepage) && (oldPath === "/" || oldPath === "/" + homepage)) {
          this.appEvents.trigger('url:refresh');
          return true;
        }

        return false;
      },

      // This has been extracted so it can be tested.
      origin: function () {
        return window.location.origin + (Discourse.BaseUri === "/" ? '' : Discourse.BaseUri);
      },

      /**
        @private
         Get a handle on the application's router. Note that currently it uses `__container__` which is not
        advised but there is no other way to access the router.
         @property router
      **/
      router: (function () {
        return Discourse.__container__.lookup('router:main');
      }).property().volatile(),

      // Get a controller. Note that currently it uses `__container__` which is not
      // advised but there is no other way to access the router.
      controllerFor: function (name) {
        return Discourse.__container__.lookup('controller:' + name);
      },

      /**
        Be wary of looking up the router. In this case, we have links in our
        HTML, say form compiled markdown posts, that need to be routed.
      **/
      handleURL: function (path, opts) {
        opts = opts || {};

        var router = this.get('router');

        if (opts.replaceURL) {
          this.replaceState(path);
        } else {
          router.router.updateURL(path);
        }

        var split = path.split('#');
        var elementId = undefined;

        if (split.length === 2) {
          path = split[0];
          elementId = split[1];
        }

        var transition = router.handleURL(path);
        transition._discourse_intercepted = true;
        transition.promise.then(function () {
          if (elementId) {

            _jumpScheduled = true;
            Em.run.next('afterRender', function () {
              var offset = $('#' + elementId).offset();
              if (offset && offset.top) {
                $('html, body').scrollTop(offset.top - $('header').height() - 10);
                _jumpScheduled = false;
              }
            });
          }
        });
      }
    }).create();

    __exports__["default"] = DiscourseURL;
  });
define("discourse/lib/debounce", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      Debounce a Javascript function. This means if it's called many times in a time limit it
      should only be executed once (at the end of the limit counted from the last call made).
      Original function will be called with the context and arguments from the last call made.
    **/

    __exports__["default"] = function (func, wait) {
      var self = undefined,
          args = undefined;
      var later = function () {
        func.apply(self, args);
      };

      return function () {
        self = this;
        args = arguments;

        Ember.run.debounce(null, later, wait);
      };
    }
  });
define("discourse/lib/quote", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {

      REGEXP: /\[quote=([^\]]*)\]((?:[\s\S](?!\[quote=[^\]]*\]))*?)\[\/quote\]/im,

      // Build the BBCode quote around the selected text
      build: function (post, contents, opts) {
        var contents_hashed, result, sansQuotes, stripped, stripped_hashed, tmp;
        var full = opts && opts["full"];
        var raw = opts && opts["raw"];

        if (!post) {
          return "";
        }

        if (!contents) contents = "";

        sansQuotes = contents.replace(this.REGEXP, '').trim();
        if (sansQuotes.length === 0) {
          return "";
        }

        // Escape the content of the quote
        sansQuotes = sansQuotes.replace(/</g, "&lt;").replace(/>/g, "&gt;");

        result = "[quote=\"" + post.get('username') + ", post:" + post.get('post_number') + ", topic:" + post.get('topic_id');

        /* Strip the HTML from cooked */
        tmp = document.createElement('div');
        tmp.innerHTML = post.get('cooked');
        stripped = tmp.textContent || tmp.innerText || "";

        /*
          Let's remove any non alphanumeric characters as a kind of hash. Yes it's
          not accurate but it should work almost every time we need it to. It would be unlikely
          that the user would quote another post that matches in exactly this way.
        */
        stripped_hashed = stripped.replace(/[^a-zA-Z0-9]/g, '');
        contents_hashed = contents.replace(/[^a-zA-Z0-9]/g, '');

        /* If the quote is the full message, attribute it as such */
        if (full || stripped_hashed === contents_hashed) result += ", full:true";
        result += "\"]\n" + (raw ? contents : sansQuotes) + "\n[/quote]\n\n";

        return result;
      }

    };
  });
define("discourse/lib/key-value-store", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // A simple key value store that uses LocalStorage
    var safeLocalStorage = undefined;

    try {
      safeLocalStorage = localStorage;
      if (localStorage["disableLocalStorage"] === "true") {
        safeLocalStorage = null;
      } else {
        // makes sure we can write to the local storage
        safeLocalStorage["safeLocalStorage"] = true;
      }
    } catch (e) {
      // cookies disabled, we don't care
      safeLocalStorage = null;
    }

    var KeyValueStore = function (ctx) {
      this.context = ctx;
    };

    KeyValueStore.prototype = {
      abandonLocal: function () {
        if (!safeLocalStorage) {
          return;
        }

        var i = safeLocalStorage.length - 1;
        while (i >= 0) {
          var k = safeLocalStorage.key(i);
          if (k.substring(0, this.context.length) === this.context) {
            safeLocalStorage.removeItem(k);
          }
          i--;
        }
        return true;
      },

      remove: function (key) {
        if (!safeLocalStorage) {
          return;
        }
        return safeLocalStorage.removeItem(this.context + key);
      },

      set: function (opts) {
        if (!safeLocalStorage) {
          return false;
        }
        safeLocalStorage[this.context + opts.key] = opts.value;
      },

      setObject: function (opts) {
        this.set({ key: opts.key, value: JSON.stringify(opts.value) });
      },

      get: function (key) {
        if (!safeLocalStorage) {
          return null;
        }
        return safeLocalStorage[this.context + key];
      },

      getInt: function (key, def) {
        if (!def) {
          def = 0;
        }
        if (!safeLocalStorage) {
          return def;
        }
        var result = parseInt(this.get(key));
        if (!isFinite(result)) {
          return def;
        }
        return result;
      },

      getObject: function (key) {
        if (!safeLocalStorage) {
          return null;
        }
        try {
          return JSON.parse(safeLocalStorage[this.context + key]);
        } catch (e) {}
      }
    };

    // API compatibility with `localStorage`
    KeyValueStore.prototype.getItem = KeyValueStore.prototype.get;
    KeyValueStore.prototype.removeItem = KeyValueStore.prototype.remove;
    KeyValueStore.prototype.setItem = function (key, value) {
      this.set({ key: key, value: value });
    };

    __exports__["default"] = KeyValueStore;
  });
define("discourse/lib/helpers", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.htmlHelper = htmlHelper;
    __exports__.registerHelper = registerHelper;
    __exports__.registerUnbound = registerUnbound;
    // `Ember.Helper` is only available in versions after 1.12

    function htmlHelper(fn) {
      if (Ember.Helper) {
        return Ember.Helper.helper(function () {
          return new Handlebars.SafeString(fn.apply(this, Array.prototype.slice.call(arguments)) || '');
        });
      } else {
        return Ember.Handlebars.makeBoundHelper(function () {
          return new Handlebars.SafeString(fn.apply(this, Array.prototype.slice.call(arguments)) || '');
        });
      }
    }

    function registerHelper(name, fn) {
      Ember.HTMLBars._registerHelper(name, fn);
    }

    var get = Discourse.EmberCompatHandlebars.get;

    function resolveParams(ctx, options) {
      var params = {};
      var hash = options.hash;

      if (hash) {
        if (options.hashTypes) {
          Object.keys(hash).forEach(function (k) {
            var type = options.hashTypes[k];
            if (type === "STRING" || type === "StringLiteral") {
              params[k] = hash[k];
            } else if (type === "ID" || type === "PathExpression") {
              params[k] = get(ctx, hash[k], options);
            }
          });
        } else {
          params = hash;
        }
      }
      return params;
    }

    function registerUnbound(name, fn) {
      var func = function (property, options) {
        if (options.types && (options.types[0] === "ID" || options.types[0] === "PathExpression")) {
          property = get(this, property, options);
        }

        return fn.call(this, property, resolveParams(this, options));
      };

      Handlebars.registerHelper(name, func);
      Ember.Handlebars.registerHelper(name, func);
    }
  });
define("discourse/helpers/i18n", 
  ["discourse/lib/helpers"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__.registerUnbound;

    registerUnbound('i18n', function (key, params) {
      return I18n.t(key, params);
    });

    registerUnbound('replace-emoji', function (text) {
      return new Handlebars.SafeString(Discourse.Emoji.unescape(text));
    });
  });
define("discourse/helpers/fa-icon", 
  ["virtual-dom","discourse/lib/helpers","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    __exports__.iconHTML = iconHTML;
    __exports__.iconNode = iconNode;
    var h = __dependency1__.h;
    var registerUnbound = __dependency2__.registerUnbound;

    function iconClasses(icon, params) {
      var classes = "fa fa-" + icon;
      if (params.modifier) {
        classes += " fa-" + params.modifier;
      }
      if (params['class']) {
        classes += ' ' + params['class'];
      }
      return classes;
    }

    function iconHTML(icon, params) {
      params = params || {};

      var html = "<i class='" + iconClasses(icon, params) + "'";
      if (params.label) {
        html += " aria-hidden='true'";
      }
      html += "></i>";
      if (params.label) {
        html += "<span class='sr-only'>" + I18n.t(params.label) + "</span>";
      }
      return html;
    }

    function iconNode(icon, params) {
      params = params || {};

      var properties = {
        className: iconClasses(icon, params),
        attributes: { "aria-hidden": true }
      };

      if (params.title) {
        properties.attributes.title = params.title;
      }

      if (params.label) {
        return h('i', properties, h('span.sr-only', I18n.t(params.label)));
      } else {
        return h('i', properties);
      }
    }

    registerUnbound('fa-icon', function (icon, params) {
      return new Handlebars.SafeString(iconHTML(icon, params));
    });
  });
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

// keep IIF for simpler testing

// EmberCompatHandlebars is a mechanism for quickly rendering templates which is Ember aware
// templates are highly compatible with Ember so you don't need to worry about calling "get"
// and computed properties function, additionally it uses stringParams like Ember does

(function(){

  // compat with ie8 in case this gets picked up elsewhere
  var objectCreate = Object.create || function(parent) {
    function F() {}
    F.prototype = parent;
    return new F();
  };


  var RawHandlebars = Handlebars.create();

  RawHandlebars.helper = function() {};
  RawHandlebars.helpers = objectCreate(Handlebars.helpers);

  RawHandlebars.helpers.get = function(context, options){
    var firstContext =  options.contexts[0];
    var val = firstContext[context];

    if (val && val.isDescriptor) { return Em.get(firstContext, context); }
    val = val === undefined ? Em.get(firstContext, context): val;
    return val;
  };

  // adds compatability so this works with stringParams
  var stringCompatHelper = function(fn){

    var old = RawHandlebars.helpers[fn];
    RawHandlebars.helpers[fn] = function(context,options){
      return old.apply(this, [
          RawHandlebars.helpers.get(context,options),
          options
      ]);
    };
  };

  // #each .. in support (as format is transformed to this)
  RawHandlebars.registerHelper('each', function(localName,inKeyword,contextName,options){
    var list = Em.get(this, contextName);
    var output = [];
    var innerContext = Object.create(this);
    for (var i=0; i<list.length; i++) {
      innerContext[localName] = list[i];
      output.push(options.fn(innerContext));
    }
    return output.join('');
  });

  stringCompatHelper("if");
  stringCompatHelper("unless");
  stringCompatHelper("with");


  if (Handlebars.Compiler) {
    RawHandlebars.Compiler = function() {};
    RawHandlebars.Compiler.prototype = objectCreate(Handlebars.Compiler.prototype);
    RawHandlebars.Compiler.prototype.compiler = RawHandlebars.Compiler;

    RawHandlebars.JavaScriptCompiler = function() {};

    RawHandlebars.JavaScriptCompiler.prototype = objectCreate(Handlebars.JavaScriptCompiler.prototype);
    RawHandlebars.JavaScriptCompiler.prototype.compiler = RawHandlebars.JavaScriptCompiler;
    RawHandlebars.JavaScriptCompiler.prototype.namespace = "Discourse.EmberCompatHandlebars";

    function buildPath(blk, args) {

      var result = { type: "PathExpression",
                     data: false,
                     depth: blk.path.depth,
                     loc: blk.path.loc };

      // Server side precompile doesn't have jquery.extend
      Object.keys(args).forEach(function (a) {
        result[a] = args[a];
      });

      return result;
    }

    function replaceGet(ast) {
      var visitor = new Handlebars.Visitor();
      visitor.mutating = true;

      visitor.MustacheStatement = function(mustache) {
        if (!(mustache.params.length || mustache.hash)) {
          mustache.params[0] = mustache.path;
          mustache.path = buildPath(mustache, { parts: ['get'], original: 'get', strict: true, falsy: true });
        }
        return Handlebars.Visitor.prototype.MustacheStatement.call(this, mustache);
      };

      // rewrite `each x as |y|` as each y in x`
      // This allows us to use the same syntax in all templates
      visitor.BlockStatement = function(block) {
        if (block.path.original === 'each' && block.params.length === 1) {
          var paramName = block.program.blockParams[0];
          block.params = [ buildPath(block, { original: paramName }),
                           { type: "CommentStatement", value: "in" },
                           block.params[0] ];
          delete block.program.blockParams;
        }

        return Handlebars.Visitor.prototype.BlockStatement.call(this, block);
      };

      visitor.accept(ast);
    }

    RawHandlebars.precompile = function(value, asObject) {
      var ast = Handlebars.parse(value);
      replaceGet(ast);

      var options = {
        knownHelpers: {
          get: true
        },
        data: true,
        stringParams: true
      };

      asObject = asObject === undefined ? true : asObject;

      var environment = new RawHandlebars.Compiler().compile(ast, options);
      return new RawHandlebars.JavaScriptCompiler().compile(environment, options, undefined, asObject);
    };

    RawHandlebars.compile = function(string) {
      var ast = Handlebars.parse(string);
      replaceGet(ast);

      // this forces us to rewrite helpers
      var options = {  data: true, stringParams: true };
      var environment = new RawHandlebars.Compiler().compile(ast, options);
      var templateSpec = new RawHandlebars.JavaScriptCompiler().compile(environment, options, undefined, true);

      var template = RawHandlebars.template(templateSpec);
      template.isMethod = false;

      return template;
    };
  }

  RawHandlebars.get = function(ctx, property, options){
    if (options.types && options.data.view) {
      var view = options.data.view;
      return view.getStream ? view.getStream(property).value() : view.getAttr(property);
    } else {
      return Ember.get(ctx, property);
    }
  };

  Discourse.EmberCompatHandlebars = RawHandlebars;

})();


// IIFE Wrapped Content Ends

 })(this);
define("discourse/lib/computed", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.propertyEqual = propertyEqual;
    __exports__.propertyNotEqual = propertyNotEqual;
    __exports__.propertyGreaterThan = propertyGreaterThan;
    __exports__.propertyLessThan = propertyLessThan;
    __exports__.i18n = i18n;
    __exports__.fmt = fmt;
    __exports__.url = url;
    __exports__.endWith = endWith;
    __exports__.setting = setting;
    /**
      Returns whether two properties are equal to each other.

      @method propertyEqual
      @params {String} p1 the first property
      @params {String} p2 the second property
      @return {Function} computedProperty function
    **/

    function propertyEqual(p1, p2) {
      return Em.computed(function () {
        return this.get(p1) === this.get(p2);
      }).property(p1, p2);
    }

    /**
      Returns whether two properties are not equal to each other.

      @method propertyNotEqual
      @params {String} p1 the first property
      @params {String} p2 the second property
      @return {Function} computedProperty function
    **/

    function propertyNotEqual(p1, p2) {
      return Em.computed(function () {
        return this.get(p1) !== this.get(p2);
      }).property(p1, p2);
    }

    function propertyGreaterThan(p1, p2) {
      return Ember.computed(function () {
        return this.get(p1) > this.get(p2);
      }).property(p1, p2);
    }

    function propertyLessThan(p1, p2) {
      return Ember.computed(function () {
        return this.get(p1) < this.get(p2);
      }).property(p1, p2);
    }

    /**
      Returns i18n version of a string based on a property.

      @method i18n
      @params {String} properties* to format
      @params {String} format the i18n format string
      @return {Function} computedProperty function
    **/

    function i18n() {
      var args = Array.prototype.slice.call(arguments, 0);
      var format = args.pop();
      var computed = Em.computed(function () {
        var self = this;
        return I18n.t(format.fmt.apply(format, args.map(function (a) {
          return self.get(a);
        })));
      });
      return computed.property.apply(computed, args);
    }

    /**
      Uses an Ember String `fmt` call to format a string. See:
      http://emberjs.com/api/classes/Em.String.html#method_fmt

      @method fmt
      @params {String} properties* to format
      @params {String} format the format string
      @return {Function} computedProperty function
    **/

    function fmt() {
      var args = Array.prototype.slice.call(arguments, 0);
      var format = args.pop();
      var computed = Em.computed(function () {
        var self = this;
        return format.fmt.apply(format, args.map(function (a) {
          return self.get(a);
        }));
      });
      return computed.property.apply(computed, args);
    }

    /**
      Creates a URL using Discourse.getURL. It takes a fmt string just like
      fmt does.

      @method url
      @params {String} properties* to format
      @params {String} format the format string for the URL
      @return {Function} computedProperty function returning a URL
    **/

    function url() {
      var args = Array.prototype.slice.call(arguments, 0);
      var format = args.pop();
      var computed = Em.computed(function () {
        var self = this;
        return Discourse.getURL(format.fmt.apply(format, args.map(function (a) {
          return self.get(a);
        })));
      });
      return computed.property.apply(computed, args);
    }

    /**
      Returns whether properties end with a string

      @method endWith
      @params {String} properties* to check
      @params {String} substring the substring
      @return {Function} computedProperty function
    **/

    function endWith() {
      var args = Array.prototype.slice.call(arguments, 0);
      var substring = args.pop();
      var computed = Em.computed(function () {
        var self = this;
        return _.all(args.map(function (a) {
          return self.get(a);
        }), function (s) {
          var position = s.length - substring.length,
              lastIndex = s.lastIndexOf(substring);
          return lastIndex !== -1 && lastIndex === position;
        });
      });
      return computed.property.apply(computed, args);
    }

    /**
      Creates a property from a SiteSetting. In the future the plan is for them to
      be able to update when changed.

      @method setting
      @param {String} name of site setting
    **/

    function setting(name) {
      return Em.computed(function () {
        return Discourse.SiteSettings[name];
      }).property();
    }
  });
define("discourse/lib/formatter", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.shortDate = shortDate;
    __exports__.toTitleCase = toTitleCase;
    __exports__.longDate = longDate;
    __exports__.longDateNoYear = longDateNoYear;
    __exports__.updateRelativeAge = updateRelativeAge;
    __exports__.autoUpdatingRelativeAge = autoUpdatingRelativeAge;
    __exports__.relativeAge = relativeAge;
    __exports__.number = number;
    /* global BreakString:true */

    /*
    * memoize.js
    * by @philogb and @addyosmani
    * with further optimizations by @mathias
    * and @DmitryBaranovsk
    * perf tests: http://bit.ly/q3zpG3
    * Released under an MIT license.
    *
    * modified with cap by Sam
    */

    function cappedMemoize(fn, max) {
      fn.maxMemoize = max;
      fn.memoizeLength = 0;

      return function () {
        var args = Array.prototype.slice.call(arguments);
        var hash = "";
        var i = args.length;
        var currentArg = null;
        while (i--) {
          currentArg = args[i];
          hash += currentArg === new Object(currentArg) ? JSON.stringify(currentArg) : currentArg;
          if (!fn.memoize) {
            fn.memoize = {};
          }
        }
        if (hash in fn.memoize) {
          return fn.memoize[hash];
        } else {
          fn.memoizeLength++;
          if (fn.memoizeLength > max) {
            fn.memoizeLength = 0;
            fn.memoize = {};
          }
          var result = fn.apply(this, args);
          fn.memoize[hash] = result;
          return result;
        }
      };
    }

    var breakUp = cappedMemoize(function (str, hint) {
      return new BreakString(str).break(hint);
    }, 100);
    __exports__.breakUp = breakUp;

    function shortDate(date) {
      return moment(date).format(I18n.t("dates.medium.date_year"));
    }

    function shortDateNoYear(date) {
      return moment(date).format(I18n.t("dates.tiny.date_month"));
    }

    function tinyDateYear(date) {
      return moment(date).format(I18n.t("dates.tiny.date_year"));
    }

    // http://stackoverflow.com/questions/196972/convert-string-to-title-case-with-javascript
    // TODO: locale support ?

    function toTitleCase(str) {
      return str.replace(/\w\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      });
    }

    function longDate(dt) {
      if (!dt) return;
      return moment(dt).longDate();
    }

    // suppress year, if current year

    function longDateNoYear(dt) {
      if (!dt) return;

      if (new Date().getFullYear() !== dt.getFullYear()) {
        return moment(dt).format(I18n.t("dates.long_date_with_year"));
      } else {
        return moment(dt).format(I18n.t("dates.long_date_without_year"));
      }
    }

    function updateRelativeAge(elems) {
      // jQuery .each
      elems.each(function () {
        var $this = $(this);
        $this.html(relativeAge(new Date($this.data('time')), { format: $this.data('format'), wrapInSpan: false }));
      });
    }

    function autoUpdatingRelativeAge(date, options) {
      if (!date) return "";
      if (+date === +new Date(0)) return "";

      options = options || {};
      var format = options.format || "tiny";

      var append = "";
      if (format === 'medium') {
        append = " date";
        if (options.leaveAgo) {
          format = 'medium-with-ago';
        }
        options.wrapInSpan = false;
      }

      var relAge = relativeAge(date, options);

      if (format === 'tiny' && relativeAgeTinyShowsYear(relAge)) {
        append += " with-year";
      }

      if (options.title) {
        append += "' title='" + longDate(date);
      }

      return "<span class='relative-date" + append + "' data-time='" + date.getTime() + "' data-format='" + format + "'>" + relAge + "</span>";
    }

    function relativeAgeTiny(date) {
      var format = "tiny";
      var distance = Math.round((new Date() - date) / 1000);
      var distanceInMinutes = Math.round(distance / 60.0);

      var formatted = undefined;
      var t = function (key, opts) {
        return I18n.t("dates." + format + "." + key, opts);
      };

      switch (true) {

        case distanceInMinutes < 1:
          formatted = t("less_than_x_minutes", { count: 1 });
          break;
        case distanceInMinutes >= 1 && distanceInMinutes <= 44:
          formatted = t("x_minutes", { count: distanceInMinutes });
          break;
        case distanceInMinutes >= 45 && distanceInMinutes <= 89:
          formatted = t("about_x_hours", { count: 1 });
          break;
        case distanceInMinutes >= 90 && distanceInMinutes <= 1409:
          formatted = t("about_x_hours", { count: Math.round(distanceInMinutes / 60.0) });
          break;
        case Discourse.SiteSettings.relative_date_duration === 0 && distanceInMinutes <= 525599:
          formatted = shortDateNoYear(date);
          break;
        case distanceInMinutes >= 1410 && distanceInMinutes <= 2519:
          formatted = t("x_days", { count: 1 });
          break;
        case distanceInMinutes >= 2520 && distanceInMinutes <= (Discourse.SiteSettings.relative_date_duration || 14) * 1440:
          formatted = t("x_days", { count: Math.round(distanceInMinutes / 1440.0) });
          break;
        default:
          if (date.getFullYear() === new Date().getFullYear()) {
            formatted = shortDateNoYear(date);
          } else {
            formatted = tinyDateYear(date);
          }
          break;
      }

      return formatted;
    }

    /*
     * Returns true if the given tiny date string includes the year.
     * Useful for checking if the string isn't so tiny.
     */
    function relativeAgeTinyShowsYear(relativeAgeString) {
      return relativeAgeString.match(/'[\d]{2}$/);
    }

    function relativeAgeMediumSpan(distance, leaveAgo) {
      var formatted = undefined;
      var distanceInMinutes = Math.round(distance / 60.0);

      var t = function (key, opts) {
        return I18n.t("dates.medium" + (leaveAgo ? "_with_ago" : "") + "." + key, opts);
      };

      switch (true) {
        case distanceInMinutes >= 1 && distanceInMinutes <= 55:
          formatted = t("x_minutes", { count: distanceInMinutes });
          break;
        case distanceInMinutes >= 56 && distanceInMinutes <= 89:
          formatted = t("x_hours", { count: 1 });
          break;
        case distanceInMinutes >= 90 && distanceInMinutes <= 1409:
          formatted = t("x_hours", { count: Math.round(distanceInMinutes / 60.0) });
          break;
        case distanceInMinutes >= 1410 && distanceInMinutes <= 2159:
          formatted = t("x_days", { count: 1 });
          break;
        case distanceInMinutes >= 2160:
          formatted = t("x_days", { count: Math.round((distanceInMinutes - 720.0) / 1440.0) });
          break;
      }
      return formatted || '&mdash';
    }

    function relativeAgeMedium(date, options) {
      var wrapInSpan = options.wrapInSpan !== false;
      var leaveAgo = options.leaveAgo;
      var distance = Math.round((new Date() - date) / 1000);

      if (!date) {
        return "&mdash;";
      }

      var fullReadable = longDate(date);
      var fiveDaysAgo = 432000;
      var oneMinuteAgo = 60;

      var displayDate = "";
      if (distance < oneMinuteAgo) {
        displayDate = I18n.t("now");
      } else if (distance > fiveDaysAgo) {
        if (new Date().getFullYear() !== date.getFullYear()) {
          displayDate = shortDate(date);
        } else {
          displayDate = shortDateNoYear(date);
        }
      } else {
        displayDate = relativeAgeMediumSpan(distance, leaveAgo);
      }
      if (wrapInSpan) {
        return "<span class='date' title='" + fullReadable + "'>" + displayDate + "</span>";
      } else {
        return displayDate;
      }
    }

    // mostly lifted from rails with a few amendments

    function relativeAge(date, options) {
      options = options || {};
      var format = options.format || "tiny";

      if (format === "tiny") {
        return relativeAgeTiny(date, options);
      } else if (format === "medium") {
        return relativeAgeMedium(date, options);
      } else if (format === 'medium-with-ago') {
        return relativeAgeMedium(date, _.extend(options, { format: 'medium', leaveAgo: true }));
      }

      return "UNKNOWN FORMAT";
    }

    function number(val) {
      var formattedNumber = undefined;

      val = parseInt(val, 10);
      if (isNaN(val)) val = 0;

      if (val > 999999) {
        formattedNumber = I18n.toNumber(val / 1000000, { precision: 1 });
        return I18n.t("number.short.millions", { number: formattedNumber });
      }
      if (val > 999) {
        formattedNumber = I18n.toNumber(val / 1000, { precision: 1 });
        return I18n.t("number.short.thousands", { number: formattedNumber });
      }
      return val.toString();
    }
  });
define("discourse/lib/eyeline", 
  ["exports"],
  function(__exports__) {
    "use strict";
    //  Track visible elemnts on the screen.
    var Eyeline = function Eyeline(selector) {
      this.selector = selector;
    };

    Eyeline.prototype.update = function () {
      if (Ember.testing) {
        return;
      }

      var docViewTop = $(window).scrollTop(),
          windowHeight = $(window).height(),
          docViewBottom = docViewTop + windowHeight,
          $elements = $(this.selector),
          bottomOffset = $elements.last().offset(),
          self = this;

      var atBottom = false;
      if (bottomOffset) {
        atBottom = bottomOffset.top <= docViewBottom && bottomOffset.top >= docViewTop;
      }

      return $elements.each(function (i, elem) {
        var $elem = $(elem),
            elemTop = $elem.offset().top,
            elemBottom = elemTop + $elem.height();

        var markSeen = false;

        // Make sure the element is visible
        if (!$elem.is(':visible')) return true;

        // It's seen if...
        // ...the element is vertically within the top and botom
        if (elemTop <= docViewBottom && elemTop >= docViewTop) markSeen = true;

        // ...the element top is above the top and the bottom is below the bottom (large elements)
        if (elemTop <= docViewTop && elemBottom >= docViewBottom) markSeen = true;

        // ...we're at the bottom and the bottom of the element is visible (large bottom elements)
        if (atBottom && elemBottom >= docViewTop) markSeen = true;

        if (!markSeen) return true;

        // If you hit the bottom we mark all the elements as seen. Otherwise, just the first one
        if (!atBottom) {
          self.trigger('saw', { detail: $elem });
          if (i === 0) {
            self.trigger('sawTop', { detail: $elem });
          }
          return false;
        }
        if (i === 0) {
          self.trigger('sawTop', { detail: $elem });
        }
        if (i === $elements.length - 1) {
          return self.trigger('sawBottom', { detail: $elem });
        }
      });
    };

    //  Call this when we know aren't loading any more elements. Mark the rest as seen
    Eyeline.prototype.flushRest = function () {
      if (Ember.testing) {
        return;
      }
      var self = this;
      $(this.selector).each(function (i, elem) {
        return self.trigger('saw', { detail: $(elem) });
      });
    };

    RSVP.EventTarget.mixin(Eyeline.prototype);

    __exports__["default"] = Eyeline;
  });
define("discourse/mixins/scrolling", 
  ["discourse/lib/debounce","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var debounce = __dependency1__["default"];

    /**
      This object provides the DOM methods we need for our Mixin to bind to scrolling
      methods in the browser. By removing them from the Mixin we can test them
      easier.
    **/
    var ScrollingDOMMethods = {
      bindOnScroll: function (onScrollMethod, name) {
        name = name || 'default';
        $(document).bind('touchmove.discourse-' + name, onScrollMethod);
        $(window).bind('scroll.discourse-' + name, onScrollMethod);
      },

      unbindOnScroll: function (name) {
        name = name || 'default';
        $(window).unbind('scroll.discourse-' + name);
        $(document).unbind('touchmove.discourse-' + name);
      },

      screenNotFull: function () {
        return $(window).height() > $("#main").height();
      }
    };

    var Scrolling = Ember.Mixin.create({

      // Begin watching for scroll events. By default they will be called at max every 100ms.
      // call with {debounce: N} for a diff time
      bindScrolling: function (opts) {
        var _this = this;

        opts = opts || { debounce: 100 };

        // So we can not call the scrolled event while transitioning
        var router = Discourse.__container__.lookup('router:main').router;

        var onScrollMethod = function () {
          if (router.activeTransition) {
            return;
          }
          return Ember.run.scheduleOnce('afterRender', _this, 'scrolled');
        };

        if (opts.debounce) {
          onScrollMethod = debounce(onScrollMethod, opts.debounce);
        }

        ScrollingDOMMethods.bindOnScroll(onScrollMethod, opts.name);
      },

      screenNotFull: function () {
        return ScrollingDOMMethods.screenNotFull();
      },

      unbindScrolling: function (name) {
        ScrollingDOMMethods.unbindOnScroll(name);
      }
    });

    __exports__.ScrollingDOMMethods = ScrollingDOMMethods;
    __exports__["default"] = Scrolling;
  });

Discourse.Scrolling = require('discourse/mixins/scrolling').default;
define("discourse/models/model", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var Model = Ember.Object.extend();

    Model.reopenClass({
      extractByKey: function (collection, klass) {
        var retval = {};
        if (Ember.isEmpty(collection)) {
          return retval;
        }

        collection.forEach(function (item) {
          retval[item.id] = klass.create(item);
        });
        return retval;
      }
    });

    __exports__["default"] = Model;
  });

Discourse.Model = require('discourse/models/model').default;
define("discourse/models/rest", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var RestModel = Ember.Object.extend({
      isNew: Ember.computed.equal('__state', 'new'),
      isCreated: Ember.computed.equal('__state', 'created'),
      isSaving: false,

      afterUpdate: Ember.K,

      update: function (props) {
        var _this = this;

        if (this.get('isSaving')) {
          return Ember.RSVP.reject();
        }

        props = props || this.updateProperties();

        var type = this.get('__type'),
            store = this.get('store');

        var self = this;
        self.set('isSaving', true);
        return store.update(type, this.get('id'), props).then(function (res) {
          var payload = self.__munge(res.payload || res.responseJson);

          if (payload.success === "OK") {
            Ember.warn("An update call should return the updated attributes");
            res = props;
          }

          self.setProperties(payload);
          self.afterUpdate(res);
          return res;
        }).finally(function () {
          return _this.set('isSaving', false);
        });
      },

      _saveNew: function (props) {
        var _this2 = this;

        if (this.get('isSaving')) {
          return Ember.RSVP.reject();
        }

        props = props || this.createProperties();

        var type = this.get('__type'),
            store = this.get('store'),
            adapter = store.adapterFor(type);

        var self = this;
        self.set('isSaving', true);
        return adapter.createRecord(store, type, props).then(function (res) {
          if (!res) {
            throw "Received no data back from createRecord";
          }

          // We can get a response back without properties, for example
          // when a post is queued.
          if (res.payload) {
            self.setProperties(self.__munge(res.payload));
            self.set('__state', 'created');
          }

          res.target = self;
          return res;
        }).finally(function () {
          return _this2.set('isSaving', false);
        });
      },

      createProperties: function () {
        throw "You must overwrite `createProperties()` before saving a record";
      },

      save: function (props) {
        return this.get('isNew') ? this._saveNew(props) : this.update(props);
      },

      destroyRecord: function () {
        var type = this.get('__type');
        return this.store.destroyRecord(type, this);
      }
    });

    RestModel.reopenClass({

      // Overwrite and JSON will be passed through here before `create` and `update`
      munge: function (json) {
        return json;
      },

      create: function (args) {
        args = args || {};
        if (!args.store) {
          var container = Discourse.__container__;
          // Ember.warn('Use `store.createRecord` to create records instead of `.create()`');
          args.store = container.lookup('store:main');
        }

        args.__munge = this.munge;
        return this._super(this.munge(args, args.store));
      }
    });

    __exports__["default"] = RestModel;
  });
define("discourse/models/badge-grouping", 
  ["ember-addons/ember-computed-decorators","discourse/models/rest","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var RestModel = __dependency2__["default"];

    __exports__["default"] = RestModel.extend(_createDecoratedObject([{
      key: 'i18nNameKey',
      decorators: [computed('name')],
      value: function () {
        return this.get('name').toLowerCase().replace(/\s/g, '_');
      }
    }, {
      key: 'displayName',
      decorators: [computed('name')],
      value: function () {
        var i18nKey = 'badges.badge_grouping.' + this.get('i18nNameKey') + '.name';
        return I18n.t(i18nKey, { defaultValue: this.get('name') });
      }
    }]));
  });
define("discourse/models/badge", 
  ["discourse/models/badge-grouping","discourse/models/rest","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var BadgeGrouping = __dependency1__["default"];
    var RestModel = __dependency2__["default"];

    var Badge = RestModel.extend({

      newBadge: Em.computed.none('id'),

      url: (function () {
        return Discourse.getURL('/badges/' + this.get('id') + '/' + this.get('slug'));
      }).property(),

      /**
        Update this badge with the response returned by the server on save.
         @method updateFromJson
        @param {Object} json The JSON response returned by the server
      **/
      updateFromJson: function (json) {
        var self = this;
        if (json.badge) {
          Object.keys(json.badge).forEach(function (key) {
            self.set(key, json.badge[key]);
          });
        }
        if (json.badge_types) {
          json.badge_types.forEach(function (badgeType) {
            if (badgeType.id === self.get('badge_type_id')) {
              self.set('badge_type', Object.create(badgeType));
            }
          });
        }
      },

      badgeTypeClassName: (function () {
        var type = this.get('badge_type.name') || "";
        return "badge-type-" + type.toLowerCase();
      }).property('badge_type.name'),

      /**
        Save and update the badge from the server's response.
         @method save
        @returns {Promise} A promise that resolves to the updated `Badge`
      **/
      save: function (data) {
        var url = "/admin/badges",
            requestType = "POST";
        var self = this;

        if (this.get('id')) {
          // We are updating an existing badge.
          url += "/" + this.get('id');
          requestType = "PUT";
        }

        return Discourse.ajax(url, {
          type: requestType,
          data: data
        }).then(function (json) {
          self.updateFromJson(json);
          return self;
        }).catch(function (error) {
          throw error;
        });
      },

      /**
        Destroy the badge.
         @method destroy
        @returns {Promise} A promise that resolves to the server response
      **/
      destroy: function () {
        if (this.get('newBadge')) return Ember.RSVP.resolve();
        return Discourse.ajax("/admin/badges/" + this.get('id'), {
          type: "DELETE"
        });
      }
    });

    Badge.reopenClass({
      /**
        Create `Badge` instances from the server JSON response.
         @method createFromJson
        @param {Object} json The JSON returned by the server
        @returns Array or instance of `Badge` depending on the input JSON
      **/
      createFromJson: function (json) {
        // Create BadgeType objects.
        var badgeTypes = {};
        if ('badge_types' in json) {
          json.badge_types.forEach(function (badgeTypeJson) {
            badgeTypes[badgeTypeJson.id] = Ember.Object.create(badgeTypeJson);
          });
        }

        var badgeGroupings = {};
        if ('badge_groupings' in json) {
          json.badge_groupings.forEach(function (badgeGroupingJson) {
            badgeGroupings[badgeGroupingJson.id] = BadgeGrouping.create(badgeGroupingJson);
          });
        }

        // Create Badge objects.
        var badges = [];
        if ("badge" in json) {
          badges = [json.badge];
        } else if (json.badges) {
          badges = json.badges;
        }
        badges = badges.map(function (badgeJson) {
          var badge = Badge.create(badgeJson);
          badge.set('badge_type', badgeTypes[badge.get('badge_type_id')]);
          badge.set('badge_grouping', badgeGroupings[badge.get('badge_grouping_id')]);
          return badge;
        });

        if ("badge" in json) {
          return badges[0];
        } else {
          return badges;
        }
      },

      /**
        Find all `Badge` instances that have been defined.
         @method findAll
        @returns {Promise} a promise that resolves to an array of `Badge`
      **/
      findAll: function (opts) {
        var listable = "";
        if (opts && opts.onlyListable) {
          listable = "?only_listable=true";
        }
        return Discourse.ajax('/badges.json' + listable).then(function (badgesJson) {
          return Badge.createFromJson(badgesJson);
        });
      },

      /**
        Returns a `Badge` that has the given ID.
         @method findById
        @param {Number} id ID of the badge
        @returns {Promise} a promise that resolves to a `Badge`
      **/
      findById: function (id) {
        return Discourse.ajax("/badges/" + id).then(function (badgeJson) {
          return Badge.createFromJson(badgeJson);
        });
      }
    });

    __exports__["default"] = Badge;
  });
define("discourse/models/permission-type", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var PermissionType = Discourse.Model.extend({
      description: (function () {
        var key = "";

        switch (this.get("id")) {
          case 1:
            key = "full";
            break;
          case 2:
            key = "create_post";
            break;
          case 3:
            key = "readonly";
            break;
        }
        return I18n.t("permission_types." + key);
      }).property("id")
    });

    PermissionType.FULL = 1;
    PermissionType.CREATE_POST = 2;
    PermissionType.READONLY = 3;

    __exports__["default"] = PermissionType;
  });
define("discourse/models/user-action-group", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      A data model representing a group of UserActions
    **/

    __exports__["default"] = Discourse.Model.extend({
      push: function (item) {
        if (!this.items) {
          this.items = [];
        }
        return this.items.push(item);
      }
    });
  });
define("discourse/models/category", 
  ["discourse/models/rest","ember-addons/ember-computed-decorators","discourse/models/permission-type","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var RestModel = __dependency1__["default"];
    var on = __dependency2__.on;
    var PermissionType = __dependency3__["default"];

    var Category = RestModel.extend(_createDecoratedObject([{
      key: 'setupGroupsAndPermissions',
      decorators: [on('init')],
      value: function () {
        var availableGroups = this.get('available_groups');
        if (!availableGroups) {
          return;
        }
        this.set("availableGroups", availableGroups);

        var groupPermissions = this.get('group_permissions');
        if (groupPermissions) {
          this.set('permissions', groupPermissions.map(function (elem) {
            availableGroups.removeObject(elem.group_name);
            return {
              group_name: elem.group_name,
              permission: PermissionType.create({ id: elem.permission_type })
            };
          }));
        }
      }
    }, {
      key: 'availablePermissions',
      initializer: function () {
        return (function () {
          return [PermissionType.create({ id: PermissionType.FULL }), PermissionType.create({ id: PermissionType.CREATE_POST }), PermissionType.create({ id: PermissionType.READONLY })];
        }).property();
      }
    }, {
      key: 'searchContext',
      initializer: function () {
        return (function () {
          return { type: 'category', id: this.get('id'), category: this };
        }).property('id');
      }
    }, {
      key: 'url',
      initializer: function () {
        return (function () {
          return Discourse.getURL("/c/") + Category.slugFor(this);
        }).property('name');
      }
    }, {
      key: 'fullSlug',
      initializer: function () {
        return (function () {
          return this.get("url").slice(3).replace("/", "-");
        }).property("url");
      }
    }, {
      key: 'nameLower',
      initializer: function () {
        return (function () {
          return this.get('name').toLowerCase();
        }).property('name');
      }
    }, {
      key: 'unreadUrl',
      initializer: function () {
        return (function () {
          return this.get('url') + '/l/unread';
        }).property('url');
      }
    }, {
      key: 'newUrl',
      initializer: function () {
        return (function () {
          return this.get('url') + '/l/new';
        }).property('url');
      }
    }, {
      key: 'style',
      initializer: function () {
        return (function () {
          return "background-color: #" + this.get('category.color') + "; color: #" + this.get('category.text_color') + ";";
        }).property('color', 'text_color');
      }
    }, {
      key: 'moreTopics',
      initializer: function () {
        return (function () {
          return this.get('topic_count') > Discourse.SiteSettings.category_featured_topics;
        }).property('topic_count');
      }
    }, {
      key: 'save',
      initializer: function () {
        return function () {
          var url = "/categories";
          if (this.get('id')) {
            url = "/categories/" + this.get('id');
          }

          return Discourse.ajax(url, {
            data: {
              name: this.get('name'),
              slug: this.get('slug'),
              color: this.get('color'),
              text_color: this.get('text_color'),
              secure: this.get('secure'),
              permissions: this.get('permissionsForUpdate'),
              auto_close_hours: this.get('auto_close_hours'),
              auto_close_based_on_last_post: this.get("auto_close_based_on_last_post"),
              position: this.get('position'),
              email_in: this.get('email_in'),
              email_in_allow_strangers: this.get('email_in_allow_strangers'),
              parent_category_id: this.get('parent_category_id'),
              logo_url: this.get('logo_url'),
              background_url: this.get('background_url'),
              allow_badges: this.get('allow_badges'),
              custom_fields: this.get('custom_fields'),
              topic_template: this.get('topic_template'),
              suppress_from_homepage: this.get('suppress_from_homepage')
            },
            type: this.get('id') ? 'PUT' : 'POST'
          });
        };
      }
    }, {
      key: 'permissionsForUpdate',
      initializer: function () {
        return (function () {
          var rval = {};
          _.each(this.get("permissions"), function (p) {
            rval[p.group_name] = p.permission.id;
          });
          return rval;
        }).property("permissions");
      }
    }, {
      key: 'destroy',
      initializer: function () {
        return function () {
          return Discourse.ajax("/categories/" + (this.get('id') || this.get('slug')), { type: 'DELETE' });
        };
      }
    }, {
      key: 'addPermission',
      initializer: function () {
        return function (permission) {
          this.get("permissions").addObject(permission);
          this.get("availableGroups").removeObject(permission.group_name);
        };
      }
    }, {
      key: 'removePermission',
      initializer: function () {
        return function (permission) {
          this.get("permissions").removeObject(permission);
          this.get("availableGroups").addObject(permission.group_name);
        };
      }
    }, {
      key: 'permissions',
      initializer: function () {
        return (function () {
          return Em.A([{ group_name: "everyone", permission: PermissionType.create({ id: 1 }) }, { group_name: "admins", permission: PermissionType.create({ id: 2 }) }, { group_name: "crap", permission: PermissionType.create({ id: 3 }) }]);
        }).property();
      }
    }, {
      key: 'latestTopic',
      initializer: function () {
        return (function () {
          var topics = this.get('topics');
          if (topics && topics.length) {
            return topics[0];
          }
        }).property("topics");
      }
    }, {
      key: 'featuredTopics',
      initializer: function () {
        return (function () {
          var topics = this.get('topics');
          if (topics && topics.length) {
            return topics.slice(0, Discourse.SiteSettings.category_featured_topics || 2);
          }
        }).property('topics');
      }
    }, {
      key: 'unreadTopics',
      initializer: function () {
        return (function () {
          return this.topicTrackingState.countUnread(this.get('id'));
        }).property('topicTrackingState.messageCount');
      }
    }, {
      key: 'newTopics',
      initializer: function () {
        return (function () {
          return this.topicTrackingState.countNew(this.get('id'));
        }).property('topicTrackingState.messageCount');
      }
    }, {
      key: 'topicStatsTitle',
      initializer: function () {
        return (function () {
          var string = I18n.t('categories.topic_stats');
          _.each(this.get('topicCountStats'), function (stat) {
            string += ' ' + I18n.t('categories.topic_stat_sentence', { count: stat.value, unit: stat.unit });
          }, this);
          return string;
        }).property('post_count');
      }
    }, {
      key: 'postStatsTitle',
      initializer: function () {
        return (function () {
          var string = I18n.t('categories.post_stats');
          _.each(this.get('postCountStats'), function (stat) {
            string += ' ' + I18n.t('categories.post_stat_sentence', { count: stat.value, unit: stat.unit });
          }, this);
          return string;
        }).property('post_count');
      }
    }, {
      key: 'topicCountStats',
      initializer: function () {
        return (function () {
          return this.countStats('topics');
        }).property('topics_year', 'topics_month', 'topics_week', 'topics_day');
      }
    }, {
      key: 'setNotification',
      initializer: function () {
        return function (notification_level) {
          var url = "/category/" + this.get('id') + "/notifications";
          this.set('notification_level', notification_level);
          return Discourse.ajax(url, {
            data: {
              notification_level: notification_level
            },
            type: 'POST'
          });
        };
      }
    }, {
      key: 'postCountStats',
      initializer: function () {
        return (function () {
          return this.countStats('posts');
        }).property('posts_year', 'posts_month', 'posts_week', 'posts_day');
      }
    }, {
      key: 'countStats',
      initializer: function () {
        return function (prefix) {
          var stats = [],
              val;
          _.each(['day', 'week', 'month', 'year'], function (unit) {
            val = this.get(prefix + '_' + unit);
            if (val > 0) stats.pushObject({ value: val, unit: I18n.t(unit) });
            if (stats.length === 2) return false;
          }, this);
          return stats;
        };
      }
    }, {
      key: 'isUncategorizedCategory',
      initializer: function () {
        return (function () {
          return this.get('id') === Discourse.Site.currentProp("uncategorized_category_id");
        }).property('id');
      }
    }]));

    var _uncategorized;

    Category.reopenClass({

      findUncategorized: function () {
        _uncategorized = _uncategorized || Category.list().findBy('id', Discourse.Site.currentProp('uncategorized_category_id'));
        return _uncategorized;
      },

      slugFor: function (category) {
        var separator = arguments.length <= 1 || arguments[1] === undefined ? "/" : arguments[1];

        if (!category) return "";

        var parentCategory = Em.get(category, 'parentCategory');
        var result = "";

        if (parentCategory) {
          result = Category.slugFor(parentCategory) + separator;
        }

        var id = Em.get(category, 'id'),
            slug = Em.get(category, 'slug');

        return !slug || slug.trim().length === 0 ? '' + result + id + '-category' : result + slug;
      },

      list: function () {
        return Discourse.SiteSettings.fixed_category_positions ? Discourse.Site.currentProp('categories') : Discourse.Site.currentProp('sortedCategories');
      },

      listByActivity: function () {
        return Discourse.Site.currentProp('sortedCategories');
      },

      idMap: function () {
        return Discourse.Site.currentProp('categoriesById');
      },

      findSingleBySlug: function (slug) {
        return Category.list().find(function (c) {
          return Category.slugFor(c) === slug;
        });
      },

      findById: function (id) {
        if (!id) {
          return;
        }
        return Category.idMap()[id];
      },

      findByIds: function (ids) {
        var categories = [];
        _.each(ids, function (id) {
          var found = Category.findById(id);
          if (found) {
            categories.push(found);
          }
        });
        return categories;
      },

      findBySlug: function (slug, parentSlug) {
        var categories = Category.list();
        var category = undefined;

        if (parentSlug) {
          var _ret = (function () {
            var parentCategory = Category.findSingleBySlug(parentSlug);
            if (parentCategory) {
              if (slug === 'none') {
                return {
                  v: parentCategory
                };
              }

              category = categories.find(function (item) {
                return item && item.get('parentCategory') === parentCategory && Category.slugFor(item) === parentSlug + "/" + slug;
              });
            }
          })();

          if (typeof _ret === 'object') return _ret.v;
        } else {
          category = Category.findSingleBySlug(slug);

          // If we have a parent category, we need to enforce it
          if (category && category.get('parentCategory')) return;
        }

        // In case the slug didn't work, try to find it by id instead.
        if (!category) {
          category = categories.findBy('id', parseInt(slug, 10));
        }

        return category;
      },

      reloadById: function (id) {
        return Discourse.ajax('/c/' + id + '/show.json');
      },

      reloadBySlug: function (slug, parentSlug) {
        return parentSlug ? Discourse.ajax('/c/' + parentSlug + '/' + slug + '/find_by_slug.json') : Discourse.ajax('/c/' + slug + '/find_by_slug.json');
      },

      search: function (term, opts) {
        var limit = 5;

        if (opts) {
          if (opts.limit === 0) {
            return [];
          } else if (opts.limit) {
            limit = opts.limit;
          }
        }

        var emptyTerm = term === "";
        var slugTerm = term;

        if (!emptyTerm) {
          term = term.toLowerCase();
          slugTerm = term;
          term = term.replace(/-/g, " ");
        }

        var categories = Category.listByActivity();
        var length = categories.length;
        var i;
        var data = [];

        var done = function () {
          return data.length === limit;
        };

        for (i = 0; i < length && !done(); i++) {
          var category = categories[i];
          if (emptyTerm && !category.get('parent_category_id') || !emptyTerm && (category.get('name').toLowerCase().indexOf(term) === 0 || category.get('slug').toLowerCase().indexOf(slugTerm) === 0)) {

            data.push(category);
          }
        }

        if (!done()) {
          for (i = 0; i < length && !done(); i++) {
            var category = categories[i];

            if (!emptyTerm && (category.get('name').toLowerCase().indexOf(term) > 0 || category.get('slug').toLowerCase().indexOf(slugTerm) > 0)) {

              if (data.indexOf(category) === -1) data.push(category);
            }
          }
        }

        return _.sortBy(data, function (category) {
          return category.get('read_restricted');
        });
      }
    });

    __exports__["default"] = Category;
  });

Discourse.Category = require('discourse/models/category').default;
define("discourse/lib/ajax-error", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.extractError = extractError;
    __exports__.throwAjaxError = throwAjaxError;
    __exports__.popupAjaxError = popupAjaxError;

    function extractError(error, defaultMessage) {
      if (error instanceof Error) {
        Ember.Logger.error(error.stack);
      }

      if (typeof error === "string") {
        Ember.Logger.error(error);
      }

      if (error.jqXHR) {
        error = error.jqXHR;
      }

      var parsedError = undefined,
          parsedJSON = undefined;

      if (error.responseJSON) {
        parsedJSON = error.responseJSON;
      }

      if (!parsedJSON && error.responseText) {
        try {
          parsedJSON = $.parseJSON(error.responseText);
        } catch (ex) {
          // in case the JSON doesn't parse
          Ember.Logger.error(ex.stack);
        }
      }

      if (parsedJSON) {
        if (parsedJSON.errors && parsedJSON.errors.length > 0) {
          parsedError = parsedJSON.errors.join("<br>");
        } else if (parsedJSON.error) {
          parsedError = parsedJSON.error;
        } else if (parsedJSON.failed) {
          parsedError = parsedJSON.message;
        }
      }

      if (!parsedError) {
        if (error.status && error.status >= 400) {
          parsedError = error.status + " " + error.statusText;
        }
      }

      return parsedError || defaultMessage || I18n.t('generic_error');
    }

    function throwAjaxError(undoCallback) {
      return function (error) {
        // If we provided an `undo` callback
        if (undoCallback) {
          undoCallback(error);
        }
        throw extractError(error);
      };
    }

    function popupAjaxError(error) {
      bootbox.alert(extractError(error));
    }
  });
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Contains methods to help us with markdown formatting.

  @class Markdown
  @namespace Discourse
  @module Discourse
**/

/**
 * An object mapping from HTML tag names to an object mapping the valid
 * attributes on that tag to an array of permitted values.
 *
 * The permitted values can be strings or regexes.
 *
 * The pseduo-attribute 'data-*' can be used to validate any data-foo
 * attributes without any specified validations.
 *
 * Code can insert into this map by calling Discourse.Markdown.whiteListTag().
 *
 * Example:
 *
 * <pre><code>
 * {
 *   a: {
 *     href: ['*'],
 *     data-mention-id: [/^\d+$/],
 *     ...
 *   },
 *   code: {
 *     class: ['ada', 'haskell', 'c', 'cpp', ... ]
 *   },
 *   ...
 * }
 * </code></pre>
 *
 * @private
 */

var _validTags = {};
/**
 * Classes valid on all elements. Map from class name to 'true'.
 * @private
 */
var _validClasses = {};
var _validIframes = [];
var _decoratedCaja = false;

function validateAttribute(tagName, attribName, value) {
  var tag = _validTags[tagName];

  // Handle classes
  if (attribName === "class") {
    if (_validClasses[value]) { return value; }
  }

  if (attribName.indexOf('data-') === 0) {
    // data-* catch-all validators
    if (tag && tag['data-*'] && !tag[attribName]) {
      var permitted = tag['data-*'];
      if (permitted && (
            permitted.indexOf(value) !== -1 ||
            permitted.indexOf('*') !== -1 ||
            ((permitted instanceof RegExp) && permitted.test(value)))
        ) { return value; }
    }
  }

  if (tag) {
    var attrs = tag[attribName];
    if (attrs && (attrs.indexOf(value) !== -1 ||
                  attrs.indexOf('*') !== -1) ||
                  _.any(attrs, function(r) { return (r instanceof RegExp) && r.test(value); })
        ) { return value; }
  }

  // return undefined;
}

function anchorRegexp(regex) {
  if (/^\^.*\$$/.test(regex.source)) {
    return regex; // already anchored
  }

  var flags = "";
  if (regex.global) {
    if (typeof console !== 'undefined') {
      console.warn("attribute validation regex should not be global");
    }
  }

  if (regex.ignoreCase) { flags += "i"; }
  if (regex.multiline) { flags += "m"; }
  if (regex.sticky) { throw "Invalid attribute validation regex - cannot be sticky"; }

  return new RegExp("^" + regex.source + "$", flags);
}

Discourse.Markdown = {

  /**
    Add to the attribute whitelist for a certain HTML tag.

    @param {String} tagName tag to whitelist the attr for
    @param {String} attribName attr to whitelist for the tag
    @param {String | RegExp} [value] whitelisted value for the attribute
  **/
  whiteListTag: function(tagName, attribName, value) {
    if (value instanceof RegExp) {
      value = anchorRegexp(value);
    }
    _validTags[tagName] = _validTags[tagName] || {};
    _validTags[tagName][attribName] = _validTags[tagName][attribName] || [];
    _validTags[tagName][attribName].push(value || '*');
  },

  /**
    Whitelists more classes for sanitization.

    @param {...String} var_args Classes to whitelist
    @method whiteListClass
  **/
  whiteListClass: function() {
    var args = Array.prototype.slice.call(arguments);
    args.forEach(function (a) { _validClasses[a] = true; });
  },

  /**
    Whitelists iframes for sanitization

    @method whiteListIframe
    @param {Regexp} regexp The regexp to whitelist.
  **/
  whiteListIframe: function(regexp) {
    _validIframes.push(regexp);
  },

  /**
    Convert a raw string to a cooked markdown string.

    @method cook
    @param {String} raw the raw string we want to apply markdown to
    @param {Object} opts the options for the rendering
    @return {String} the cooked markdown string
  **/
  cook: function(raw, opts) {
    if (!opts) opts = {};

    // Make sure we've got a string
    if (!raw || raw.length === 0) return "";

    return this.markdownConverter(opts).makeHtml(raw);
  },

  /**
    Checks to see if a URL is allowed in the cooked content

    @method urlAllowed
    @param {String} uri Url to check
    @param {Number} effect ignored
    @param {Number} ltype ignored
    @param {Object} hints an object with hints, used to check if this url is from an iframe
    @return {String} url to insert in the cooked content
  **/
  urlAllowed: function (uri, effect, ltype, hints) {
    var url = typeof(uri) === "string" ? uri : uri.toString();

    // escape single quotes
    url = url.replace(/'/g, "%27");

    // whitelist some iframe only
    if (hints && hints.XML_TAG === "iframe" && hints.XML_ATTR === "src") {
      for (var i = 0, length = _validIframes.length; i < length; i++) {
        if(_validIframes[i].test(url)) { return url; }
      }
      return;
    }

    // absolute urls
    if(/^(https?:)?\/\/[\w\.\-]+/i.test(url)) { return url; }
    // relative urls
    if(/^\/[\w\.\-]+/i.test(url)) { return url; }
    // anchors
    if(/^#[\w\.\-]+/i.test(url)) { return url; }
    // mailtos
    if(/^mailto:[\w\.\-@]+/i.test(url)) { return url; }
  },

  /**
    Sanitize text using the sanitizer

    @method sanitize
    @param {String} text The text to sanitize
    @return {String} text The sanitized text
  **/
  sanitize: function(text) {
    if (!window.html_sanitize || !text) return "";

    // Allow things like <3 and <_<
    text = text.replace(/<([^A-Za-z\/\!]|$)/g, "&lt;$1");

    // The first time, let's add some more whitelisted tags
    if (!_decoratedCaja) {

      // Add anything whitelisted to the list of elements if it's not in there already.
      var elements = window.html4.ELEMENTS;
      Object.keys(_validTags).forEach(function(t) {
        if (!elements[t]) {
          elements[t] = 0;
        }
      });

      _decoratedCaja = true;
    }

    return window.html_sanitize(text, Discourse.Markdown.urlAllowed, validateAttribute);
  },

  /**
    Creates a Markdown.Converter that we we can use for formatting

    @method markdownConverter
    @param {Object} opts the converting options
  **/
  markdownConverter: function(opts) {
    if (!opts) opts = {};

    return {
      makeHtml: function(text) {
        text = Discourse.Dialect.cook(text, opts);
        return !text ? "" : text;
      }
    };
  }

};

RSVP.EventTarget.mixin(Discourse.Markdown);

Discourse.Markdown.whiteListTag('a', 'class', 'attachment');
Discourse.Markdown.whiteListTag('a', 'class', 'onebox');
Discourse.Markdown.whiteListTag('a', 'class', 'mention');
Discourse.Markdown.whiteListTag('a', 'class', 'mention-group');
Discourse.Markdown.whiteListTag('a', 'class', 'hashtag');

Discourse.Markdown.whiteListTag('a', 'target', '_blank');
Discourse.Markdown.whiteListTag('a', 'rel', 'nofollow');
Discourse.Markdown.whiteListTag('a', 'data-bbcode');
Discourse.Markdown.whiteListTag('a', 'name');

Discourse.Markdown.whiteListTag('img', 'src', /^data:image.*$/i);

Discourse.Markdown.whiteListTag('div', 'class', 'title');
Discourse.Markdown.whiteListTag('div', 'class', 'quote-controls');

Discourse.Markdown.whiteListTag('span', 'class', 'mention');
Discourse.Markdown.whiteListTag('span', 'class', 'hashtag');
Discourse.Markdown.whiteListTag('aside', 'class', 'quote');
Discourse.Markdown.whiteListTag('aside', 'data-*');

Discourse.Markdown.whiteListTag('span', 'bbcode-b');
Discourse.Markdown.whiteListTag('span', 'bbcode-i');
Discourse.Markdown.whiteListTag('span', 'bbcode-u');
Discourse.Markdown.whiteListTag('span', 'bbcode-s');

// used for pinned topics
Discourse.Markdown.whiteListTag('span', 'class', 'excerpt');

Discourse.Markdown.whiteListIframe(/^(https?:)?\/\/www\.google\.com\/maps\/embed\?.+/i);
Discourse.Markdown.whiteListIframe(/^(https?:)?\/\/www\.openstreetmap\.org\/export\/embed.html\?.+/i);


// IIFE Wrapped Content Ends

 })(this);
define("discourse/lib/search", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.translateResults = translateResults;

    function translateResults(results, opts) {

      var User = require('discourse/models/user').default;
      var Category = require('discourse/models/category').default;
      var Post = require('discourse/models/post').default;
      var Topic = require('discourse/models/topic').default;

      if (!opts) opts = {};

      // Topics might not be included
      if (!results.topics) {
        results.topics = [];
      }
      if (!results.users) {
        results.users = [];
      }
      if (!results.posts) {
        results.posts = [];
      }
      if (!results.categories) {
        results.categories = [];
      }

      var topicMap = {};
      results.topics = results.topics.map(function (topic) {
        topic = Topic.create(topic);
        topicMap[topic.id] = topic;
        return topic;
      });

      results.posts = results.posts.map(function (post) {
        post = Post.create(post);
        post.set('topic', topicMap[post.topic_id]);
        return post;
      });

      results.users = results.users.map(function (user) {
        user = User.create(user);
        return user;
      });

      results.categories = results.categories.map(function (category) {
        return Category.list().findProperty('id', category.id);
      }).compact();

      var r = results.grouped_search_result;
      results.resultTypes = [];

      // TODO: consider refactoring front end to take a better structure
      [['topic', 'posts'], ['user', 'users'], ['category', 'categories']].forEach(function (pair) {
        var type = pair[0],
            name = pair[1];
        if (results[name].length > 0) {
          var result = {
            results: results[name],
            componentName: "search-result-" + (opts.searchContext && opts.searchContext.type === 'topic' && type === 'topic' ? 'post' : type),
            type: type,
            more: r['more_' + name]
          };

          if (result.more && name === "posts" && opts.fullSearchUrl) {
            result.more = false;
            result.moreUrl = opts.fullSearchUrl;
          }

          results.resultTypes.push(result);
        }
      });

      var noResults = !!(results.topics.length === 0 && results.posts.length === 0 && results.users.length === 0 && results.categories.length === 0);

      return noResults ? null : Em.Object.create(results);
    }

    function searchForTerm(term, opts) {
      if (!opts) opts = {};

      // Only include the data we have
      var data = { term: term, include_blurbs: 'true' };
      if (opts.typeFilter) data.type_filter = opts.typeFilter;
      if (opts.searchForId) data.search_for_id = true;

      if (opts.searchContext) {
        data.search_context = {
          type: opts.searchContext.type,
          id: opts.searchContext.id
        };
      }

      var promise = Discourse.ajax('/search/query', { data: data });

      promise.then(function (results) {
        return translateResults(results, opts);
      });

      return promise;
    }

    var searchContextDescription = function (type, name) {
      if (type) {
        switch (type) {
          case 'topic':
            return I18n.t('search.context.topic');
          case 'user':
            return I18n.t('search.context.user', { username: name });
          case 'category':
            return I18n.t('search.context.category', { category: name });
          case 'private_messages':
            return I18n.t('search.context.private_messages');
        }
      }
    };

    var getSearchKey = function (args) {
      return args.q + "|" + (args.searchContext && args.searchContext.type || "") + "|" + (args.searchContext && args.searchContext.id || "");
    };

    var isValidSearchTerm = function (searchTerm) {
      if (searchTerm) {
        return searchTerm.trim().length >= Discourse.SiteSettings.min_search_term_length;
      } else {
        return false;
      }
    };

    __exports__.searchForTerm = searchForTerm;
    __exports__.searchContextDescription = searchContextDescription;
    __exports__.getSearchKey = getSearchKey;
    __exports__.isValidSearchTerm = isValidSearchTerm;
  });
define("discourse/lib/user-search", 
  ["discourse/lib/autocomplete","exports"],
  function(__dependency1__, __exports__) {
    "use strict";


    __exports__["default"] = userSearch;
    var CANCELLED_STATUS = __dependency1__.CANCELLED_STATUS;

    var cache = {},
        cacheTopicId,
        cacheTime,
        currentTerm,
        oldSearch;

    function performSearch(term, topicId, includeGroups, includeMentionableGroups, allowedUsers, resultsFn) {
      var cached = cache[term];
      if (cached) {
        resultsFn(cached);
        return;
      }

      // need to be able to cancel this
      oldSearch = $.ajax(Discourse.getURL('/users/search/users'), {
        data: { term: term,
          topic_id: topicId,
          include_groups: includeGroups,
          include_mentionable_groups: includeMentionableGroups,
          topic_allowed_users: allowedUsers }
      });

      var returnVal = CANCELLED_STATUS;

      oldSearch.then(function (r) {
        cache[term] = r;
        cacheTime = new Date();
        // If there is a newer search term, return null
        if (term === currentTerm) {
          returnVal = r;
        }
      }).always(function () {
        oldSearch = null;
        resultsFn(returnVal);
      });
    }

    var debouncedSearch = _.debounce(performSearch, 300);

    function organizeResults(r, options) {
      if (r === CANCELLED_STATUS) {
        return r;
      }

      var exclude = options.exclude || [],
          limit = options.limit || 5,
          users = [],
          groups = [],
          results = [];

      if (r.users) {
        r.users.every(function (u) {
          if (exclude.indexOf(u.username) === -1) {
            users.push(u);
            results.push(u);
          }
          return results.length <= limit;
        });
      }

      if (r.groups) {
        r.groups.every(function (g) {
          if (results.length > limit) return false;
          if (exclude.indexOf(g.name) === -1) {
            groups.push(g);
            results.push(g);
          }
          return true;
        });
      }

      results.users = users;
      results.groups = groups;
      return results;
    }
    function userSearch(options) {
      var term = options.term || "",
          includeGroups = options.includeGroups,
          includeMentionableGroups = options.includeMentionableGroups,
          allowedUsers = options.allowedUsers,
          topicId = options.topicId;

      if (oldSearch) {
        oldSearch.abort();
        oldSearch = null;
      }

      currentTerm = term;

      return new Ember.RSVP.Promise(function (resolve) {
        // TODO site setting for allowed regex in username
        if (term.match(/[^a-zA-Z0-9_\.\-]/)) {
          resolve([]);
          return;
        }
        if (new Date() - cacheTime > 30000 || cacheTopicId !== topicId) {
          cache = {};
        }

        cacheTopicId = topicId;

        var clearPromise = setTimeout(function () {
          resolve(CANCELLED_STATUS);
        }, 5000);

        debouncedSearch(term, topicId, includeGroups, includeMentionableGroups, allowedUsers, function (r) {
          clearTimeout(clearPromise);
          resolve(organizeResults(r, options));
        });
      });
    }
  });
define("discourse/lib/export-csv", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.exportUserArchive = exportUserArchive;
    __exports__.exportEntity = exportEntity;
    function exportEntityByType(type, entity, args) {
      return Discourse.ajax("/export_csv/export_entity.json", {
        method: 'POST',
        data: { entity_type: type, entity: entity, args: args }
      });
    }

    function exportUserArchive() {
      return exportEntityByType('user', 'user_archive').then(function () {
        bootbox.alert(I18n.t("admin.export_csv.success"));
      }).catch(function () {
        bootbox.alert(I18n.t("admin.export_csv.rate_limit_error"));
      });
    }

    function exportEntity(entity, args) {
      return exportEntityByType('admin', entity, args);
    }
  });
define("discourse/lib/autocomplete", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      This is a jQuery plugin to support autocompleting values in our text fields.

      @module $.fn.autocomplete
    **/

    var CANCELLED_STATUS = "__CANCELLED";

    __exports__.CANCELLED_STATUS = CANCELLED_STATUS;
    var allowedLettersRegex = /[\s\t\[\{\(\/]/;

    var keys = {
      backSpace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      ctrl: 17,
      alt: 18,
      esc: 27,
      space: 32,
      leftWindows: 91,
      rightWindows: 92,
      pageUp: 33,
      pageDown: 34,
      end: 35,
      home: 36,
      leftArrow: 37,
      upArrow: 38,
      rightArrow: 39,
      downArrow: 40,
      insert: 45,
      deleteKey: 46,
      zero: 48,
      a: 65,
      z: 90
    };

    var inputTimeout = undefined;

    __exports__["default"] = function (options) {
      var autocompletePlugin = this;

      if (this.length === 0) return;

      if (options === 'destroy') {
        Ember.run.cancel(inputTimeout);

        $(this).off('keyup.autocomplete').off('keydown.autocomplete').off('paste.autocomplete').off('click.autocomplete');

        return;
      }

      if (options && options.cancel && this.data("closeAutocomplete")) {
        this.data("closeAutocomplete")();
        return this;
      }

      if (this.length !== 1) {
        if (window.console) {
          window.console.log("WARNING: passed multiple elements to $.autocomplete, skipping.");
          if (window.Error) {
            window.console.log(new window.Error().stack);
          }
        }
        return this;
      }

      var disabled = options && options.disabled;
      var wrap = null;
      var autocompleteOptions = null;
      var selectedOption = null;
      var completeStart = null;
      var completeEnd = null;
      var me = this;
      var div = null;
      var prevTerm = null;

      // input is handled differently
      var isInput = this[0].tagName === "INPUT";
      var inputSelectedItems = [];

      var closeAutocomplete = function () {
        if (div) {
          div.hide().remove();
        }
        div = null;
        completeStart = null;
        autocompleteOptions = null;
        prevTerm = null;
      };

      var addInputSelectedItem = function (item) {
        var transformed,
            transformedItem = item;

        if (options.transformComplete) {
          transformedItem = options.transformComplete(transformedItem);
        }
        // dump what we have in single mode, just in case
        if (options.single) {
          inputSelectedItems = [];
        }
        transformed = _.isArray(transformedItem) ? transformedItem : [transformedItem || item];

        var divs = transformed.map(function (itm) {
          var d = $("<div class='item'><span>" + itm + "<a class='remove' href><i class='fa fa-times'></i></a></span></div>");
          var prev = me.parent().find('.item:last');
          if (prev.length === 0) {
            me.parent().prepend(d);
          } else {
            prev.after(d);
          }
          inputSelectedItems.push(itm);
          return d[0];
        });

        if (options.onChangeItems) {
          options.onChangeItems(inputSelectedItems);
        }

        $(divs).find('a').click(function () {
          closeAutocomplete();
          inputSelectedItems.splice($.inArray(transformedItem, inputSelectedItems), 1);
          $(this).parent().parent().remove();
          if (options.single) {
            me.show();
          }
          if (options.onChangeItems) {
            options.onChangeItems(inputSelectedItems);
          }
          return false;
        });
      };

      var completeTerm = function (term) {
        if (term) {
          if (isInput) {
            me.val("");
            if (options.single) {
              me.hide();
            }
            addInputSelectedItem(term);
          } else {
            if (options.transformComplete) {
              term = options.transformComplete(term);
            }

            if (term) {
              var text = me.val();
              text = text.substring(0, completeStart) + (options.key || "") + term + ' ' + text.substring(completeEnd + 1, text.length);
              me.val(text);
              Discourse.Utilities.setCaretPosition(me[0], completeStart + 1 + term.length);

              if (options && options.afterComplete) {
                options.afterComplete(text);
              }
            }
          }
        }
        closeAutocomplete();
      };

      if (isInput) {
        var width = this.width();
        wrap = this.wrap("<div class='ac-wrap clearfix" + (disabled ? " disabled" : "") + "'/>").parent();
        wrap.width(width);
        if (options.single) {
          this.css("width", "100%");
        } else {
          this.width(150);
        }
        this.attr('name', this.attr('name') + "-renamed");
        var vals = this.val().split(",");
        _.each(vals, function (x) {
          if (x !== "") {
            if (options.reverseTransform) {
              x = options.reverseTransform(x);
            }
            addInputSelectedItem(x);
          }
        });
        if (options.items) {
          _.each(options.items, function (item) {
            addInputSelectedItem(item);
          });
        }
        this.val("");
        completeStart = 0;
        wrap.click(function () {
          autocompletePlugin.focus();
          return true;
        });
      }

      var markSelected = function () {
        var links = div.find('li a');
        links.removeClass('selected');
        return $(links[selectedOption]).addClass('selected');
      };

      var renderAutocomplete = function () {
        if (div) {
          div.hide().remove();
        }
        if (autocompleteOptions.length === 0) return;

        div = $(options.template({ options: autocompleteOptions }));

        var ul = div.find('ul');
        selectedOption = 0;
        markSelected();
        ul.find('li').click(function () {
          selectedOption = ul.find('li').index(this);
          completeTerm(autocompleteOptions[selectedOption]);
          return false;
        });
        var pos = null;
        var vOffset = 0;
        var hOffset = 0;
        if (isInput) {
          pos = {
            left: 0,
            top: 0
          };
          vOffset = -32;
          hOffset = 0;
        } else {
          pos = me.caretPosition({
            pos: completeStart,
            key: options.key
          });
          hOffset = 27;
        }
        div.css({
          left: "-1000px"
        });

        me.parent().append(div);

        if (!isInput) {
          vOffset = div.height();
        }

        if (Discourse.Site.currentProp('mobileView') && !isInput) {
          div.css('width', 'auto');

          if (me.height() / 2 >= pos.top) {
            vOffset = -23;
          }
          if (me.width() / 2 <= pos.left) {
            hOffset = -div.width();
          }
        }

        var mePos = me.position();
        var borderTop = parseInt(me.css('border-top-width'), 10) || 0;
        div.css({
          position: 'absolute',
          top: mePos.top + pos.top - vOffset + borderTop + 'px',
          left: mePos.left + pos.left + hOffset + 'px'
        });
      };

      var SKIP = "skip";

      var dataSource = function (term, opts) {
        if (prevTerm === term) {
          return SKIP;
        }

        prevTerm = term;
        if (term.length !== 0 && term.trim().length === 0) {
          closeAutocomplete();
          return null;
        } else {
          return opts.dataSource(term);
        }
      };

      var updateAutoComplete = function (r) {

        if (completeStart === null || r === SKIP) return;

        if (r && r.then && typeof r.then === "function") {
          if (div) {
            div.hide().remove();
          }
          r.then(updateAutoComplete);
          return;
        }

        // Allow an update method to cancel. This allows us to debounce
        // promises without leaking
        if (r === CANCELLED_STATUS) {
          return;
        }

        autocompleteOptions = r;
        if (!r || r.length === 0) {
          closeAutocomplete();
        } else {
          renderAutocomplete();
        }
      };

      // chain to allow multiples
      var oldClose = me.data("closeAutocomplete");
      me.data("closeAutocomplete", function () {
        if (oldClose) {
          oldClose();
        }
        closeAutocomplete();
      });

      $(this).on('click.autocomplete', function () {
        closeAutocomplete();
      });

      $(this).on('paste.autocomplete', function () {
        _.delay(function () {
          me.trigger("keydown");
        }, 50);
      });

      var checkTriggerRule = function (opts) {
        if (options.triggerRule) {
          return options.triggerRule(me[0], opts);
        } else {
          return true;
        }
      };

      $(this).on('keyup.autocomplete', function (e) {
        if ([keys.esc, keys.enter].indexOf(e.which) !== -1) return true;

        var caretPosition = Discourse.Utilities.caretPosition(me[0]);

        if (options.key && completeStart === null && caretPosition > 0) {
          var key = me[0].value[caretPosition - 1];
          if (key === options.key) {
            var prevChar = me.val().charAt(caretPosition - 2);
            if (checkTriggerRule() && (!prevChar || allowedLettersRegex.test(prevChar))) {
              completeStart = completeEnd = caretPosition - 1;
              updateAutoComplete(dataSource("", options));
            }
          }
        } else if (completeStart !== null) {
          var term = me.val().substring(completeStart + (options.key ? 1 : 0), caretPosition);
          updateAutoComplete(dataSource(term, options));
        }
      });

      $(this).on('keydown.autocomplete', function (e) {
        var c, caretPosition, i, initial, prev, prevIsGood, stopFound, term, total, userToComplete;

        if (e.ctrlKey || e.altKey || e.metaKey) {
          return true;
        }

        if (options.allowAny) {
          // saves us wiring up a change event as well

          Ember.run.cancel(inputTimeout);
          inputTimeout = Ember.run.later(function () {
            if (inputSelectedItems.length === 0) {
              inputSelectedItems.push("");
            }

            if (_.isString(inputSelectedItems[0]) && me.val().length > 0) {
              inputSelectedItems.pop();
              inputSelectedItems.push(me.val());
              if (options.onChangeItems) {
                options.onChangeItems(inputSelectedItems);
              }
            }
          }, 50);
        }

        if (!options.key) {
          completeStart = 0;
        }
        if (e.which === keys.shift) return;
        if (completeStart === null && e.which === keys.backSpace && options.key) {
          c = Discourse.Utilities.caretPosition(me[0]);
          c -= 1;
          initial = c;
          prevIsGood = true;
          while (prevIsGood && c >= 0) {
            c -= 1;
            prev = me[0].value[c];
            stopFound = prev === options.key;
            if (stopFound) {
              prev = me[0].value[c - 1];
              if (checkTriggerRule({ backSpace: true }) && (!prev || allowedLettersRegex.test(prev))) {
                completeStart = c;
                caretPosition = completeEnd = initial;
                term = me[0].value.substring(c + 1, initial);
                updateAutoComplete(dataSource(term, options));
                return true;
              }
            }
            prevIsGood = /[a-zA-Z\.-]/.test(prev);
          }
        }

        // ESC
        if (e.which === keys.esc) {
          if (div !== null) {
            closeAutocomplete();
            return false;
          }
          return true;
        }

        if (completeStart !== null) {
          caretPosition = Discourse.Utilities.caretPosition(me[0]);

          // allow people to right arrow out of completion
          if (e.which === keys.rightArrow && me[0].value[caretPosition] === ' ') {
            closeAutocomplete();
            return true;
          }

          // If we've backspaced past the beginning, cancel unless no key
          if (caretPosition <= completeStart && options.key) {
            closeAutocomplete();
            return true;
          }

          // Keyboard codes! So 80's.
          switch (e.which) {
            case keys.enter:
            case keys.tab:
              if (!autocompleteOptions) return true;
              if (selectedOption >= 0 && (userToComplete = autocompleteOptions[selectedOption])) {
                completeTerm(userToComplete);
              } else {
                // We're cancelling it, really.
                return true;
              }
              e.stopImmediatePropagation();
              return false;
            case keys.upArrow:
              selectedOption = selectedOption - 1;
              if (selectedOption < 0) {
                selectedOption = 0;
              }
              markSelected();
              return false;
            case keys.downArrow:
              total = autocompleteOptions.length;
              selectedOption = selectedOption + 1;
              if (selectedOption >= total) {
                selectedOption = total - 1;
              }
              if (selectedOption < 0) {
                selectedOption = 0;
              }
              markSelected();
              return false;
            case keys.backSpace:
              completeEnd = caretPosition;
              caretPosition--;

              if (caretPosition < 0) {
                closeAutocomplete();
                if (isInput) {
                  i = wrap.find('a:last');
                  if (i) {
                    i.click();
                  }
                }
                return true;
              }

              term = me.val().substring(completeStart + (options.key ? 1 : 0), caretPosition);

              if (completeStart === caretPosition && term === options.key) {
                closeAutocomplete();
              }

              updateAutoComplete(dataSource(term, options));
              return true;
            default:
              completeEnd = caretPosition;
              return true;
          }
        }
      });

      return this;
    }
  });
define("discourse/lib/after-transition", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      CSS transitions are a PITA, often we need to queue some js after a transition, this helper ensures
      it happens after the transition.

      SO: http://stackoverflow.com/questions/9943435/css3-animation-end-techniques
    **/

    var dummy = document.createElement("div"),
        eventNameHash = {
      webkit: "webkitTransitionEnd",
      Moz: "transitionend",
      O: "oTransitionEnd",
      ms: "MSTransitionEnd"
    };

    var transitionEnd = (function () {
      var retValue;
      retValue = "transitionend";
      Object.keys(eventNameHash).some(function (vendor) {
        if (vendor + "TransitionProperty" in dummy.style) {
          retValue = eventNameHash[vendor];
          return true;
        }
      });
      return retValue;
    })();

    __exports__["default"] = function (element, callback) {
      return $(element).on(transitionEnd, callback);
    }
  });
define("discourse/lib/safari-hacks", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.isWorkaroundActive = isWorkaroundActive;
    function applicable() {
      // IE has no DOMNodeInserted so can not get this hack despite saying it is like iPhone
      // This will apply hack on all iDevices
      return navigator.userAgent.match(/(iPad|iPhone|iPod)/g) && navigator.userAgent.match(/Safari/g) && !navigator.userAgent.match(/Trident/g);
    }

    var workaroundActive = false;

    function isWorkaroundActive() {
      return workaroundActive;
    }

    // per http://stackoverflow.com/questions/29001977/safari-in-ios8-is-scrolling-screen-when-fixed-elements-get-focus/29064810
    function positioningWorkaround($fixedElement) {
      if (!applicable()) {
        return;
      }

      var fixedElement = $fixedElement[0];

      var done = false;
      var originalScrollTop = 0;

      var blurredNow = function (evt) {
        if (!done && _.include($(document.activeElement).parents(), fixedElement)) {
          // something in focus so skip
          return;
        }

        done = true;

        $('#main-outlet').show();
        $('header').show();

        fixedElement.style.position = '';
        fixedElement.style.top = '';
        fixedElement.style.height = '';

        $(window).scrollTop(originalScrollTop);

        if (evt) {
          evt.target.removeEventListener('blur', blurred);
        }
        workaroundActive = false;
      };

      var blurred = _.debounce(blurredNow, 250);

      var positioningHack = function (evt) {
        var self = this;
        done = false;

        // we need this, otherwise changing focus means we never clear
        self.addEventListener('blur', blurred);

        if (fixedElement.style.top === '0px') {
          if (this !== document.activeElement) {
            evt.preventDefault();
            self.focus();
          }
          return;
        }

        originalScrollTop = $(window).scrollTop();

        // take care of body

        $('#main-outlet').hide();
        $('header').hide();

        $(window).scrollTop(0);

        fixedElement.style.top = '0px';

        fixedElement.style.height = parseInt(window.innerHeight * 0.6) + "px";

        // I used to do this, but it seems like we don't need to with position
        // fixed
        // setTimeout(()=>$(window).scrollTop(0),500);

        evt.preventDefault();
        self.focus();
        workaroundActive = true;
      };

      function attachTouchStart(elem, fn) {
        if (!$(elem).data('listening')) {
          elem.addEventListener('touchstart', fn);
          $(elem).data('listening', true);
        }
      }

      var checkForInputs = _.debounce(function () {
        $fixedElement.find('button:not(.hide-preview),a:not(.mobile-file-upload):not(.toggle-toolbar)').each(function (idx, elem) {
          if ($(elem).parents('.autocomplete').length > 0) {
            return;
          }

          if ($(elem).parents('.d-editor-button-bar').length > 0) {
            return;
          }

          attachTouchStart(this, function (evt) {
            done = true;
            $(document.activeElement).blur();
            evt.preventDefault();
            $(this).click();
          });
        });
        $fixedElement.find('input[type=text],textarea').each(function () {
          attachTouchStart(this, positioningHack);
        });
      }, 100);

      fixedElement.addEventListener('DOMNodeInserted', checkForInputs);
    }

    __exports__["default"] = positioningWorkaround;
  });
define("discourse/adapters/email-template", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestAdapter = __dependency1__["default"];

    __exports__["default"] = RestAdapter.extend({
      basePath: function () {
        return "/admin/customize/";
      }
    });
  });
define("discourse/adapters/notification", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestAdapter = __dependency1__["default"];

    __exports__["default"] = RestAdapter.extend({ cache: true });
  });
define("discourse/adapters/post-reply-history", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestAdapter = __dependency1__["default"];

    __exports__["default"] = RestAdapter.extend({
      find: function (store, type, findArgs) {
        var maxReplies = Discourse.SiteSettings.max_reply_history;
        return Discourse.ajax('/posts/' + findArgs.postId + '/reply-history?max_replies=' + maxReplies).then(function (replies) {
          return { post_reply_histories: replies };
        });
      }
    });
  });
define("discourse/adapters/post-reply", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestAdapter = __dependency1__["default"];

    __exports__["default"] = RestAdapter.extend({
      find: function (store, type, findArgs) {
        return Discourse.ajax('/posts/' + findArgs.postId + '/replies').then(function (replies) {
          return { post_replies: replies };
        });
      }
    });
  });
define("discourse/adapters/post", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestAdapter = __dependency1__["default"];
    var Result = __dependency1__.Result;

    __exports__["default"] = RestAdapter.extend({

      find: function (store, type, findArgs) {
        return this._super(store, type, findArgs).then(function (result) {
          return { post: result };
        });
      },

      createRecord: function (store, type, args) {
        var typeField = Ember.String.underscore(type);
        args.nested_post = true;
        return Discourse.ajax(this.pathFor(store, type), { method: 'POST', data: args }).then(function (json) {
          return new Result(json[typeField], json);
        });
      }

    });
  });
define("discourse/adapters/rest", 
  ["discourse/lib/hash","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.Result = Result;
    var hashString = __dependency1__.hashString;

    var ADMIN_MODELS = ['plugin', 'site-customization', 'embeddable-host'];

    function Result(payload, responseJson) {
      this.payload = payload;
      this.responseJson = responseJson;
      this.target = null;
    }

    var ajax = Discourse.ajax;

    // We use this to make sure 404s are caught
    function rethrow(error) {
      if (error.status === 404) {
        throw "404: " + error.responseText;
      }
      throw error;
    }

    __exports__["default"] = Ember.Object.extend({

      storageKey: function (type, findArgs, options) {
        if (options && options.cacheKey) {
          return options.cacheKey;
        }
        var hashedArgs = Math.abs(hashString(JSON.stringify(findArgs)));
        return type + '_' + hashedArgs;
      },

      basePath: function (store, type) {
        if (ADMIN_MODELS.indexOf(type.replace('_', '-')) !== -1) {
          return "/admin/";
        }
        return "/";
      },

      appendQueryParams: function (path, findArgs) {
        if (findArgs) {
          if (typeof findArgs === "object") {
            var queryString = Object.keys(findArgs).reject(function (k) {
              return !findArgs[k];
            }).map(function (k) {
              return k + "=" + encodeURIComponent(findArgs[k]);
            });

            if (queryString.length) {
              return path + "?" + queryString.join('&');
            }
          } else {
            // It's serializable as a string if not an object
            return path + "/" + findArgs;
          }
        }
        return path;
      },

      pathFor: function (store, type, findArgs) {
        var path = this.basePath(store, type, findArgs) + Ember.String.underscore(store.pluralize(type));
        return this.appendQueryParams(path, findArgs);
      },

      findAll: function (store, type) {
        return ajax(this.pathFor(store, type)).catch(rethrow);
      },

      find: function (store, type, findArgs) {
        return ajax(this.pathFor(store, type, findArgs)).catch(rethrow);
      },

      findStale: function (store, type, findArgs, options) {
        if (this.cached) {
          return this.cached[this.storageKey(type, findArgs, options)];
        }
      },

      cacheFind: function (store, type, findArgs, opts, hydrated) {
        this.cached = this.cached || {};
        this.cached[this.storageKey(type, findArgs, opts)] = hydrated;
      },

      update: function (store, type, id, attrs) {
        var data = {};
        var typeField = Ember.String.underscore(type);
        data[typeField] = attrs;
        return ajax(this.pathFor(store, type, id), { method: 'PUT', data: data }).then(function (json) {
          return new Result(json[typeField], json);
        });
      },

      createRecord: function (store, type, attrs) {
        var data = {};
        var typeField = Ember.String.underscore(type);
        data[typeField] = attrs;
        return ajax(this.pathFor(store, type), { method: 'POST', data: data }).then(function (json) {
          return new Result(json[typeField], json);
        });
      },

      destroyRecord: function (store, type, record) {
        return ajax(this.pathFor(store, type, record.get('id')), { method: 'DELETE' });
      }

    });
  });
define("discourse/adapters/tag-notification", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RESTAdapter = __dependency1__["default"];

    __exports__["default"] = RESTAdapter.extend({
      pathFor: function (store, type, id) {
        return "/tags/" + id + "/notifications";
      }
    });
  });
define("discourse/adapters/topic-list", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.finderFor = finderFor;
    var RestAdapter = __dependency1__["default"];

    function finderFor(filter, params) {
      return function () {
        var url = Discourse.getURL("/") + filter + ".json";

        if (params) {
          (function () {
            var keys = Object.keys(params),
                encoded = [];

            keys.forEach(function (p) {
              var value = encodeURI(params[p]);
              if (typeof value !== 'undefined') {
                encoded.push(p + "=" + value);
              }
            });

            if (encoded.length > 0) {
              url += "?" + encoded.join('&');
            }
          })();
        }
        return Discourse.ajax(url);
      };
    }

    __exports__["default"] = RestAdapter.extend({

      find: function (store, type, findArgs) {
        var filter = findArgs.filter;
        var params = findArgs.params;

        return PreloadStore.getAndRemove("topic_list_" + filter, finderFor(filter, params)).then(function (result) {
          result.filter = filter;
          result.params = params;
          return result;
        });
      }
    });
  });
define("discourse/adapters/topic", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestAdapter = __dependency1__["default"];

    __exports__["default"] = RestAdapter.extend({
      find: function (store, type, findArgs) {
        if (findArgs.similar) {
          return Discourse.ajax("/topics/similar_to", { data: findArgs.similar });
        } else {
          return this._super(store, type, findArgs);
        }
      }
    });
  });
define("discourse/models/result-set", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.ArrayProxy.extend({
      loading: false,
      loadingMore: false,
      totalRows: 0,
      refreshing: false,

      content: null,
      loadMoreUrl: null,
      refreshUrl: null,
      findArgs: null,
      store: null,
      __type: null,

      canLoadMore: (function () {
        return this.get('length') < this.get('totalRows');
      }).property('totalRows', 'length'),

      loadMore: function () {
        var _this = this;

        var loadMoreUrl = this.get('loadMoreUrl');
        if (!loadMoreUrl) {
          return;
        }

        var totalRows = this.get('totalRows');
        if (this.get('length') < totalRows && !this.get('loadingMore')) {
          var _ret = (function () {
            _this.set('loadingMore', true);

            var self = _this;
            return {
              v: _this.store.appendResults(_this, _this.get('__type'), loadMoreUrl).finally(function () {
                self.set('loadingMore', false);
              })
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }

        return Ember.RSVP.resolve();
      },

      refresh: function () {
        if (this.get('refreshing')) {
          return;
        }

        var refreshUrl = this.get('refreshUrl');
        if (!refreshUrl) {
          return;
        }

        var self = this;
        this.set('refreshing', true);
        return this.store.refreshResults(this, this.get('__type'), refreshUrl).finally(function () {
          self.set('refreshing', false);
        });
      }
    });
  });
define("discourse/models/store", 
  ["discourse/models/rest","discourse/models/result-set","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];
    var ResultSet = __dependency2__["default"];

    var _identityMap = undefined;

    // You should only call this if you're a test scaffold
    function flushMap() {
      _identityMap = {};
    }

    function storeMap(type, id, obj) {
      if (!id) {
        return;
      }

      _identityMap[type] = _identityMap[type] || {};
      _identityMap[type][id] = obj;
    }

    function fromMap(type, id) {
      var byType = _identityMap[type];
      if (byType) {
        return byType[id];
      }
    }

    function removeMap(type, id) {
      var byType = _identityMap[type];
      if (byType) {
        delete byType[id];
      }
    }

    function findAndRemoveMap(type, id) {
      var byType = _identityMap[type];
      if (byType) {
        var result = byType[id];
        delete byType[id];
        return result;
      }
    }

    flushMap();

    __exports__["default"] = Ember.Object.extend({
      _plurals: { 'post-reply': 'post-replies',
        'post-reply-history': 'post_reply_histories' },

      pluralize: function (thing) {
        return this._plurals[thing] || thing + "s";
      },

      addPluralization: function (thing, plural) {
        this._plurals[thing] = plural;
      },

      findAll: function (type) {
        var self = this;
        return this.adapterFor(type).findAll(this, type).then(function (result) {
          return self._resultSet(type, result);
        });
      },

      // Mostly for legacy, things like TopicList without ResultSets
      findFiltered: function (type, findArgs) {
        var self = this;
        return this.adapterFor(type).find(this, type, findArgs).then(function (result) {
          return self._build(type, result);
        });
      },

      _hydrateFindResults: function (result, type, findArgs) {
        if (typeof findArgs === "object") {
          return this._resultSet(type, result, findArgs);
        } else {
          return this._hydrate(type, result[Ember.String.underscore(type)], result);
        }
      },

      // See if the store can find stale data. We sometimes prefer to show stale data and
      // refresh it in the background.
      findStale: function (type, findArgs, opts) {
        var _this = this;

        var stale = this.adapterFor(type).findStale(this, type, findArgs, opts);
        return {
          hasResults: stale !== undefined,
          results: stale,
          refresh: function () {
            return _this.find(type, findArgs, opts);
          }
        };
      },

      find: function (type, findArgs, opts) {
        var _this2 = this;

        var adapter = this.adapterFor(type);
        return adapter.find(this, type, findArgs, opts).then(function (result) {
          var hydrated = _this2._hydrateFindResults(result, type, findArgs, opts);
          if (adapter.cache) {
            var stale = adapter.findStale(_this2, type, findArgs, opts);
            hydrated = _this2._updateStale(stale, hydrated);
            adapter.cacheFind(_this2, type, findArgs, opts, hydrated);
          }
          return hydrated;
        });
      },

      _updateStale: function (stale, hydrated) {
        if (!stale) {
          return hydrated;
        }

        hydrated.set('content', hydrated.get('content').map(function (item) {
          var staleItem = stale.content.findBy('id', item.get('id'));
          if (staleItem) {
            staleItem.setProperties(item);
          } else {
            staleItem = item;
          }
          return staleItem;
        }));
        return hydrated;
      },

      refreshResults: function (resultSet, type, url) {
        var self = this;
        return Discourse.ajax(url).then(function (result) {
          var typeName = Ember.String.underscore(self.pluralize(type));
          var content = result[typeName].map(function (obj) {
            return self._hydrate(type, obj, result);
          });
          resultSet.set('content', content);
        });
      },

      appendResults: function (resultSet, type, url) {
        var self = this;

        return Discourse.ajax(url).then(function (result) {
          var typeName = Ember.String.underscore(self.pluralize(type)),
              totalRows = result["total_rows_" + typeName] || result.get('totalRows'),
              loadMoreUrl = result["load_more_" + typeName],
              content = result[typeName].map(function (obj) {
            return self._hydrate(type, obj, result);
          });

          resultSet.setProperties({ totalRows: totalRows, loadMoreUrl: loadMoreUrl });
          resultSet.get('content').pushObjects(content);

          // If we've loaded them all, clear the load more URL
          if (resultSet.get('length') >= totalRows) {
            resultSet.set('loadMoreUrl', null);
          }
        });
      },

      update: function (type, id, attrs) {
        return this.adapterFor(type).update(this, type, id, attrs, function (result) {
          if (result && result[type] && result[type].id) {
            var oldRecord = findAndRemoveMap(type, id);
            storeMap(type, result[type].id, oldRecord);
          }
          return result;
        });
      },

      createRecord: function (type, attrs) {
        attrs = attrs || {};
        return !!attrs.id ? this._hydrate(type, attrs) : this._build(type, attrs);
      },

      destroyRecord: function (type, record) {
        // If the record is new, don't perform an Ajax call
        if (record.get('isNew')) {
          removeMap(type, record.get('id'));
          return Ember.RSVP.Promise.resolve(true);
        }

        return this.adapterFor(type).destroyRecord(this, type, record).then(function (result) {
          removeMap(type, record.get('id'));
          return result;
        });
      },

      _resultSet: function (type, result, findArgs) {
        var _this3 = this;

        var typeName = Ember.String.underscore(this.pluralize(type));
        var content = result[typeName].map(function (obj) {
          return _this3._hydrate(type, obj, result);
        });

        var createArgs = {
          content: content,
          findArgs: findArgs,
          totalRows: result["total_rows_" + typeName] || content.length,
          loadMoreUrl: result["load_more_" + typeName],
          refreshUrl: result['refresh_' + typeName],
          store: this,
          __type: type
        };

        if (result.extras) {
          createArgs.extras = result.extras;
        }

        return ResultSet.create(createArgs);
      },

      _build: function (type, obj) {
        obj.store = this;
        obj.__type = type;
        obj.__state = obj.id ? "created" : "new";

        // TODO: Have injections be automatic
        obj.topicTrackingState = this.container.lookup('topic-tracking-state:main');
        obj.keyValueStore = this.container.lookup('key-value-store:main');

        var klass = this.container.lookupFactory('model:' + type) || RestModel;
        var model = klass.create(obj);

        storeMap(type, obj.id, model);
        return model;
      },

      adapterFor: function (type) {
        return this.container.lookup('adapter:' + type) || this.container.lookup('adapter:rest');
      },

      _lookupSubType: function (subType, type, id, root) {
        var _this4 = this;

        // cheat: we know we already have categories in memory
        // TODO: topics do their own resolving of `category_id`
        // to category. That should either respect this or be
        // removed.
        if (subType === 'category' && type !== 'topic') {
          return Discourse.Category.findById(id);
        }

        var pluralType = this.pluralize(subType);
        var collection = root[this.pluralize(subType)];
        if (collection) {
          var _ret = (function () {
            var hashedProp = "__hashed_" + pluralType;
            var hashedCollection = root[hashedProp];
            if (!hashedCollection) {
              hashedCollection = {};
              collection.forEach(function (it) {
                hashedCollection[it.id] = it;
              });
              root[hashedProp] = hashedCollection;
            }

            var found = hashedCollection[id];
            if (found) {
              var hydrated = _this4._hydrate(subType, found, root);
              hashedCollection[id] = hydrated;
              return {
                v: hydrated
              };
            }
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
      },

      _hydrateEmbedded: function (type, obj, root) {
        var self = this;
        Object.keys(obj).forEach(function (k) {
          var m = /(.+)\_id(s?)$/.exec(k);
          if (m) {
            (function () {
              var subType = m[1];

              if (m[2]) {
                var hydrated = obj[k].map(function (id) {
                  return self._lookupSubType(subType, type, id, root);
                });
                obj[self.pluralize(subType)] = hydrated || [];
                delete obj[k];
              } else {
                var hydrated = self._lookupSubType(subType, type, obj[k], root);
                if (hydrated) {
                  obj[subType] = hydrated;
                  delete obj[k];
                }
              }
            })();
          }
        });
      },

      _hydrate: function (type, obj, root) {
        if (!obj) {
          throw "Can't hydrate " + type + " of `null`";
        }
        if (!obj.id) {
          throw "Can't hydrate " + type + " without an `id`";
        }

        root = root || obj;

        // Experimental: If serialized with a certain option we'll wire up embedded objects
        // automatically.
        if (root.__rest_serializer === "1") {
          this._hydrateEmbedded(type, obj, root);
        }

        var existing = fromMap(type, obj.id);
        if (existing === obj) {
          return existing;
        }

        if (existing) {
          delete obj.id;
          var klass = this.container.lookupFactory('model:' + type) || RestModel;
          existing.setProperties(klass.munge(obj));
          return existing;
        }

        return this._build(type, obj);
      }
    });

    __exports__.flushMap = flushMap;
  });
define("discourse/models/post-action-type", 
  ["discourse/models/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];

    var PostActionType = RestModel.extend({
      notCustomFlag: Em.computed.not('is_custom_flag')
    });

    var MAX_MESSAGE_LENGTH = 500;

    __exports__.MAX_MESSAGE_LENGTH = MAX_MESSAGE_LENGTH;
    __exports__["default"] = PostActionType;
  });
define("discourse/models/action-summary", 
  ["discourse/models/rest","discourse/lib/ajax-error","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];
    var popupAjaxError = __dependency2__.popupAjaxError;

    __exports__["default"] = RestModel.extend({

      canToggle: (function () {
        return this.get('can_undo') || this.get('can_act');
      }).property('can_undo', 'can_act'),

      // Remove it
      removeAction: function () {
        this.setProperties({
          acted: false,
          count: this.get('count') - 1,
          can_act: true,
          can_undo: false
        });
      },

      togglePromise: function (post) {
        return this.get('acted') ? this.undo(post) : this.act(post);
      },

      toggle: function (post) {
        if (!this.get('acted')) {
          this.act(post);
          return true;
        } else {
          this.undo(post);
          return false;
        }
      },

      // Perform this action
      act: function (post, opts) {

        if (!opts) opts = {};

        var action = this.get('actionType.name_key');

        // Mark it as acted
        this.setProperties({
          acted: true,
          count: this.get('count') + 1,
          can_act: false,
          can_undo: true
        });

        if (action === 'notify_moderators' || action === 'notify_user') {
          this.set('can_undo', false);
          this.set('can_defer_flags', false);
        }

        // Create our post action
        var self = this;
        return Discourse.ajax("/post_actions", {
          type: 'POST',
          data: {
            id: this.get('flagTopic') ? this.get('flagTopic.id') : post.get('id'),
            post_action_type_id: this.get('id'),
            message: opts.message,
            is_warning: opts.isWarning,
            take_action: opts.takeAction,
            flag_topic: this.get('flagTopic') ? true : false
          },
          returnXHR: true
        }).then(function (data) {
          if (!self.get('flagTopic')) {
            post.updateActionsSummary(data.result);
          }
          var remaining = parseInt(data.xhr.getResponseHeader('Discourse-Actions-Remaining') || 0);
          var max = parseInt(data.xhr.getResponseHeader('Discourse-Actions-Max') || 0);
          return { acted: true, remaining: remaining, max: max };
        }).catch(function (error) {
          popupAjaxError(error);
          self.removeAction(post);
        });
      },

      // Undo this action
      undo: function (post) {
        this.removeAction(post);

        // Remove our post action
        return Discourse.ajax("/post_actions/" + post.get('id'), {
          type: 'DELETE',
          data: { post_action_type_id: this.get('id') }
        }).then(function (result) {
          post.updateActionsSummary(result);
          return { acted: false };
        });
      },

      deferFlags: function (post) {
        var _this = this;

        return Discourse.ajax("/post_actions/defer_flags", {
          type: "POST",
          data: { post_action_type_id: this.get("id"), id: post.get('id') }
        }).then(function () {
          return _this.set('count', 0);
        });
      }
    });
  });
define("discourse/models/post", 
  ["discourse/models/rest","discourse/lib/ajax-error","discourse/models/action-summary","discourse/lib/computed","discourse/lib/quote","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var RestModel = __dependency1__["default"];
    var popupAjaxError = __dependency2__.popupAjaxError;
    var ActionSummary = __dependency3__["default"];
    var url = __dependency4__.url;
    var propertyEqual = __dependency4__.propertyEqual;
    var Quote = __dependency5__["default"];
    var computed = __dependency6__["default"];

    var Post = RestModel.extend(_createDecoratedObject([{
      key: 'siteSettings',
      decorators: [computed()],
      value: function () {
        // TODO: Remove this once one instantiate all `Discourse.Post` models via the store.
        return Discourse.SiteSettings;
      }
    }, {
      key: 'shareUrl',
      initializer: function () {
        return (function () {
          var user = Discourse.User.current();
          var userSuffix = user ? '?u=' + user.get('username_lower') : '';

          if (this.get('firstPost')) {
            return this.get('topic.url') + userSuffix;
          } else {
            return this.get('url') + userSuffix;
          }
        }).property('url');
      }
    }, {
      key: 'new_user',
      initializer: function () {
        return Em.computed.equal('trust_level', 0);
      }
    }, {
      key: 'firstPost',
      initializer: function () {
        return Em.computed.equal('post_number', 1);
      }
    }, {
      key: 'deletedViaTopic',

      // Posts can show up as deleted if the topic is deleted
      initializer: function () {
        return Em.computed.and('firstPost', 'topic.deleted_at');
      }
    }, {
      key: 'deleted',
      initializer: function () {
        return Em.computed.or('deleted_at', 'deletedViaTopic');
      }
    }, {
      key: 'notDeleted',
      initializer: function () {
        return Em.computed.not('deleted');
      }
    }, {
      key: 'showName',
      initializer: function () {
        return (function () {
          var name = this.get('name');
          return name && name !== this.get('username') && Discourse.SiteSettings.display_name_on_posts;
        }).property('name', 'username');
      }
    }, {
      key: 'postDeletedBy',
      initializer: function () {
        return (function () {
          if (this.get('firstPost')) {
            return this.get('topic.deleted_by');
          }
          return this.get('deleted_by');
        }).property('firstPost', 'deleted_by', 'topic.deleted_by');
      }
    }, {
      key: 'postDeletedAt',
      initializer: function () {
        return (function () {
          if (this.get('firstPost')) {
            return this.get('topic.deleted_at');
          }
          return this.get('deleted_at');
        }).property('firstPost', 'deleted_at', 'topic.deleted_at');
      }
    }, {
      key: 'url',
      initializer: function () {
        return (function () {
          return Discourse.Utilities.postUrl(this.get('topic.slug') || this.get('topic_slug'), this.get('topic_id'), this.get('post_number'));
        }).property('post_number', 'topic_id', 'topic.slug');
      }
    }, {
      key: 'urlWithNumber',
      decorators: [computed('post_number', 'url')],
      value: function (postNumber, postUrl) {
        return postNumber === 1 ? postUrl + "/1" : postUrl;
      }
    }, {
      key: 'usernameUrl',
      initializer: function () {
        return url('username', '/users/%@');
      }
    }, {
      key: 'topicOwner',
      initializer: function () {
        return propertyEqual('topic.details.created_by.id', 'user_id');
      }
    }, {
      key: 'updatePostField',
      value: function (field, value) {
        var _this = this;

        var data = {};
        data[field] = value;

        return Discourse.ajax('/posts/' + this.get('id') + '/' + field, { type: 'PUT', data: data }).then(function () {
          _this.set(field, value);
          _this.incrementProperty("version");
        }).catch(popupAjaxError);
      }
    }, {
      key: 'internalLinks',
      initializer: function () {
        return (function () {
          if (Ember.isEmpty(this.get('link_counts'))) return null;
          return this.get('link_counts').filterProperty('internal').filterProperty('title');
        }).property('link_counts.@each.internal');
      }
    }, {
      key: 'flagsAvailable',
      initializer: function () {
        return (function () {
          var post = this;
          return Discourse.Site.currentProp('flagTypes').filter(function (item) {
            return post.get("actionByName." + item.get('name_key') + ".can_act");
          });
        }).property('actions_summary.@each.can_act');
      }
    }, {
      key: 'afterUpdate',
      value: function (res) {
        if (res.category) {
          Discourse.Site.current().updateCategory(res.category);
        }
      }
    }, {
      key: 'updateProperties',
      value: function () {
        return {
          post: { raw: this.get('raw'), edit_reason: this.get('editReason') },
          image_sizes: this.get('imageSizes')
        };
      }
    }, {
      key: 'createProperties',
      value: function () {
        // composer only used once, defer the dependency
        var Composer = require('discourse/models/composer').default;
        var data = this.getProperties(Composer.serializedFieldsForCreate());
        data.reply_to_post_number = this.get('reply_to_post_number');
        data.image_sizes = this.get('imageSizes');

        var metaData = this.get('metaData');

        // Put the metaData into the request
        if (metaData) {
          data.meta_data = {};
          Object.keys(metaData).forEach(function (key) {
            data.meta_data[key] = metaData.get(key);
          });
        }

        return data;
      }
    }, {
      key: 'expand',

      // Expands the first post's content, if embedded and shortened.
      value: function () {
        var self = this;
        return Discourse.ajax("/posts/" + this.get('id') + "/expand-embed").then(function (post) {
          self.set('cooked', "<section class='expanded-embed'>" + post.cooked + "</section>");
        });
      }
    }, {
      key: 'recover',

      // Recover a deleted post
      value: function () {
        var post = this,
            initProperties = post.getProperties('deleted_at', 'deleted_by', 'user_deleted', 'can_delete');

        post.setProperties({
          deleted_at: null,
          deleted_by: null,
          user_deleted: false,
          can_delete: false
        });

        return Discourse.ajax("/posts/" + this.get('id') + "/recover", { type: 'PUT', cache: false }).then(function (data) {
          post.setProperties({
            cooked: data.cooked,
            raw: data.raw,
            user_deleted: false,
            can_delete: true,
            version: data.version
          });
        }).catch(function (error) {
          popupAjaxError(error);
          post.setProperties(initProperties);
        });
      }
    }, {
      key: 'setDeletedState',

      /**
        Changes the state of the post to be deleted. Does not call the server, that should be
        done elsewhere.
      **/
      value: function (deletedBy) {
        this.set('oldCooked', this.get('cooked'));

        // Moderators can delete posts. Users can only trigger a deleted at message, unless delete_removed_posts_after is 0.
        if (deletedBy.get('staff') || Discourse.SiteSettings.delete_removed_posts_after === 0) {
          this.setProperties({
            deleted_at: new Date(),
            deleted_by: deletedBy,
            can_delete: false
          });
        } else {
          this.setProperties({
            cooked: Discourse.Markdown.cook(I18n.t("post.deleted_by_author", { count: Discourse.SiteSettings.delete_removed_posts_after })),
            can_delete: false,
            version: this.get('version') + 1,
            can_recover: true,
            can_edit: false,
            user_deleted: true
          });
        }
      }
    }, {
      key: 'undoDeleteState',

      /**
        Changes the state of the post to NOT be deleted. Does not call the server.
        This can only be called after setDeletedState was called, but the delete
        failed on the server.
      **/
      value: function () {
        if (this.get('oldCooked')) {
          this.setProperties({
            deleted_at: null,
            deleted_by: null,
            cooked: this.get('oldCooked'),
            version: this.get('version') - 1,
            can_recover: false,
            can_delete: true,
            user_deleted: false
          });
        }
      }
    }, {
      key: 'destroy',
      value: function (deletedBy) {
        this.setDeletedState(deletedBy);
        return Discourse.ajax("/posts/" + this.get('id'), {
          data: { context: window.location.pathname },
          type: 'DELETE'
        });
      }
    }, {
      key: 'updateFromPost',

      /**
        Updates a post from another's attributes. This will normally happen when a post is loading but
        is already found in an identity map.
      **/
      value: function (otherPost) {
        var self = this;
        Object.keys(otherPost).forEach(function (key) {
          var value = otherPost[key],
              oldValue = self[key];

          if (!value) {
            value = null;
          }
          if (!oldValue) {
            oldValue = null;
          }

          var skip = false;
          if (typeof value !== "function" && oldValue !== value) {
            // wishing for an identity map
            if (key === "reply_to_user" && value && oldValue) {
              skip = value.username === oldValue.username || Em.get(value, "username") === Em.get(oldValue, "username");
            }

            if (!skip) {
              self.set(key, value);
            }
          }
        });
      }
    }, {
      key: 'expandHidden',
      value: function () {
        var _this2 = this;

        return Discourse.ajax("/posts/" + this.get('id') + "/cooked.json").then(function (result) {
          _this2.setProperties({ cooked: result.cooked, cooked_hidden: false });
        });
      }
    }, {
      key: 'rebake',
      value: function () {
        return Discourse.ajax("/posts/" + this.get("id") + "/rebake", { type: "PUT" });
      }
    }, {
      key: 'unhide',
      value: function () {
        return Discourse.ajax("/posts/" + this.get("id") + "/unhide", { type: "PUT" });
      }
    }, {
      key: 'toggleBookmark',
      value: function () {
        var self = this;
        var bookmarkedTopic = undefined;

        this.toggleProperty("bookmarked");

        if (this.get("bookmarked") && !this.get("topic.bookmarked")) {
          this.set("topic.bookmarked", true);
          bookmarkedTopic = true;
        }

        // need to wait to hear back from server (stuff may not be loaded)

        return Discourse.Post.updateBookmark(this.get('id'), this.get('bookmarked')).then(function (result) {
          self.set("topic.bookmarked", result.topic_bookmarked);
        }).catch(function (e) {
          self.toggleProperty("bookmarked");
          if (bookmarkedTopic) {
            self.set("topic.bookmarked", false);
          }
          throw e;
        });
      }
    }, {
      key: 'updateActionsSummary',
      value: function (json) {
        if (json && json.id === this.get('id')) {
          json = Post.munge(json);
          this.set('actions_summary', json.actions_summary);
        }
      }
    }, {
      key: 'revertToRevision',
      value: function (version) {
        return Discourse.ajax('/posts/' + this.get('id') + '/revisions/' + version + '/revert', { type: 'PUT' });
      }
    }]));

    Post.reopenClass({

      munge: function (json) {
        if (json.actions_summary) {
          (function () {
            var lookup = Em.Object.create();

            // this area should be optimized, it is creating way too many objects per post
            json.actions_summary = json.actions_summary.map(function (a) {
              a.actionType = Discourse.Site.current().postActionTypeById(a.id);
              a.count = a.count || 0;
              var actionSummary = ActionSummary.create(a);
              lookup[a.actionType.name_key] = actionSummary;

              if (a.actionType.name_key === "like") {
                json.likeAction = actionSummary;
              }
              return actionSummary;
            });

            json.actionByName = lookup;
          })();
        }

        if (json && json.reply_to_user) {
          json.reply_to_user = Discourse.User.create(json.reply_to_user);
        }
        return json;
      },

      updateBookmark: function (postId, bookmarked) {
        return Discourse.ajax("/posts/" + postId + "/bookmark", {
          type: 'PUT',
          data: { bookmarked: bookmarked }
        });
      },

      deleteMany: function (selectedPosts, selectedReplies) {
        return Discourse.ajax("/posts/destroy_many", {
          type: 'DELETE',
          data: {
            post_ids: selectedPosts.map(function (p) {
              return p.get('id');
            }),
            reply_post_ids: selectedReplies.map(function (p) {
              return p.get('id');
            })
          }
        });
      },

      loadRevision: function (postId, version) {
        return Discourse.ajax("/posts/" + postId + "/revisions/" + version + ".json").then(function (result) {
          return Ember.Object.create(result);
        });
      },

      hideRevision: function (postId, version) {
        return Discourse.ajax("/posts/" + postId + "/revisions/" + version + "/hide", { type: 'PUT' });
      },

      showRevision: function (postId, version) {
        return Discourse.ajax("/posts/" + postId + "/revisions/" + version + "/show", { type: 'PUT' });
      },

      loadQuote: function (postId) {
        return Discourse.ajax("/posts/" + postId + ".json").then(function (result) {
          var post = Discourse.Post.create(result);
          return Quote.build(post, post.get('raw'), { raw: true, full: true });
        });
      },

      loadRawEmail: function (postId) {
        return Discourse.ajax('/posts/' + postId + '/raw-email.json');
      }

    });

    __exports__["default"] = Post;

    // Don't drop the /1
  });

Discourse.Post = require('discourse/models/post').default;
define("discourse/lib/posts-with-placeholders", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.Placeholder = Placeholder;

    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__.default;

    function Placeholder(viewName) {
      this.viewName = viewName;
    }

    __exports__["default"] = Ember.Object.extend(Ember.Array, _createDecoratedObject([{
      key: 'posts',
      initializer: function () {
        return null;
      }
    }, {
      key: '_appendingIds',
      initializer: function () {
        return null;
      }
    }, {
      key: 'init',
      value: function () {
        this._appendingIds = {};
      }
    }, {
      key: 'length',
      decorators: [computed],
      value: function () {
        return this.get('posts.length') + Object.keys(this._appendingIds || {}).length;
      }
    }, {
      key: '_changeArray',
      value: function (cb, offset, removed, inserted) {
        this.arrayContentWillChange(offset, removed, inserted);
        cb();
        this.arrayContentDidChange(offset, removed, inserted);
        this.propertyDidChange('length');
      }
    }, {
      key: 'clear',
      value: function (cb) {
        this._changeArray(cb, 0, this.get('posts.length'), 0);
      }
    }, {
      key: 'appendPost',
      value: function (cb) {
        this._changeArray(cb, this.get('posts.length'), 0, 1);
      }
    }, {
      key: 'removePost',
      value: function (cb) {
        this._changeArray(cb, this.get('posts.length') - 1, 1, 0);
      }
    }, {
      key: 'refreshAll',
      value: function (cb) {
        var length = this.get('posts.length');
        this._changeArray(cb, 0, length, length);
      }
    }, {
      key: 'appending',
      value: function (postIds) {
        var _this = this;

        this._changeArray(function () {
          var appendingIds = _this._appendingIds;
          postIds.forEach(function (pid) {
            return appendingIds[pid] = true;
          });
        }, this.get('length'), 0, postIds.length);
      }
    }, {
      key: 'finishedAppending',
      value: function (postIds) {
        var _this2 = this;

        this._changeArray(function () {
          var appendingIds = _this2._appendingIds;
          postIds.forEach(function (pid) {
            return delete appendingIds[pid];
          });
        }, this.get('posts.length') - postIds.length, postIds.length, postIds.length);
      }
    }, {
      key: 'finishedPrepending',
      value: function (postIds) {
        this._changeArray(Ember.K, 0, 0, postIds.length);
      }
    }, {
      key: 'objectAt',
      value: function (index) {
        var posts = this.get('posts');
        return index < posts.length ? posts[index] : new Placeholder('post-placeholder');
      }
    }]));
  });
define("discourse/models/post-stream", 
  ["discourse/lib/url","discourse/models/rest","discourse/lib/posts-with-placeholders","ember-addons/ember-computed-decorators","discourse/models/topic","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var DiscourseURL = __dependency1__["default"];
    var RestModel = __dependency2__["default"];
    var PostsWithPlaceholders = __dependency3__["default"];
    var computed = __dependency4__.default;
    var loadTopicView = __dependency5__.loadTopicView;

    __exports__["default"] = RestModel.extend(_createDecoratedObject([{
      key: '_identityMap',
      initializer: function () {
        return null;
      }
    }, {
      key: 'posts',
      initializer: function () {
        return null;
      }
    }, {
      key: 'stream',
      initializer: function () {
        return null;
      }
    }, {
      key: 'userFilters',
      initializer: function () {
        return null;
      }
    }, {
      key: 'summary',
      initializer: function () {
        return null;
      }
    }, {
      key: 'loaded',
      initializer: function () {
        return null;
      }
    }, {
      key: 'loadingAbove',
      initializer: function () {
        return null;
      }
    }, {
      key: 'loadingBelow',
      initializer: function () {
        return null;
      }
    }, {
      key: 'loadingFilter',
      initializer: function () {
        return null;
      }
    }, {
      key: 'stagingPost',
      initializer: function () {
        return null;
      }
    }, {
      key: 'postsWithPlaceholders',
      initializer: function () {
        return null;
      }
    }, {
      key: 'init',
      value: function () {
        this._identityMap = {};
        var posts = [];
        var postsWithPlaceholders = PostsWithPlaceholders.create({ posts: posts, store: this.store });

        this.setProperties({
          posts: posts,
          postsWithPlaceholders: postsWithPlaceholders,
          stream: [],
          userFilters: [],
          summary: false,
          loaded: false,
          loadingAbove: false,
          loadingBelow: false,
          loadingFilter: false,
          stagingPost: false
        });
      }
    }, {
      key: 'loading',
      initializer: function () {
        return Ember.computed.or('loadingAbove', 'loadingBelow', 'loadingFilter', 'stagingPost');
      }
    }, {
      key: 'notLoading',
      initializer: function () {
        return Ember.computed.not('loading');
      }
    }, {
      key: 'filteredPostsCount',
      initializer: function () {
        return Ember.computed.alias("stream.length");
      }
    }, {
      key: 'hasPosts',
      decorators: [computed('posts.[]')],
      value: function () {
        return this.get('posts.length') > 0;
      }
    }, {
      key: 'hasLoadedData',
      decorators: [computed('hasPosts', 'filteredPostsCount')],
      value: function (hasPosts, filteredPostsCount) {
        return hasPosts && filteredPostsCount > 0;
      }
    }, {
      key: 'canAppendMore',
      initializer: function () {
        return Ember.computed.and('notLoading', 'hasPosts', 'lastPostNotLoaded');
      }
    }, {
      key: 'canPrependMore',
      initializer: function () {
        return Ember.computed.and('notLoading', 'hasPosts', 'firstPostNotLoaded');
      }
    }, {
      key: 'firstPostPresent',
      decorators: [computed('hasLoadedData', 'firstPostId', 'posts.[]')],
      value: function (hasLoadedData, firstPostId) {
        if (!hasLoadedData) {
          return false;
        }
        return !!this.get('posts').findProperty('id', firstPostId);
      }
    }, {
      key: 'firstPostNotLoaded',
      initializer: function () {
        return Ember.computed.not('firstPostPresent');
      }
    }, {
      key: 'firstPostId',
      initializer: function () {
        return Ember.computed.alias('stream.firstObject');
      }
    }, {
      key: 'lastPostId',
      initializer: function () {
        return Ember.computed.alias('stream.lastObject');
      }
    }, {
      key: 'loadedAllPosts',
      decorators: [computed('hasLoadedData', 'lastPostId', 'posts.@each.id')],
      value: function (hasLoadedData, lastPostId) {
        if (!hasLoadedData) {
          return false;
        }
        if (lastPostId === -1) {
          return true;
        }

        return !!this.get('posts').findProperty('id', lastPostId);
      }
    }, {
      key: 'lastPostNotLoaded',
      initializer: function () {
        return Ember.computed.not('loadedAllPosts');
      }
    }, {
      key: 'streamFilters',
      decorators: [computed('summary', 'show_deleted', 'userFilters.[]')],
      value: function (summary, showDeleted) {
        var result = {};
        if (summary) {
          result.filter = "summary";
        }
        if (showDeleted) {
          result.show_deleted = true;
        }

        var userFilters = this.get('userFilters');
        if (!Ember.isEmpty(userFilters)) {
          result.username_filters = userFilters.join(",");
        }

        return result;
      }
    }, {
      key: 'hasNoFilters',
      decorators: [computed('streamFilters.[]', 'topic.posts_count', 'posts.length')],
      value: function () {
        var streamFilters = this.get('streamFilters');
        return !(streamFilters && (streamFilters.filter === 'summary' || streamFilters.username_filters));
      }
    }, {
      key: 'previousWindow',
      decorators: [computed('posts.[]', 'stream.[]')],
      value: function () {
        // If we can't find the last post loaded, bail
        var firstPost = _.first(this.get('posts'));
        if (!firstPost) {
          return [];
        }

        // Find the index of the last post loaded, if not found, bail
        var stream = this.get('stream');
        var firstIndex = this.indexOf(firstPost);
        if (firstIndex === -1) {
          return [];
        }

        var startIndex = firstIndex - this.get('topic.chunk_size');
        if (startIndex < 0) {
          startIndex = 0;
        }
        return stream.slice(startIndex, firstIndex);
      }
    }, {
      key: 'nextWindow',
      decorators: [computed('posts.lastObject', 'stream.[]')],
      value: function (lastLoadedPost) {
        // If we can't find the last post loaded, bail
        if (!lastLoadedPost) {
          return [];
        }

        // Find the index of the last post loaded, if not found, bail
        var stream = this.get('stream');
        var lastIndex = this.indexOf(lastLoadedPost);
        if (lastIndex === -1) {
          return [];
        }
        if (lastIndex + 1 >= this.get('highest_post_number')) {
          return [];
        }

        // find our window of posts
        return stream.slice(lastIndex + 1, lastIndex + this.get('topic.chunk_size') + 1);
      }
    }, {
      key: 'cancelFilter',
      value: function () {
        this.set('summary', false);
        this.set('show_deleted', false);
        this.get('userFilters').clear();
      }
    }, {
      key: 'toggleSummary',
      value: function () {
        var _this = this;

        this.get('userFilters').clear();
        this.toggleProperty('summary');

        return this.refresh().then(function () {
          if (_this.get('summary')) {
            _this.jumpToSecondVisible();
          }
        });
      }
    }, {
      key: 'toggleDeleted',
      value: function () {
        this.toggleProperty('show_deleted');
        return this.refresh();
      }
    }, {
      key: 'jumpToSecondVisible',
      value: function () {
        var posts = this.get('posts');
        if (posts.length > 1) {
          var secondPostNum = posts[1].get('post_number');
          DiscourseURL.jumpToPost(secondPostNum);
        }
      }
    }, {
      key: 'toggleParticipant',

      // Filter the stream to a particular user.
      value: function (username) {
        var _this2 = this;

        var userFilters = this.get('userFilters');
        this.set('summary', false);
        this.set('show_deleted', true);

        var jump = false;
        if (userFilters.contains(username)) {
          userFilters.removeObject(username);
        } else {
          userFilters.addObject(username);
          jump = true;
        }
        return this.refresh().then(function () {
          if (jump) {
            _this2.jumpToSecondVisible();
          }
        });
      }
    }, {
      key: 'refresh',

      /**
        Loads a new set of posts into the stream. If you provide a `nearPost` option and the post
        is already loaded, it will simply scroll there and load nothing.
      **/
      value: function (opts) {
        var _this3 = this;

        opts = opts || {};
        opts.nearPost = parseInt(opts.nearPost, 10);

        if (opts.cancelSummary) {
          this.set('summary', false);
          delete opts.cancelSummary;
        }

        var topic = this.get('topic');

        // Do we already have the post in our list of posts? Jump there.
        if (opts.forceLoad) {
          this.set('loaded', false);
        } else {
          var postWeWant = this.get('posts').findProperty('post_number', opts.nearPost);
          if (postWeWant) {
            return Ember.RSVP.resolve();
          }
        }

        // TODO: if we have all the posts in the filter, don't go to the server for them.
        this.set('loadingFilter', true);

        opts = _.merge(opts, this.get('streamFilters'));

        // Request a topicView
        return loadTopicView(topic, opts).then(function (json) {
          _this3.updateFromJson(json.post_stream);
          _this3.setProperties({ loadingFilter: false, loaded: true });
        }).catch(function (result) {
          _this3.errorLoading(result);
          throw result;
        });
      }
    }, {
      key: 'collapsePosts',
      value: function (from, to) {
        var posts = this.get('posts');
        var remove = posts.filter(function (post) {
          var postNumber = post.get('post_number');
          return postNumber >= from && postNumber <= to;
        });

        posts.removeObjects(remove);

        // make gap
        this.set('gaps', this.get('gaps') || { before: {}, after: {} });
        var before = this.get('gaps.before');
        var post = posts.find(function (p) {
          return p.get('post_number') > to;
        });

        before[post.get('id')] = remove.map(function (p) {
          return p.get('id');
        });
        post.set('hasGap', true);

        this.get('stream').enumerableContentDidChange();
      }
    }, {
      key: 'fillGapBefore',

      // Fill in a gap of posts before a particular post
      value: function (post, gap) {
        var _this4 = this;

        var postId = post.get('id'),
            stream = this.get('stream'),
            idx = stream.indexOf(postId),
            currentPosts = this.get('posts');

        if (idx !== -1) {
          var _ret = (function () {
            // Insert the gap at the appropriate place
            stream.splice.apply(stream, [idx, 0].concat(gap));

            var postIdx = currentPosts.indexOf(post);
            var origIdx = postIdx;
            if (postIdx !== -1) {
              return {
                v: _this4.findPostsByIds(gap).then(function (posts) {
                  posts.forEach(function (p) {
                    var stored = _this4.storePost(p);
                    if (!currentPosts.contains(stored)) {
                      currentPosts.insertAt(postIdx++, stored);
                    }
                  });

                  delete _this4.get('gaps.before')[postId];
                  _this4.get('stream').enumerableContentDidChange();
                  _this4.get('postsWithPlaceholders').arrayContentDidChange(origIdx, 0, posts.length);
                  post.set('hasGap', false);
                })
              };
            }
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
        return Ember.RSVP.resolve();
      }
    }, {
      key: 'fillGapAfter',

      // Fill in a gap of posts after a particular post
      value: function (post, gap) {
        var _this5 = this;

        var postId = post.get('id'),
            stream = this.get('stream'),
            idx = stream.indexOf(postId);

        if (idx !== -1) {
          stream.pushObjects(gap);
          return this.appendMore().then(function () {
            delete _this5.get('gaps.after')[postId];
            _this5.get('stream').enumerableContentDidChange();
          });
        }
        return Ember.RSVP.resolve();
      }
    }, {
      key: 'appendMore',

      // Appends the next window of posts to the stream. Call it when scrolling downwards.
      value: function () {
        var _this6 = this;

        // Make sure we can append more posts
        if (!this.get('canAppendMore')) {
          return Ember.RSVP.resolve();
        }

        var postIds = this.get('nextWindow');
        if (Ember.isEmpty(postIds)) {
          return Ember.RSVP.resolve();
        }

        this.set('loadingBelow', true);
        var postsWithPlaceholders = this.get('postsWithPlaceholders');
        postsWithPlaceholders.appending(postIds);
        return this.findPostsByIds(postIds).then(function (posts) {
          posts.forEach(function (p) {
            return _this6.appendPost(p);
          });
          return posts;
        }).finally(function () {
          postsWithPlaceholders.finishedAppending(postIds);
          _this6.set('loadingBelow', false);
        });
      }
    }, {
      key: 'prependMore',

      // Prepend the previous window of posts to the stream. Call it when scrolling upwards.
      value: function () {
        var _this7 = this;

        // Make sure we can append more posts
        if (!this.get('canPrependMore')) {
          return Ember.RSVP.resolve();
        }

        var postIds = this.get('previousWindow');
        if (Ember.isEmpty(postIds)) {
          return Ember.RSVP.resolve();
        }

        this.set('loadingAbove', true);
        return this.findPostsByIds(postIds.reverse()).then(function (posts) {
          posts.forEach(function (p) {
            return _this7.prependPost(p);
          });
        }).finally(function () {
          var postsWithPlaceholders = _this7.get('postsWithPlaceholders');
          postsWithPlaceholders.finishedPrepending(postIds);
          _this7.set('loadingAbove', false);
        });
      }
    }, {
      key: 'stagePost',

      /**
        Stage a post for insertion in the stream. It should be rendered right away under the
        assumption that the post will succeed. We can then `commitPost` when it succeeds or
        `undoPost` when it fails.
      **/
      value: function (post, user) {
        // We can't stage two posts simultaneously
        if (this.get('stagingPost')) {
          return "alreadyStaging";
        }

        this.set('stagingPost', true);

        var topic = this.get('topic');
        topic.setProperties({
          posts_count: (topic.get('posts_count') || 0) + 1,
          last_posted_at: new Date(),
          'details.last_poster': user,
          highest_post_number: (topic.get('highest_post_number') || 0) + 1
        });

        post.setProperties({
          post_number: topic.get('highest_post_number'),
          topic: topic,
          created_at: new Date(),
          id: -1
        });

        // If we're at the end of the stream, add the post
        if (this.get('loadedAllPosts')) {
          this.appendPost(post);
          this.get('stream').addObject(post.get('id'));
          return "staged";
        }

        return "offScreen";
      }
    }, {
      key: 'commitPost',

      // Commit the post we staged. Call this after a save succeeds.
      value: function (post) {
        if (this.get('topic.id') === post.get('topic_id')) {
          if (this.get('loadedAllPosts')) {
            this.appendPost(post);
            this.get('stream').addObject(post.get('id'));
          }
        }

        this.get('stream').removeObject(-1);
        this._identityMap[-1] = null;
        this.set('stagingPost', false);
      }
    }, {
      key: 'undoPost',

      /**
        Undo a post we've staged in the stream. Remove it from being rendered and revert the
        state we changed.
      **/
      value: function (post) {
        var _this8 = this;

        this.get('stream').removeObject(-1);
        this.get('postsWithPlaceholders').removePost(function () {
          return _this8.posts.removeObject(post);
        });
        this._identityMap[-1] = null;

        var topic = this.get('topic');
        this.set('stagingPost', false);

        topic.setProperties({
          highest_post_number: (topic.get('highest_post_number') || 0) - 1,
          posts_count: (topic.get('posts_count') || 0) - 1
        });

        // TODO unfudge reply count on parent post
      }
    }, {
      key: 'prependPost',
      value: function (post) {
        var stored = this.storePost(post);
        if (stored) {
          var posts = this.get('posts');
          posts.unshiftObject(stored);
        }

        return post;
      }
    }, {
      key: 'appendPost',
      value: function (post) {
        var _this9 = this;

        var stored = this.storePost(post);
        if (stored) {
          (function () {
            var posts = _this9.get('posts');

            if (!posts.contains(stored)) {
              if (!_this9.get('loadingBelow')) {
                _this9.get('postsWithPlaceholders').appendPost(function () {
                  return posts.pushObject(stored);
                });
              } else {
                posts.pushObject(stored);
              }
            }

            if (stored.get('id') !== -1) {
              _this9.set('lastAppended', stored);
            }
          })();
        }
        return post;
      }
    }, {
      key: 'removePosts',
      value: function (posts) {
        var _this10 = this;

        if (Ember.isEmpty(posts)) {
          return;
        }

        this.get('postsWithPlaceholders').refreshAll(function () {
          var allPosts = _this10.get('posts');
          var postIds = posts.map(function (p) {
            return p.get('id');
          });
          var identityMap = _this10._identityMap;

          _this10.get('stream').removeObjects(postIds);
          allPosts.removeObjects(posts);
          postIds.forEach(function (id) {
            return delete identityMap[id];
          });
        });
      }
    }, {
      key: 'findLoadedPost',

      // Returns a post from the identity map if it's been inserted.
      value: function (id) {
        return this._identityMap[id];
      }
    }, {
      key: 'loadPost',
      value: function (postId) {
        var _this11 = this;

        var url = "/posts/" + postId;
        var store = this.store;

        return Discourse.ajax(url).then(function (p) {
          return _this11.storePost(store.createRecord('post', p));
        });
      }
    }, {
      key: 'triggerNewPostInStream',

      /**
        Finds and adds a post to the stream by id. Typically this would happen if we receive a message
        from the message bus indicating there's a new post. We'll only insert it if we currently
        have no filters.
      **/
      value: function (postId) {
        var _this12 = this;

        var resolved = Ember.RSVP.Promise.resolve();

        if (!postId) {
          return resolved;
        }

        // We only trigger if there are no filters active
        if (!this.get('hasNoFilters')) {
          return resolved;
        }

        var loadedAllPosts = this.get('loadedAllPosts');

        if (this.get('stream').indexOf(postId) === -1) {
          this.get('stream').addObject(postId);
          if (loadedAllPosts) {
            this.set('loadingLastPost', true);
            return this.findPostsByIds([postId]).then(function (posts) {
              posts.forEach(function (p) {
                return _this12.appendPost(p);
              });
            }).finally(function () {
              _this12.set('loadingLastPost', false);
            });
          }
        }

        return resolved;
      }
    }, {
      key: 'triggerRecoveredPost',
      value: function (postId) {
        var _this13 = this;

        var existing = this._identityMap[postId];

        if (existing) {
          return this.triggerChangedPost(postId, new Date());
        } else {
          var _ret3 = (function () {
            // need to insert into stream
            var url = "/posts/" + postId;
            var store = _this13.store;
            return {
              v: Discourse.ajax(url).then(function (p) {
                var post = store.createRecord('post', p);
                var stream = _this13.get("stream");
                var posts = _this13.get("posts");
                _this13.storePost(post);

                // we need to zip this into the stream
                var index = 0;
                stream.forEach(function (pid) {
                  if (pid < p.id) {
                    index += 1;
                  }
                });

                stream.insertAt(index, p.id);

                index = 0;
                posts.forEach(function (_post) {
                  if (_post.id < p.id) {
                    index += 1;
                  }
                });

                if (index < posts.length) {
                  posts.insertAt(index, post);
                } else {
                  if (post.post_number < posts[posts.length - 1].post_number + 5) {
                    _this13.appendMore();
                  }
                }
              })
            };
          })();

          if (typeof _ret3 === 'object') return _ret3.v;
        }
      }
    }, {
      key: 'triggerDeletedPost',
      value: function (postId) {
        var _this14 = this;

        var existing = this._identityMap[postId];

        if (existing) {
          var _ret4 = (function () {
            var url = "/posts/" + postId;
            var store = _this14.store;

            return {
              v: Discourse.ajax(url).then(function (p) {
                _this14.storePost(store.createRecord('post', p));
              }).catch(function () {
                _this14.removePosts([existing]);
              })
            };
          })();

          if (typeof _ret4 === 'object') return _ret4.v;
        }
        return Ember.RSVP.Promise.resolve();
      }
    }, {
      key: 'triggerChangedPost',
      value: function (postId, updatedAt) {
        var _this15 = this;

        var resolved = Ember.RSVP.Promise.resolve();
        if (!postId) {
          return resolved;
        }

        var existing = this._identityMap[postId];
        if (existing && existing.updated_at !== updatedAt) {
          var _ret5 = (function () {
            var url = "/posts/" + postId;
            var store = _this15.store;
            return {
              v: Discourse.ajax(url).then(function (p) {
                return _this15.storePost(store.createRecord('post', p));
              })
            };
          })();

          if (typeof _ret5 === 'object') return _ret5.v;
        }
        return resolved;
      }
    }, {
      key: 'closestPostForPostNumber',

      /**
        Returns the closest post given a postNumber that may not exist in the stream.
        For example, if the user asks for a post that's deleted or otherwise outside the range.
        This allows us to set the progress bar with the correct number.
      **/
      value: function (postNumber) {
        if (!this.get('hasPosts')) {
          return;
        }

        var closest = null;
        this.get('posts').forEach(function (p) {
          if (!closest) {
            closest = p;
            return;
          }

          if (Math.abs(postNumber - p.get('post_number')) < Math.abs(closest.get('post_number') - postNumber)) {
            closest = p;
          }
        });

        return closest;
      }
    }, {
      key: 'progressIndexOfPost',

      // Get the index of a post in the stream. (Use this for the topic progress bar.)
      value: function (post) {
        return this.progressIndexOfPostId(post.get('id'));
      }
    }, {
      key: 'progressIndexOfPostId',

      // Get the index in the stream of a post id. (Use this for the topic progress bar.)
      value: function (postId) {
        return this.get('stream').indexOf(postId) + 1;
      }
    }, {
      key: 'closestPostNumberFor',

      /**
        Returns the closest post number given a postNumber that may not exist in the stream.
        For example, if the user asks for a post that's deleted or otherwise outside the range.
        This allows us to set the progress bar with the correct number.
      **/
      value: function (postNumber) {
        if (!this.get('hasPosts')) {
          return;
        }

        var closest = null;
        this.get('posts').forEach(function (p) {
          if (closest === postNumber) {
            return;
          }
          if (!closest) {
            closest = p.get('post_number');
          }

          if (Math.abs(postNumber - p.get('post_number')) < Math.abs(closest - postNumber)) {
            closest = p.get('post_number');
          }
        });

        return closest;
      }
    }, {
      key: 'findPostIdForPostNumber',

      // Find a postId for a postNumber, respecting gaps
      value: function (postNumber) {
        var stream = this.get('stream'),
            beforeLookup = this.get('gaps.before'),
            streamLength = stream.length;

        var sum = 1;
        for (var i = 0; i < streamLength; i++) {
          var pid = stream[i];

          // See if there are posts before this post
          if (beforeLookup) {
            var before = beforeLookup[pid];
            if (before) {
              for (var j = 0; j < before.length; j++) {
                if (sum === postNumber) {
                  return pid;
                }
                sum++;
              }
            }
          }

          if (sum === postNumber) {
            return pid;
          }
          sum++;
        }
      }
    }, {
      key: 'updateFromJson',
      value: function (postStreamData) {
        var _this16 = this;

        var posts = this.get('posts');

        var postsWithPlaceholders = this.get('postsWithPlaceholders');
        postsWithPlaceholders.clear(function () {
          return posts.clear();
        });

        this.set('gaps', null);
        if (postStreamData) {
          (function () {
            // Load posts if present
            var store = _this16.store;
            postStreamData.posts.forEach(function (p) {
              return _this16.appendPost(store.createRecord('post', p));
            });
            delete postStreamData.posts;

            // Update our attributes
            _this16.setProperties(postStreamData);
          })();
        }
      }
    }, {
      key: 'storePost',

      /**
        Stores a post in our identity map, and sets up the references it needs to
        find associated objects like the topic. It might return a different reference
        than you supplied if the post has already been loaded.
      **/
      value: function (post) {
        // Calling `Ember.get(undefined)` raises an error
        if (!post) {
          return;
        }

        var postId = Ember.get(post, 'id');
        if (postId) {
          var existing = this._identityMap[post.get('id')];

          // Update the `highest_post_number` if this post is higher.
          var postNumber = post.get('post_number');
          if (postNumber && postNumber > (this.get('topic.highest_post_number') || 0)) {
            this.set('topic.highest_post_number', postNumber);
          }

          if (existing) {
            // If the post is in the identity map, update it and return the old reference.
            existing.updateFromPost(post);
            return existing;
          }

          post.set('topic', this.get('topic'));
          this._identityMap[post.get('id')] = post;
        }
        return post;
      }
    }, {
      key: 'findPostsByIds',
      value: function (postIds) {
        var identityMap = this._identityMap;
        var unloaded = postIds.filter(function (p) {
          return !identityMap[p];
        });

        // Load our unloaded posts by id
        return this.loadIntoIdentityMap(unloaded).then(function () {
          return postIds.map(function (p) {
            return identityMap[p];
          }).compact();
        });
      }
    }, {
      key: 'loadIntoIdentityMap',
      value: function (postIds) {
        var _this17 = this;

        if (Ember.isEmpty(postIds)) {
          return Ember.RSVP.resolve([]);
        }

        var url = "/t/" + this.get('topic.id') + "/posts.json";
        var data = { post_ids: postIds };
        var store = this.store;
        return Discourse.ajax(url, { data: data }).then(function (result) {
          var posts = Ember.get(result, "post_stream.posts");
          if (posts) {
            posts.forEach(function (p) {
              return _this17.storePost(store.createRecord('post', p));
            });
          }
        });
      }
    }, {
      key: 'indexOf',
      value: function (post) {
        return this.get('stream').indexOf(post.get('id'));
      }
    }, {
      key: 'errorLoading',

      // Handles an error loading a topic based on a HTTP status code. Updates
      // the text to the correct values.
      value: function (result) {
        var status = result.jqXHR.status;

        var topic = this.get('topic');
        this.set('loadingFilter', false);
        topic.set('errorLoading', true);

        // If the result was 404 the post is not found
        // If it was 410 the post is deleted and the user should not see it
        if (status === 404 || status === 410) {
          topic.set('notFoundHtml', result.jqXHR.responseText);
          return;
        }

        // If the result is 403 it means invalid access
        if (status === 403) {
          topic.set('noRetry', true);
          if (Discourse.User.current()) {
            topic.set('message', I18n.t('topic.invalid_access.description'));
          } else {
            topic.set('message', I18n.t('topic.invalid_access.login_required'));
          }
          return;
        }

        // Otherwise supply a generic error message
        topic.set('message', I18n.t('topic.server_error.description'));
      }
    }]));

    /**
      Returns a JS Object of current stream filter options. It should match the query
      params for the stream.
    **/

    /**
      Returns the window of posts above the current set in the stream, bound to the top of the stream.
      This is the collection we'll ask for when scrolling upwards.
    **/

    /**
      Returns the window of posts below the current set in the stream, bound by the bottom of the
      stream. This is the collection we use when scrolling downwards.
    **/
  });
define("discourse/models/topic-details", 
  ["discourse/models/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    /**
      A model representing a Topic's details that aren't always present, such as a list of participants.
      When showing topics in lists and such this information should not be required.
    **/

    var RestModel = __dependency1__["default"];

    var TopicDetails = RestModel.extend({
      loaded: false,

      updateFromJson: function (details) {
        var _this = this;

        var topic = this.get('topic');

        if (details.allowed_users) {
          details.allowed_users = details.allowed_users.map(function (u) {
            return Discourse.User.create(u);
          });
        }

        if (details.suggested_topics) {
          (function () {
            var store = _this.store;
            details.suggested_topics = details.suggested_topics.map(function (st) {
              return store.createRecord('topic', st);
            });
          })();
        }

        if (details.participants) {
          details.participants = details.participants.map(function (p) {
            p.topic = topic;
            return Ember.Object.create(p);
          });
        }

        this.setProperties(details);
        this.set('loaded', true);
      },

      notificationReasonText: (function () {
        var level = this.get('notification_level');
        if (typeof level !== 'number') {
          level = 1;
        }

        var localeString = "topic.notifications.reasons." + level;
        if (typeof this.get('notifications_reason_id') === 'number') {
          var tmp = localeString + "_" + this.get('notifications_reason_id');
          // some sane protection for missing translations of edge cases
          if (I18n.lookup(tmp)) {
            localeString = tmp;
          }
        }
        return I18n.t(localeString, { username: Discourse.User.currentProp('username_lower') });
      }).property('notification_level', 'notifications_reason_id'),

      updateNotifications: function (v) {
        this.set('notification_level', v);
        this.set('notifications_reason_id', null);
        return Discourse.ajax("/t/" + this.get('topic.id') + "/notifications", {
          type: 'POST',
          data: { notification_level: v }
        });
      },

      removeAllowedUser: function (user) {
        var users = this.get('allowed_users');
        var username = user.get('username');

        return Discourse.ajax("/t/" + this.get('topic.id') + "/remove-allowed-user", {
          type: 'PUT',
          data: { username: username }
        }).then(function () {
          users.removeObject(users.findProperty('username', username));
        });
      }
    });

    __exports__["default"] = TopicDetails;
  });
define("discourse/models/topic", 
  ["discourse/models/store","discourse/models/rest","discourse/lib/computed","discourse/lib/formatter","ember-addons/ember-computed-decorators","discourse/models/action-summary","discourse/lib/ajax-error","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
    "use strict";
    __exports__.loadTopicView = loadTopicView;
    __exports__.movePosts = movePosts;
    __exports__.mergeTopic = mergeTopic;

    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var flushMap = __dependency1__.flushMap;
    var RestModel = __dependency2__["default"];
    var propertyEqual = __dependency3__.propertyEqual;
    var longDate = __dependency4__.longDate;
    var computed = __dependency5__["default"];
    var ActionSummary = __dependency6__["default"];
    var popupAjaxError = __dependency7__.popupAjaxError;

    function loadTopicView(topic, args) {
      var topicId = topic.get('id');
      var data = _.merge({}, args);
      var url = Discourse.getURL("/t/") + topicId;
      var jsonUrl = (data.nearPost ? url + '/' + data.nearPost : url) + '.json';

      delete data.nearPost;
      delete data.__type;
      delete data.store;

      return PreloadStore.getAndRemove('topic_' + topicId, function () {
        return Discourse.ajax(jsonUrl, { data: data });
      }).then(function (json) {
        topic.updateFromJson(json);
        return json;
      });
    }

    var Topic = RestModel.extend(_createDecoratedObject([{
      key: 'message',
      initializer: function () {
        return null;
      }
    }, {
      key: 'errorLoading',
      initializer: function () {
        return false;
      }
    }, {
      key: 'creator',
      decorators: [computed('posters.firstObject')],
      value: function (poster) {
        return poster && poster.user;
      }
    }, {
      key: 'lastPoster',
      decorators: [computed('posters.[]')],
      value: function (posters) {
        var user;
        if (posters && posters.length > 0) {
          var latest = posters.filter(function (p) {
            return p.extras && p.extras.indexOf("latest") >= 0;
          })[0];
          user = latest && latest.user;
        }
        return user || this.get("creator");
      }
    }, {
      key: 'fancyTitle',
      decorators: [computed('fancy_title')],
      value: function (title) {
        title = title || "";
        title = Discourse.Emoji.unescape(title);
        return Discourse.CensoredWords.censor(title);
      }
    }, {
      key: 'bumpedAt',

      // returns createdAt if there's no bumped date
      initializer: function () {
        return (function () {
          var bumpedAt = this.get('bumped_at');
          if (bumpedAt) {
            return new Date(bumpedAt);
          } else {
            return this.get('createdAt');
          }
        }).property('bumped_at', 'createdAt');
      }
    }, {
      key: 'bumpedAtTitle',
      initializer: function () {
        return (function () {
          return I18n.t('first_post') + ": " + longDate(this.get('createdAt')) + "\n" + I18n.t('last_post') + ": " + longDate(this.get('bumpedAt'));
        }).property('bumpedAt');
      }
    }, {
      key: 'createdAt',
      initializer: function () {
        return (function () {
          return new Date(this.get('created_at'));
        }).property('created_at');
      }
    }, {
      key: 'postStream',
      initializer: function () {
        return (function () {
          return this.store.createRecord('postStream', { id: this.get('id'), topic: this });
        }).property();
      }
    }, {
      key: 'visibleListTags',
      decorators: [computed('tags')],
      value: function (tags) {
        if (!tags || !Discourse.SiteSettings.suppress_overlapping_tags_in_list) {
          return tags;
        }

        var title = this.get('title');
        var newTags = [];

        tags.forEach(function (tag) {
          if (title.toLowerCase().indexOf(tag) === -1 || Discourse.SiteSettings.staff_tags.indexOf(tag) !== -1) {
            newTags.push(tag);
          }
        });

        return newTags;
      }
    }, {
      key: 'replyCount',
      initializer: function () {
        return (function () {
          return this.get('posts_count') - 1;
        }).property('posts_count');
      }
    }, {
      key: 'details',
      initializer: function () {
        return (function () {
          return this.store.createRecord('topicDetails', { id: this.get('id'), topic: this });
        }).property();
      }
    }, {
      key: 'invisible',
      initializer: function () {
        return Em.computed.not('visible');
      }
    }, {
      key: 'deleted',
      initializer: function () {
        return Em.computed.notEmpty('deleted_at');
      }
    }, {
      key: 'searchContext',
      initializer: function () {
        return (function () {
          return { type: 'topic', id: this.get('id') };
        }).property('id');
      }
    }, {
      key: '_categoryIdChanged',
      initializer: function () {
        return (function () {
          this.set('category', Discourse.Category.findById(this.get('category_id')));
        }).observes('category_id').on('init');
      }
    }, {
      key: '_categoryNameChanged',
      initializer: function () {
        return (function () {
          var categoryName = this.get('categoryName');
          var category = undefined;
          if (categoryName) {
            category = Discourse.Category.list().findProperty('name', categoryName);
          }
          this.set('category', category);
        }).observes('categoryName');
      }
    }, {
      key: 'categoryClass',
      initializer: function () {
        return (function () {
          return 'category-' + this.get('category.fullSlug');
        }).property('category.fullSlug');
      }
    }, {
      key: 'shareUrl',
      initializer: function () {
        return (function () {
          var user = Discourse.User.current();
          return this.get('url') + (user ? '?u=' + user.get('username_lower') : '');
        }).property('url');
      }
    }, {
      key: 'url',
      initializer: function () {
        return (function () {
          var slug = this.get('slug') || '';
          if (slug.trim().length === 0) {
            slug = "topic";
          }
          return Discourse.getURL("/t/") + slug + "/" + this.get('id');
        }).property('id', 'slug');
      }
    }, {
      key: 'urlForPostNumber',

      // Helper to build a Url with a post number
      value: function (postNumber) {
        var url = this.get('url');
        if (postNumber && postNumber > 0) {
          url += "/" + postNumber;
        }
        return url;
      }
    }, {
      key: 'totalUnread',
      initializer: function () {
        return (function () {
          var count = (this.get('unread') || 0) + (this.get('new_posts') || 0);
          return count > 0 ? count : null;
        }).property('new_posts', 'unread');
      }
    }, {
      key: 'lastReadUrl',
      initializer: function () {
        return (function () {
          return this.urlForPostNumber(this.get('last_read_post_number'));
        }).property('url', 'last_read_post_number');
      }
    }, {
      key: 'lastUnreadUrl',
      initializer: function () {
        return (function () {
          var postNumber = Math.min(this.get('last_read_post_number') + 1, this.get('highest_post_number'));
          return this.urlForPostNumber(postNumber);
        }).property('url', 'last_read_post_number', 'highest_post_number');
      }
    }, {
      key: 'lastPostUrl',
      initializer: function () {
        return (function () {
          return this.urlForPostNumber(this.get('highest_post_number'));
        }).property('url', 'highest_post_number');
      }
    }, {
      key: 'firstPostUrl',
      initializer: function () {
        return (function () {
          return this.urlForPostNumber(1);
        }).property('url');
      }
    }, {
      key: 'summaryUrl',
      initializer: function () {
        return (function () {
          return this.urlForPostNumber(1) + (this.get('has_summary') ? "?filter=summary" : "");
        }).property('url');
      }
    }, {
      key: 'lastPosterUrl',
      initializer: function () {
        return (function () {
          return Discourse.getURL("/users/") + this.get("last_poster.username");
        }).property('last_poster');
      }
    }, {
      key: 'displayNewPosts',

      // The amount of new posts to display. It might be different than what the server
      // tells us if we are still asynchronously flushing our "recently read" data.
      // So take what the browser has seen into consideration.
      initializer: function () {
        return (function () {
          var highestSeen = Discourse.Session.currentProp('highestSeenByTopic')[this.get('id')];
          if (highestSeen) {
            var delta = highestSeen - this.get('last_read_post_number');
            if (delta > 0) {
              var result = this.get('new_posts') - delta;
              if (result < 0) {
                result = 0;
              }
              return result;
            }
          }
          return this.get('new_posts');
        }).property('new_posts', 'id');
      }
    }, {
      key: 'viewsHeat',
      initializer: function () {
        return (function () {
          var v = this.get('views');
          if (v >= Discourse.SiteSettings.topic_views_heat_high) return 'heatmap-high';
          if (v >= Discourse.SiteSettings.topic_views_heat_medium) return 'heatmap-med';
          if (v >= Discourse.SiteSettings.topic_views_heat_low) return 'heatmap-low';
          return null;
        }).property('views');
      }
    }, {
      key: 'archetypeObject',
      initializer: function () {
        return (function () {
          return Discourse.Site.currentProp('archetypes').findProperty('id', this.get('archetype'));
        }).property('archetype');
      }
    }, {
      key: 'isPrivateMessage',
      initializer: function () {
        return Em.computed.equal('archetype', 'private_message');
      }
    }, {
      key: 'isBanner',
      initializer: function () {
        return Em.computed.equal('archetype', 'banner');
      }
    }, {
      key: 'toggleStatus',
      value: function (property) {
        this.toggleProperty(property);
        this.saveStatus(property, !!this.get(property));
      }
    }, {
      key: 'saveStatus',
      value: function (property, value, until) {
        if (property === 'closed') {
          this.incrementProperty('posts_count');

          if (value === true) {
            this.set('details.auto_close_at', null);
          }
        }
        return Discourse.ajax(this.get('url') + "/status", {
          type: 'PUT',
          data: {
            status: property,
            enabled: !!value,
            until: until
          }
        });
      }
    }, {
      key: 'makeBanner',
      value: function () {
        var self = this;
        return Discourse.ajax('/t/' + this.get('id') + '/make-banner', { type: 'PUT' }).then(function () {
          self.set('archetype', 'banner');
        });
      }
    }, {
      key: 'removeBanner',
      value: function () {
        var self = this;
        return Discourse.ajax('/t/' + this.get('id') + '/remove-banner', { type: 'PUT' }).then(function () {
          self.set('archetype', 'regular');
        });
      }
    }, {
      key: 'toggleBookmark',
      value: function () {
        var _this = this;

        if (this.get('bookmarking')) {
          return Ember.RSVP.Promise.resolve();
        }
        this.set("bookmarking", true);

        var stream = this.get('postStream');
        var posts = Em.get(stream, 'posts');
        var firstPost = posts && posts[0] && posts[0].get('post_number') === 1 && posts[0];
        var bookmark = !this.get('bookmarked');
        var path = bookmark ? '/bookmark' : '/remove_bookmarks';

        var toggleBookmarkOnServer = function () {
          return Discourse.ajax('/t/' + _this.get('id') + path, { type: 'PUT' }).then(function () {
            _this.toggleProperty('bookmarked');
            if (bookmark && firstPost) {
              firstPost.set('bookmarked', true);
              return [firstPost.id];
            }
            if (!bookmark && posts) {
              var _ret = (function () {

                var updated = [];
                posts.forEach(function (post) {
                  if (post.get('bookmarked')) {
                    post.set('bookmarked', false);
                    updated.push(post.get('id'));
                  }
                });
                return {
                  v: updated
                };
              })();

              if (typeof _ret === 'object') return _ret.v;
            }

            return [];
          }).catch(function (error) {
            var showGenericError = true;
            if (error && error.responseText) {
              try {
                bootbox.alert($.parseJSON(error.responseText).errors);
                showGenericError = false;
              } catch (e) {}
            }

            if (showGenericError) {
              bootbox.alert(I18n.t('generic_error'));
            }

            throw error;
          }).finally(function () {
            return _this.set('bookmarking', false);
          });
        };

        var unbookmarkedPosts = [];
        if (!bookmark && posts) {
          posts.forEach(function (post) {
            return post.get('bookmarked') && unbookmarkedPosts.push(post);
          });
        }

        return new Ember.RSVP.Promise(function (resolve) {
          if (unbookmarkedPosts.length > 1) {
            bootbox.confirm(I18n.t("bookmarks.confirm_clear"), I18n.t("no_value"), I18n.t("yes_value"), function (confirmed) {
              return confirmed ? toggleBookmarkOnServer().then(resolve) : resolve();
            });
          } else {
            toggleBookmarkOnServer().then(resolve);
          }
        });
      }
    }, {
      key: 'createInvite',
      value: function (emailOrUsername, groupNames) {
        return Discourse.ajax("/t/" + this.get('id') + "/invite", {
          type: 'POST',
          data: { user: emailOrUsername, group_names: groupNames }
        });
      }
    }, {
      key: 'generateInviteLink',
      initializer: function () {
        return function (email, groupNames, topicId) {
          return Discourse.ajax('/invites/link', {
            type: 'POST',
            data: { email: email, group_names: groupNames, topic_id: topicId }
          });
        };
      }
    }, {
      key: 'destroy',

      // Delete this topic
      value: function (deleted_by) {
        this.setProperties({
          deleted_at: new Date(),
          deleted_by: deleted_by,
          'details.can_delete': false,
          'details.can_recover': true
        });
        return Discourse.ajax("/t/" + this.get('id'), {
          data: { context: window.location.pathname },
          type: 'DELETE'
        });
      }
    }, {
      key: 'recover',

      // Recover this topic if deleted
      value: function () {
        this.setProperties({
          deleted_at: null,
          deleted_by: null,
          'details.can_delete': true,
          'details.can_recover': false
        });
        return Discourse.ajax("/t/" + this.get('id') + "/recover", { type: 'PUT' });
      }
    }, {
      key: 'updateFromJson',

      // Update our attributes from a JSON result
      value: function (json) {
        var _this2 = this;

        this.get('details').updateFromJson(json.details);

        var keys = Object.keys(json);
        keys.removeObject('details');
        keys.removeObject('post_stream');

        keys.forEach(function (key) {
          return _this2.set(key, json[key]);
        });
      }
    }, {
      key: 'reload',
      value: function () {
        var self = this;
        return Discourse.ajax('/t/' + this.get('id'), { type: 'GET' }).then(function (topic_json) {
          self.updateFromJson(topic_json);
        });
      }
    }, {
      key: 'isPinnedUncategorized',
      initializer: function () {
        return (function () {
          return this.get('pinned') && this.get('category.isUncategorizedCategory');
        }).property('pinned', 'category.isUncategorizedCategory');
      }
    }, {
      key: 'clearPin',
      value: function () {
        var topic = this;

        // Clear the pin optimistically from the object
        topic.set('pinned', false);
        topic.set('unpinned', true);

        Discourse.ajax("/t/" + this.get('id') + "/clear-pin", {
          type: 'PUT'
        }).then(null, function () {
          // On error, put the pin back
          topic.set('pinned', true);
          topic.set('unpinned', false);
        });
      }
    }, {
      key: 'togglePinnedForUser',
      value: function () {
        if (this.get('pinned')) {
          this.clearPin();
        } else {
          this.rePin();
        }
      }
    }, {
      key: 'rePin',
      value: function () {
        var topic = this;

        // Clear the pin optimistically from the object
        topic.set('pinned', true);
        topic.set('unpinned', false);

        Discourse.ajax("/t/" + this.get('id') + "/re-pin", {
          type: 'PUT'
        }).then(null, function () {
          // On error, put the pin back
          topic.set('pinned', true);
          topic.set('unpinned', false);
        });
      }
    }, {
      key: 'hasExcerpt',
      initializer: function () {
        return Em.computed.notEmpty('excerpt');
      }
    }, {
      key: 'excerptTruncated',
      initializer: function () {
        return (function () {
          var e = this.get('excerpt');
          return e && e.substr(e.length - 8, 8) === '&hellip;';
        }).property('excerpt');
      }
    }, {
      key: 'readLastPost',
      initializer: function () {
        return propertyEqual('last_read_post_number', 'highest_post_number');
      }
    }, {
      key: 'canClearPin',
      initializer: function () {
        return Em.computed.and('pinned', 'readLastPost');
      }
    }, {
      key: 'archiveMessage',
      value: function () {
        var _this3 = this;

        this.set("archiving", true);
        var promise = Discourse.ajax('/t/' + this.get('id') + '/archive-message', { type: 'PUT' });

        promise.then(function (msg) {
          _this3.set('message_archived', true);
          if (msg && msg.group_name) {
            _this3.set('inboxGroupName', msg.group_name);
          }
        }).finally(function () {
          return _this3.set('archiving', false);
        });

        return promise;
      }
    }, {
      key: 'moveToInbox',
      value: function () {
        var _this4 = this;

        this.set("archiving", true);
        var promise = Discourse.ajax('/t/' + this.get('id') + '/move-to-inbox', { type: 'PUT' });

        promise.then(function (msg) {
          _this4.set('message_archived', false);
          if (msg && msg.group_name) {
            _this4.set('inboxGroupName', msg.group_name);
          }
        }).finally(function () {
          return _this4.set('archiving', false);
        });

        return promise;
      }
    }, {
      key: 'convertTopic',
      value: function (type) {
        return Discourse.ajax('/t/' + this.get('id') + '/convert-topic/' + type, { type: 'PUT' }).then(function () {
          window.location.reload();
        }).catch(popupAjaxError);
      }
    }]));

    Topic.reopenClass({
      NotificationLevel: {
        WATCHING: 3,
        TRACKING: 2,
        REGULAR: 1,
        MUTED: 0
      },

      createActionSummary: function (result) {
        if (result.actions_summary) {
          (function () {
            var lookup = Em.Object.create();
            result.actions_summary = result.actions_summary.map(function (a) {
              a.post = result;
              a.actionType = Discourse.Site.current().postActionTypeById(a.id);
              var actionSummary = ActionSummary.create(a);
              lookup.set(a.actionType.get('name_key'), actionSummary);
              return actionSummary;
            });
            result.set('actionByName', lookup);
          })();
        }
      },

      update: function (topic, props) {
        props = JSON.parse(JSON.stringify(props)) || {};

        // We support `category_id` and `categoryId` for compatibility
        if (typeof props.categoryId !== "undefined") {
          props.category_id = props.categoryId;
          delete props.categoryId;
        }

        // Make sure we never change the category for private messages
        if (topic.get("isPrivateMessage")) {
          delete props.category_id;
        }

        // Annoyingly, empty arrays are not sent across the wire. This
        // allows us to make a distinction between arrays that were not
        // sent and arrays that we specifically want to be empty.
        Object.keys(props).forEach(function (k) {
          var v = props[k];
          if (v instanceof Array && v.length === 0) {
            props[k + '_empty_array'] = true;
          }
        });

        return Discourse.ajax(topic.get('url'), { type: 'PUT', data: props }).then(function (result) {
          // The title can be cleaned up server side
          props.title = result.basic_topic.title;
          props.fancy_title = result.basic_topic.fancy_title;
          topic.setProperties(props);
        });
      },

      create: function () {
        var result = this._super.apply(this, arguments);
        this.createActionSummary(result);
        return result;
      },

      // Load a topic, but accepts a set of filters
      find: function (topicId, opts) {
        var url = Discourse.getURL("/t/") + topicId;
        if (opts.nearPost) {
          url += "/" + opts.nearPost;
        }

        var data = {};
        if (opts.postsAfter) {
          data.posts_after = opts.postsAfter;
        }
        if (opts.postsBefore) {
          data.posts_before = opts.postsBefore;
        }
        if (opts.trackVisit) {
          data.track_visit = true;
        }

        // Add username filters if we have them
        if (opts.userFilters && opts.userFilters.length > 0) {
          data.username_filters = [];
          opts.userFilters.forEach(function (username) {
            data.username_filters.push(username);
          });
          data.show_deleted = true;
        }

        // Add the summary of filter if we have it
        if (opts.summary === true) {
          data.summary = true;
        }

        // Check the preload store. If not, load it via JSON
        return Discourse.ajax(url + ".json", { data: data });
      },

      changeOwners: function (topicId, opts) {
        var promise = Discourse.ajax("/t/" + topicId + "/change-owner", {
          type: 'POST',
          data: opts
        }).then(function (result) {
          if (result.success) return result;
          promise.reject(new Error("error changing ownership of posts"));
        });
        return promise;
      },

      changeTimestamp: function (topicId, timestamp) {
        var promise = Discourse.ajax("/t/" + topicId + '/change-timestamp', {
          type: 'PUT',
          data: { timestamp: timestamp }
        }).then(function (result) {
          if (result.success) return result;
          promise.reject(new Error("error updating timestamp of topic"));
        });
        return promise;
      },

      bulkOperation: function (topics, operation) {
        return Discourse.ajax("/topics/bulk", {
          type: 'PUT',
          data: {
            topic_ids: topics.map(function (t) {
              return t.get('id');
            }),
            operation: operation
          }
        });
      },

      bulkOperationByFilter: function (filter, operation, categoryId) {
        var data = { filter: filter, operation: operation };
        if (categoryId) data['category_id'] = categoryId;
        return Discourse.ajax("/topics/bulk", {
          type: 'PUT',
          data: data
        });
      },

      resetNew: function () {
        return Discourse.ajax("/topics/reset-new", { type: 'PUT' });
      },

      idForSlug: function (slug) {
        return Discourse.ajax("/t/id_for/" + slug);
      }
    });

    function moveResult(result) {
      if (result.success) {
        // We should be hesitant to flush the map but moving ids is one rare case
        flushMap();
        return result;
      }
      throw "error moving posts topic";
    }

    function movePosts(topicId, data) {
      return Discourse.ajax("/t/" + topicId + "/move-posts", { type: 'POST', data: data }).then(moveResult);
    }

    function mergeTopic(topicId, destinationTopicId) {
      return Discourse.ajax("/t/" + topicId + "/merge-topic", {
        type: 'POST',
        data: { destination_topic_id: destinationTopicId }
      }).then(moveResult);
    }

    __exports__["default"] = Topic;
  });

Discourse.Topic = require('discourse/models/topic').default;
define("discourse/models/user-action", 
  ["discourse/models/rest","discourse/lib/computed","ember-addons/ember-computed-decorators","discourse/models/user-action-group","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var RestModel = __dependency1__["default"];
    var url = __dependency2__.url;
    var on = __dependency3__.on;
    var computed = __dependency3__["default"];
    var UserActionGroup = __dependency4__["default"];

    var UserActionTypes = {
      likes_given: 1,
      likes_received: 2,
      bookmarks: 3,
      topics: 4,
      posts: 5,
      replies: 6,
      mentions: 7,
      quotes: 9,
      edits: 11,
      messages_sent: 12,
      messages_received: 13,
      pending: 14
    };
    var InvertedActionTypes = {};

    _.each(UserActionTypes, function (k, v) {
      InvertedActionTypes[k] = v;
    });

    var UserAction = RestModel.extend(_createDecoratedObject([{
      key: '_attachCategory',
      decorators: [on("init")],
      value: function () {
        var categoryId = this.get('category_id');
        if (categoryId) {
          this.set('category', Discourse.Category.findById(categoryId));
        }
      }
    }, {
      key: 'descriptionKey',
      decorators: [computed("action_type")],
      value: function (action) {
        if (action === null || UserAction.TO_SHOW.indexOf(action) >= 0) {
          if (this.get('isPM')) {
            return this.get('sameUser') ? 'sent_by_you' : 'sent_by_user';
          } else {
            return this.get('sameUser') ? 'posted_by_you' : 'posted_by_user';
          }
        }

        if (this.get('topicType')) {
          return this.get('sameUser') ? 'you_posted_topic' : 'user_posted_topic';
        }

        if (this.get('postReplyType')) {
          if (this.get('reply_to_post_number')) {
            return this.get('sameUser') ? 'you_replied_to_post' : 'user_replied_to_post';
          } else {
            return this.get('sameUser') ? 'you_replied_to_topic' : 'user_replied_to_topic';
          }
        }

        if (this.get('mentionType')) {
          if (this.get('sameUser')) {
            return 'you_mentioned_user';
          } else {
            return this.get('targetUser') ? 'user_mentioned_you' : 'user_mentioned_user';
          }
        }
      }
    }, {
      key: 'sameUser',
      decorators: [computed("username")],
      value: function (username) {
        return username === Discourse.User.currentProp('username');
      }
    }, {
      key: 'targetUser',
      decorators: [computed("target_username")],
      value: function (targetUsername) {
        return targetUsername === Discourse.User.currentProp('username');
      }
    }, {
      key: 'presentName',
      initializer: function () {
        return Em.computed.any('name', 'username');
      }
    }, {
      key: 'targetDisplayName',
      initializer: function () {
        return Em.computed.any('target_name', 'target_username');
      }
    }, {
      key: 'actingDisplayName',
      initializer: function () {
        return Em.computed.any('acting_name', 'acting_username');
      }
    }, {
      key: 'targetUserUrl',
      initializer: function () {
        return url('target_username', '/users/%@');
      }
    }, {
      key: 'usernameLower',
      decorators: [computed("username")],
      value: function (username) {
        return username.toLowerCase();
      }
    }, {
      key: 'userUrl',
      initializer: function () {
        return url('usernameLower', '/users/%@');
      }
    }, {
      key: 'postUrl',
      decorators: [computed()],
      value: function () {
        return Discourse.Utilities.postUrl(this.get('slug'), this.get('topic_id'), this.get('post_number'));
      }
    }, {
      key: 'replyUrl',
      decorators: [computed()],
      value: function () {
        return Discourse.Utilities.postUrl(this.get('slug'), this.get('topic_id'), this.get('reply_to_post_number'));
      }
    }, {
      key: 'replyType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.replies);
      }
    }, {
      key: 'postType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.posts);
      }
    }, {
      key: 'topicType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.topics);
      }
    }, {
      key: 'bookmarkType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.bookmarks);
      }
    }, {
      key: 'messageSentType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.messages_sent);
      }
    }, {
      key: 'messageReceivedType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.messages_received);
      }
    }, {
      key: 'mentionType',
      initializer: function () {
        return Em.computed.equal('action_type', UserActionTypes.mentions);
      }
    }, {
      key: 'isPM',
      initializer: function () {
        return Em.computed.or('messageSentType', 'messageReceivedType');
      }
    }, {
      key: 'postReplyType',
      initializer: function () {
        return Em.computed.or('postType', 'replyType');
      }
    }, {
      key: 'removableBookmark',
      initializer: function () {
        return Em.computed.and('bookmarkType', 'sameUser');
      }
    }, {
      key: 'addChild',
      value: function (action) {
        var groups = this.get("childGroups");
        if (!groups) {
          groups = {
            likes: UserActionGroup.create({ icon: "fa fa-heart" }),
            stars: UserActionGroup.create({ icon: "fa fa-star" }),
            edits: UserActionGroup.create({ icon: "fa fa-pencil" }),
            bookmarks: UserActionGroup.create({ icon: "fa fa-bookmark" })
          };
        }
        this.set("childGroups", groups);

        var bucket = (function () {
          switch (action.action_type) {
            case UserActionTypes.likes_given:
            case UserActionTypes.likes_received:
              return "likes";
            case UserActionTypes.edits:
              return "edits";
            case UserActionTypes.bookmarks:
              return "bookmarks";
          }
        })();
        var current = groups[bucket];
        if (current) {
          current.push(action);
        }
      }
    }, {
      key: 'children',
      initializer: function () {
        return (function () {
          var g = this.get("childGroups");
          var rval = [];
          if (g) {
            rval = [g.likes, g.stars, g.edits, g.bookmarks].filter(function (i) {
              return i.get("items") && i.get("items").length > 0;
            });
          }
          return rval;
        }).property("childGroups", "childGroups.likes.items", "childGroups.likes.items.[]", "childGroups.stars.items", "childGroups.stars.items.[]", "childGroups.edits.items", "childGroups.edits.items.[]", "childGroups.bookmarks.items", "childGroups.bookmarks.items.[]");
      }
    }, {
      key: 'switchToActing',
      value: function () {
        this.setProperties({
          username: this.get('acting_username'),
          name: this.get('actingDisplayName')
        });
      }
    }]));

    UserAction.reopenClass({
      collapseStream: function (stream) {
        var uniq = {};
        var collapsed = [];
        var pos = 0;

        stream.forEach(function (item) {
          var key = "" + item.topic_id + "-" + item.post_number;
          var found = uniq[key];
          if (found === void 0) {

            var current = undefined;
            if (UserAction.TO_COLLAPSE.indexOf(item.action_type) >= 0) {
              current = UserAction.create(item);
              item.switchToActing();
              current.addChild(item);
            } else {
              current = item;
            }
            uniq[key] = pos;
            collapsed[pos] = current;
            pos += 1;
          } else {
            if (UserAction.TO_COLLAPSE.indexOf(item.action_type) >= 0) {
              item.switchToActing();
              collapsed[found].addChild(item);
            } else {
              collapsed[found].setProperties(item.getProperties('action_type', 'description'));
            }
          }
        });
        return collapsed;
      },

      TYPES: UserActionTypes,
      TYPES_INVERTED: InvertedActionTypes,

      TO_COLLAPSE: [UserActionTypes.likes_given, UserActionTypes.likes_received, UserActionTypes.edits, UserActionTypes.bookmarks],

      TO_SHOW: [UserActionTypes.likes_given, UserActionTypes.likes_received, UserActionTypes.edits, UserActionTypes.bookmarks, UserActionTypes.messages_sent, UserActionTypes.messages_received]

    });

    __exports__["default"] = UserAction;
  });

Discourse.UserAction = require('discourse/models/user-action').default;
define("discourse/models/draft", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var Draft = Discourse.Model.extend();

    Draft.reopenClass({

      clear: function (key, sequence) {
        return Discourse.ajax("/draft.json", {
          type: 'DELETE',
          data: {
            draft_key: key,
            sequence: sequence
          }
        });
      },

      get: function (key) {
        return Discourse.ajax('/draft.json', {
          data: { draft_key: key },
          dataType: 'json'
        });
      },

      getLocal: function (key, current) {
        // TODO: implement this
        return current;
      },

      save: function (key, sequence, data) {
        data = typeof data === "string" ? data : JSON.stringify(data);
        return Discourse.ajax("/draft.json", {
          type: 'POST',
          data: {
            draft_key: key,
            data: data,
            sequence: sequence
          }
        });
      }

    });

    __exports__["default"] = Draft;
  });
define("discourse/models/composer", 
  ["discourse/models/rest","discourse/models/topic","discourse/lib/ajax-error","discourse/lib/quote","discourse/models/draft","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var RestModel = __dependency1__["default"];
    var Topic = __dependency2__["default"];
    var throwAjaxError = __dependency3__.throwAjaxError;
    var Quote = __dependency4__["default"];
    var Draft = __dependency5__["default"];
    var computed = __dependency6__["default"];

    var CLOSED = 'closed',
        SAVING = 'saving',
        OPEN = 'open',
        DRAFT = 'draft',

    // The actions the composer can take
    CREATE_TOPIC = 'createTopic',
        PRIVATE_MESSAGE = 'privateMessage',
        REPLY = 'reply',
        EDIT = 'edit',
        REPLY_AS_NEW_TOPIC_KEY = "reply_as_new_topic",

    // When creating, these fields are moved into the post model from the composer model
    _create_serializer = {
      raw: 'reply',
      title: 'title',
      category: 'categoryId',
      topic_id: 'topic.id',
      is_warning: 'isWarning',
      whisper: 'whisper',
      archetype: 'archetypeId',
      target_usernames: 'targetUsernames',
      typing_duration_msecs: 'typingTime',
      composer_open_duration_msecs: 'composerTime',
      tags: 'tags'
    },
        _edit_topic_serializer = {
      title: 'topic.title',
      categoryId: 'topic.category.id',
      tags: 'topic.tags'
    };

    var Composer = RestModel.extend(_createDecoratedObject([{
      key: '_categoryId',
      initializer: function () {
        return null;
      }
    }, {
      key: 'archetypes',
      initializer: function () {
        return (function () {
          return this.site.get('archetypes');
        }).property();
      }
    }, {
      key: 'categoryId',
      decorators: [computed],
      initializer: function () {
        return {
          get: function () {
            return this._categoryId;
          },

          // We wrap categoryId this way so we can fire `applyTopicTemplate` with
          // the previous value as well as the new value
          set: function (categoryId) {
            var oldCategoryId = this._categoryId;

            if (Ember.isEmpty(categoryId)) {
              categoryId = null;
            }
            this._categoryId = categoryId;

            if (oldCategoryId !== categoryId) {
              this.applyTopicTemplate(oldCategoryId, categoryId);
            }
            return categoryId;
          }
        };
      }
    }, {
      key: 'creatingTopic',
      initializer: function () {
        return Em.computed.equal('action', CREATE_TOPIC);
      }
    }, {
      key: 'creatingPrivateMessage',
      initializer: function () {
        return Em.computed.equal('action', PRIVATE_MESSAGE);
      }
    }, {
      key: 'notCreatingPrivateMessage',
      initializer: function () {
        return Em.computed.not('creatingPrivateMessage');
      }
    }, {
      key: 'showCategoryChooser',
      decorators: [computed("privateMessage", "archetype.hasOptions")],
      value: function (isPrivateMessage, hasOptions) {
        var manyCategories = Discourse.Category.list().length > 1;
        return !isPrivateMessage && (hasOptions || manyCategories);
      }
    }, {
      key: 'privateMessage',
      decorators: [computed("creatingPrivateMessage", "topic")],
      value: function (creatingPrivateMessage, topic) {
        return creatingPrivateMessage || topic && topic.get('archetype') === 'private_message';
      }
    }, {
      key: 'topicFirstPost',
      initializer: function () {
        return Em.computed.or('creatingTopic', 'editingFirstPost');
      }
    }, {
      key: 'editingPost',
      initializer: function () {
        return Em.computed.equal('action', EDIT);
      }
    }, {
      key: 'replyingToTopic',
      initializer: function () {
        return Em.computed.equal('action', REPLY);
      }
    }, {
      key: 'viewOpen',
      initializer: function () {
        return Em.computed.equal('composeState', OPEN);
      }
    }, {
      key: 'viewDraft',
      initializer: function () {
        return Em.computed.equal('composeState', DRAFT);
      }
    }, {
      key: 'composeStateChanged',
      initializer: function () {
        return (function () {
          var oldOpen = this.get('composerOpened');

          if (this.get('composeState') === OPEN) {
            this.set('composerOpened', oldOpen || new Date());
          } else {
            if (oldOpen) {
              var oldTotal = this.get('composerTotalOpened') || 0;
              this.set('composerTotalOpened', oldTotal + (new Date() - oldOpen));
            }
            this.set('composerOpened', null);
          }
        }).observes('composeState');
      }
    }, {
      key: 'composerTime',
      initializer: function () {
        return (function () {
          var total = this.get('composerTotalOpened') || 0;

          var oldOpen = this.get('composerOpened');
          if (oldOpen) {
            total += new Date() - oldOpen;
          }

          return total;
        }).property().volatile();
      }
    }, {
      key: 'archetype',
      initializer: function () {
        return (function () {
          return this.get('archetypes').findProperty('id', this.get('archetypeId'));
        }).property('archetypeId');
      }
    }, {
      key: 'archetypeChanged',
      initializer: function () {
        return (function () {
          return this.set('metaData', Em.Object.create());
        }).observes('archetype');
      }
    }, {
      key: 'typing',

      // view detected user is typing
      initializer: function () {
        return _.throttle(function () {
          var typingTime = this.get("typingTime") || 0;
          this.set("typingTime", typingTime + 100);
        }, 100, { leading: false, trailing: true });
      }
    }, {
      key: 'editingFirstPost',
      initializer: function () {
        return Em.computed.and('editingPost', 'post.firstPost');
      }
    }, {
      key: 'canEditTitle',
      initializer: function () {
        return Em.computed.or('creatingTopic', 'creatingPrivateMessage', 'editingFirstPost');
      }
    }, {
      key: 'canCategorize',
      initializer: function () {
        return Em.computed.and('canEditTitle', 'notCreatingPrivateMessage');
      }
    }, {
      key: 'actionTitle',

      // Determine the appropriate title for this action
      initializer: function () {
        return (function () {
          var topic = this.get('topic');

          var postLink = undefined,
              topicLink = undefined,
              usernameLink = undefined;
          if (topic) {
            var postNumber = this.get('post.post_number');
            postLink = "<a href='" + topic.get('url') + "/" + postNumber + "'>" + I18n.t("post.post_number", { number: postNumber }) + "</a>";
            topicLink = "<a href='" + topic.get('url') + "'> " + Discourse.Utilities.escapeExpression(topic.get('title')) + "</a>";
            usernameLink = "<a href='" + topic.get('url') + "/" + postNumber + "'>" + this.get('post.username') + "</a>";
          }

          var postDescription = undefined;
          var post = this.get('post');

          if (post) {
            postDescription = I18n.t('post.' + this.get('action'), {
              link: postLink,
              replyAvatar: Discourse.Utilities.tinyAvatar(post.get('avatar_template')),
              username: this.get('post.username'),
              usernameLink: usernameLink
            });

            if (!this.site.mobileView) {
              var replyUsername = post.get('reply_to_user.username');
              var replyAvatarTemplate = post.get('reply_to_user.avatar_template');
              if (replyUsername && replyAvatarTemplate && this.get('action') === EDIT) {
                postDescription += " <i class='fa fa-mail-forward reply-to-glyph'></i> " + Discourse.Utilities.tinyAvatar(replyAvatarTemplate) + " " + replyUsername;
              }
            }
          }

          switch (this.get('action')) {
            case PRIVATE_MESSAGE:
              return I18n.t('topic.private_message');
            case CREATE_TOPIC:
              return I18n.t('topic.create_long');
            case REPLY:
            case EDIT:
              if (postDescription) return postDescription;
              if (topic) return I18n.t('post.reply_topic', { link: topicLink });
          }
        }).property('action', 'post', 'topic', 'topic.title');
      }
    }, {
      key: 'cantSubmitPost',

      // whether to disable the post button
      initializer: function () {
        return (function () {

          // can't submit while loading
          if (this.get('loading')) return true;

          // title is required when
          //  - creating a new topic/private message
          //  - editing the 1st post
          if (this.get('canEditTitle') && !this.get('titleLengthValid')) return true;

          // reply is always required
          if (this.get('missingReplyCharacters') > 0) return true;

          if (this.get("privateMessage")) {
            // need at least one user when sending a PM
            return this.get('targetUsernames') && (this.get('targetUsernames').trim() + ',').indexOf(',') === 0;
          } else {
            // has a category? (when needed)
            return this.get('canCategorize') && !this.siteSettings.allow_uncategorized_topics && !this.get('categoryId') && !this.user.get('admin');
          }
        }).property('loading', 'canEditTitle', 'titleLength', 'targetUsernames', 'replyLength', 'categoryId', 'missingReplyCharacters');
      }
    }, {
      key: 'titleLengthValid',
      initializer: function () {
        return (function () {
          if (this.user.get('admin') && this.get('post.static_doc') && this.get('titleLength') > 0) return true;
          if (this.get('titleLength') < this.get('minimumTitleLength')) return false;
          return this.get('titleLength') <= this.siteSettings.max_topic_title_length;
        }).property('minimumTitleLength', 'titleLength', 'post.static_doc');
      }
    }, {
      key: 'saveIcon',

      // The icon for the save button
      initializer: function () {
        return (function () {
          switch (this.get('action')) {
            case EDIT:
              return '<i class="fa fa-pencil"></i>';
            case REPLY:
              return '<i class="fa fa-reply"></i>';
            case CREATE_TOPIC:
              return '<i class="fa fa-plus"></i>';
            case PRIVATE_MESSAGE:
              return '<i class="fa fa-envelope"></i>';
          }
        }).property('action');
      }
    }, {
      key: 'saveText',

      // The text for the save button
      initializer: function () {
        return (function () {
          switch (this.get('action')) {
            case EDIT:
              return I18n.t('composer.save_edit');
            case REPLY:
              return I18n.t('composer.reply');
            case CREATE_TOPIC:
              return I18n.t('composer.create_topic');
            case PRIVATE_MESSAGE:
              return I18n.t('composer.create_pm');
          }
        }).property('action');
      }
    }, {
      key: 'hasMetaData',
      initializer: function () {
        return (function () {
          var metaData = this.get('metaData');
          return metaData ? Em.isEmpty(Em.keys(this.get('metaData'))) : false;
        }).property('metaData');
      }
    }, {
      key: 'replyDirty',

      /**
        Did the user make changes to the reply?
         @property replyDirty
      **/
      initializer: function () {
        return (function () {
          return this.get('reply') !== this.get('originalText');
        }).property('reply', 'originalText');
      }
    }, {
      key: 'missingTitleCharacters',

      /**
        Number of missing characters in the title until valid.
         @property missingTitleCharacters
      **/
      initializer: function () {
        return (function () {
          return this.get('minimumTitleLength') - this.get('titleLength');
        }).property('minimumTitleLength', 'titleLength');
      }
    }, {
      key: 'minimumTitleLength',

      /**
        Minimum number of characters for a title to be valid.
         @property minimumTitleLength
      **/
      initializer: function () {
        return (function () {
          if (this.get('privateMessage')) {
            return this.siteSettings.min_private_message_title_length;
          } else {
            return this.siteSettings.min_topic_title_length;
          }
        }).property('privateMessage');
      }
    }, {
      key: 'missingReplyCharacters',
      initializer: function () {
        return (function () {
          var postType = this.get('post.post_type');
          if (postType === this.site.get('post_types.small_action')) {
            return 0;
          }
          return this.get('minimumPostLength') - this.get('replyLength');
        }).property('minimumPostLength', 'replyLength');
      }
    }, {
      key: 'minimumPostLength',

      /**
        Minimum number of characters for a post body to be valid.
         @property minimumPostLength
      **/
      initializer: function () {
        return (function () {
          if (this.get('privateMessage')) {
            return this.siteSettings.min_private_message_post_length;
          } else if (this.get('topicFirstPost')) {
            // first post (topic body)
            return this.siteSettings.min_first_post_length;
          } else {
            return this.siteSettings.min_post_length;
          }
        }).property('privateMessage', 'topicFirstPost');
      }
    }, {
      key: 'titleLength',

      /**
        Computes the length of the title minus non-significant whitespaces
         @property titleLength
      **/
      initializer: function () {
        return (function () {
          var title = this.get('title') || "";
          return title.replace(/\s+/img, " ").trim().length;
        }).property('title');
      }
    }, {
      key: 'replyLength',

      /**
        Computes the length of the reply minus the quote(s) and non-significant whitespaces
         @property replyLength
      **/
      initializer: function () {
        return (function () {
          var reply = this.get('reply') || "";
          while (Quote.REGEXP.test(reply)) {
            reply = reply.replace(Quote.REGEXP, "");
          }
          return reply.replace(/\s+/img, " ").trim().length;
        }).property('reply');
      }
    }, {
      key: '_setupComposer',
      initializer: function () {
        return (function () {
          this.set('archetypeId', this.site.get('default_archetype'));
        }).on('init');
      }
    }, {
      key: 'appendText',

      /**
        Append text to the current reply
         @method appendText
        @param {String} text the text to append
      **/
      value: function (text, position, opts) {
        var reply = this.get('reply') || '';
        position = typeof position === "number" ? position : reply.length;

        var before = reply.slice(0, position) || '';
        var after = reply.slice(position) || '';

        var stripped = undefined,
            i = undefined;
        if (opts && opts.block) {
          if (before.trim() !== "") {
            stripped = before.replace(/\r/g, "");
            for (i = 0; i < 2; i++) {
              if (stripped[stripped.length - 1 - i] !== "\n") {
                before += "\n";
                position++;
              }
            }
          }
          if (after.trim() !== "") {
            stripped = after.replace(/\r/g, "");
            for (i = 0; i < 2; i++) {
              if (stripped[i] !== "\n") {
                after = "\n" + after;
              }
            }
          }
        }

        if (opts && opts.space) {
          if (before.length > 0 && !before[before.length - 1].match(/\s/)) {
            before = before + " ";
          }
          if (after.length > 0 && !after[0].match(/\s/)) {
            after = " " + after;
          }
        }

        this.set('reply', before + text + after);

        return before.length + text.length;
      }
    }, {
      key: 'prependText',
      value: function (text, opts) {
        var reply = this.get('reply') || '';

        if (opts && opts.new_line && reply.length > 0) {
          text = text.trim() + "\n\n";
        }
        this.set('reply', text + reply);
      }
    }, {
      key: 'applyTopicTemplate',
      value: function (oldCategoryId, categoryId) {
        if (this.get('action') !== CREATE_TOPIC) {
          return;
        }
        var reply = this.get('reply');

        // If the user didn't change the template, clear it
        if (oldCategoryId) {
          var oldCat = this.site.categories.findProperty('id', oldCategoryId);
          if (oldCat && oldCat.get('topic_template') === reply) {
            reply = "";
          }
        }

        if (!Ember.isEmpty(reply)) {
          return;
        }
        var category = this.site.categories.findProperty('id', categoryId);
        if (category) {
          this.set('reply', category.get('topic_template') || "");
        }
      }
    }, {
      key: 'open',

      /*
         Open a composer
          opts:
           action   - The action we're performing: edit, reply or createTopic
           post     - The post we're replying to, if present
           topic    - The topic we're replying to, if present
           quote    - If we're opening a reply from a quote, the quote we're making
      */
      value: function (opts) {
        if (!opts) opts = {};
        this.set('loading', false);

        var replyBlank = Em.isEmpty(this.get("reply"));

        var composer = this;
        if (!replyBlank && (opts.reply || opts.action === EDIT) && this.get('replyDirty')) {
          return;
        }

        if (opts.action === REPLY && this.get('action') === EDIT) this.set('reply', '');
        if (!opts.draftKey) throw 'draft key is required';
        if (opts.draftSequence === null) throw 'draft sequence is required';

        this.setProperties({
          draftKey: opts.draftKey,
          draftSequence: opts.draftSequence,
          composeState: opts.composerState || OPEN,
          action: opts.action,
          topic: opts.topic,
          targetUsernames: opts.usernames,
          composerTotalOpened: opts.composerTime,
          typingTime: opts.typingTime
        });

        if (opts.post) {
          this.set('post', opts.post);

          this.set('whisper', opts.post.get('post_type') === this.site.get('post_types.whisper'));
          if (!this.get('topic')) {
            this.set('topic', opts.post.get('topic'));
          }
        } else {
          this.set('post', null);
        }

        this.setProperties({
          archetypeId: opts.archetypeId || this.site.get('default_archetype'),
          metaData: opts.metaData ? Em.Object.create(opts.metaData) : null,
          reply: opts.reply || this.get("reply") || ""
        });

        // We set the category id separately for topic templates on opening of composer
        this.set('categoryId', opts.categoryId || this.get('topic.category.id'));

        if (!this.get('categoryId') && this.get('creatingTopic')) {
          var categories = Discourse.Category.list();
          if (categories.length === 1) {
            this.set('categoryId', categories[0].get('id'));
          }
        }

        if (opts.postId) {
          this.set('loading', true);
          this.store.find('post', opts.postId).then(function (post) {
            composer.set('post', post);
            composer.set('loading', false);
          });
        }

        // If we are editing a post, load it.
        if (opts.action === EDIT && opts.post) {

          var topicProps = this.serialize(_edit_topic_serializer);
          topicProps.loading = true;

          this.setProperties(topicProps);

          this.store.find('post', opts.post.get('id')).then(function (post) {
            composer.setProperties({
              reply: post.get('raw'),
              originalText: post.get('raw'),
              loading: false
            });
          });
        } else if (opts.action === REPLY && opts.quote) {
          this.setProperties({
            reply: opts.quote,
            originalText: opts.quote
          });
        }
        if (opts.title) {
          this.set('title', opts.title);
        }
        this.set('originalText', opts.draft ? '' : this.get('reply'));

        return false;
      }
    }, {
      key: 'save',
      value: function (opts) {
        if (!this.get('cantSubmitPost')) {
          return this.get('editingPost') ? this.editPost(opts) : this.createPost(opts);
        }
      }
    }, {
      key: 'clearState',

      /**
        Clear any state we have in preparation for a new composition.
         @method clearState
      **/
      value: function () {
        this.setProperties({
          originalText: null,
          reply: null,
          post: null,
          title: null,
          editReason: null,
          stagedPost: false,
          typingTime: 0,
          composerOpened: null,
          composerTotalOpened: 0
        });
      }
    }, {
      key: 'editPost',

      // When you edit a post
      value: function (opts) {
        var post = this.get('post'),
            oldCooked = post.get('cooked'),
            self = this;

        var promise = undefined;

        // Update the title if we've changed it, otherwise consider it a
        // successful resolved promise
        if (this.get('title') && post.get('post_number') === 1 && this.get('topic.details.can_edit')) {
          var topicProps = this.getProperties(Object.keys(_edit_topic_serializer));

          promise = Topic.update(this.get('topic'), topicProps);
        } else {
          promise = Ember.RSVP.resolve();
        }

        var props = {
          raw: this.get('reply'),
          edit_reason: opts.editReason,
          image_sizes: opts.imageSizes,
          cooked: this.getCookedHtml()
        };

        this.set('composeState', CLOSED);

        var rollback = throwAjaxError(function () {
          post.set('cooked', oldCooked);
          self.set('composeState', OPEN);
        });

        return promise.then(function () {
          return post.save(props).then(function (result) {
            self.clearState();
            return result;
          }).catch(function (error) {
            throw error;
          });
        }).catch(rollback);
      }
    }, {
      key: 'serialize',
      value: function (serializer, dest) {
        var _this = this;

        dest = dest || {};
        Object.keys(serializer).forEach(function (f) {
          var val = _this.get(serializer[f]);
          if (typeof val !== 'undefined') {
            Ember.set(dest, f, val);
          }
        });
        return dest;
      }
    }, {
      key: 'createPost',

      // Create a new Post
      value: function (opts) {
        var post = this.get('post'),
            topic = this.get('topic'),
            user = this.user,
            postStream = this.get('topic.postStream');

        var addedToStream = false;

        var postTypes = this.site.get('post_types');
        var postType = this.get('whisper') ? postTypes.whisper : postTypes.regular;

        // Build the post object
        var createdPost = this.store.createRecord('post', {
          imageSizes: opts.imageSizes,
          cooked: this.getCookedHtml(),
          reply_count: 0,
          name: user.get('name'),
          display_username: user.get('name'),
          username: user.get('username'),
          user_id: user.get('id'),
          user_title: user.get('title'),
          avatar_template: user.get('avatar_template'),
          user_custom_fields: user.get('custom_fields'),
          post_type: postType,
          actions_summary: [],
          moderator: user.get('moderator'),
          admin: user.get('admin'),
          yours: true,
          read: true,
          wiki: false,
          typingTime: this.get('typingTime'),
          composerTime: this.get('composerTime')
        });

        this.serialize(_create_serializer, createdPost);

        if (post) {
          createdPost.setProperties({
            reply_to_post_number: post.get('post_number'),
            reply_to_user: {
              username: post.get('username'),
              avatar_template: post.get('avatar_template')
            }
          });
        }

        var state = null;

        // If we're in a topic, we can append the post instantly.
        if (postStream) {
          // If it's in reply to another post, increase the reply count
          if (post) {
            post.set('reply_count', (post.get('reply_count') || 0) + 1);
            post.set('replies', []);
          }

          // We do not stage posts in mobile view, we do not have the "cooked"
          // Furthermore calculating cooked is very complicated, especially since
          // we would need to handle oneboxes and other bits that are not even in the
          // engine, staging will just cause a blank post to render
          if (!_.isEmpty(createdPost.get('cooked'))) {
            state = postStream.stagePost(createdPost, user);
            if (state === "alreadyStaging") {
              return;
            }
          }
        }

        var composer = this;
        composer.set('composeState', SAVING);
        composer.set("stagedPost", state === "staged" && createdPost);

        return createdPost.save().then(function (result) {
          var saving = true;

          if (result.responseJson.action === "enqueued") {
            if (postStream) {
              postStream.undoPost(createdPost);
            }
            return result;
          }

          if (topic) {
            // It's no longer a new post
            topic.set('draft_sequence', result.target.draft_sequence);
            postStream.commitPost(createdPost);
            addedToStream = true;
          } else {
            // We created a new topic, let's show it.
            composer.set('composeState', CLOSED);
            saving = false;

            // Update topic_count for the category
            var category = composer.site.get('categories').find(function (x) {
              return x.get('id') === (parseInt(createdPost.get('category'), 10) || 1);
            });
            if (category) category.incrementProperty('topic_count');
            Discourse.notifyPropertyChange('globalNotice');
          }

          composer.clearState();
          composer.set('createdPost', createdPost);

          if (addedToStream) {
            composer.set('composeState', CLOSED);
          } else if (saving) {
            composer.set('composeState', SAVING);
          }

          return result;
        }).catch(throwAjaxError(function () {
          if (postStream) {
            postStream.undoPost(createdPost);
          }
          Ember.run.next(function () {
            return composer.set('composeState', OPEN);
          });
        }));
      }
    }, {
      key: 'getCookedHtml',
      value: function () {
        return $('#reply-control .d-editor-preview').html().replace(/<span class="marker"><\/span>/g, '');
      }
    }, {
      key: 'saveDraft',
      value: function () {
        // Do not save when drafts are disabled
        if (this.get('disableDrafts')) return;
        // Do not save when there is no reply
        if (!this.get('reply')) return;
        // Do not save when the reply's length is too small
        if (this.get('replyLength') < this.siteSettings.min_post_length) return;

        var data = {
          reply: this.get('reply'),
          action: this.get('action'),
          title: this.get('title'),
          categoryId: this.get('categoryId'),
          postId: this.get('post.id'),
          archetypeId: this.get('archetypeId'),
          metaData: this.get('metaData'),
          usernames: this.get('targetUsernames'),
          composerTime: this.get('composerTime'),
          typingTime: this.get('typingTime')
        };

        this.set('draftStatus', I18n.t('composer.saving_draft_tip'));

        var composer = this;

        if (this._clearingStatus) {
          Em.run.cancel(this._clearingStatus);
          this._clearingStatus = null;
        }

        // try to save the draft
        return Draft.save(this.get('draftKey'), this.get('draftSequence'), data).then(function () {
          composer.set('draftStatus', I18n.t('composer.saved_draft_tip'));
        }).catch(function () {
          composer.set('draftStatus', I18n.t('composer.drafts_offline'));
        });
      }
    }, {
      key: 'dataChanged',
      initializer: function () {
        return (function () {
          var draftStatus = this.get('draftStatus');
          var self = this;

          if (draftStatus && !this._clearingStatus) {

            this._clearingStatus = Em.run.later(this, function () {
              self.set('draftStatus', null);
              self._clearingStatus = null;
            }, 1000);
          }
        }).observes('title', 'reply');
      }
    }]));

    Composer.reopenClass({

      // TODO: Replace with injection
      create: function (args) {
        args = args || {};
        args.user = args.user || Discourse.User.current();
        args.site = args.site || Discourse.Site.current();
        args.siteSettings = args.siteSettings || Discourse.SiteSettings;
        return this._super(args);
      },

      serializeToTopic: function (fieldName, property) {
        if (!property) {
          property = fieldName;
        }
        _edit_topic_serializer[fieldName] = property;
      },

      serializeOnCreate: function (fieldName, property) {
        if (!property) {
          property = fieldName;
        }
        _create_serializer[fieldName] = property;
      },

      serializedFieldsForCreate: function () {
        return Object.keys(_create_serializer);
      },

      // The status the compose view can have
      CLOSED: CLOSED,
      SAVING: SAVING,
      OPEN: OPEN,
      DRAFT: DRAFT,

      // The actions the composer can take
      CREATE_TOPIC: CREATE_TOPIC,
      PRIVATE_MESSAGE: PRIVATE_MESSAGE,
      REPLY: REPLY,
      EDIT: EDIT,

      // Draft key
      REPLY_AS_NEW_TOPIC_KEY: REPLY_AS_NEW_TOPIC_KEY
    });

    __exports__["default"] = Composer;
  });
define("discourse/mixins/add-archetype-class", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Mix this in to a view that has a `archetype` property to automatically
    // add it to the body as the view is entered / left / model is changed.
    // This is used for keeping the `body` style in sync for the background image.
    __exports__["default"] = {
      _init: (function () {
        this.get('archetype');
      }).on('init'),

      _cleanUp: function () {
        $('body').removeClass(function (_, css) {
          return (css.match(/\barchetype-\S+/g) || []).join(' ');
        });
      },

      _archetypeChanged: (function () {
        var archetype = this.get('archetype');
        this._cleanUp();

        if (archetype) {
          $('body').addClass('archetype-' + archetype);
        }
      }).observes('archetype'),

      _willDestroyElement: (function () {
        this._cleanUp();
      }).on('willDestroyElement')
    };
  });

Discourse.AddArchetypeClass = require('discourse/mixins/add-archetype-class').default;
define("discourse/mixins/add-category-class", 
  ["ember","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    // Mix this in to a view that has a `categoryFullSlug` property to automatically
    // add it to the body as the view is entered / left / model is changed.
    // This is used for keeping the `body` style in sync for the background image.

    var Ember = __dependency1__["default"];
    var on = Ember.on;
    var observer = Ember.observer;

    __exports__["default"] = {
      _categoryChanged: on("didInsertElement", observer("categoryFullSlug", function () {
        var categoryFullSlug = this.get("categoryFullSlug");

        this._removeClass();

        if (categoryFullSlug) {
          $("body").addClass("category-" + categoryFullSlug);
        }
      })),

      _leave: on("willDestroyElement", function () {
        this.removeObserver("categoryFullSlug");
        this._removeClass();
      }),

      _removeClass: function () {
        $("body").removeClass(function (_, css) {
          return (css.match(/\bcategory-\S+/g) || []).join(" ");
        });
      }
    };
  });

Discourse.AddCategoryClass = require('discourse/mixins/add-category-class').default;
define("discourse/mixins/badge-select-controller", 
  ["discourse/models/badge","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Badge = __dependency1__["default"];

    __exports__["default"] = Ember.Mixin.create({
      saving: false,
      saved: false,

      selectableUserBadges: (function () {
        var items = this.get('filteredList');
        items = _.uniq(items, false, function (e) {
          return e.get('badge.name');
        });
        items.unshiftObject(Em.Object.create({
          badge: Badge.create({ name: I18n.t('badges.none') })
        }));
        return items;
      }).property('filteredList'),

      savingStatus: (function () {
        if (this.get('saving')) {
          return I18n.t('saving');
        } else {
          return I18n.t('save');
        }
      }).property('saving'),

      selectedUserBadge: (function () {
        var selectedUserBadgeId = parseInt(this.get('selectedUserBadgeId'));
        var selectedUserBadge = null;
        this.get('selectableUserBadges').forEach(function (userBadge) {
          if (userBadge.get('id') === selectedUserBadgeId) {
            selectedUserBadge = userBadge;
          }
        });
        return selectedUserBadge;
      }).property('selectedUserBadgeId'),

      disableSave: Em.computed.alias('saving')
    });
  });

Discourse.BadgeSelectController = require('discourse/mixins/badge-select-controller').default;
define("discourse/mixins/buffered-content", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.bufferedProperty = bufferedProperty;
    /* global BufferedProxy: true */

    function bufferedProperty(property) {
      var mixin = {
        buffered: (function () {
          return Em.ObjectProxy.extend(BufferedProxy).create({
            content: this.get(property)
          });
        }).property(property),

        rollbackBuffer: function () {
          this.get('buffered').discardBufferedChanges();
        },

        commitBuffer: function () {
          this.get('buffered').applyBufferedChanges();
        }
      };

      // It's a good idea to null out fields when declaring objects
      mixin.property = null;

      return Ember.Mixin.create(mixin);
    }

    __exports__["default"] = bufferedProperty('content');
  });

Discourse.BufferedContent = require('discourse/mixins/buffered-content').default;
define("discourse/mixins/bulk-topic-selection", 
  ["discourse/lib/notification-levels","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var NotificationLevels = __dependency1__["default"];

    __exports__["default"] = Ember.Mixin.create({
      bulkSelectEnabled: false,
      selected: null,

      canBulkSelect: Em.computed.alias('currentUser.staff'),

      resetSelected: (function () {
        this.set('selected', []);
      }).on('init'),

      actions: {
        toggleBulkSelect: function () {
          this.toggleProperty('bulkSelectEnabled');
          this.get('selected').clear();
        },

        dismissRead: function (operationType) {
          var self = this,
              selected = this.get('selected');

          var operation = undefined;
          if (operationType === "posts") {
            operation = { type: 'dismiss_posts' };
          } else {
            operation = { type: 'change_notification_level',
              notification_level_id: NotificationLevels.REGULAR };
          }

          var promise = undefined;
          if (selected.length > 0) {
            promise = Discourse.Topic.bulkOperation(selected, operation);
          } else {
            promise = Discourse.Topic.bulkOperationByFilter('unread', operation, this.get('category.id'));
          }
          promise.then(function (result) {
            if (result && result.topic_ids) {
              (function () {
                var tracker = self.topicTrackingState;
                result.topic_ids.forEach(function (t) {
                  tracker.removeTopic(t);
                });
                tracker.incrementMessageCount();
              })();
            }
            self.send('closeModal');
            self.send('refresh');
          });
        }
      }
    });
  });

Discourse.BulkTopicSelection = require('discourse/mixins/bulk-topic-selection').default;
define("discourse/mixins/can-check-emails", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;
    var setting = __dependency1__.setting;

    __exports__["default"] = Ember.Mixin.create({
      isOwnEmail: propertyEqual("model.id", "currentUser.id"),
      showEmailOnProfile: setting("show_email_on_profile"),
      canStaffCheckEmails: Em.computed.and("showEmailOnProfile", "currentUser.staff"),
      canAdminCheckEmails: Em.computed.alias("currentUser.admin"),
      canCheckEmails: Em.computed.or("isOwnEmail", "canStaffCheckEmails", "canAdminCheckEmails")
    });
  });

Discourse.CanCheckEmails = require('discourse/mixins/can-check-emails').default;
define("discourse/mixins/cleans-up", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Include this mixin if you want to be notified when the dom should be
    // cleaned (usually on route change.)
    __exports__["default"] = Ember.Mixin.create({
      _initializeChooser: (function () {
        this.appEvents.on('dom:clean', this, "cleanUp");
      }).on('didInsertElement'),

      _clearChooser: (function () {
        this.appEvents.off('dom:clean', this, "cleanUp");
      }).on('willDestroyElement')
    });
  });

Discourse.CleansUp = require('discourse/mixins/cleans-up').default;
define("discourse/mixins/load-more", 
  ["discourse/lib/eyeline","discourse/mixins/scrolling","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var Eyeline = __dependency1__["default"];
    var Scrolling = __dependency2__["default"];
    var on = __dependency3__.on;

    // Provides the ability to load more items for a view which is scrolled to the bottom.
    __exports__["default"] = Ember.Mixin.create(Ember.ViewTargetActionSupport, Scrolling, _createDecoratedObject([{
      key: 'scrolled',
      value: function () {
        var eyeline = this.get('eyeline');
        return eyeline && eyeline.update();
      }
    }, {
      key: 'loadMoreUnlessFull',
      value: function () {
        if (this.screenNotFull()) {
          this.send("loadMore");
        }
      }
    }, {
      key: '_bindEyeline',
      decorators: [on("didInsertElement")],
      value: function () {
        var _this = this;

        var eyeline = new Eyeline(this.get('eyelineSelector') + ":last");
        this.set('eyeline', eyeline);
        eyeline.on('sawBottom', function () {
          return _this.send('loadMore');
        });
        this.bindScrolling();
      }
    }, {
      key: '_removeEyeline',
      decorators: [on("willDestroyElement")],
      value: function () {
        this.unbindScrolling();
      }
    }]));
  });

Discourse.LoadMore = require('discourse/mixins/load-more').default;
define("discourse/mixins/modal-functionality", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.Mixin.create({
      flashMessage: null,

      needs: ['modal'],

      flash: function (message, messageClass) {
        this.set('flashMessage', Em.Object.create({ message: message, messageClass: messageClass }));
      }
    });
  });

Discourse.ModalFunctionality = require('discourse/mixins/modal-functionality').default;
define("discourse/mixins/open-composer", 
  ["discourse/models/composer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    // This mixin allows a route to open the composer
    var Composer = __dependency1__["default"];

    __exports__["default"] = Ember.Mixin.create({

      openComposer: function (controller) {
        this.controllerFor('composer').open({
          categoryId: controller.get('category.id'),
          action: Composer.CREATE_TOPIC,
          draftKey: controller.get('model.draft_key'),
          draftSequence: controller.get('model.draft_sequence')
        });
      },

      openComposerWithTopicParams: function (controller, topicTitle, topicBody, topicCategoryId, topicCategory) {
        this.controllerFor('composer').open({
          action: Composer.CREATE_TOPIC,
          topicTitle: topicTitle,
          topicBody: topicBody,
          topicCategoryId: topicCategoryId,
          topicCategory: topicCategory,
          draftKey: controller.get('model.draft_key'),
          draftSequence: controller.get('model.draft_sequence')
        });
      },

      openComposerWithMessageParams: function (usernames, topicTitle, topicBody) {
        this.controllerFor('composer').open({
          action: Composer.PRIVATE_MESSAGE,
          usernames: usernames,
          topicTitle: topicTitle,
          topicBody: topicBody,
          archetypeId: 'private_message',
          draftKey: 'new_private_message'
        });
      }

    });
  });

Discourse.OpenComposer = require('discourse/mixins/open-composer').default;
define("discourse/mixins/scroll-top", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    function scrollTop() {
      if (DiscourseURL.isJumpScheduled()) {
        return;
      }
      Ember.run.schedule('afterRender', function () {
        $(document).scrollTop(0);
      });
    }

    __exports__["default"] = Ember.Mixin.create({
      _scrollTop: scrollTop.on('didInsertElement')
    });

    __exports__.scrollTop = scrollTop;
  });

Discourse.ScrollTop = require('discourse/mixins/scroll-top').default;
define("discourse/mixins/selected-posts-count", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.Mixin.create({

      selectedPostsCount: (function () {
        if (this.get('allPostsSelected')) {
          return this.get('model.posts_count') || this.get('topic.posts_count') || this.get('posts_count');
        }

        var sum = this.get('selectedPosts.length') || 0;
        if (this.get('selectedReplies')) {
          this.get('selectedReplies').forEach(function (p) {
            sum += p.get('reply_count') || 0;
          });
        }

        return sum;
      }).property('selectedPosts.length', 'allPostsSelected', 'selectedReplies.length'),

      // The username that owns every selected post, or undefined if no selection or if ownership is mixed.
      selectedPostsUsername: (function () {
        // Don't proceed if replies are selected or usernames are mixed
        // Changing ownership in those cases normally doesn't make sense
        if (this.get('selectedReplies') && this.get('selectedReplies').length > 0) {
          return undefined;
        }
        if (this.get('selectedPosts').length <= 0) {
          return undefined;
        }

        var selectedPosts = this.get('selectedPosts'),
            username = selectedPosts[0].username;

        if (selectedPosts.every(function (post) {
          return post.username === username;
        })) {
          return username;
        } else {
          return undefined;
        }
      }).property('selectedPosts.length', 'selectedReplies.length')
    });
  });

Discourse.SelectedPostsCount = require('discourse/mixins/selected-posts-count').default;
define("discourse/mixins/singleton", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      This mixin allows a class to return a singleton, as well as a method to quickly
      read/write attributes on the singleton.


      Example usage:

      ```javascript

        // Define your class and apply the Mixin
        User = Ember.Object.extend({});
        User.reopenClass(Singleton);

        // Retrieve the current instance:
        var instance = User.current();

      ```

      Commonly you want to read or write a property on the singleton. There's a
      helper method which is a little nicer than `.current().get()`:

      ```javascript

        // Sets the age to 34
        User.currentProp('age', 34);

        console.log(User.currentProp('age')); // 34

      ```

      If you want to customize how the singleton is created, redefine the `createCurrent`
      method:

      ```javascript

        // Define your class and apply the Mixin
        Foot = Ember.Object.extend({});
        Foot.reopenClass(Singleton, {
          createCurrent: function() {
            return Foot.create({toes: 5});
          }
        });

        console.log(Foot.currentProp('toes')); // 5

      ```
    **/

    var Singleton = Ember.Mixin.create({

      current: function () {
        if (!this._current) {
          this._current = this.createCurrent();
        }
        return this._current;
      },

      /**
        How the singleton instance is created. This can be overridden
        with logic for creating (or even returning null) your instance.
         By default it just calls `create` with an empty object.
      **/
      createCurrent: function () {
        return this.create({});
      },

      // Returns OR sets a property on the singleton instance.
      currentProp: function (property, value) {
        var instance = this.current();
        if (!instance) {
          return;
        }

        if (typeof value !== "undefined") {
          instance.set(property, value);
          return value;
        } else {
          return instance.get(property);
        }
      },

      resetCurrent: function (val) {
        this._current = val;
      }
    });

    __exports__["default"] = Singleton;
  });

Discourse.Singleton = require('discourse/mixins/singleton').default;
define("discourse/mixins/string-buffer", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Mixin.create({

      _watchProps: (function () {
        var _this = this;

        var args = this.get('rerenderTriggers');
        if (!Ember.isNone(args)) {
          args.forEach(function (k) {
            return _this.addObserver(k, _this.rerenderString);
          });
        }
      }).on('init'),

      render: function (buffer) {
        this.renderString(buffer);
      },

      renderString: function (buffer) {
        var template = Discourse.__container__.lookup('template:' + this.rawTemplate);
        if (template) {
          buffer.push(template(this));
        }
      },

      _rerenderString: function () {
        var $sel = this.$();
        if (!$sel) {
          return;
        }

        var buffer = [];
        this.renderString(buffer);

        // Chrome likes scrolling after HTML is set
        // This happens if you navigate back and forth a few times
        // Before removing this code confirm that this does not cause scrolling
        // 1. Sort by views
        // 2. Go to last post on one of the topics
        // 3. Hit back
        // 4. Go to last post on same topic
        // 5. Expand likes
        var scrollTop = $(window).scrollTop();
        $sel.html(buffer.join(''));
        $(window).scrollTop(scrollTop);
      },

      rerenderString: function () {
        Ember.run.once(this, '_rerenderString');
      }

    });
  });

Discourse.StringBuffer = require('discourse/mixins/string-buffer').default;
define("discourse/mixins/upload", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.Mixin.create({
      uploading: false,
      uploadProgress: 0,

      uploadDone: function () {
        Em.warn("You should implement `uploadDone`");
      },

      _initialize: (function () {
        var _this = this;

        var $upload = this.$(),
            csrf = Discourse.Session.currentProp("csrfToken"),
            uploadUrl = Discourse.getURL(this.getWithDefault("uploadUrl", "/uploads")),
            reset = function () {
          return _this.setProperties({ uploading: false, uploadProgress: 0 });
        };

        this.messageBus.subscribe("/uploads/" + this.get("type"), function (upload) {
          if (upload && upload.url) {
            _this.uploadDone(upload);
          } else {
            Discourse.Utilities.displayErrorForUpload(upload);
          }
          reset();
        });

        $upload.fileupload({
          url: uploadUrl + ".json?client_id=" + this.messageBus.clientId + "&authenticity_token=" + encodeURIComponent(csrf),
          dataType: "json",
          dropZone: $upload,
          pasteZone: $upload
        });

        $upload.on("fileuploaddrop", function (e, data) {
          if (data.files.length > 10) {
            bootbox.alert(I18n.t("post.errors.too_many_dragged_and_dropped_files"));
            return false;
          } else {
            return true;
          }
        });

        $upload.on("fileuploadsubmit", function (e, data) {
          var isValid = Discourse.Utilities.validateUploadedFiles(data.files, true);
          var form = { type: _this.get("type") };
          if (_this.get("data")) {
            form = $.extend(form, _this.get("data"));
          }
          data.formData = form;
          _this.setProperties({ uploadProgress: 0, uploading: isValid });
          return isValid;
        });

        $upload.on("fileuploadprogressall", function (e, data) {
          var progress = parseInt(data.loaded / data.total * 100, 10);
          _this.set("uploadProgress", progress);
        });

        $upload.on("fileuploadfail", function (e, data) {
          Discourse.Utilities.displayErrorForUpload(data);
          reset();
        });
      }).on("didInsertElement"),

      _destroy: (function () {
        this.messageBus.unsubscribe("/uploads/" + this.get("type"));
        var $upload = this.$();
        try {
          $upload.fileupload("destroy");
        } catch (e) {/* wasn't initialized yet */}
        $upload.off();
      }).on("willDestroyElement")
    });
  });

Discourse.Upload = require('discourse/mixins/upload').default;
define("discourse/mixins/url-refresh", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // A Mixin that a view can use to listen for 'url:refresh' when
    // it is on screen, and will send an action to refresh its data.
    //
    // This is useful if you want to get around Ember's default
    // behavior of not refreshing when navigating to the same place.
    __exports__["default"] = {
      didInsertElement: function () {
        var _this = this;

        this._super();
        this.appEvents.on('url:refresh', function () {
          return _this.sendAction('refresh');
        });
      },

      willDestroyElement: function () {
        this._super();
        this.appEvents.off('url:refresh');
      }
    };
  });

Discourse.UrlRefresh = require('discourse/mixins/url-refresh').default;
define("discourse/mixins/viewing-action-type", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      viewingActionType: function (userActionType) {
        this.controllerFor('user').set('userActionType', userActionType);
        this.controllerFor('user-activity').set('userActionType', userActionType);
      }

    };
  });

Discourse.ViewingActionType = require('discourse/mixins/viewing-action-type').default;
define("discourse/models/invite", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var Invite = Discourse.Model.extend({

      rescind: function () {
        Discourse.ajax('/invites', {
          type: 'DELETE',
          data: { email: this.get('email') }
        });
        this.set('rescinded', true);
      },

      reinvite: function () {
        Discourse.ajax('/invites/reinvite', {
          type: 'POST',
          data: { email: this.get('email') }
        });
        this.set('reinvited', true);
      }

    });

    Invite.reopenClass({

      create: function () {
        var result = this._super.apply(this, arguments);
        if (result.user) {
          result.user = Discourse.User.create(result.user);
        }
        return result;
      },

      findInvitedBy: function (user, filter, search, offset) {
        if (!user) {
          return Em.RSVP.resolve();
        }

        var data = {};
        if (!Em.isNone(filter)) {
          data.filter = filter;
        }
        if (!Em.isNone(search)) {
          data.search = search;
        }
        data.offset = offset || 0;

        return Discourse.ajax("/users/" + user.get('username_lower') + "/invited.json", { data: data }).then(function (result) {
          result.invites = result.invites.map(function (i) {
            return Invite.create(i);
          });

          return Em.Object.create(result);
        });
      },

      findInvitedCount: function (user) {
        if (!user) {
          return Em.RSVP.resolve();
        }
        return Discourse.ajax("/users/" + user.get('username_lower') + "/invited_count.json").then(function (result) {
          return Em.Object.create(result.counts);
        });
      }

    });

    __exports__["default"] = Invite;
  });
define("discourse/models/user-badge", 
  ["discourse/models/badge","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Badge = __dependency1__["default"];

    var UserBadge = Discourse.Model.extend({
      postUrl: (function () {
        if (this.get('topic_title')) {
          return "/t/-/" + this.get('topic_id') + "/" + this.get('post_number');
        }
      }).property(), // avoid the extra bindings for now

      revoke: function () {
        return Discourse.ajax("/user_badges/" + this.get('id'), {
          type: "DELETE"
        });
      }
    });

    UserBadge.reopenClass({

      createFromJson: function (json) {
        // Create User objects.
        if (json.users === undefined) {
          json.users = [];
        }
        var users = {};
        json.users.forEach(function (userJson) {
          users[userJson.id] = Discourse.User.create(userJson);
        });

        // Create Topic objects.
        if (json.topics === undefined) {
          json.topics = [];
        }
        var topics = {};
        json.topics.forEach(function (topicJson) {
          topics[topicJson.id] = Discourse.Topic.create(topicJson);
        });

        // Create the badges.
        if (json.badges === undefined) {
          json.badges = [];
        }
        var badges = {};
        Badge.createFromJson(json).forEach(function (badge) {
          badges[badge.get('id')] = badge;
        });

        // Create UserBadge object(s).
        var userBadges = [];
        if ("user_badge" in json) {
          userBadges = [json.user_badge];
        } else {
          userBadges = json.user_badge_info && json.user_badge_info.user_badges || json.user_badges;
        }

        userBadges = userBadges.map(function (userBadgeJson) {
          var userBadge = UserBadge.create(userBadgeJson);

          var grantedAtDate = Date.parse(userBadge.get('granted_at'));
          userBadge.set('grantedAt', grantedAtDate);

          userBadge.set('badge', badges[userBadge.get('badge_id')]);
          if (userBadge.get('user_id')) {
            userBadge.set('user', users[userBadge.get('user_id')]);
          }
          if (userBadge.get('granted_by_id')) {
            userBadge.set('granted_by', users[userBadge.get('granted_by_id')]);
          }
          if (userBadge.get('topic_id')) {
            userBadge.set('topic', topics[userBadge.get('topic_id')]);
          }
          return userBadge;
        });

        if ("user_badge" in json) {
          return userBadges[0];
        } else {
          if (json.user_badge_info) {
            userBadges.grant_count = json.user_badge_info.grant_count;
            userBadges.username = json.user_badge_info.username;
          }
          return userBadges;
        }
      },

      /**
        Find all badges for a given username.
         @method findByUsername
        @param {String} username
        @param {Object} options
        @returns {Promise} a promise that resolves to an array of `UserBadge`.
      **/
      findByUsername: function (username, options) {
        var url = "/user-badges/" + username + ".json";
        if (options && options.grouped) {
          url += "?grouped=true";
        }
        return Discourse.ajax(url).then(function (json) {
          return UserBadge.createFromJson(json);
        });
      },

      /**
        Find all badge grants for a given badge ID.
         @method findById
        @param {String} badgeId
        @returns {Promise} a promise that resolves to an array of `UserBadge`.
      **/
      findByBadgeId: function (badgeId, options) {
        if (!options) {
          options = {};
        }
        options.badge_id = badgeId;

        return Discourse.ajax("/user_badges.json", {
          data: options
        }).then(function (json) {
          return UserBadge.createFromJson(json);
        });
      },

      /**
        Grant the badge having id `badgeId` to the user identified by `username`.
         @method grant
        @param {Integer} badgeId id of the badge to be granted.
        @param {String} username username of the user to be granted the badge.
        @returns {Promise} a promise that resolves to an instance of `UserBadge`.
      **/
      grant: function (badgeId, username, reason) {
        return Discourse.ajax("/user_badges", {
          type: "POST",
          data: {
            username: username,
            badge_id: badgeId,
            reason: reason
          }
        }).then(function (json) {
          return UserBadge.createFromJson(json);
        });
      }
    });

    __exports__["default"] = UserBadge;
  });
define("discourse/controllers/discovery-sortable", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Just add query params here to have them automatically passed to topic list filters.
    var queryParams = {
      order: { replace: true, refreshModel: true },
      ascending: { replace: true, refreshModel: true },
      status: { replace: true, refreshModel: true },
      state: { replace: true, refreshModel: true },
      search: { replace: true, refreshModel: true },
      max_posts: { replace: true, refreshModel: true },
      q: { replace: true, refreshModel: true }
    };

    __exports__.queryParams = queryParams;
    // Basic controller options
    var controllerOpts = {
      needs: ['discovery/topics'],
      queryParams: Object.keys(queryParams)
    };

    // Aliases for the values
    controllerOpts.queryParams.forEach(function (p) {
      return controllerOpts[p] = Em.computed.alias('controllers.discovery/topics.' + p);
    });

    __exports__["default"] = Ember.Controller.extend(controllerOpts);
  });
define("discourse/controllers/navigation/default", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['discovery', 'discovery/topics'];
      }
    }, {
      key: 'categories',
      decorators: [computed()],
      value: function () {
        return Discourse.Category.list();
      }
    }, {
      key: 'navItems',
      decorators: [computed("filterMode")],
      value: function (filterMode) {
        // we don't want to show the period in the navigation bar since it's in a dropdown
        if (filterMode.indexOf("top/") === 0) {
          filterMode = filterMode.replace("top/", "");
        }
        return Discourse.NavItem.buildList(null, { filterMode: filterMode });
      }
    }]));
  });
define("discourse/views/container", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.ContainerView.extend({

      attachViewWithArgs: function (viewArgs, viewClass) {
        if (typeof viewClass === "string") {
          viewClass = this.container.lookupFactory("view:" + viewClass) || this.container.lookupFactory("component:" + viewClass);
        }

        if (!viewClass) {
          viewClass = Ember.View.extend();
        }
        this.pushObject(this.createChildView(viewClass, viewArgs));
      },

      attachViewClass: function (viewClass) {
        this.attachViewWithArgs(null, viewClass);
      }
    });
  });
define("discourse/views/modal-body", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var observes = __dependency1__.observes;
    var on = __dependency1__.on;

    __exports__["default"] = Ember.View.extend(_createDecoratedObject([{
      key: "focusInput",
      initializer: function () {
        return true;
      }
    }, {
      key: "_setupModal",
      decorators: [on("didInsertElement")],
      value: function () {
        var _this = this;

        $('#modal-alert').hide();
        $('#discourse-modal').modal('show');

        // Focus on first element
        if (!this.site.mobileView && this.get('focusInput')) {
          Em.run.schedule('afterRender', function () {
            return _this.$('input:first').focus();
          });
        }

        var title = this.get('title');
        if (title) {
          this.set('controller.controllers.modal.title', title);
        }
      }
    }, {
      key: "flashMessageChanged",
      decorators: [observes("controller.flashMessage")],
      value: function () {
        var flashMessage = this.get('controller.flashMessage');
        if (flashMessage) {
          var messageClass = flashMessage.get('messageClass') || 'success';
          $('#modal-alert').hide().removeClass('alert-error', 'alert-success').addClass("alert alert-" + messageClass).html(flashMessage.get('message')).fadeIn();
        }
      }
    }]));
  });
define("discourse/views/flag", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/flag',

      title: (function () {
        return this.get('controller.flagTopic') ? I18n.t('flagging_topic.title') : I18n.t('flagging.title');
      }).property('controller.flagTopic'),

      _selectRadio: function () {
        this.$("input[type='radio']").prop('checked', false);

        var nameKey = this.get('controller.selected.name_key');
        if (!nameKey) {
          return;
        }

        this.$('#radio_' + nameKey).prop('checked', 'true');
      },

      selectedChanged: (function () {
        Ember.run.next(this, this._selectRadio);
      }).observes('controller.selected.name_key'),

      // See: https://github.com/emberjs/ember.js/issues/10869
      _selectedHack: (function () {
        this.removeObserver('controller.selected.name_key');
      }).on('willDestroyElement')
    });
  });
define("discourse/components/combo-box", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;
    var observes = __dependency1__.observes;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'select';
      }
    }, {
      key: 'attributeBindings',
      initializer: function () {
        return ['tabindex'];
      }
    }, {
      key: 'classNames',
      initializer: function () {
        return ['combobox'];
      }
    }, {
      key: 'valueAttribute',
      initializer: function () {
        return 'id';
      }
    }, {
      key: 'nameProperty',
      initializer: function () {
        return 'name';
      }
    }, {
      key: 'render',
      value: function (buffer) {
        var _this = this;

        var nameProperty = this.get('nameProperty');
        var none = this.get('none');

        // Add none option if required
        if (typeof none === "string") {
          buffer.push('<option value="">' + I18n.t(none) + "</option>");
        } else if (typeof none === "object") {
          buffer.push("<option value=\"\">" + Em.get(none, nameProperty) + "</option>");
        }

        var selected = this.get('value');
        if (!Em.isNone(selected)) {
          selected = selected.toString();
        }

        if (this.get('content')) {
          this.get('content').forEach(function (o) {
            var val = o[_this.get('valueAttribute')];
            if (typeof val === "undefined") {
              val = o;
            }
            if (!Em.isNone(val)) {
              val = val.toString();
            }

            var selectedText = val === selected ? "selected" : "";
            var name = Handlebars.Utils.escapeExpression(Ember.get(o, nameProperty) || o);
            buffer.push('<option ' + selectedText + ' value="' + val + '">' + name + '</option>');
          });
        }
      }
    }, {
      key: 'valueChanged',
      decorators: [observes('value')],
      value: function () {
        var $combo = this.$(),
            val = this.get('value');

        if (val !== undefined && val !== null) {
          $combo.select2('val', val.toString());
        } else {
          $combo.select2('val', null);
        }
      }
    }, {
      key: '_rerenderOnChange',
      decorators: [observes('content.[]')],
      value: function () {
        this.rerender();
      }
    }, {
      key: '_initializeCombo',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this2 = this;

        // Workaround for https://github.com/emberjs/ember.js/issues/9813
        // Can be removed when fixed. Without it, the wrong option is selected
        this.$('option').each(function (i, o) {
          return o.selected = !!$(o).attr('selected');
        });

        // observer for item names changing (optional)
        if (this.get('nameChanges')) {
          this.addObserver('content.@each.' + this.get('nameProperty'), this.rerender);
        }

        var $elem = this.$();
        var minimumResultsForSearch = this.capabilities.isIOS ? -1 : 5;
        $elem.select2({ formatResult: this.comboTemplate, minimumResultsForSearch: minimumResultsForSearch, width: 'resolve' });

        var castInteger = this.get('castInteger');
        $elem.on("change", function (e) {
          var val = $(e.target).val();
          if (val && val.length && castInteger) {
            val = parseInt(val, 10);
          }
          _this2.set('value', val);
        });
        $elem.trigger('change');
      }
    }, {
      key: '_destroyDropdown',
      decorators: [on('willDestroyElement')],
      value: function () {
        this.$().select2('destroy');
      }
    }]));
  });
define("discourse/components/edit-category-panel", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.buildCategoryPanel = buildCategoryPanel;
    var EditCategoryPanel = Ember.Component.extend({
      classNameBindings: [':modal-tab', 'activeTab::invisible']
    });

    __exports__["default"] = EditCategoryPanel;

    function buildCategoryPanel(tab, extras) {
      return EditCategoryPanel.extend({
        activeTab: Ember.computed.equal('selectedTab', tab)
      }, extras || {});
    }
  });
define("discourse/views/button", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(StringBuffer, {
      tagName: 'button',
      classNameBindings: [':btn', ':standard', 'dropDownToggle'],
      attributeBindings: ['title', 'data-toggle', 'data-share-url'],

      title: (function () {
        return I18n.t(this.get('helpKey') || this.get('textKey'));
      }).property('helpKey', 'textKey'),

      text: (function () {
        if (Ember.isEmpty(this.get('textKey'))) {
          return "";
        }
        return I18n.t(this.get('textKey'));
      }).property('textKey'),

      renderString: function (buffer) {
        if (this.renderIcon) {
          this.renderIcon(buffer);
        }
        buffer.push(this.get('text'));
      }
    });
  });
define("discourse/components/dropdown-button", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      classNameBindings: [':btn-group', 'hidden'],
      rerenderTriggers: ['text', 'longDescription'],

      _bindClick: (function () {
        var _this = this;

        // If there's a click handler, call it
        if (this.clicked) {
          (function () {
            var self = _this;
            _this.$().on('click.dropdown-button', 'ul li', function (e) {
              e.preventDefault();
              if ($(e.currentTarget).data('id') !== self.get('activeItem')) {
                self.clicked($(e.currentTarget).data('id'));
              }
              self.$('.dropdown-toggle').dropdown('toggle');
              return false;
            });
          })();
        }
      }).on('didInsertElement'),

      _unbindClick: (function () {
        this.$().off('click.dropdown-button', 'ul li');
      }).on('willDestroyElement'),

      renderString: function (buffer) {
        var _this2 = this;

        var title = this.get('title');
        if (title) {
          buffer.push("<h4 class='title'>" + title + "</h4>");
        }

        buffer.push('<button class=\'btn standard dropdown-toggle ' + this.get('buttonExtraClasses') + '\' data-toggle=\'dropdown\'>' + this.get('text') + '</button>');
        buffer.push("<ul class='dropdown-menu'>");

        var contents = this.get('dropDownContent');
        if (contents) {
          (function () {
            var self = _this2;
            contents.forEach(function (row) {
              var id = row.id,
                  className = self.get('activeItem') === id ? 'disabled' : '';

              buffer.push("<li data-id=\"" + id + "\" class=\"" + className + "\"><a href>");
              buffer.push("<span class='icon " + row.styleClasses + "'></span>");
              buffer.push("<div><span class='title'>" + row.title + "</span>");
              buffer.push("<span>" + row.description + "</span></div>");
              buffer.push("</a></li>");
            });
          })();
        }

        buffer.push("</ul>");

        var desc = this.get('longDescription');
        if (desc) {
          buffer.push("<p>");
          buffer.push(desc);
          buffer.push("</p>");
        }
      }
    });
  });
define("discourse/components/notifications-button", 
  ["discourse/components/dropdown-button","discourse/lib/notification-levels","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var DropdownButton = __dependency1__["default"];
    var NotificationLevels = __dependency2__["default"];

    var NotificationsButton = DropdownButton.extend({
      classNames: ['notification-options'],
      title: '',
      buttonIncludesText: true,
      activeItem: Em.computed.alias('notificationLevel'),
      i18nPrefix: '',
      i18nPostfix: '',
      watchingClasses: 'fa fa-exclamation-circle watching',
      trackingClasses: 'fa fa-circle tracking',
      mutedClasses: 'fa fa-times-circle muted',
      regularClasses: 'fa fa-circle-o regular',

      options: (function () {
        return [['WATCHING', 'watching', this.watchingClasses], ['TRACKING', 'tracking', this.trackingClasses], ['REGULAR', 'regular', this.regularClasses], ['MUTED', 'muted', this.mutedClasses]];
      }).property(),

      dropDownContent: (function () {
        var contents = [],
            prefix = this.get('i18nPrefix'),
            postfix = this.get('i18nPostfix');

        _.each(this.get('options'), function (pair) {
          if (postfix === '_pm' && pair[1] === 'regular') {
            return;
          }
          contents.push({
            id: NotificationLevels[pair[0]],
            title: I18n.t(prefix + '.' + pair[1] + postfix + '.title'),
            description: I18n.t(prefix + '.' + pair[1] + postfix + '.description'),
            styleClasses: pair[2]
          });
        });

        return contents;
      }).property(),

      text: (function () {
        var self = this,
            prefix = this.get('i18nPrefix'),
            postfix = this.get('i18nPostfix');

        var key = (function () {
          switch (this.get('notificationLevel')) {
            case NotificationLevels.WATCHING:
              return 'watching';
            case NotificationLevels.TRACKING:
              return 'tracking';
            case NotificationLevels.MUTED:
              return 'muted';
            default:
              return 'regular';
          }
        }).call(this);

        var icon = (function () {
          switch (key) {
            case 'watching':
              return '<i class="' + self.watchingClasses + '"></i>&nbsp;';
            case 'tracking':
              return '<i class="' + self.trackingClasses + '"></i>&nbsp;';
            case 'muted':
              return '<i class="' + self.mutedClasses + '"></i>&nbsp;';
            default:
              return '<i class="' + self.regularClasses + '"></i>&nbsp;';
          }
        })();
        return icon + (this.get('buttonIncludesText') ? I18n.t(prefix + '.' + key + postfix + ".title") : '') + "<span class='caret'></span>";
      }).property('notificationLevel'),

      clicked: function () /* id */{
        // sub-class needs to implement this
      }

    });

    __exports__["default"] = NotificationsButton;
    __exports__.NotificationLevels = NotificationLevels;
  });
define("discourse/components/topic-notifications-button", 
  ["discourse/components/notifications-button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var NotificationsButton = __dependency1__["default"];

    __exports__["default"] = NotificationsButton.extend({
      longDescription: Em.computed.alias('topic.details.notificationReasonText'),
      hidden: Em.computed.alias('topic.deleted'),
      notificationLevel: Em.computed.alias('topic.details.notification_level'),
      i18nPrefix: 'topic.notifications',

      i18nPostfix: (function () {
        return this.get('topic.isPrivateMessage') ? '_pm' : '';
      }).property('topic.isPrivateMessage'),

      clicked: function (id) {
        this.get('topic.details').updateNotifications(id);
      }
    });
  });
define("discourse/lib/link-mentions", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.linkSeenMentions = linkSeenMentions;
    __exports__.fetchUnseenMentions = fetchUnseenMentions;
    function replaceSpan($e, username, opts) {
      if (opts && opts.group) {
        var extra = "",
            extraClass = "";
        if (opts.mentionable) {
          extra = " data-name='" + username + "' data-mentionable-user-count='" + opts.mentionable.user_count + "' ";
          extraClass = " notify";
        }
        $e.replaceWith("<a href='" + Discourse.getURL("/groups/") + username + "' class='mention-group" + extraClass + "'" + extra + ">@" + username + "</a>");
      } else {
        $e.replaceWith("<a href='" + Discourse.getURL("/users/") + username.toLowerCase() + "' class='mention'>@" + username + "</a>");
      }
    }

    var found = [];
    var foundGroups = [];
    var mentionableGroups = [];
    var checked = [];

    function updateFound($mentions, usernames) {
      Ember.run.scheduleOnce('afterRender', function () {
        $mentions.each(function (i, e) {
          var $e = $(e);
          var username = usernames[i];
          if (found.indexOf(username.toLowerCase()) !== -1) {
            replaceSpan($e, username);
          } else if (foundGroups.indexOf(username) !== -1) {
            var mentionable = _(mentionableGroups).where({ name: username }).first();
            replaceSpan($e, username, { group: true, mentionable: mentionable });
          } else if (checked.indexOf(username) !== -1) {
            $e.addClass('mention-tested');
          }
        });
      });
    }

    function linkSeenMentions($elem, siteSettings) {
      var $mentions = $('span.mention:not(.mention-tested)', $elem);
      if ($mentions.length) {
        var usernames = $mentions.map(function (_, e) {
          return $(e).text().substr(1);
        });
        var unseen = _.uniq(usernames).filter(function (u) {
          return u.length >= siteSettings.min_username_length && checked.indexOf(u) === -1;
        });
        updateFound($mentions, usernames);
        return unseen;
      }

      return [];
    }

    function fetchUnseenMentions($elem, usernames) {
      return Discourse.ajax("/users/is_local_username", { data: { usernames: usernames } }).then(function (r) {
        found.push.apply(found, r.valid);
        foundGroups.push.apply(foundGroups, r.valid_groups);
        mentionableGroups.push.apply(mentionableGroups, r.mentionable_groups);
        checked.push.apply(checked, usernames);
        return r;
      });
    }
  });
define("discourse/components/site-header", 
  ["discourse/components/mount-widget","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    __exports__.headerHeight = headerHeight;

    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var MountWidget = __dependency1__["default"];
    var observes = __dependency2__.observes;

    var _flagProperties = [];
    function addFlagProperty(prop) {
      _flagProperties.pushObject(prop);
    }

    var PANEL_BODY_MARGIN = 30;

    var SiteHeaderComponent = MountWidget.extend(_createDecoratedObject([{
      key: 'widget',
      initializer: function () {
        return 'header';
      }
    }, {
      key: 'docAt',
      initializer: function () {
        return null;
      }
    }, {
      key: 'dockedHeader',
      initializer: function () {
        return null;
      }
    }, {
      key: '_topic',
      initializer: function () {
        return null;
      }
    }, {
      key: '_notificationsChanged',
      decorators: [observes('currentUser.unread_notifications', 'currentUser.unread_private_messages')],
      value: function () {
        this.queueRerender();
      }
    }, {
      key: 'examineDockHeader',
      value: function () {
        var _this = this;

        var $body = $('body');

        // Check the dock after the current run loop. While rendering,
        // it's much slower to calculate `outlet.offset()`
        Ember.run.next(function () {
          if (_this.docAt === null) {
            var outlet = $('#main-outlet');
            if (!(outlet && outlet.length === 1)) return;
            _this.docAt = outlet.offset().top;
          }

          var offset = window.pageYOffset || $('html').scrollTop();
          if (offset >= _this.docAt) {
            if (!_this.dockedHeader) {
              $body.addClass('docked');
              _this.dockedHeader = true;
            }
          } else {
            if (_this.dockedHeader) {
              $body.removeClass('docked');
              _this.dockedHeader = false;
            }
          }
        });
      }
    }, {
      key: 'setTopic',
      value: function (topic) {
        this._topic = topic;
        this.queueRerender();
      }
    }, {
      key: 'didInsertElement',
      value: function () {
        var _this2 = this;

        this._super();
        $(window).bind('scroll.discourse-dock', function () {
          return _this2.examineDockHeader();
        });
        $(document).bind('touchmove.discourse-dock', function () {
          return _this2.examineDockHeader();
        });
        $(window).on('resize.discourse-menu-panel', function () {
          return _this2.afterRender();
        });

        this.appEvents.on('header:show-topic', function (topic) {
          return _this2.setTopic(topic);
        });
        this.appEvents.on('header:hide-topic', function () {
          return _this2.setTopic(null);
        });

        this.dispatch('notifications:changed', 'user-notifications');
        this.dispatch('header:keyboard-trigger', 'header');

        this.appEvents.on('dom:clean', function () {
          // For performance, only trigger a re-render if any menu panels are visible
          if (_this2.$('.menu-panel').length) {
            _this2.eventDispatched('dom:clean', 'header');
          }
        });

        this.examineDockHeader();
      }
    }, {
      key: 'willDestroyElement',
      value: function () {
        this._super();
        $(window).unbind('scroll.discourse-dock');
        $(document).unbind('touchmove.discourse-dock');
        $('body').off('keydown.header');
        this.appEvents.off('notifications:changed');
        $(window).off('resize.discourse-menu-panel');

        this.appEvents.off('header:show-topic');
        this.appEvents.off('header:hide-topic');
        this.appEvents.off('dom:clean');
      }
    }, {
      key: 'buildArgs',
      value: function () {
        var _this3 = this;

        return {
          flagCount: _flagProperties.reduce(function (prev, cur) {
            return prev + (_this3.get(cur) || 0);
          }, 0),
          topic: this._topic,
          canSignUp: this.get('canSignUp')
        };
      }
    }, {
      key: 'afterRender',
      value: function () {
        var $menuPanels = $('.menu-panel');
        if ($menuPanels.length === 0) {
          return;
        }

        var $window = $(window);
        var windowWidth = parseInt($window.width());

        var headerWidth = $('#main-outlet .container').width() || 1100;
        var remaining = parseInt((windowWidth - headerWidth) / 2);
        var viewMode = remaining < 50 ? 'slide-in' : 'drop-down';

        $menuPanels.each(function (idx, panel) {
          var $panel = $(panel);
          var width = parseInt($panel.attr('data-max-width') || 300);
          if (windowWidth - width < 50) {
            width = windowWidth - 50;
          }

          $panel.removeClass('drop-down').removeClass('slide-in').addClass(viewMode);

          var $panelBody = $('.panel-body', $panel);
          var contentHeight = parseInt($('.panel-body-contents', $panel).height());

          // We use a mutationObserver to check for style changes, so it's important
          // we don't set it if it doesn't change. Same goes for the $panelBody!
          var style = $panel.prop('style');

          if (viewMode === 'drop-down') {
            var $buttonPanel = $('header ul.icons');
            if ($buttonPanel.length === 0) {
              return;
            }

            // These values need to be set here, not in the css file - this is to deal with the
            // possibility of the window being resized and the menu changing from .slide-in to .drop-down.
            if (style.top !== '100%' || style.height !== 'auto') {
              $panel.css({ top: '100%', height: 'auto' });
            }

            // adjust panel height
            var fullHeight = parseInt($window.height());
            var offsetTop = $panel.offset().top;
            var scrollTop = $window.scrollTop();

            if (contentHeight + (offsetTop - scrollTop) + PANEL_BODY_MARGIN > fullHeight) {
              contentHeight = fullHeight - (offsetTop - scrollTop) - PANEL_BODY_MARGIN;
            }
            if ($panelBody.height() !== contentHeight) {
              $panelBody.height(contentHeight);
            }
            $('body').addClass('drop-down-visible');
          } else {
            var menuTop = headerHeight();

            var height = undefined;
            var winHeight = $(window).height() - 16;
            if (menuTop + contentHeight < winHeight) {
              height = contentHeight + "px";
            } else {
              height = winHeight - menuTop;
            }

            if ($panelBody.prop('style').height !== '100%') {
              $panelBody.height('100%');
            }
            if (style.top !== menuTop + "px" || style.height !== height) {
              $panel.css({ top: menuTop + "px", height: height });
            }
            $('body').removeClass('drop-down-visible');
          }

          $panel.width(width);
        });
      }
    }]));

    __exports__["default"] = SiteHeaderComponent;

    function applyFlaggedProperties() {
      var args = _flagProperties.slice();
      args.push((function () {
        this.queueRerender();
      }).on('init'));

      SiteHeaderComponent.reopen({ _flagsChanged: Ember.observer.apply(this, args) });
    }

    addFlagProperty('currentUser.site_flagged_posts_count');
    addFlagProperty('currentUser.post_queue_new_count');

    __exports__.addFlagProperty = addFlagProperty;
    __exports__.applyFlaggedProperties = applyFlaggedProperties;

    function headerHeight() {
      var $header = $('header.d-header');
      var headerOffset = $header.offset();
      var headerOffsetTop = headerOffset ? headerOffset.top : 0;
      return parseInt($header.outerHeight() + headerOffsetTop - $(window).scrollTop());
    }

    // profileWidget: true,
    // classNameBindings: ['editingTopic'],
  });
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:


var discourseEscape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  '`': '&#x60;'
};
var discourseBadChars = /[&<>"'`]/g;
var discoursePossible = /[&<>"'`]/;

function discourseEscapeChar(chr) {
  return discourseEscape[chr];
}
Discourse.Utilities = {

  translateSize: function(size) {
    switch (size) {
      case 'tiny': return 20;
      case 'small': return 25;
      case 'medium': return 32;
      case 'large': return 45;
      case 'extra_large': return 60;
      case 'huge': return 120;
    }
    return size;
  },

  // Handlebars no longer allows spaces in its `escapeExpression` code which makes it
  // unsuitable for many of Discourse's uses. Use `Handlebars.Utils.escapeExpression`
  // when escaping an attribute in HTML, otherwise this one will do.
  escapeExpression: function(string) {
    // don't escape SafeStrings, since they're already safe
    if (string instanceof Handlebars.SafeString) {
      return string.toString();
    } else if (string == null) {
      return "";
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = "" + string;

    if(!discoursePossible.test(string)) { return string; }
    return string.replace(discourseBadChars, discourseEscapeChar);
  },

  avatarUrl: function(template, size) {
    if (!template) { return ""; }
    var rawSize = Discourse.Utilities.getRawSize(Discourse.Utilities.translateSize(size));
    return template.replace(/\{size\}/g, rawSize);
  },

  getRawSize: function(size) {
    var pixelRatio = window.devicePixelRatio || 1;
    return size * Math.min(3, Math.max(1, Math.round(pixelRatio)));
  },

  avatarImg: function(options) {
    var size = Discourse.Utilities.translateSize(options.size);
    var url = Discourse.Utilities.avatarUrl(options.avatarTemplate, size);

    // We won't render an invalid url
    if (!url || url.length === 0) { return ""; }

    var classes = "avatar" + (options.extraClasses ? " " + options.extraClasses : "");
    var title = (options.title) ? " title='" + Handlebars.Utils.escapeExpression(options.title || "") + "'" : "";

    return "<img alt='' width='" + size + "' height='" + size + "' src='" + Discourse.getURLWithCDN(url) + "' class='" + classes + "'" + title + ">";
  },

  tinyAvatar: function(avatarTemplate, options) {
    return Discourse.Utilities.avatarImg(_.merge({avatarTemplate: avatarTemplate, size: 'tiny' }, options));
  },

  postUrl: function(slug, topicId, postNumber) {
    var url = Discourse.getURL("/t/");
    if (slug) {
      url += slug + "/";
    } else {
      url += 'topic/';
    }
    url += topicId;
    if (postNumber > 1) {
      url += "/" + postNumber;
    }
    return url;
  },

  userUrl: function(username) {
    return Discourse.getURL("/users/" + username.toLowerCase());
  },

  emailValid: function(email) {
    // see:  http://stackoverflow.com/questions/46155/validate-email-address-in-javascript
    var re = /^[a-zA-Z0-9!#$%&'*+\/=?\^_`{|}~\-]+(?:\.[a-zA-Z0-9!#$%&'\*+\/=?\^_`{|}~\-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;
    return re.test(email);
  },

  selectedText: function() {
    var html = '';

    if (typeof window.getSelection !== "undefined") {
      var sel = window.getSelection();
      if (sel.rangeCount) {
        var container = document.createElement("div");
        for (var i = 0, len = sel.rangeCount; i < len; ++i) {
          container.appendChild(sel.getRangeAt(i).cloneContents());
        }
        html = container.innerHTML;
      }
    } else if (typeof document.selection !== "undefined") {
      if (document.selection.type === "Text") {
        html = document.selection.createRange().htmlText;
      }
    }

    // Strip out any .click elements from the HTML before converting it to text
    var div = document.createElement('div');
    div.innerHTML = html;
    var $div = $(div);
    // Find all emojis and replace with its title attribute.
    $div.find('img.emoji').replaceWith(function() { return this.title; });
    $('.clicks', $div).remove();
    var text = div.textContent || div.innerText || "";

    return String(text).trim();
  },

  // Determine the row and col of the caret in an element
  caretRowCol: function(el) {
    var caretPosition = Discourse.Utilities.caretPosition(el);
    var rows = el.value.slice(0, caretPosition).split("\n");
    var rowNum = rows.length;

    var colNum = caretPosition - rows.splice(0, rowNum - 1).reduce(function(sum, row) {
      return sum + row.length + 1;
    }, 0);

    return { rowNum: rowNum, colNum: colNum};
  },

  // Determine the position of the caret in an element
  caretPosition: function(el) {
    var r, rc, re;
    if (el.selectionStart) {
      return el.selectionStart;
    }
    if (document.selection) {
      el.focus();
      r = document.selection.createRange();
      if (!r) return 0;

      re = el.createTextRange();
      rc = re.duplicate();
      re.moveToBookmark(r.getBookmark());
      rc.setEndPoint('EndToStart', re);
      return rc.text.length;
    }
    return 0;
  },

  // Set the caret's position
  setCaretPosition: function(ctrl, pos) {
    var range;
    if (ctrl.setSelectionRange) {
      ctrl.focus();
      ctrl.setSelectionRange(pos, pos);
      return;
    }
    if (ctrl.createTextRange) {
      range = ctrl.createTextRange();
      range.collapse(true);
      range.moveEnd('character', pos);
      range.moveStart('character', pos);
      return range.select();
    }
  },

  validateUploadedFiles: function(files, bypassNewUserRestriction) {
    if (!files || files.length === 0) { return false; }

    if (files.length > 1) {
      bootbox.alert(I18n.t('post.errors.too_many_uploads'));
      return false;
    }

    var upload = files[0];

    // CHROME ONLY: if the image was pasted, sets its name to a default one
    if (typeof Blob !== "undefined" && typeof File !== "undefined") {
      if (upload instanceof Blob && !(upload instanceof File) && upload.type === "image/png") { upload.name = "blob.png"; }
    }

    var type = Discourse.Utilities.uploadTypeFromFileName(upload.name);

    return Discourse.Utilities.validateUploadedFile(upload, type, bypassNewUserRestriction);
  },

  validateUploadedFile: function(file, type, bypassNewUserRestriction) {
    // check that the uploaded file is authorized
    if (!Discourse.Utilities.authorizesAllExtensions() &&
        !Discourse.Utilities.isAuthorizedUpload(file)) {
      var extensions = Discourse.Utilities.authorizedExtensions();
      bootbox.alert(I18n.t('post.errors.upload_not_authorized', { authorized_extensions: extensions }));
      return false;
    }

    if (!bypassNewUserRestriction) {
      // ensures that new users can upload a file
      if (!Discourse.User.current().isAllowedToUploadAFile(type)) {
        bootbox.alert(I18n.t('post.errors.' + type + '_upload_not_allowed_for_new_user'));
        return false;
      }
    }

    // everything went fine
    return true;
  },

  uploadTypeFromFileName: function(fileName) {
    return Discourse.Utilities.isAnImage(fileName) ? 'image' : 'attachment';
  },

  authorizesAllExtensions: function() {
    return Discourse.SiteSettings.authorized_extensions.indexOf("*") >= 0;
  },

  isAuthorizedUpload: function(file) {
    if (file && file.name) {
      var extensions = _.chain(Discourse.SiteSettings.authorized_extensions.split("|"))
                        .reject(function(extension) { return extension.indexOf("*") >= 0; })
                        .map(function(extension) { return (extension.indexOf(".") === 0 ? extension.substring(1) : extension).replace(".", "\\."); })
                        .value();
      return new RegExp("\\.(" + extensions.join("|") + ")$", "i").test(file.name);
    }
    return false;
  },

  authorizedExtensions: function() {
    return _.chain(Discourse.SiteSettings.authorized_extensions.split("|"))
            .reject(function(extension) { return extension.indexOf("*") >= 0; })
            .map(function(extension) { return extension.toLowerCase(); })
            .value()
            .join(", ");
  },

  getUploadMarkdown: function(upload) {
    if (Discourse.Utilities.isAnImage(upload.original_filename)) {
      return '<img src="' + upload.url + '" width="' + upload.width + '" height="' + upload.height + '">';
    } else if (!Discourse.SiteSettings.prevent_anons_from_downloading_files && (/\.(mov|mp4|webm|ogv|mp3|ogg|wav)$/i).test(upload.original_filename)) {
      // is Audio/Video
      if (Discourse.CDN) {
        return Discourse.CDN.startsWith('//') ? "http:" + Discourse.getURLWithCDN(upload.url) : Discourse.getURLWithCDN(upload.url);
      } else {
        return "http://" + Discourse.BaseUrl + upload.url;
      }
    } else {
      return '<a class="attachment" href="' + upload.url + '">' + upload.original_filename + '</a> (' + I18n.toHumanSize(upload.filesize) + ')';
    }
  },

  isAnImage: function(path) {
    return (/\.(png|jpe?g|gif|bmp|tiff?|svg|webp|ico)$/i).test(path);
  },

  allowsImages: function() {
    return Discourse.Utilities.authorizesAllExtensions() ||
           (/(png|jpe?g|gif|bmp|tiff?|svg|webp|ico)/i).test(Discourse.Utilities.authorizedExtensions());
  },

  allowsAttachments: function() {
    return Discourse.Utilities.authorizesAllExtensions() ||
           !(/((png|jpe?g|gif|bmp|tiff?|svg|web|ico)(,\s)?)+$/i).test(Discourse.Utilities.authorizedExtensions());
  },

  displayErrorForUpload: function(data) {
    // deal with meaningful errors first
    if (data.jqXHR) {
      switch (data.jqXHR.status) {
        // cancelled by the user
        case 0: return;

        // entity too large, usually returned from the web server
        case 413:
          var type = Discourse.Utilities.uploadTypeFromFileName(data.files[0].name);
          var maxSizeKB = Discourse.SiteSettings['max_' + type + '_size_kb'];
          bootbox.alert(I18n.t('post.errors.file_too_large', { max_size_kb: maxSizeKB }));
          return;

        // the error message is provided by the server
        case 422:
          if (data.jqXHR.responseJSON.message) {
            bootbox.alert(data.jqXHR.responseJSON.message);
          } else {
            bootbox.alert(data.jqXHR.responseJSON.join("\n"));
          }
          return;
      }
    } else if (data.errors && data.errors.length > 0) {
      bootbox.alert(data.errors.join("\n"));
      return;
    }
    // otherwise, display a generic error message
    bootbox.alert(I18n.t('post.errors.upload'));
  },

  defaultHomepage: function() {
    // the homepage is the first item of the 'top_menu' site setting
    return Discourse.SiteSettings.top_menu.split("|")[0].split(",")[0];
  }

};


// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/*eslint no-bitwise:0 */

/**

  Discourse uses the Markdown.js as its main parser. `Discourse.Dialect` is the framework
  for extending it with additional formatting.

**/

var parser = window.BetterMarkdown,
    MD = parser.Markdown,
    DialectHelpers = parser.DialectHelpers,
    dialect = MD.dialects.Discourse = DialectHelpers.subclassDialect( MD.dialects.Gruber ),
    initialized = false,
    emitters = [],
    hoisted,
    preProcessors = [],
    escape = Discourse.Utilities.escapeExpression;

/**
  Initialize our dialects for processing.

  @method initializeDialects
**/
function initializeDialects() {
  MD.buildBlockOrder(dialect.block);
  var index = dialect.block.__order__.indexOf("code");
  if (index > -1) {
    dialect.block.__order__.splice(index, 1);
    dialect.block.__order__.unshift("code");
  }
  MD.buildInlinePatterns(dialect.inline);
  initialized = true;
}

/**
  Process the text nodes in the JsonML tree, calling any emitters that have
  been added.

  @method processTextNodes
  @param {Array} node the JsonML tree
  @param {Object} event the parse node event data
  @param {Function} emitter the function to call on the text node
**/
function processTextNodes(node, event, emitter) {
  if (node.length < 2) { return; }

  if (node[0] === '__RAW') {
    var hash = Discourse.Dialect.guid();
    hoisted[hash] = node[1];
    node[1] = hash;
    return;
  }

  for (var j=1; j<node.length; j++) {
    var textContent = node[j];
    if (typeof textContent === "string") {
      var result = emitter(textContent, event);
      if (result) {
        if (result instanceof Array) {
          node.splice.apply(node, [j, 1].concat(result));
        } else {
          node[j] = result;
        }
      } else {
        node[j] = textContent;
      }

    }
  }
}


/**
  Parse a JSON ML tree, using registered handlers to adjust it if necessary.

  @method parseTree
  @param {Array} tree the JsonML tree to parse
  @param {Array} path the path of ancestors to the current node in the tree. Can be used for matching.
  @param {Object} insideCounts counts what tags we're inside
  @returns {Array} the parsed tree
**/
function parseTree(tree, path, insideCounts) {

  if (tree instanceof Array) {
    var event = {node: tree, path: path, dialect: dialect, insideCounts: insideCounts || {}};
    Discourse.Dialect.trigger('parseNode', event);

    for (var j=0; j<emitters.length; j++) {
      processTextNodes(tree, event, emitters[j]);
    }

    path = path || [];
    insideCounts = insideCounts || {};

    path.push(tree);

    for (var i=1; i<tree.length; i++) {
      var n = tree[i],
          tagName = n[0];

      insideCounts[tagName] = (insideCounts[tagName] || 0) + 1;

      if (n && n.length === 2 && n[0] === "p" && /^<!--([\s\S]*)-->$/.exec(n[1])) {
        // Remove paragraphs around comment-only nodes.
        tree[i] = n[1];
      } else {
        parseTree(n, path, insideCounts);
      }

      insideCounts[tagName] = insideCounts[tagName] - 1;
    }

    // If raw nodes are in paragraphs, pull them up
    if (tree.length === 2 && tree[0] === 'p' && tree[1] instanceof Array && tree[1][0] === "__RAW") {
      var text = tree[1][1];
      tree[0] = "__RAW";
      tree[1] = text;
    }

    path.pop();
  }
  return tree;
}

/**
  Returns true if there's an invalid word boundary for a match.

  @method invalidBoundary
  @param {Object} args our arguments, including whether we care about boundaries
  @param {Array} prev the previous content, if exists
  @returns {Boolean} whether there is an invalid word boundary
**/
function invalidBoundary(args, prev) {
  if (!(args.wordBoundary || args.spaceBoundary || args.spaceOrTagBoundary)) { return false; }

  var last = prev[prev.length - 1];
  if (typeof last !== "string") { return false; }

  if (args.wordBoundary && (!last.match(/\W$/))) { return true; }
  if (args.spaceBoundary && (!last.match(/\s$/))) { return true; }
  if (args.spaceOrTagBoundary && (!last.match(/(\s|\>)$/))) { return true; }
}

/**
  Returns the number of (terminated) lines in a string.

  @method countLines
  @param {string} str the string.
  @returns {Integer} number of terminated lines in str
**/
function countLines(str) {
  var index = -1, count = 0;
  while ((index = str.indexOf("\n", index + 1)) !== -1) { count++; }
  return count;
}

function hoister(t, target, replacement) {
  var regexp = new RegExp(target.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), "g");
  if (t.match(regexp)) {
    var hash = Discourse.Dialect.guid();
    t = t.replace(regexp, hash);
    hoisted[hash] = replacement;
  }
  return t;
}

function outdent(t) {
  return t.replace(/^([ ]{4}|\t)/gm, "");
}

function removeEmptyLines(t) {
  return t.replace(/^\n+/, "")
          .replace(/\s+$/, "");
}

function hideBackslashEscapedCharacters(t) {
  return t.replace(/\\\\/g, "\u1E800")
          .replace(/\\`/g, "\u1E8001");
}

function showBackslashEscapedCharacters(t) {
  return t.replace(/\u1E8001/g, "\\`")
          .replace(/\u1E800/g, "\\\\");
}

function hoistCodeBlocksAndSpans(text) {
  // replace all "\`" with a single character
  text = hideBackslashEscapedCharacters(text);

  // /!\ the order is important /!\

  // fenced code blocks (AKA GitHub code blocks)
  text = text.replace(/(^\n*|\n)```([a-z0-9\-]*)\n([\s\S]*?)\n```/g, function(_, before, language, content) {
    var hash = Discourse.Dialect.guid();
    hoisted[hash] = escape(showBackslashEscapedCharacters(removeEmptyLines(content)));
    return before + "```" + language + "\n" + hash + "\n```";
  });

  // markdown code blocks
  text = text.replace(/(^\n*|\n\n)((?:(?:[ ]{4}|\t).*\n*)+)/g, function(match, before, content, index) {
    // make sure we aren't in a list
    var previousLine = text.slice(0, index).trim().match(/.*$/);
    if (previousLine && previousLine[0].length) {
      previousLine = previousLine[0].trim();
      if (/^(?:\*|\+|-|\d+\.)\s+/.test(previousLine)) {
        return match;
      }
    }
    // we can safely hoist the code block
    var hash = Discourse.Dialect.guid();
    hoisted[hash] = escape(outdent(showBackslashEscapedCharacters(removeEmptyLines(content))));
    return before + "    " + hash + "\n";
  });

  // <pre>...</pre> code blocks
  text = text.replace(/(\s|^)<pre>([\s\S]*?)<\/pre>/ig, function(_, before, content) {
    var hash = Discourse.Dialect.guid();
    hoisted[hash] = escape(showBackslashEscapedCharacters(removeEmptyLines(content)));
    return before + "<pre>" + hash + "</pre>";
  });

  // code spans (double & single `)
  ["``", "`"].forEach(function(delimiter) {
    var regexp = new RegExp("(^|[^`])" + delimiter + "([^`\\n]+?)" + delimiter + "([^`]|$)", "g");
    text = text.replace(regexp, function(_, before, content, after) {
      var hash = Discourse.Dialect.guid();
      hoisted[hash] = escape(showBackslashEscapedCharacters(content.trim()));
      return before + delimiter + hash + delimiter + after;
    });
  });

  // replace back all weird character with "\`"
  return showBackslashEscapedCharacters(text);
}

/**
  An object used for rendering our dialects.

  @class Dialect
  @namespace Discourse
  @module Discourse
**/
Discourse.Dialect = {

  // http://stackoverflow.com/a/8809472/17174
  guid: function(){
    var d = new Date().getTime();
    if(window.performance && typeof window.performance.now === "function"){
        d += performance.now(); //use high-precision timer if available
    }
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d/16);
        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
    return uuid;
  },

  /**
    Cook text using the dialects.

    @method cook
    @param {String} text the raw text to cook
    @param {Object} opts hash of options
    @returns {String} the cooked text
  **/
  cook: function(text, opts) {
    if (!initialized) { initializeDialects(); }

    dialect.options = opts;

    // Helps us hoist out HTML
    hoisted = {};

    // pre-hoist all code-blocks/spans
    text = hoistCodeBlocksAndSpans(text);

    // pre-processors
    preProcessors.forEach(function(p) {
      text = p(text, hoister);
    });

    var tree = parser.toHTMLTree(text, 'Discourse'),
        result = parser.renderJsonML(parseTree(tree));

    if (opts.sanitize) {
      result = Discourse.Markdown.sanitize(result);
    } else if (opts.sanitizerFunction) {
      result = opts.sanitizerFunction(result);
    }

    // If we hoisted out anything, put it back
    var keys = Object.keys(hoisted);
    if (keys.length) {
      var found = true;

      var unhoist = function(key) {
        result = result.replace(new RegExp(key, "g"), function() {
          found = true;
          return hoisted[key];
        });
      };

      while(found) {
        found = false;
        keys.forEach(unhoist);
      }
    }

    return result.trim();
  },

  /**
    Adds a text pre-processor. Use only if necessary, as a dialect
    that emits JsonML is much better if possible.
  **/
  addPreProcessor: function(preProc) {
    preProcessors.push(preProc);
  },

  /**
    Registers an inline replacer function

    @method registerInline
    @param {String} start The token the replacement begins with
    @param {Function} fn The replacing function
  **/
  registerInline: function(start, fn) {
    dialect.inline[start] = fn;
  },


  /**
    The simplest kind of replacement possible. Replace a stirng token with JsonML.

    For example to replace all occurrances of :) with a smile image:

    ```javascript
      Discourse.Dialect.inlineReplace(':)', function (text) {
        return ['img', {src: '/images/smile.png'}];
      });

    ```

    @method inlineReplace
    @param {String} token The token we want to replace
    @param {Function} emitter A function that emits the JsonML for the replacement.
  **/
  inlineReplace: function(token, emitter) {
    this.registerInline(token, function(text, match, prev) {
      return [token.length, emitter.call(this, token, match, prev)];
    });
  },

  /**
    Matches inline using a regular expression. The emitter function is passed
    the matches from the regular expression.

    For example, this auto links URLs:

    ```javascript
      Discourse.Dialect.inlineRegexp({
        matcher: /((?:https?:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.])(?:[^\s()<>]+|\([^\s()<>]+\))+(?:\([^\s()<>]+\)|[^`!()\[\]{};:'".,<>?«»“”‘’\s]))/gm,
        spaceBoundary: true,
        start: 'http',

        emitter: function(matches) {
          var url = matches[1];
          return ['a', {href: url}, url];
        }
      });
    ```

    @method inlineRegexp
    @param {Object} args Our replacement options
      @param {Function} [opts.emitter] The function that will be called with the contents and regular expresison match and returns JsonML.
      @param {String} [opts.start] The starting token we want to find
      @param {String} [opts.matcher] The regular expression to match
      @param {Boolean} [opts.wordBoundary] If true, the match must be on a word boundary
      @param {Boolean} [opts.spaceBoundary] If true, the match must be on a space boundary
  **/
  inlineRegexp: function(args) {
    this.registerInline(args.start, function(text, match, prev) {
      if (invalidBoundary(args, prev)) { return; }

      args.matcher.lastIndex = 0;
      var m = args.matcher.exec(text);
      if (m) {
        var result = args.emitter.call(this, m);
        if (result) {
          return [m[0].length, result];
        }
      }
    });
  },

  /**
    Handles inline replacements surrounded by tokens.

    For example, to handle markdown style bold. Note we use `concat` on the array because
    the contents are JsonML too since we didn't pass `rawContents` as true. This supports
    recursive markup.

    ```javascript

      Discourse.Dialect.inlineBetween({
        between: '**',
        wordBoundary: true.
        emitter: function(contents) {
          return ['strong'].concat(contents);
        }
      });
    ```

    @method inlineBetween
    @param {Object} args Our replacement options
      @param {Function} [opts.emitter] The function that will be called with the contents and returns JsonML.
      @param {String} [opts.start] The starting token we want to find
      @param {String} [opts.stop] The ending token we want to find
      @param {String} [opts.between] A shortcut for when the `start` and `stop` are the same.
      @param {Boolean} [opts.rawContents] If true, the contents between the tokens will not be parsed.
      @param {Boolean} [opts.wordBoundary] If true, the match must be on a word boundary
      @param {Boolean} [opts.spaceBoundary] If true, the match must be on a space boundary
  **/
  inlineBetween: function(args) {
    var start = args.start || args.between,
        stop = args.stop || args.between,
        startLength = start.length,
        self = this;

    this.registerInline(start, function(text, match, prev) {
      if (invalidBoundary(args, prev)) { return; }

      var endPos = self.findEndPos(text, start, stop, args, startLength);
      if (endPos === -1) { return; }
      var between = text.slice(startLength, endPos);

      // If rawcontents is set, don't process inline
      if (!args.rawContents) {
        between = this.processInline(between);
      }

      var contents = args.emitter.call(this, between);
      if (contents) {
        return [endPos+stop.length, contents];
      }
    });
  },

  findEndPos: function(text, start, stop, args, offset) {
    var endPos, nextStart;
    do {
      endPos = text.indexOf(stop, offset);
      if (endPos === -1) { return -1; }
      nextStart = text.indexOf(start, offset);
      offset = endPos + stop.length;
    } while (nextStart !== -1 && nextStart < endPos);
    return endPos;
  },

  /**
    Registers a block for processing. This is more complicated than using one of
    the other helpers such as `replaceBlock` so consider using them first!

    @method registerBlock
    @param {String} name the name of the block handler
    @param {Function} handler the handler
  **/
  registerBlock: function(name, handler) {
    dialect.block[name] = handler;
  },

  /**
    Replaces a block of text between a start and stop. As opposed to inline, these
    might span multiple lines.

    Here's an example that takes the content between `[code]` ... `[/code]` and
    puts them inside a `pre` tag:

    ```javascript
      Discourse.Dialect.replaceBlock({
        start: /(\[code\])([\s\S]*)/igm,
        stop: '[/code]',
        rawContents: true,

        emitter: function(blockContents) {
          return ['p', ['pre'].concat(blockContents)];
        }
      });
    ```

    @method replaceBlock
    @param {Object} args Our replacement options
      @param {RegExp} [args.start] The starting regexp we want to find
      @param {String} [args.stop] The ending token we want to find
      @param {Boolean} [args.rawContents] True to skip recursive processing
      @param {Function} [args.emitter] The emitting function to transform the contents of the block into jsonML

  **/
  replaceBlock: function(args) {
    var fn = function(block, next) {

      var linebreaks = dialect.options.traditional_markdown_linebreaks ||
          Discourse.SiteSettings.traditional_markdown_linebreaks;
      if (linebreaks && args.skipIfTradtionalLinebreaks) { return; }

      args.start.lastIndex = 0;
      var result = [], match = (args.start).exec(block);
      if (!match) { return; }

      var lastChance = function() {
        return !next.some(function(blk) { return blk.match(args.stop); });
      };

      // shave off start tag and leading text, if any.
      var pos = args.start.lastIndex - match[0].length,
          leading = block.slice(0, pos),
          trailing = match[2] ? match[2].replace(/^\n*/, "") : "";

      if(args.withoutLeading && args.withoutLeading.test(leading)) {
        //The other leading block should be processed first! eg a code block wrapped around a code block.
        return;
      }

      // just give up if there's no stop tag in this or any next block
      args.stop.lastIndex = block.length - trailing.length;
      if (!args.stop.exec(block) && lastChance()) { return; }
      if (leading.length > 0) {
        var parsedLeading = this.processBlock(MD.mk_block(leading), []);
        if (parsedLeading && parsedLeading[0]) {
          result.push(parsedLeading[0]);
        }
      }
      if (trailing.length > 0) {
        next.unshift(MD.mk_block(trailing, block.trailing,
          block.lineNumber + countLines(leading) + (match[2] ? match[2].length : 0) - trailing.length));
      }

      // go through the available blocks to find the matching stop tag.
      var contentBlocks = [], nesting = 0, actualEndPos = -1, currentBlock;
      blockloop:
      while (currentBlock = next.shift()) {
        // collect all the start and stop tags in the current block
        args.start.lastIndex = 0;
        var startPos = [], m;
        while (m = (args.start).exec(currentBlock)) {
          startPos.push(args.start.lastIndex - m[0].length);
          args.start.lastIndex = args.start.lastIndex - (m[2] ? m[2].length : 0);
        }
        args.stop.lastIndex = 0;
        var endPos = [];
        while (m = (args.stop).exec(currentBlock)) {
          endPos.push(args.stop.lastIndex - m[0].length);
        }

        // go through the available end tags:
        var ep = 0, sp = 0; // array indices
        while (ep < endPos.length) {
          if (sp < startPos.length && startPos[sp] < endPos[ep]) {
            // there's an end tag, but there's also another start tag first. we need to go deeper.
            sp++; nesting++;
          } else if (nesting > 0) {
            // found an end tag, but we must go up a level first.
            ep++; nesting--;
          } else {
            // found an end tag and we're at the top: done! -- or: start tag and end tag are
            // identical, (i.e. startPos[sp] == endPos[ep]), so we don't do nesting at all.
            actualEndPos = endPos[ep];
            break blockloop;
          }
        }

        if (lastChance()) {
          // when lastChance() becomes true the first time, currentBlock contains the last
          // end tag available in the input blocks but it's not on the right nesting level
          // or we would have terminated the loop already. the only thing we can do is to
          // treat the last available end tag as tho it were matched with our start tag
          // and let the emitter figure out how to render the garbage inside.
          actualEndPos = endPos[endPos.length - 1];
          break;
        }

        // any left-over start tags still increase the nesting level
        nesting += startPos.length - sp;
        contentBlocks.push(currentBlock);
      }

      var stopLen = currentBlock.match(args.stop)[0].length,
          before = currentBlock.slice(0, actualEndPos).replace(/\n*$/, ""),
          after = currentBlock.slice(actualEndPos + stopLen).replace(/^\n*/, "");
      if (before.length > 0) contentBlocks.push(MD.mk_block(before, "", currentBlock.lineNumber));
      if (after.length > 0) next.unshift(MD.mk_block(after, currentBlock.trailing, currentBlock.lineNumber + countLines(before)));

      var emitterResult = args.emitter.call(this, contentBlocks, match, dialect.options);
      if (emitterResult) { result.push(emitterResult); }
      return result;
    };

    if (args.priority) {
      fn.priority = args.priority;
    }

    this.registerBlock(args.start.toString(), fn);
  },

  /**
    After the parser has been executed, post process any text nodes in the HTML document.
    This is useful if you want to apply a transformation to the text.

    If you are generating HTML from the text, it is preferable to use the replacer
    functions and do it in the parsing part of the pipeline. This function is best for
    simple transformations or transformations that have to happen after all earlier
    processing is done.

    For example, to convert all text to upper case:

    ```javascript

      Discourse.Dialect.postProcessText(function (text) {
        return text.toUpperCase();
      });

    ```

    @method postProcessText
    @param {Function} emitter The function to call with the text. It returns JsonML to modify the tree.
  **/
  postProcessText: function(emitter) {
    emitters.push(emitter);
  },

  /**
    After the parser has been executed, change the contents of a HTML tag.

    Let's say you want to replace the contents of all code tags to prepend
    "EVIL TROUT HACKED YOUR CODE!":

    ```javascript
      Discourse.Dialect.postProcessTag('code', function (contents) {
        return "EVIL TROUT HACKED YOUR CODE!\n\n" + contents;
      });
    ```

    @method postProcessTag
    @param {String} tag The HTML tag you want to match on
    @param {Function} emitter The function to call with the text. It returns JsonML to modify the tree.
  **/
  postProcessTag: function(tag, emitter) {
    Discourse.Dialect.on('parseNode', function (event) {
      var node = event.node;
      if (node[0] === tag) {
        node[node.length-1] = emitter(node[node.length-1]);
      }
    });
  }

};

RSVP.EventTarget.mixin(Discourse.Dialect);




// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

// TODO @robin to move this whole thing to es6
Discourse.Emoji = {};

// bump up this number to expire all emojis
Discourse.Emoji.ImageVersion = "2"

var emoji = ["100", "1234", "8ball", "a", "ab", "abc", "abcd", "accept", "aerial_tramway", "airplane", "airplane_arriving", "airplane_departure", "airplane_small", "alarm_clock", "alembic", "alien", "ambulance", "amphora", "anchor", "angel", "anger", "anger_right", "angry", "anguished", "ant", "apple", "aquarius", "aries", "arrow_backward", "arrow_double_down", "arrow_double_up", "arrow_down", "arrow_down_small", "arrow_forward", "arrow_heading_down", "arrow_heading_up", "arrow_left", "arrow_lower_left", "arrow_lower_right", "arrow_right", "arrow_right_hook", "arrow_up", "arrow_up_down", "arrow_up_small", "arrow_upper_left", "arrow_upper_right", "arrows_clockwise", "arrows_counterclockwise", "art", "articulated_lorry", "astonished", "athletic_shoe", "atm", "atom", "b", "baby", "baby_bottle", "baby_chick", "baby_symbol", "back", "badminton", "baggage_claim", "balloon", "ballot_box", "ballot_box_with_check", "bamboo", "banana", "bangbang", "bank", "bar_chart", "barber", "baseball", "basketball", "basketball_player", "bath", "bathtub", "battery", "beach", "beach_umbrella", "bear", "bed", "bee", "beer", "beers", "beetle", "beginner", "bell", "bellhop", "bento", "bicyclist", "bike", "bikini", "biohazard", "bird", "birthday", "black_circle", "black_joker", "black_large_square", "black_medium_small_square", "black_medium_square", "black_nib", "black_small_square", "black_square_button", "blossom", "blowfish", "blue_book", "blue_car", "blue_heart", "blush", "boar", "bomb", "book", "bookmark", "bookmark_tabs", "books", "boom", "boot", "bouquet", "bow", "bow_and_arrow", "bowling", "boy", "bread", "bride_with_veil", "bridge_at_night", "briefcase", "broken_heart", "bug", "bulb", "bullettrain_front", "bullettrain_side", "burrito", "bus", "busstop", "bust_in_silhouette", "busts_in_silhouette", "cactus", "cake", "calendar", "calendar_spiral", "calling", "camel", "camera", "camera_with_flash", "camping", "cancer", "candle", "candy", "capital_abcd", "capricorn", "card_box", "card_index", "carousel_horse", "cat", "cat2", "cd", "chains", "champagne", "chart", "chart_with_downwards_trend", "chart_with_upwards_trend", "checkered_flag", "cheese", "cherries", "cherry_blossom", "chestnut", "chicken", "children_crossing", "chipmunk", "chocolate_bar", "christmas_tree", "church", "cinema", "circus_tent", "city_dusk", "city_sunset", "cityscape", "cl", "clap", "clapper", "classical_building", "clipboard", "clock", "clock1", "clock10", "clock1030", "clock11", "clock1130", "clock12", "clock1230", "clock130", "clock2", "clock230", "clock3", "clock330", "clock4", "clock430", "clock5", "clock530", "clock6", "clock630", "clock7", "clock730", "clock8", "clock830", "clock9", "clock930", "closed_book", "closed_lock_with_key", "closed_umbrella", "cloud", "cloud_lightning", "cloud_rain", "cloud_snow", "cloud_tornado", "clubs", "cocktail", "coffee", "coffin", "cold_sweat", "comet", "compression", "computer", "confetti_ball", "confounded", "confused", "congratulations", "construction", "construction_site", "construction_worker", "control_knobs", "convenience_store", "cookie", "cool", "cop", "copyright", "corn", "couch", "couple", "couple_with_heart", "couplekiss", "cow", "cow2", "crab", "crayon", "credit_card", "crescent_moon", "cricket", "crocodile", "cross", "crossed_flags", "crossed_swords", "crown", "cruise_ship", "cry", "crying_cat_face", "crystal_ball", "cupid", "curly_loop", "currency_exchange", "curry", "custard", "customs", "cyclone", "dagger", "dancer", "dancers", "dango", "dark_sunglasses", "dart", "dash", "date", "deciduous_tree", "department_store", "desert", "desktop", "diamond_shape_with_a_dot_inside", "diamonds", "disappointed", "disappointed_relieved", "dividers", "dizzy", "dizzy_face", "do_not_litter", "dog", "dog2", "dollar", "dolls", "dolphin", "door", "doughnut", "dove", "dragon", "dragon_face", "dress", "dromedary_camel", "droplet", "dvd", "e-mail", "ear", "ear_of_rice", "earth_africa", "earth_americas", "earth_asia", "egg", "eggplant", "eight", "eight_pointed_black_star", "eight_spoked_asterisk", "electric_plug", "elephant", "end", "envelope", "envelope_with_arrow", "euro", "european_castle", "european_post_office", "evergreen_tree", "exclamation", "expressionless", "eye", "eyeglasses", "eyes", "factory", "fallen_leaf", "family", "fast_forward", "fax", "fearful", "feet", "ferris_wheel", "ferry", "field_hockey", "file_cabinet", "file_folder", "film_frames", "fire", "fire_engine", "fireworks", "first_quarter_moon", "first_quarter_moon_with_face", "fish", "fish_cake", "fishing_pole_and_fish", "fist", "five", "flag_black", "flag_cn", "flag_de", "flag_es", "flag_fr", "flag_gb", "flag_it", "flag_jp", "flag_kr", "flag_ru", "flag_us", "flag_white", "flags", "flashlight", "fleur-de-lis", "floppy_disk", "flower_playing_cards", "flushed", "fog", "foggy", "football", "footprints", "fork_and_knife", "fork_knife_plate", "fountain", "four", "four_leaf_clover", "frame_photo", "free", "fried_shrimp", "fries", "frog", "frowning", "frowning2", "fuelpump", "full_moon", "full_moon_with_face", "game_die", "gear", "gem", "gemini", "ghost", "gift", "gift_heart", "girl", "globe_with_meridians", "goat", "golf", "golfer", "grapes", "green_apple", "green_book", "green_heart", "grey_exclamation", "grey_question", "grimacing", "grin", "grinning", "guardsman", "guitar", "gun", "haircut", "hamburger", "hammer", "hammer_pick", "hamster", "hand_splayed", "handbag", "hash", "hatched_chick", "hatching_chick", "head_bandage", "headphones", "hear_no_evil", "heart", "heart_decoration", "heart_exclamation", "heart_eyes", "heart_eyes_cat", "heartbeat", "heartpulse", "hearts", "heavy_check_mark", "heavy_division_sign", "heavy_dollar_sign", "heavy_minus_sign", "heavy_multiplication_x", "heavy_plus_sign", "helicopter", "helmet_with_cross", "herb", "hibiscus", "high_brightness", "high_heel", "hockey", "hole", "homes", "honey_pot", "horse", "horse_racing", "hospital", "hot_pepper", "hotdog", "hotel", "hotsprings", "hourglass", "hourglass_flowing_sand", "house", "house_abandoned", "house_with_garden", "hugging", "hushed", "ice_cream", "ice_skate", "icecream", "id", "ideograph_advantage", "imp", "inbox_tray", "incoming_envelope", "information_desk_person", "information_source", "innocent", "interrobang", "iphone", "island", "izakaya_lantern", "jack_o_lantern", "japan", "japanese_castle", "japanese_goblin", "japanese_ogre", "jeans", "joy", "joy_cat", "joystick", "kaaba", "key", "key2", "keyboard", "kimono", "kiss", "kissing", "kissing_cat", "kissing_closed_eyes", "kissing_heart", "kissing_smiling_eyes", "knife", "koala", "koko", "label", "large_blue_circle", "large_blue_diamond", "large_orange_diamond", "last_quarter_moon", "last_quarter_moon_with_face", "laughing", "leaves", "ledger", "left_luggage", "left_right_arrow", "leftwards_arrow_with_hook", "lemon", "leo", "leopard", "level_slider", "levitate", "libra", "lifter", "light_rail", "link", "lion_face", "lips", "lipstick", "lock", "lock_with_ink_pen", "lollipop", "loop", "loud_sound", "loudspeaker", "love_hotel", "love_letter", "low_brightness", "m", "mag", "mag_right", "mahjong", "mailbox", "mailbox_closed", "mailbox_with_mail", "mailbox_with_no_mail", "man", "man_with_gua_pi_mao", "man_with_turban", "mans_shoe", "map", "maple_leaf", "mask", "massage", "meat_on_bone", "medal", "mega", "melon", "menorah", "mens", "metal", "metro", "microphone", "microphone2", "microscope", "middle_finger", "military_medal", "milky_way", "minibus", "minidisc", "mobile_phone_off", "money_mouth", "money_with_wings", "moneybag", "monkey", "monkey_face", "monorail", "mortar_board", "mosque", "motorboat", "motorcycle", "motorway", "mount_fuji", "mountain", "mountain_bicyclist", "mountain_cableway", "mountain_railway", "mountain_snow", "mouse", "mouse2", "mouse_three_button", "movie_camera", "moyai", "muscle", "mushroom", "musical_keyboard", "musical_note", "musical_score", "mute", "nail_care", "name_badge", "necktie", "negative_squared_cross_mark", "nerd", "neutral_face", "new", "new_moon", "new_moon_with_face", "newspaper", "newspaper2", "ng", "night_with_stars", "nine", "no_bell", "no_bicycles", "no_entry", "no_entry_sign", "no_good", "no_mobile_phones", "no_mouth", "no_pedestrians", "no_smoking", "non-potable_water", "nose", "notebook", "notebook_with_decorative_cover", "notepad_spiral", "notes", "nut_and_bolt", "o", "o2", "ocean", "octopus", "oden", "office", "oil", "ok", "ok_hand", "ok_woman", "older_man", "older_woman", "om_symbol", "on", "oncoming_automobile", "oncoming_bus", "oncoming_police_car", "oncoming_taxi", "one", "open_file_folder", "open_hands", "open_mouth", "ophiuchus", "orange_book", "orthodox_cross", "outbox_tray", "ox", "package", "page_facing_up", "page_with_curl", "pager", "paintbrush", "palm_tree", "panda_face", "paperclip", "paperclips", "park", "parking", "part_alternation_mark", "partly_sunny", "passport_control", "pause_button", "peace", "peach", "pear", "pen_ballpoint", "pen_fountain", "pencil", "pencil2", "penguin", "pensive", "performing_arts", "persevere", "person_frowning", "person_with_blond_hair", "person_with_pouting_face", "pick", "pig", "pig2", "pig_nose", "pill", "pineapple", "ping_pong", "pisces", "pizza", "place_of_worship", "play_pause", "point_down", "point_left", "point_right", "point_up", "point_up_2", "police_car", "poodle", "poop", "popcorn", "post_office", "postal_horn", "postbox", "potable_water", "pouch", "poultry_leg", "pound", "pouting_cat", "pray", "prayer_beads", "princess", "printer", "projector", "punch", "purple_heart", "purse", "pushpin", "put_litter_in_its_place", "question", "rabbit", "rabbit2", "race_car", "racehorse", "radio", "radio_button", "radioactive", "rage", "railway_car", "railway_track", "rainbow", "raised_hand", "raised_hands", "raising_hand", "ram", "ramen", "rat", "record_button", "recycle", "red_car", "red_circle", "registered", "relaxed", "relieved", "reminder_ribbon", "repeat", "repeat_one", "restroom", "revolving_hearts", "rewind", "ribbon", "rice", "rice_ball", "rice_cracker", "rice_scene", "ring", "robot", "rocket", "roller_coaster", "rolling_eyes", "rooster", "rose", "rosette", "rotating_light", "round_pushpin", "rowboat", "rugby_football", "runner", "running_shirt_with_sash", "sa", "sagittarius", "sailboat", "sake", "sandal", "santa", "satellite", "satellite_orbital", "saxophone", "scales", "school", "school_satchel", "scissors", "scorpion", "scorpius", "scream", "scream_cat", "scroll", "seat", "secret", "see_no_evil", "seedling", "seven", "shamrock", "shaved_ice", "sheep", "shell", "shield", "shinto_shrine", "ship", "shirt", "shopping_bags", "shower", "signal_strength", "six", "six_pointed_star", "ski", "skier", "skull", "skull_crossbones", "sleeping", "sleeping_accommodation", "sleepy", "slight_frown", "slight_smile", "slot_machine", "small_blue_diamond", "small_orange_diamond", "small_red_triangle", "small_red_triangle_down", "smile", "smile_cat", "smiley", "smiley_cat", "smiling_imp", "smirk", "smirk_cat", "smoking", "snail", "snake", "snowboarder", "snowflake", "snowman", "snowman2", "sob", "soccer", "soon", "sos", "sound", "space_invader", "spades", "spaghetti", "sparkle", "sparkler", "sparkles", "sparkling_heart", "speak_no_evil", "speaker", "speaking_head", "speech_balloon", "speedboat", "spider", "spider_web", "spy", "stadium", "star", "star2", "star_and_crescent", "star_of_david", "stars", "station", "statue_of_liberty", "steam_locomotive", "stew", "stop_button", "stopwatch", "straight_ruler", "strawberry", "stuck_out_tongue", "stuck_out_tongue_closed_eyes", "stuck_out_tongue_winking_eye", "sun_with_face", "sunflower", "sunglasses", "sunny", "sunrise", "sunrise_over_mountains", "surfer", "sushi", "suspension_railway", "sweat", "sweat_drops", "sweat_smile", "sweet_potato", "swimmer", "symbols", "synagogue", "syringe", "taco", "tada", "tanabata_tree", "tangerine", "taurus", "taxi", "tea", "telephone", "telephone_receiver", "telescope", "ten", "tennis", "tent", "thermometer", "thermometer_face", "thinking", "thought_balloon", "three", "thumbsdown", "thumbsup", "thunder_cloud_rain", "ticket", "tickets", "tiger", "tiger2", "timer", "tired_face", "tm", "toilet", "tokyo_tower", "tomato", "tongue", "tools", "top", "tophat", "track_next", "track_previous", "trackball", "tractor", "traffic_light", "train", "train2", "tram", "triangular_flag_on_post", "triangular_ruler", "trident", "triumph", "trolleybus", "trophy", "tropical_drink", "tropical_fish", "truck", "trumpet", "tulip", "turkey", "turtle", "tv", "twisted_rightwards_arrows", "two", "two_hearts", "two_men_holding_hands", "two_women_holding_hands", "u5272", "u5408", "u55b6", "u6307", "u6708", "u6709", "u6e80", "u7121", "u7533", "u7981", "u7a7a", "umbrella", "umbrella2", "unamused", "underage", "unicorn", "unlock", "up", "upside_down", "urn", "v", "vertical_traffic_light", "vhs", "vibration_mode", "video_camera", "video_game", "violin", "virgo", "volcano", "volleyball", "vs", "vulcan", "walking", "waning_crescent_moon", "waning_gibbous_moon", "warning", "wastebasket", "watch", "water_buffalo", "watermelon", "wave", "wavy_dash", "waxing_crescent_moon", "waxing_gibbous_moon", "wc", "weary", "wedding", "whale", "whale2", "wheel_of_dharma", "wheelchair", "white_check_mark", "white_circle", "white_flower", "white_large_square", "white_medium_small_square", "white_medium_square", "white_small_square", "white_square_button", "white_sun_cloud", "white_sun_rain_cloud", "white_sun_small_cloud", "wind_blowing_face", "wind_chime", "wine_glass", "wink", "wolf", "woman", "womans_clothes", "womans_hat", "womens", "worried", "wrench", "writing_hand", "x", "yellow_heart", "yen", "yin_yang", "yum", "zap", "zero", "zipper_mouth", "zzz", "+1", "-1"];
var aliases = {"airplane_small":["small_airplane"], "anger_right":["right_anger_bubble"], "atom":["atom_symbol"], "ballot_box":["ballot_box_with_ballot"], "basketball_player":["person_with_ball"], "beach":["beach_with_umbrella"], "beach_umbrella":["umbrella_on_ground"], "bellhop":["bellhop_bell"], "biohazard":["biohazard_sign"], "bow_and_arrow":["archery"], "calendar_spiral":["spiral_calendar_pad"], "card_box":["card_file_box"], "champagne":["bottle_with_popping_cork"], "cheese":["cheese_wedge"], "city_sunset":["city_sunrise"], "clock":["mantlepiece_clock"], "cloud_lightning":["cloud_with_lightning"], "cloud_rain":["cloud_with_rain"], "cloud_snow":["cloud_with_snow"], "cloud_tornado":["cloud_with_tornado"], "construction_site":["building_construction"], "couch":["couch_and_lamp"], "crayon":["lower_left_crayon"], "cricket":["cricket_bat_ball"], "cross":["latin_cross"], "cruise_ship":["passenger_ship"], "dagger":["dagger_knife"], "desktop":["desktop_computer"], "dividers":["card_index_dividers"], "dove":["dove_of_peace"], "e-mail":["email"], "feet":["paw_prints"], "fire":["flame"], "flag_black":["waving_black_flag"], "flag_cn":["cn"], "flag_de":["de"], "flag_es":["es"], "flag_fr":["fr"], "flag_gb":["gb"], "flag_it":["it"], "flag_jp":["jp"], "flag_kr":["kr"], "flag_ru":["ru"], "flag_us":["us"], "flag_white":["waving_white_flag"], "fork_knife_plate":["fork_and_knife_with_plate"], "frame_photo":["frame_with_picture"], "frowning2":["white_frowning_face"], "hammer_pick":["hammer_and_pick"], "hand_splayed":["raised_hand_with_fingers_splayed"], "head_bandage":["face_with_head_bandage"], "heart_exclamation":["heavy_heart_exclamation_mark_ornament"], "helmet_with_cross":["helmet_with_white_cross"], "homes":["house_buildings"], "hotdog":["hot_dog"], "house_abandoned":["derelict_house_building"], "hugging":["hugging_face"], "island":["desert_island"], "key2":["old_key"], "laughing":["satisfied"], "levitate":["man_in_business_suit_levitating"], "lifter":["weight_lifter"], "lion_face":["lion"], "map":["world_map"], "medal":["sports_medal"], "metal":["sign_of_the_horns"], "microphone2":["studio_microphone"], "middle_finger":["reversed_hand_with_middle_finger_extended"], "money_mouth":["money_mouth_face"], "motorcycle":["racing_motorcycle"], "mountain_snow":["snow_capped_mountain"], "mouse_three_button":["three_button_mouse"], "nerd":["nerd_face"], "newspaper2":["rolled_up_newspaper"], "notepad_spiral":["spiral_note_pad"], "oil":["oil_drum"], "older_woman":["grandma"], "paintbrush":["lower_left_paintbrush"], "paperclips":["linked_paperclips"], "park":["national_park"], "pause_button":["double_vertical_bar"], "peace":["peace_symbol"], "pen_ballpoint":["lower_left_ballpoint_pen"], "pen_fountain":["lower_left_fountain_pen"], "ping_pong":["table_tennis"], "place_of_worship":["worship_symbol"], "poop":["shit", "hankey", "poo"], "projector":["film_projector"], "race_car":["racing_car"], "radioactive":["radioactive_sign"], "railway_track":["railroad_track"], "robot":["robot_face"], "rolling_eyes":["face_with_rolling_eyes"], "skull":["skeleton"], "skull_crossbones":["skull_and_crossbones"], "slight_frown":["slightly_frowning_face"], "slight_smile":["slightly_smiling_face", "slightly_smiling"], "speaking_head":["speaking_head_in_silhouette"], "spy":["sleuth_or_spy"], "thermometer_face":["face_with_thermometer"], "thinking":["thinking_face"], "thumbsdown":["-1"], "thumbsup":["+1"], "thunder_cloud_rain":["thunder_cloud_and_rain"], "tickets":["admission_tickets"], "timer":["timer_clock"], "tools":["hammer_and_wrench"], "track_next":["next_track"], "track_previous":["previous_track"], "unicorn":["unicorn_face"], "upside_down":["upside_down_face"], "urn":["funeral_urn"], "vulcan":["raised_hand_with_part_between_middle_and_ring_fingers"], "white_sun_cloud":["white_sun_behind_cloud"], "white_sun_rain_cloud":["white_sun_behind_cloud_with_rain"], "white_sun_small_cloud":["white_sun_with_small_cloud"], "zipper_mouth":["zipper_mouth_face"]};

var extendedEmoji = {};
if (Discourse.Dialect) {
  Discourse.Dialect.registerEmoji = function(code, url) {
    code = code.toLowerCase();
    extendedEmoji[code] = url;
  };
}

var _unicodeReplacements;
var _unicodeRegexp;
Discourse.Dialect.setUnicodeReplacements = function(replacements) {
  _unicodeReplacements = replacements;
  if (replacements) {
    _unicodeRegexp = new RegExp(Object.keys(replacements).join("|"), "g");
  }
}

// This method is used by PrettyText to reset custom emojis in multisites
Discourse.Dialect.resetEmojis = function() {
  extendedEmoji = {};
};

var customEmojiCallbacks = [];
Discourse.Emoji.addCustomEmojis = function(cb) {
  customEmojiCallbacks.push(cb);
};

Discourse.Emoji.applyCustomEmojis = function() {
  var self = this;
  _.each(customEmojiCallbacks, function(cb) { cb.apply(self); });
};

Discourse.Emoji.list = function(){
  var list = emoji.slice(0);
  _.each(extendedEmoji, function(v,k){ list.push(k); });
  return list;
};


var emojiHash = {};
// add all default emojis
emoji.forEach(function(code){ emojiHash[code] = true; });
// and their aliases

var aliasHash = {};
for (var name in aliases) {
  aliases[name].forEach(function(alias) {
    aliasHash[alias] = name;
  });
}

Discourse.Emoji.unescape = function(string) {
  //this can be further improved by supporting matches of emoticons that don't begin with a colon
  if (Discourse.SiteSettings.enable_emoji && string.indexOf(":") >= 0) {
    string = string.replace(/\B:[^\s:]+:?\B/g, function(m) {
      var isEmoticon = !!Discourse.Emoji.translations[m],
            emoji = isEmoticon ? Discourse.Emoji.translations[m] : m.slice(1, m.length - 1),
            hasEndingColon = m.lastIndexOf(":") === m.length - 1,
            url = Discourse.Emoji.urlFor(emoji);
      return url && (isEmoticon || hasEndingColon) ? "<img src='" + url + "' title='" + emoji + "' alt='" + emoji + "' class='emoji'>" : m;
    });
  }

  return string;
};

Discourse.Emoji.urlFor = urlFor = function(code) {
  var url, set = Discourse.SiteSettings.emoji_set;

  code = code.toLowerCase();

  if(extendedEmoji.hasOwnProperty(code)) {
    url = extendedEmoji[code];
  }

  if(!url && emojiHash.hasOwnProperty(code)) {
    url = Discourse.getURL('/images/emoji/' + set + '/' + code + '.png');
  }

  if(url && url[0] !== 'h' && Discourse.CDN) {
    url = Discourse.CDN + url;
  }

  if(url){
    url = url + "?v=" + Discourse.Emoji.ImageVersion;
  }

  return url;
};

Discourse.Emoji.exists = function(code){
  code = code.toLowerCase();
  return !!(extendedEmoji.hasOwnProperty(code) || emojiHash.hasOwnProperty(code));
};

function imageFor(code) {
  code = code.toLowerCase();
  var url = urlFor(code);
  if (url) {
    var code = ':' + code + ':';
    return ['img', { href: url, title: code, 'class': 'emoji', alt: code }];
  }
}

// Also support default emotions
var translations = {
  ':)'   : 'slight_smile',
  ':-)'  : 'slight_smile',
  ':('   : 'frowning',
  ':-('  : 'frowning',
  ';)'   : 'wink',
  ';-)'  : 'wink',
  ':\'(' : 'cry',
  ':\'-(': 'cry',
  ':-\'(': 'cry',
  ':p'   : 'stuck_out_tongue',
  ':P'   : 'stuck_out_tongue',
  ':-P'  : 'stuck_out_tongue',
  ':O'   : 'open_mouth',
  ':-O'  : 'open_mouth',
  ':D'   : 'smiley',
  ':-D'  : 'smiley',
  ':|'   : 'expressionless',
  ':-|'  : 'expressionless',
  ':/'   : 'confused',
  '8-)'  : 'sunglasses',
  ";P"   : 'stuck_out_tongue_winking_eye',
  ";-P"  : 'stuck_out_tongue_winking_eye',
  ":$"   : 'blush',
  ":-$"  : 'blush'
};

Discourse.Emoji.translations = translations;

function checkPrev(prev) {
  if (prev && prev.length) {
    var lastToken = prev[prev.length-1];
    if (lastToken && lastToken.charAt) {
      var lastChar = lastToken.charAt(lastToken.length-1);
      if (!/\W/.test(lastChar)) return false;
    }
  }
  return true;
}

var translationsWithColon = {};
Object.keys(translations).forEach(function (t) {
  if (t[0] === ':') {
    translationsWithColon[t] = translations[t];
  } else {
    var replacement = translations[t];
    Discourse.Dialect.inlineReplace(t, function (token, match, prev) {
      if (!Discourse.SiteSettings.enable_emoji) { return token; }
      return checkPrev(prev) ? imageFor(replacement) : token;
    });
  }
});

Discourse.Dialect.addPreProcessor(function(text) {
  if (_unicodeReplacements) {
    _unicodeRegexp.lastIndex = 0;

    var m;
    while ((m = _unicodeRegexp.exec(text)) !== null) {

      var replacement = ":" + _unicodeReplacements[m[0]] + ":";

      var before = text.charAt(m.index-1);
      if (!/\B/.test(before)) {
        replacement = "\u200b" + replacement;
      }

      text = text.replace(m[0], replacement);
    }
  }

  return text;
});

function escapeRegExp(s) {
  return s.replace(/[-/\\^$*+?.()|[\]{}]/gi, '\\$&');
}

var translationColonRegexp = new RegExp(Object.keys(translationsWithColon).map(function (t) {
                                           return "(" + escapeRegExp(t) + ")";
                                         }).join("|"));

Discourse.Dialect.registerInline(':', function(text, match, prev) {
  if (!Discourse.SiteSettings.enable_emoji) { return; }

  var endPos = text.indexOf(':', 1),
      firstSpace = text.search(/\s/),
      contents;

  if (!checkPrev(prev)) { return; }

  // If there is no trailing colon, check our translations that begin with colons
  if (endPos === -1 || (firstSpace !== -1 && endPos > firstSpace)) {
    translationColonRegexp.lastIndex = 0;
    var m = translationColonRegexp.exec(text);
    if (m && m[0] && text.indexOf(m[0]) === 0) {
      // Check outer edge
      var lastChar = text.charAt(m[0].length);
      if (lastChar && !/\s/.test(lastChar)) return;
      contents = imageFor(translationsWithColon[m[0]]);
      if (contents) {
        return [m[0].length, contents];
      }
    }
    return;
  }

  // Simple find and replace from our array
  var between = text.slice(1, endPos);
  contents = imageFor(between);
  if (contents) {
    return [endPos+1, contents];
  }
});


var toSearch;
Discourse.Emoji.search = function(term, options) {
  var maxResults = (options && options["maxResults"]) || -1;
  if (maxResults === 0) { return []; }

  toSearch = toSearch || _.union(_.keys(emojiHash), _.keys(extendedEmoji), _.keys(aliasHash)).sort();

  var i, results = [];
  function addResult(term) {
    var val = aliasHash[term] || term;
    if (results.indexOf(val) === -1) {
      results.push(val);
    }
    return maxResults > 0 && results.length >= maxResults;
  }

  var item;
  for (i=0; i<toSearch.length; i++) {
    item = toSearch[i];
    if (item.indexOf(term) === 0 && addResult(item)) {
      return results;
    }
  }

  for (i=0; i<toSearch.length; i++) {
    item = toSearch[i];
    if (item.indexOf(term) === 0 && addResult(item)) {
      return results;
    }
  }

  return results;
};

Discourse.Markdown.whiteListTag('img', 'class', 'emoji');


// IIFE Wrapped Content Ends

 })(this);
define("discourse/lib/emoji/emoji-groups", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // note that these categories are copied from Slack
    // be careful, there are ~20 differences in synonyms, e.g. :boom: vs. :collision:
    // a few Emoji are actually missing from the Slack categories as well (?), and were added
    var groups = [{
      name: "people",
      fullname: "People",
      tabicon: "grinning",
      icons: ["slight_smile", "grinning", "grin", "joy", "smiley", "smile", "sweat_smile", "laughing", "innocent", "smiling_imp", "imp", "wink", "blush", "relaxed", "yum", "relieved", "heart_eyes", "sunglasses", "smirk", "neutral_face", "expressionless", "unamused", "sweat", "pensive", "confused", "confounded", "kissing", "kissing_heart", "kissing_smiling_eyes", "kissing_closed_eyes", "stuck_out_tongue", "stuck_out_tongue_winking_eye", "stuck_out_tongue_closed_eyes", "disappointed", "worried", "angry", "rage", "cry", "persevere", "triumph", "disappointed_relieved", "frowning", "anguished", "fearful", "weary", "sleepy", "tired_face", "grimacing", "sob", "open_mouth", "hushed", "cold_sweat", "scream", "astonished", "flushed", "sleeping", "dizzy_face", "no_mouth", "mask", "smile_cat", "joy_cat", "smiley_cat", "heart_eyes_cat", "smirk_cat", "kissing_cat", "pouting_cat", "crying_cat_face", "scream_cat", "footprints", "bust_in_silhouette", "busts_in_silhouette", "baby", "boy", "girl", "man", "woman", "family", "couple", "two_men_holding_hands", "two_women_holding_hands", "dancers", "bride_with_veil", "person_with_blond_hair", "man_with_gua_pi_mao", "man_with_turban", "older_man", "older_woman", "cop", "construction_worker", "princess", "guardsman", "angel", "santa", "ghost", "japanese_ogre", "japanese_goblin", "hankey", "skull", "alien", "space_invader", "bow", "information_desk_person", "no_good", "ok_woman", "raising_hand", "person_with_pouting_face", "person_frowning", "massage", "haircut", "couple_with_heart", "couplekiss", "raised_hands", "clap", "hand", "ear", "eyes", "nose", "lips", "kiss", "tongue", "nail_care", "wave", "+1", "-1", "point_up", "point_up_2", "point_down", "point_left", "point_right", "ok_hand", "v", "facepunch", "fist", "raised_hand", "muscle", "open_hands", "pray", "anger_right", "eye", "frowning2", "hand_splayed", "head_bandage", "hugging", "middle_finger", "money_mouth", "nerd", "poop", "punch", "robot", "rolling_eyes", "skull_crossbones", "slight_frown", "speaking_head", "spy", "thinking", "thumbsdown", "thumbsup", "upside_down", "urn", "vulcan", "wind_blowing_face", "writing_hand", "zipper_mouth"]
    }, {
      name: "nature",
      fullname: "Nature",
      tabicon: "evergreen_tree",
      icons: ["seedling", "evergreen_tree", "deciduous_tree", "palm_tree", "cactus", "tulip", "cherry_blossom", "rose", "hibiscus", "sunflower", "blossom", "bouquet", "ear_of_rice", "herb", "four_leaf_clover", "maple_leaf", "fallen_leaf", "leaves", "mushroom", "chestnut", "rat", "mouse2", "mouse", "hamster", "ox", "water_buffalo", "cow2", "cow", "tiger2", "leopard", "tiger", "rabbit2", "rabbit", "cat2", "cat", "racehorse", "horse", "ram", "sheep", "goat", "rooster", "chicken", "baby_chick", "hatching_chick", "hatched_chick", "bird", "penguin", "elephant", "dromedary_camel", "camel", "boar", "pig2", "pig", "pig_nose", "dog2", "poodle", "dog", "wolf", "bear", "koala", "panda_face", "monkey_face", "see_no_evil", "hear_no_evil", "speak_no_evil", "monkey", "dragon", "dragon_face", "crocodile", "snake", "turtle", "frog", "whale2", "whale", "dolphin", "octopus", "fish", "tropical_fish", "blowfish", "shell", "snail", "bug", "ant", "bee", "beetle", "feet", "zap", "fire", "crescent_moon", "sunny", "partly_sunny", "cloud", "droplet", "sweat_drops", "umbrella", "dash", "snowflake", "star2", "star", "stars", "sunrise_over_mountains", "sunrise", "rainbow", "ocean", "volcano", "milky_way", "mount_fuji", "japan", "globe_with_meridians", "earth_africa", "earth_americas", "earth_asia", "new_moon", "waxing_crescent_moon", "first_quarter_moon", "moon", "full_moon", "waning_gibbous_moon", "last_quarter_moon", "waning_crescent_moon", "new_moon_with_face", "full_moon_with_face", "first_quarter_moon_with_face", "last_quarter_moon_with_face", "sun_with_face", "chipmunk", "cloud_lightning", "cloud_rain", "cloud_snow", "cloud_tornado", "comet", "crab", "dove", "fog", "lion_face", "scorpion", "spider", "spider_web", "thunder_cloud_rain", "turkey", "unicorn", "waxing_gibbous_moon", "white_sun_cloud", "white_sun_rain_cloud", "white_sun_small_cloud"]
    }, {
      name: "food",
      fullname: "Food & Drink",
      tabicon: "hamburger",
      icons: ["tomato", "eggplant", "corn", "sweet_potato", "grapes", "melon", "watermelon", "tangerine", "lemon", "banana", "pineapple", "apple", "green_apple", "pear", "peach", "cherries", "strawberry", "hamburger", "pizza", "meat_on_bone", "poultry_leg", "rice_cracker", "rice_ball", "rice", "curry", "ramen", "spaghetti", "bread", "fries", "dango", "oden", "sushi", "fried_shrimp", "fish_cake", "icecream", "shaved_ice", "ice_cream", "doughnut", "cookie", "chocolate_bar", "candy", "lollipop", "custard", "honey_pot", "cake", "bento", "stew", "egg", "fork_and_knife", "tea", "coffee", "sake", "wine_glass", "cocktail", "tropical_drink", "beer", "beers", "baby_bottle", "burrito", "champagne", "cheese", "hot_pepper", "hotdog", "taco"]
    }, {
      name: "celebration",
      fullname: "Celebration",
      tabicon: "gift",
      icons: ["ribbon", "gift", "birthday", "jack_o_lantern", "christmas_tree", "tanabata_tree", "bamboo", "rice_scene", "fireworks", "sparkler", "tada", "confetti_ball", "balloon", "dizzy", "sparkles", "boom", "mortar_board", "crown", "dolls", "flags", "wind_chime", "crossed_flags", "izakaya_lantern", "ring", "heart", "broken_heart", "love_letter", "two_hearts", "revolving_hearts", "heartbeat", "heartpulse", "sparkling_heart", "cupid", "gift_heart", "heart_decoration", "purple_heart", "yellow_heart", "green_heart", "blue_heart", "heart_exclamation"]
    }, {
      name: "activity",
      fullname: "Activities",
      tabicon: "soccer",
      icons: ["runner", "walking", "dancer", "rowboat", "swimmer", "surfer", "bath", "snowboarder", "ski", "snowman", "bicyclist", "mountain_bicyclist", "horse_racing", "tent", "fishing_pole_and_fish", "soccer", "basketball", "football", "baseball", "tennis", "rugby_football", "golf", "trophy", "running_shirt_with_sash", "checkered_flag", "musical_keyboard", "guitar", "violin", "saxophone", "trumpet", "musical_note", "notes", "musical_score", "headphones", "microphone", "performing_arts", "ticket", "tophat", "circus_tent", "clapper", "art", "dart", "8ball", "bowling", "slot_machine", "game_die", "video_game", "flower_playing_cards", "black_joker", "mahjong", "carousel_horse", "ferris_wheel", "roller_coaster", "badminton", "ballot_box", "basketball_player", "bow_and_arrow", "cricket", "crossed_swords", "field_hockey", "golfer", "hockey", "ice_skate", "paintbrush", "skier", "snowman2", "stadium", "volleyball"]
    }, {
      name: "travel",
      fullname: "Travel & Places",
      tabicon: "airplane",
      icons: ["train", "mountain_railway", "railway_car", "steam_locomotive", "monorail", "bullettrain_side", "bullettrain_front", "train2", "metro", "light_rail", "station", "tram", "bus", "oncoming_bus", "trolleybus", "minibus", "ambulance", "fire_engine", "police_car", "oncoming_police_car", "rotating_light", "taxi", "oncoming_taxi", "car", "oncoming_automobile", "blue_car", "truck", "articulated_lorry", "tractor", "bike", "busstop", "fuelpump", "construction", "vertical_traffic_light", "traffic_light", "rocket", "helicopter", "airplane", "seat", "anchor", "ship", "speedboat", "boat", "aerial_tramway", "mountain_cableway", "suspension_railway", "passport_control", "customs", "baggage_claim", "left_luggage", "yen", "euro", "pound", "dollar", "statue_of_liberty", "moyai", "foggy", "tokyo_tower", "fountain", "european_castle", "japanese_castle", "city_sunrise", "city_sunset", "night_with_stars", "bridge_at_night", "house", "house_with_garden", "office", "department_store", "factory", "post_office", "european_post_office", "hospital", "bank", "hotel", "love_hotel", "wedding", "church", "convenience_store", "school", "cn", "de", "es", "fr", "gb", "it", "jp", "kr", "ru", "us", "airplane_arriving", "airplane_departure", "airplane_small", "beach", "beach_umbrella", "camping", "city_dusk", "cityscape", "classical_building", "construction_site", "cruise_ship", "desert", "ferry", "flag_black", "flag_cn", "flag_de", "flag_es", "flag_fr", "flag_gb", "flag_it", "flag_jp", "flag_kr", "flag_ru", "flag_us", "flag_white", "hole", "homes", "house_abandoned", "island", "kaaba", "map", "mosque", "motorboat", "motorcycle", "motorway", "mountain", "mountain_snow", "park", "place_of_worship", "race_car", "railway_track", "red_car", "sailboat", "shinto_shrine", "sleeping_accommodation", "synagogue"]
    }, {
      name: "objects",
      fullname: "Objects & Symbols",
      tabicon: "eyeglasses",
      icons: ["watch", "iphone", "calling", "computer", "alarm_clock", "hourglass_flowing_sand", "hourglass", "camera", "video_camera", "movie_camera", "tv", "radio", "pager", "telephone_receiver", "phone", "fax", "minidisc", "floppy_disk", "cd", "dvd", "vhs", "battery", "electric_plug", "bulb", "flashlight", "satellite", "credit_card", "money_with_wings", "moneybag", "gem", "closed_umbrella", "pouch", "purse", "handbag", "briefcase", "school_satchel", "lipstick", "eyeglasses", "womans_hat", "sandal", "high_heel", "boot", "mans_shoe", "athletic_shoe", "bikini", "dress", "kimono", "womans_clothes", "shirt", "necktie", "jeans", "door", "shower", "bathtub", "toilet", "barber", "syringe", "pill", "microscope", "telescope", "crystal_ball", "wrench", "hocho", "nut_and_bolt", "hammer", "bomb", "smoking", "gun", "bookmark", "newspaper", "key", "email", "envelope_with_arrow", "incoming_envelope", "e-mail", "inbox_tray", "outbox_tray", "package", "postal_horn", "postbox", "mailbox_closed", "mailbox", "mailbox_with_mail", "mailbox_with_no_mail", "page_facing_up", "page_with_curl", "bookmark_tabs", "chart_with_upwards_trend", "chart_with_downwards_trend", "bar_chart", "date", "calendar", "low_brightness", "high_brightness", "scroll", "clipboard", "book", "notebook", "notebook_with_decorative_cover", "ledger", "closed_book", "green_book", "blue_book", "orange_book", "books", "card_index", "link", "paperclip", "pushpin", "scissors", "triangular_ruler", "round_pushpin", "straight_ruler", "triangular_flag_on_post", "file_folder", "open_file_folder", "black_nib", "pencil2", "memo", "lock_with_ink_pen", "closed_lock_with_key", "lock", "unlock", "mega", "loudspeaker", "sound", "loud_sound", "speaker", "mute", "zzz", "bell", "no_bell", "thought_balloon", "speech_balloon", "children_crossing", "mag", "mag_right", "no_entry_sign", "no_entry", "name_badge", "no_pedestrians", "do_not_litter", "no_bicycles", "non-potable_water", "no_mobile_phones", "underage", "accept", "ideograph_advantage", "white_flower", "secret", "congratulations", "u5408", "u6e80", "u7981", "u6709", "u7121", "u7533", "u55b6", "u6708", "u5272", "u7a7a", "sa", "koko", "u6307", "chart", "sparkle", "eight_spoked_asterisk", "negative_squared_cross_mark", "white_check_mark", "eight_pointed_black_star", "vibration_mode", "mobile_phone_off", "vs", "a", "b", "ab", "cl", "o2", "sos", "id", "parking", "wc", "cool", "free", "new", "ng", "ok", "up", "atm", "aries", "taurus", "gemini", "cancer", "leo", "virgo", "libra", "scorpius", "sagittarius", "capricorn", "aquarius", "pisces", "restroom", "mens", "womens", "baby_symbol", "wheelchair", "potable_water", "no_smoking", "put_litter_in_its_place", "arrow_forward", "arrow_backward", "arrow_up_small", "arrow_down_small", "fast_forward", "rewind", "arrow_double_up", "arrow_double_down", "arrow_right", "arrow_left", "arrow_up", "arrow_down", "arrow_upper_right", "arrow_lower_right", "arrow_lower_left", "arrow_upper_left", "arrow_up_down", "left_right_arrow", "arrows_counterclockwise", "arrow_right_hook", "leftwards_arrow_with_hook", "arrow_heading_up", "arrow_heading_down", "twisted_rightwards_arrows", "repeat", "repeat_one", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "keycap_ten", "1234", "hash", "abc", "abcd", "capital_abcd", "information_source", "signal_strength", "cinema", "symbols", "heavy_plus_sign", "heavy_minus_sign", "wavy_dash", "heavy_division_sign", "heavy_multiplication_x", "heavy_check_mark", "arrows_clockwise", "tm", "copyright", "registered", "currency_exchange", "heavy_dollar_sign", "curly_loop", "loop", "part_alternation_mark", "exclamation", "bangbang", "question", "grey_exclamation", "grey_question", "interrobang", "x", "o", "100", "end", "back", "on", "top", "soon", "cyclone", "m", "ophiuchus", "six_pointed_star", "beginner", "trident", "warning", "hotsprings", "recycle", "anger", "diamond_shape_with_a_dot_inside", "spades", "clubs", "hearts", "diamonds", "ballot_box_with_check", "white_circle", "black_circle", "radio_button", "red_circle", "large_blue_circle", "small_red_triangle", "small_red_triangle_down", "small_orange_diamond", "small_blue_diamond", "large_orange_diamond", "large_blue_diamond", "black_small_square", "white_small_square", "black_large_square", "white_large_square", "black_medium_square", "white_medium_square", "black_medium_small_square", "white_medium_small_square", "black_square_button", "white_square_button", "clock1", "clock2", "clock3", "clock4", "clock5", "clock6", "clock7", "clock8", "clock9", "clock10", "clock11", "clock12", "clock130", "clock230", "clock330", "clock430", "clock530", "clock630", "clock730", "clock830", "clock930", "clock1030", "clock1130", "clock1230", "alembic", "amphora", "atom", "biohazard", "bed", "bellhop", "calendar_spiral", "camera_with_flash", "candle", "card_box", "chains", "clock", "coffin", "compression", "control_knobs", "couch", "crayon", "cross", "dagger", "dark_sunglasses", "desktop", "dividers", "envelope", "file_cabinet", "film_frames", "fleur-de-lis", "fork_knife_plate", "frame_photo", "gear", "hammer_pick", "helmet_with_cross", "joystick", "key2", "keyboard", "knife", "label", "level_slider", "levitate", "lifter", "medal", "menorah", "metal", "microphone2", "military_medal", "mouse_three_button", "newspaper2", "notepad_spiral", "oil", "om_symbol", "orthodox_cross", "paperclips", "pause_button", "peace", "pen_ballpoint", "pen_fountain", "pencil", "pick", "ping_pong", "play_pause", "popcorn", "prayer_beads", "printer", "projector", "radioactive", "record_button", "reminder_ribbon", "rosette", "satellite_orbital", "scales", "shamrock", "shield", "shopping_bags", "star_and_crescent", "star_of_david", "stop_button", "stopwatch", "telephone", "ten", "thermometer", "thermometer_face", "tickets", "timer", "tools", "track_next", "track_previous", "trackball", "umbrella2", "wastebasket", "wheel_of_dharma", "yin_yang"]
    }];

    // scrub groups
    groups.forEach(function (group) {
      group.icons = group.icons.reject(function (obj) {
        return !Discourse.Emoji.exists(obj);
      });
    });

    // export so others can modify
    Discourse.Emoji.groups = groups;

    __exports__["default"] = groups;
  });
define("discourse/lib/emoji/emoji-toolbar", 
  ["discourse/lib/emoji/emoji-groups","discourse/lib/key-value-store","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var groups = __dependency1__["default"];
    var KeyValueStore = __dependency2__["default"];

    var keyValueStore = new KeyValueStore("discourse_emojis_");
    var EMOJI_USAGE = "emojiUsage";

    var PER_ROW = 12;
    var PER_PAGE = 60;

    var ungroupedIcons = undefined,
        recentlyUsedIcons = undefined;

    if (!keyValueStore.getObject(EMOJI_USAGE)) {
      keyValueStore.setObject({ key: EMOJI_USAGE, value: {} });
    }

    function closeSelector() {
      $('.emoji-modal, .emoji-modal-wrapper').remove();
      $('body, textarea').off('keydown.emoji');
    }

    function initializeUngroupedIcons() {
      var groupedIcons = {};

      groups.forEach(function (group) {
        group.icons.forEach(function (icon) {
          return groupedIcons[icon] = true;
        });
      });

      ungroupedIcons = [];
      var emojis = Discourse.Emoji.list();
      emojis.forEach(function (emoji) {
        if (groupedIcons[emoji] !== true) {
          ungroupedIcons.push(emoji);
        }
      });

      if (ungroupedIcons.length) {
        groups.push({ name: 'ungrouped', icons: ungroupedIcons });
      }
    }

    function trackEmojiUsage(title) {
      var recent = keyValueStore.getObject(EMOJI_USAGE) || {};

      if (!recent[title]) {
        recent[title] = { title: title, usage: 0 };
      }
      recent[title]["usage"]++;

      keyValueStore.setObject({ key: EMOJI_USAGE, value: recent });

      // clear the cache
      recentlyUsedIcons = null;
    }

    function sortByUsage(a, b) {
      if (a.usage > b.usage) {
        return -1;
      }
      if (b.usage > a.usage) {
        return 1;
      }
      return a.title.localeCompare(b.title);
    }

    function initializeRecentlyUsedIcons() {
      recentlyUsedIcons = [];

      var usage = _.map(keyValueStore.getObject(EMOJI_USAGE)).sort(sortByUsage);
      var recent = usage.slice(0, PER_ROW);

      if (recent.length > 0) {

        recent.forEach(function (emoji) {
          return recentlyUsedIcons.push(emoji.title);
        });

        var recentGroup = groups.findProperty('name', 'recent');
        if (recentGroup) {
          recentGroup.icons = recentlyUsedIcons;
        } else {
          groups.push({ name: 'recent', icons: recentlyUsedIcons });
        }
      }
    }

    function toolbar(selected) {
      if (!ungroupedIcons) {
        initializeUngroupedIcons();
      }
      if (!recentlyUsedIcons) {
        initializeRecentlyUsedIcons();
      }

      return groups.map(function (g, i) {
        var icon = g.tabicon;
        var title = g.fullname;
        if (g.name === "recent") {
          icon = "star";
          title = "Recent";
        } else if (g.name === "ungrouped") {
          icon = g.icons[0];
          title = "Custom";
        }

        return { src: Discourse.Emoji.urlFor(icon),
          title: title,
          groupId: i,
          selected: i === selected };
      });
    }

    function bindEvents(page, offset, options) {
      $('.emoji-page a').click(function (e) {
        var title = $(e.currentTarget).attr('title');
        trackEmojiUsage(title);
        options.onSelect(title);
        closeSelector();
        return false;
      }).hover(function (e) {
        var title = $(e.currentTarget).attr('title');
        var html = "<img src='" + Discourse.Emoji.urlFor(title) + "' class='emoji'> <span>:" + title + ":<span>";
        $('.emoji-modal .info').html(html);
      }, function () {
        return $('.emoji-modal .info').html("");
      });

      $('.emoji-modal .nav .next a').click(function () {
        return render(page, offset + PER_PAGE, options);
      });
      $('.emoji-modal .nav .prev a').click(function () {
        return render(page, offset - PER_PAGE, options);
      });

      $('.emoji-modal .toolbar a').click(function () {
        var p = parseInt($(this).data('group-id'));
        render(p, 0, options);
        return false;
      });
    }

    function render(page, offset, options) {
      keyValueStore.set({ key: "emojiPage", value: page });
      keyValueStore.set({ key: "emojiOffset", value: offset });

      var toolbarItems = toolbar(page);
      var rows = [];
      var row = [];
      var icons = groups[page].icons;
      var max = offset + PER_PAGE;

      for (var i = offset; i < max; i++) {
        if (!icons[i]) {
          break;
        }
        if (row.length === PER_ROW) {
          rows.push(row);
          row = [];
        }
        row.push({ src: Discourse.Emoji.urlFor(icons[i]), title: icons[i] });
      }
      rows.push(row);

      var model = {
        toolbarItems: toolbarItems,
        rows: rows,
        prevDisabled: offset === 0,
        nextDisabled: max + 1 > icons.length
      };

      $('.emoji-modal', options.appendTo).remove();
      var template = options.container.lookup('template:emoji-toolbar.raw');
      options.appendTo.append(template(model));

      bindEvents(page, offset, options);
    }

    function showSelector(options) {
      options = options || {};
      options.appendTo = options.appendTo || $('body');

      options.appendTo.append('<div class="emoji-modal-wrapper"></div>');
      $('.emoji-modal-wrapper').click(function () {
        return closeSelector();
      });

      if (Discourse.Site.currentProp('mobileView')) {
        PER_ROW = 9;
      }
      var page = keyValueStore.getInt("emojiPage", 0);
      var offset = keyValueStore.getInt("emojiOffset", 0);

      render(page, offset, options);

      $('body, textarea').on('keydown.emoji', function (e) {
        if (e.which === 27) {
          closeSelector();
          return false;
        }
      });
    }

    __exports__.showSelector = showSelector;
  });
define("discourse/components/d-editor", 
  ["discourse/lib/load-script","ember-addons/ember-computed-decorators","discourse/lib/emoji/emoji-toolbar","discourse/models/category","discourse/lib/category-hashtags","discourse/lib/tag-hashtags","discourse/lib/category-tag-search","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
    "use strict";
    var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    __exports__.addToolbarCallback = addToolbarCallback;
    __exports__.onToolbarCreate = onToolbarCreate;

    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    /*global Mousetrap:true */

    var loadScript = __dependency1__["default"];
    var computed = __dependency2__.default;
    var on = __dependency2__.on;
    var observes = __dependency2__.observes;
    var showSelector = __dependency3__.showSelector;
    var Category = __dependency4__["default"];
    var categoryHashtagTriggerRule = __dependency5__.categoryHashtagTriggerRule;
    var TAG_HASHTAG_POSTFIX = __dependency6__.TAG_HASHTAG_POSTFIX;
    var searchCategoryTag = __dependency7__.search;
    var SEPARATOR = __dependency5__.SEPARATOR;

    // Our head can be a static string or a function that returns a string
    // based on input (like for numbered lists).
    function getHead(head, prev) {
      if (typeof head === "string") {
        return [head, head.length];
      } else {
        return getHead(head(prev));
      }
    }

    var OP = {
      NONE: 0,
      REMOVED: 1,
      ADDED: 2
    };

    var _createCallbacks = [];

    var Toolbar = (function () {
      function Toolbar(site) {
        _classCallCheck(this, Toolbar);

        this.shortcuts = {};

        this.groups = [{ group: 'fontStyles', buttons: [] }, { group: 'insertions', buttons: [] }, { group: 'extras', buttons: [] }];

        this.addButton({
          trimLeading: true,
          id: 'bold',
          group: 'fontStyles',
          shortcut: 'B',
          perform: function (e) {
            return e.applySurround('**', '**', 'bold_text');
          }
        });

        this.addButton({
          trimLeading: true,
          id: 'italic',
          group: 'fontStyles',
          shortcut: 'I',
          perform: function (e) {
            return e.applySurround('_', '_', 'italic_text');
          }
        });

        this.addButton({ id: 'link', group: 'insertions', shortcut: 'K', action: 'showLinkModal' });

        this.addButton({
          id: 'quote',
          group: 'insertions',
          icon: 'quote-right',
          shortcut: 'Shift+9',
          perform: function (e) {
            return e.applySurround('> ', '', 'code_text');
          }
        });

        this.addButton({
          id: 'code',
          group: 'insertions',
          shortcut: 'Shift+C',
          perform: function (e) {
            if (e.selected.value.indexOf("\n") !== -1) {
              e.applySurround('    ', '', 'code_text');
            } else {
              e.applySurround('`', '`', 'code_text');
            }
          }
        });

        this.addButton({
          id: 'bullet',
          group: 'extras',
          icon: 'list-ul',
          shortcut: 'Shift+8',
          title: 'composer.ulist_title',
          perform: function (e) {
            return e.applyList('* ', 'list_item');
          }
        });

        this.addButton({
          id: 'list',
          group: 'extras',
          icon: 'list-ol',
          shortcut: 'Shift+7',
          title: 'composer.olist_title',
          perform: function (e) {
            return e.applyList(function (i) {
              return !i ? "1. " : parseInt(i) + 1 + '. ';
            }, 'list_item');
          }
        });

        this.addButton({
          id: 'heading',
          group: 'extras',
          icon: 'font',
          shortcut: 'Alt+1',
          perform: function (e) {
            return e.applyList('## ', 'heading_text');
          }
        });

        this.addButton({
          id: 'rule',
          group: 'extras',
          icon: 'minus',
          shortcut: 'Alt+R',
          title: 'composer.hr_title',
          perform: function (e) {
            return e.addText("\n\n----------\n");
          }
        });

        if (site.mobileView) {
          this.groups.push({ group: 'mobileExtras', buttons: [] });

          this.addButton({
            id: 'preview',
            group: 'mobileExtras',
            icon: 'television',
            title: 'composer.hr_preview',
            perform: function (e) {
              return e.preview();
            }
          });
        }

        this.groups[this.groups.length - 1].lastGroup = true;
      }

      _createClass(Toolbar, [{
        key: 'addButton',
        value: function addButton(button) {
          var g = this.groups.findProperty('group', button.group);
          if (!g) {
            throw 'Couldn\'t find toolbar group ' + button.group;
          }

          var createdButton = {
            id: button.id,
            className: button.className || button.id,
            icon: button.icon || button.id,
            action: button.action || 'toolbarButton',
            perform: button.perform || Ember.K,
            trimLeading: button.trimLeading
          };

          if (button.sendAction) {
            createdButton.sendAction = button.sendAction;
          }

          var title = I18n.t(button.title || 'composer.' + button.id + '_title');
          if (button.shortcut) {
            var mac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
            var mod = mac ? 'Meta' : 'Ctrl';
            var shortcutTitle = mod + '+' + button.shortcut;

            // Mac users are used to glyphs for shortcut keys
            if (mac) {
              shortcutTitle = shortcutTitle.replace('Shift', "\u21E7").replace('Meta', "\u2318").replace('Alt', "\u2325").replace(/\+/g, '');
            } else {
              shortcutTitle = shortcutTitle.replace('Shift', I18n.t('shortcut_modifier_key.shift')).replace('Ctrl', I18n.t('shortcut_modifier_key.ctrl')).replace('Alt', I18n.t('shortcut_modifier_key.alt'));
            }

            createdButton.title = title + ' (' + shortcutTitle + ')';

            this.shortcuts[(mod + '+' + button.shortcut).toLowerCase()] = createdButton;
          } else {
            createdButton.title = title;
          }

          if (button.unshift) {
            g.buttons.unshift(createdButton);
          } else {
            g.buttons.push(createdButton);
          }
        }
      }]);

      return Toolbar;
    })();

    function addToolbarCallback(func) {
      _createCallbacks.push(func);
    }

    function onToolbarCreate(func) {
      console.warn('`onToolbarCreate` is deprecated, use the plugin api instead.');
      addToolbarCallback(func);
    }

    ;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['d-editor'];
      }
    }, {
      key: 'ready',
      initializer: function () {
        return false;
      }
    }, {
      key: 'forcePreview',
      initializer: function () {
        return false;
      }
    }, {
      key: 'insertLinkHidden',
      initializer: function () {
        return true;
      }
    }, {
      key: 'linkUrl',
      initializer: function () {
        return '';
      }
    }, {
      key: 'linkText',
      initializer: function () {
        return '';
      }
    }, {
      key: 'lastSel',
      initializer: function () {
        return null;
      }
    }, {
      key: '_mouseTrap',
      initializer: function () {
        return null;
      }
    }, {
      key: 'placeholderTranslated',
      decorators: [computed('placeholder')],
      value: function (placeholder) {
        if (placeholder) return I18n.t(placeholder);
        return null;
      }
    }, {
      key: '_startUp',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this = this;

        var container = this.get('container'),
            $editorInput = this.$('.d-editor-input');

        this._applyEmojiAutocomplete(container, $editorInput);
        this._applyCategoryHashtagAutocomplete(container, $editorInput);

        loadScript('defer/html-sanitizer-bundle').then(function () {
          return _this.set('ready', true);
        });

        var mouseTrap = Mousetrap(this.$('.d-editor-input')[0]);

        var shortcuts = this.get('toolbar.shortcuts');
        Object.keys(shortcuts).forEach(function (sc) {
          var button = shortcuts[sc];
          mouseTrap.bind(sc, function () {
            _this.send(button.action, button);
            return false;
          });
        });

        // disable clicking on links in the preview
        this.$('.d-editor-preview').on('click.preview', function (e) {
          e.preventDefault();
          return false;
        });

        this.appEvents.on('composer:insert-text', function (text) {
          _this._addText(_this._getSelected(), text);
        });

        this._mouseTrap = mouseTrap;
      }
    }, {
      key: '_shutDown',
      decorators: [on('willDestroyElement')],
      value: function () {
        this.appEvents.off('composer:insert-text');

        var mouseTrap = this._mouseTrap;
        Object.keys(this.get('toolbar.shortcuts')).forEach(function (sc) {
          return mouseTrap.unbind(sc);
        });
        this.$('.d-editor-preview').off('click.preview');
      }
    }, {
      key: 'toolbar',
      decorators: [computed],
      value: function () {
        var toolbar = new Toolbar(this.site);
        _createCallbacks.forEach(function (cb) {
          return cb(toolbar);
        });
        this.sendAction('extraButtons', toolbar);
        return toolbar;
      }
    }, {
      key: '_updatePreview',
      value: function () {
        var _this2 = this;

        if (this._state !== "inDOM") {
          return;
        }

        var value = this.get('value');
        var markdownOptions = this.get('markdownOptions') || {};
        markdownOptions.sanitize = true;

        this.set('preview', Discourse.Dialect.cook(value || "", markdownOptions));
        Ember.run.scheduleOnce('afterRender', function () {
          if (_this2._state !== "inDOM") {
            return;
          }
          var $preview = _this2.$('.d-editor-preview');
          if ($preview.length === 0) return;

          _this2.sendAction('previewUpdated', $preview);
        });
      }
    }, {
      key: '_watchForChanges',
      decorators: [observes('ready', 'value')],
      value: function () {
        if (!this.get('ready')) {
          return;
        }
        Ember.run.debounce(this, this._updatePreview, 30);
      }
    }, {
      key: '_applyCategoryHashtagAutocomplete',
      value: function (container) {
        var template = container.lookup('template:category-tag-autocomplete.raw');
        var siteSettings = this.siteSettings;

        this.$('.d-editor-input').autocomplete({
          template: template,
          key: '#',
          transformComplete: function (obj) {
            if (obj.model) {
              return Category.slugFor(obj.model, SEPARATOR);
            } else {
              return '' + obj.text + TAG_HASHTAG_POSTFIX;
            }
          },
          dataSource: function (term) {
            return searchCategoryTag(term, siteSettings);
          },
          triggerRule: function (textarea, opts) {
            return categoryHashtagTriggerRule(textarea, opts);
          }
        });
      }
    }, {
      key: '_applyEmojiAutocomplete',
      value: function (container, $editorInput) {
        if (!this.siteSettings.enable_emoji) {
          return;
        }

        var template = container.lookup('template:emoji-selector-autocomplete.raw');
        var self = this;

        $editorInput.autocomplete({
          template: template,
          key: ":",
          afterComplete: function (text) {
            self.set('value', text);
          },

          transformComplete: function (v) {
            if (v.code) {
              return v.code + ':';
            } else {
              showSelector({
                appendTo: self.$(),
                container: container,
                onSelect: function (title) {
                  // Remove the previously type characters when a new emoji is selected from the selector.
                  var selected = self._getSelected();
                  var newPre = selected.pre.replace(/:[^:]+$/, ":");
                  var numOfRemovedChars = selected.pre.length - newPre.length;
                  selected.pre = newPre;
                  selected.start -= numOfRemovedChars;
                  selected.end -= numOfRemovedChars;
                  self._addText(selected, title + ':');
                }
              });
              return "";
            }
          },

          dataSource: function (term) {
            return new Ember.RSVP.Promise(function (resolve) {
              var full = ':' + term;
              term = term.toLowerCase();

              if (term === "") {
                return resolve(["slight_smile", "smile", "wink", "sunny", "blush"]);
              }

              if (Discourse.Emoji.translations[full]) {
                return resolve([Discourse.Emoji.translations[full]]);
              }

              var options = Discourse.Emoji.search(term, { maxResults: 5 });

              return resolve(options);
            }).then(function (list) {
              return list.map(function (code) {
                return { code: code, src: Discourse.Emoji.urlFor(code) };
              });
            }).then(function (list) {
              if (list.length) {
                list.push({ label: I18n.t("composer.more_emoji") });
              }
              return list;
            });
          }
        });
      }
    }, {
      key: '_getSelected',
      value: function (trimLeading) {
        if (!this.get('ready')) {
          return;
        }

        var textarea = this.$('textarea.d-editor-input')[0];
        var value = textarea.value;
        var start = textarea.selectionStart;
        var end = textarea.selectionEnd;

        // trim trailing spaces cause **test ** would be invalid
        while (end > start && /\s/.test(value.charAt(end - 1))) {
          end--;
        }

        if (trimLeading) {
          // trim leading spaces cause ** test** would be invalid
          while (end > start && /\s/.test(value.charAt(start))) {
            start++;
          }
        }

        var selVal = value.substring(start, end);
        var pre = value.slice(0, start);
        var post = value.slice(end);

        return { start: start, end: end, value: selVal, pre: pre, post: post };
      }
    }, {
      key: '_selectText',
      value: function (from, length) {
        var _this3 = this;

        Ember.run.scheduleOnce('afterRender', function () {
          var $textarea = _this3.$('textarea.d-editor-input');
          var textarea = $textarea[0];
          var oldScrollPos = $textarea.scrollTop();
          if (!_this3.capabilities.isIOS) {
            $textarea.focus();
          }
          textarea.selectionStart = from;
          textarea.selectionEnd = textarea.selectionStart + length;
          $textarea.scrollTop(oldScrollPos);
        });
      }
    }, {
      key: '_getMultilineContents',

      // perform the same operation over many lines of text
      value: function (lines, head, hval, hlen, tail, tlen) {
        var operation = OP.NONE;

        return lines.map(function (l) {
          if (l.length === 0) {
            return l;
          }

          if (operation !== OP.ADDED && (l.slice(0, hlen) === hval && tlen === 0 || l.slice(-tlen) === tail)) {
            operation = OP.REMOVED;
            if (tlen === 0) {
              var _result = l.slice(hlen);

              var _getHead = getHead(head, hval);

              var _getHead2 = _slicedToArray(_getHead, 2);

              hval = _getHead2[0];
              hlen = _getHead2[1];

              return _result;
            } else if (l.slice(-tlen) === tail) {
              var _result2 = l.slice(hlen, -tlen);

              var _getHead3 = getHead(head, hval);

              var _getHead32 = _slicedToArray(_getHead3, 2);

              hval = _getHead32[0];
              hlen = _getHead32[1];

              return _result2;
            }
          } else if (operation === OP.NONE) {
            operation = OP.ADDED;
          } else if (operation === OP.REMOVED) {
            return l;
          }

          var result = '' + hval + l + tail;

          var _getHead4 = getHead(head, hval);

          var _getHead42 = _slicedToArray(_getHead4, 2);

          hval = _getHead42[0];
          hlen = _getHead42[1];

          return result;
        }).join("\n");
      }
    }, {
      key: '_applySurround',
      value: function (sel, head, tail, exampleKey) {
        var pre = sel.pre;
        var post = sel.post;

        var tlen = tail.length;
        if (sel.start === sel.end) {
          if (tlen === 0) {
            return;
          }

          var _getHead5 = getHead(head);

          var _getHead52 = _slicedToArray(_getHead5, 2);

          var hval = _getHead52[0];
          var hlen = _getHead52[1];

          var example = I18n.t('composer.' + exampleKey);
          this.set('value', '' + pre + hval + example + tail + post);
          this._selectText(pre.length + hlen, example.length);
        } else {
          var lines = sel.value.split("\n");

          var _getHead6 = getHead(head);

          var _getHead62 = _slicedToArray(_getHead6, 2);

          var hval = _getHead62[0];
          var hlen = _getHead62[1];

          if (lines.length === 1 && pre.slice(-tlen) === tail && post.slice(0, hlen) === hval) {
            this.set('value', '' + pre.slice(0, -hlen) + sel.value + post.slice(tlen));
            this._selectText(sel.start - hlen, sel.value.length);
          } else {
            var contents = this._getMultilineContents(lines, head, hval, hlen, tail, tlen);

            this.set('value', '' + pre + contents + post);
            if (lines.length === 1 && tlen > 0) {
              this._selectText(sel.start + hlen, contents.length - hlen - hlen);
            } else {
              this._selectText(sel.start, contents.length);
            }
          }
        }
      }
    }, {
      key: '_applyList',
      value: function (sel, head, exampleKey) {
        if (sel.value.indexOf("\n") !== -1) {
          this._applySurround(sel, head, '', exampleKey);
        } else {
          var _getHead7 = getHead(head);

          var _getHead72 = _slicedToArray(_getHead7, 2);

          var hval = _getHead72[0];
          var hlen = _getHead72[1];

          if (sel.start === sel.end) {
            sel.value = I18n.t('composer.' + exampleKey);
          }

          var trimmedPre = sel.pre.trim();
          var number = sel.value.indexOf(hval) === 0 ? sel.value.slice(hlen) : '' + hval + sel.value;
          var preLines = trimmedPre.length ? trimmedPre + '\n\n' : "";

          var trimmedPost = sel.post.trim();
          var post = trimmedPost.length ? '\n\n' + trimmedPost : trimmedPost;

          this.set('value', '' + preLines + number + post);
          this._selectText(preLines.length, number.length);
        }
      }
    }, {
      key: '_addText',
      value: function (sel, text) {
        var _this4 = this;

        var insert = '' + sel.pre + text;
        this.set('value', '' + insert + sel.post);
        this._selectText(insert.length, 0);
        Ember.run.scheduleOnce("afterRender", function () {
          return _this4.$("textarea.d-editor-input").focus();
        });
      }
    }, {
      key: '_togglePreview',
      value: function () {
        this.toggleProperty('forcePreview');
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          toolbarButton: function (button) {
            var _this5 = this;

            var selected = this._getSelected(button.trimLeading);
            var toolbarEvent = {
              selected: selected,
              applySurround: function (head, tail, exampleKey) {
                return _this5._applySurround(selected, head, tail, exampleKey);
              },
              applyList: function (head, exampleKey) {
                return _this5._applyList(selected, head, exampleKey);
              },
              addText: function (text) {
                return _this5._addText(selected, text);
              },
              preview: function () {
                return _this5._togglePreview();
              }
            };

            if (button.sendAction) {
              return this.sendAction(button.sendAction, toolbarEvent);
            } else {
              button.perform(toolbarEvent);
            }
          },

          hidePreview: function () {
            this.set('forcePreview', false);
          },

          showLinkModal: function () {
            this._lastSel = this._getSelected();
            this.set('insertLinkHidden', false);
          },

          insertLink: function () {
            var origLink = this.get('linkUrl');
            var linkUrl = origLink.indexOf('://') === -1 ? 'http://' + origLink : origLink;
            var sel = this._lastSel;

            if (Ember.isEmpty(linkUrl)) {
              return;
            }

            var linkText = this.get('linkText') || '';
            if (linkText.length) {
              this._addText(sel, '[' + linkText + '](' + linkUrl + ')');
            } else {
              if (sel.value) {
                this._addText(sel, '[' + sel.value + '](' + linkUrl + ')');
              } else {
                this._addText(sel, '[' + origLink + '](' + linkUrl + ')');
                this._selectText(sel.start + 1, origLink.length);
              }
            }

            this.set('linkUrl', '');
            this.set('linkText', '');
          },

          emoji: function () {
            var _this6 = this;

            showSelector({
              appendTo: this.$(),
              container: this.container,
              onSelect: function (title) {
                return _this6._addText(_this6._getSelected(), ':' + title + ':');
              }
            });
          }
        };
      }
    }]));
  });
define("discourse/views/composer", 
  ["discourse/lib/after-transition","discourse/lib/safari-hacks","discourse/components/site-header","ember-addons/ember-computed-decorators","discourse/models/composer","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var afterTransition = __dependency1__["default"];
    var positioningWorkaround = __dependency2__["default"];
    var headerHeight = __dependency3__.headerHeight;
    var computed = __dependency4__.default;
    var on = __dependency4__.on;
    var observes = __dependency4__.observes;
    var Composer = __dependency5__["default"];

    var ComposerView = Ember.View.extend(_createDecoratedObject([{
      key: '_lastKeyTimeout',
      initializer: function () {
        return null;
      }
    }, {
      key: 'elementId',
      initializer: function () {
        return 'reply-control';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return ['composer.creatingPrivateMessage:private-message', 'composeState', 'composer.loading', 'composer.canEditTitle:edit-title', 'composer.createdPost:created-post', 'composer.creatingTopic:topic'];
      }
    }, {
      key: 'composer',
      initializer: function () {
        return Em.computed.alias('controller.model');
      }
    }, {
      key: 'composeState',
      decorators: [computed('composer.composeState')],
      value: function (composeState) {
        return composeState || Composer.CLOSED;
      }
    }, {
      key: 'movePanels',
      value: function (sizePx) {

        $('#main-outlet').css('padding-bottom', sizePx);

        // signal the progress bar it should move!
        this.appEvents.trigger("composer:resized");
      }
    }, {
      key: 'resize',
      decorators: [observes('composeState', 'composer.action')],
      value: function () {
        var _this = this;

        Ember.run.scheduleOnce('afterRender', function () {
          var h = $('#reply-control').height() || 0;
          _this.movePanels(h + "px");

          // Figure out the size of the fields
          var $fields = _this.$('.composer-fields');
          var fieldPos = $fields.position();
          if (fieldPos) {
            _this.$('.wmd-controls').css('top', $fields.height() + fieldPos.top + 5);
          }

          // get the submit panel height
          var submitPos = _this.$('.submit-panel').position();
          if (submitPos) {
            _this.$('.wmd-controls').css('bottom', h - submitPos.top + 7);
          }
        });
      }
    }, {
      key: 'keyUp',
      value: function () {
        var _this2 = this;

        var controller = this.get('controller');
        controller.checkReplyLength();

        this.get('composer').typing();

        var lastKeyUp = new Date();
        this._lastKeyUp = lastKeyUp;

        // One second from now, check to see if the last key was hit when
        // we recorded it. If it was, the user paused typing.
        Ember.run.cancel(this._lastKeyTimeout);
        this._lastKeyTimeout = Ember.run.later(function () {
          if (lastKeyUp !== _this2._lastKeyUp) {
            return;
          }

          // Search for similar topics if the user pauses typing
          controller.findSimilarTopics();
        }, 1000);
      }
    }, {
      key: 'keyDown',
      value: function (e) {
        if (e.which === 27) {
          this.get('controller').send('hitEsc');
          return false;
        } else if (e.which === 13 && (e.ctrlKey || e.metaKey)) {
          // CTRL+ENTER or CMD+ENTER
          this.get('controller').send('save');
          return false;
        }
      }
    }, {
      key: '_enableResizing',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this3 = this;

        var $replyControl = $('#reply-control');
        var resize = function () {
          return Ember.run(function () {
            return _this3.resize();
          });
        };

        $replyControl.DivResizer({
          resize: resize,
          maxHeight: function (winHeight) {
            return winHeight - headerHeight();
          },
          onDrag: function (sizePx) {
            return _this3.movePanels(sizePx);
          }
        });

        afterTransition($replyControl, resize);
        positioningWorkaround(this.$());
      }
    }, {
      key: 'click',
      value: function () {
        this.get('controller').send('openIfDraft');
      }
    }]));

    RSVP.EventTarget.mixin(ComposerView);
    __exports__["default"] = ComposerView;
  });
define("discourse/lib/show-modal", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = function (name, opts) {
      opts = opts || {};
      var container = Discourse.__container__;

      // We use the container here because modals are like singletons
      // in Discourse. Only one can be shown with a particular state.
      var route = container.lookup('route:application');
      var modalController = route.controllerFor('modal');

      modalController.set('modalClass', null);

      var viewClass = container.lookupFactory('view:' + name);
      var controller = container.lookup('controller:' + name);
      if (viewClass) {
        route.render(name, { into: 'modal', outlet: 'modalBody' });
      } else {
        var templateName = Ember.String.dasherize(name);

        var renderArgs = { into: 'modal', outlet: 'modalBody', view: 'modal-body' };
        if (controller) {
          renderArgs.controller = name;
        }

        route.render('modal/' + templateName, renderArgs);
        if (opts.title) {
          modalController.set('title', I18n.t(opts.title));
        }
      }

      if (controller) {
        var model = opts.model;
        if (model) {
          controller.set('model', model);
        }
        if (controller.onShow) {
          controller.onShow();
        }
        controller.set('flashMessage', null);
      }

      return controller;
    };
  });
define("discourse/lib/screen-track", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    // We use this class to track how long posts in a topic are on the screen.
    var PAUSE_UNLESS_SCROLLED = 1000 * 60 * 3;
    var MAX_TRACKING_TIME = 1000 * 60 * 6;
    var ANON_MAX_TOPIC_IDS = 5;

    var getTime = function () {
      return new Date().getTime();
    };

    var _default = (function () {
      function _default(topicTrackingState, siteSettings, session, currentUser) {
        _classCallCheck(this, _default);

        this.topicTrackingState = topicTrackingState;
        this.siteSettings = siteSettings;
        this.session = session;
        this.currentUser = currentUser;
        this.reset();
      }

      _createClass(_default, [{
        key: 'start',
        value: function start(topicId, topicController) {
          var _this = this;

          var currentTopicId = this._topicId;
          if (currentTopicId && currentTopicId !== topicId) {
            this.tick();
            this.flush();
          }

          this.reset();

          // Create an interval timer if we don't have one.
          if (!this._interval) {
            this._interval = setInterval(function () {
              return _this.tick();
            }, 1000);
            $(window).on('scroll.screentrack', function () {
              return _this.scrolled();
            });
          }

          this._topicId = topicId;
          this._topicController = topicController;
        }
      }, {
        key: 'stop',
        value: function stop() {
          // already stopped no need to "extra stop"
          if (!this._topicId) {
            return;
          }

          $(window).off('scroll.screentrack');
          this.tick();
          this.flush();
          this.reset();

          this._topicId = null;
          this._topicController = null;

          if (this._interval) {
            clearInterval(this._interval);
            this._interval = null;
          }
        }
      }, {
        key: 'setOnscreen',
        value: function setOnscreen(onscreen) {
          this._onscreen = onscreen;
        }

        // Reset our timers
      }, {
        key: 'reset',
        value: function reset() {
          var now = getTime();
          this._lastTick = now;
          this._lastScrolled = now;
          this._lastFlush = 0;
          this._timings = {};
          this._totalTimings = {};
          this._topicTime = 0;
          this._onscreen = [];
        }
      }, {
        key: 'scrolled',
        value: function scrolled() {
          this._lastScrolled = getTime();
        }
      }, {
        key: 'registerAnonCallback',
        value: function registerAnonCallback(cb) {
          this._anonCallback = cb;
        }
      }, {
        key: 'flush',
        value: function flush() {
          var _this2 = this;

          var newTimings = {};
          var totalTimings = this._totalTimings;

          var timings = this._timings;
          Object.keys(this._timings).forEach(function (postNumber) {
            var time = timings[postNumber];
            totalTimings[postNumber] = totalTimings[postNumber] || 0;

            if (time > 0 && totalTimings[postNumber] < MAX_TRACKING_TIME) {
              totalTimings[postNumber] += time;
              newTimings[postNumber] = time;
            }
            timings[postNumber] = 0;
          });

          var topicId = parseInt(this._topicId, 10);
          var highestSeen = 0;

          Object.keys(newTimings).forEach(function (postNumber) {
            highestSeen = Math.max(highestSeen, parseInt(postNumber, 10));
          });

          var highestSeenByTopic = this.session.get('highestSeenByTopic');
          if ((highestSeenByTopic[topicId] || 0) < highestSeen) {
            highestSeenByTopic[topicId] = highestSeen;
          }

          this.topicTrackingState.updateSeen(topicId, highestSeen);

          if (!$.isEmptyObject(newTimings)) {
            if (this.currentUser) {
              Discourse.ajax('/topics/timings', {
                data: {
                  timings: newTimings,
                  topic_time: this._topicTime,
                  topic_id: topicId
                },
                cache: false,
                type: 'POST',
                headers: {
                  'X-SILENCE-LOGGER': 'true'
                }
              }).then(function () {
                var controller = _this2._topicController;
                if (controller) {
                  var postNumbers = Object.keys(newTimings).map(function (v) {
                    return parseInt(v, 10);
                  });
                  controller.readPosts(topicId, postNumbers);
                }
              });
            } else if (this._anonCallback) {
              // Anonymous viewer - save to localStorage
              var storage = this.keyValueStore;

              // Save total time
              var existingTime = storage.getInt('anon-topic-time');
              storage.setItem('anon-topic-time', existingTime + this._topicTime);

              // Save unique topic IDs up to a max
              var topicIds = storage.get('anon-topic-ids');
              if (topicIds) {
                topicIds = topicIds.split(',').map(function (e) {
                  return parseInt(e);
                });
              } else {
                topicIds = [];
              }
              if (topicIds.indexOf(topicId) === -1 && topicIds.length < ANON_MAX_TOPIC_IDS) {
                topicIds.push(topicId);
                storage.setItem('anon-topic-ids', topicIds.join(','));
              }

              // Inform the observer
              this._anonCallback();

              // No need to call controller.readPosts()
            }

            this._topicTime = 0;
          }

          this._lastFlush = 0;
        }
      }, {
        key: 'tick',
        value: function tick() {
          var now = new Date().getTime();

          // If the user hasn't scrolled the browser in a long time, stop tracking time read
          var sinceScrolled = now - this._lastScrolled;
          if (sinceScrolled > PAUSE_UNLESS_SCROLLED) {
            return;
          }

          var diff = now - this._lastTick;
          this._lastFlush += diff;
          this._lastTick = now;

          var totalTimings = this._totalTimings;
          var timings = this._timings;
          var nextFlush = this.siteSettings.flush_timings_secs * 1000;

          var rush = Object.keys(timings).some(function (postNumber) {
            return timings[postNumber] > 0 && !totalTimings[postNumber];
          });

          if (this._lastFlush > nextFlush || rush) {
            this.flush();
          }

          // Don't track timings if we're not in focus
          if (!Discourse.get("hasFocus")) return;

          this._topicTime += diff;

          this._onscreen.forEach(function (postNumber) {
            return timings[postNumber] = (timings[postNumber] || 0) + diff;
          });
        }
      }]);

      return _default;
    })();

    __exports__["default"] = _default;
  });
define("discourse/routes/discourse", 
  ["discourse/models/composer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.cleanDOM = cleanDOM;
    var Composer = __dependency1__["default"];

    var DiscourseRoute = Ember.Route.extend({

      // Set to true to refresh a model without a transition if a query param
      // changes
      resfreshQueryWithoutTransition: false,

      refresh: function () {
        var _this = this;

        if (!this.refreshQueryWithoutTransition) {
          return this._super();
        }

        if (!this.router.router.activeTransition) {
          (function () {
            var controller = _this.controller,
                model = controller.get('model'),
                params = _this.controller.getProperties(Object.keys(_this.queryParams));

            model.set('loading', true);
            _this.model(params).then(function (m) {
              return _this.setupController(controller, m);
            });
          })();
        }
      },

      _refreshTitleOnce: function () {
        this.send('_collectTitleTokens', []);
      },

      actions: {

        _collectTitleTokens: function (tokens) {
          // If there's a title token method, call it and get the token
          if (this.titleToken) {
            var t = this.titleToken();
            if (t && t.length) {
              if (t instanceof Array) {
                t.forEach(function (ti) {
                  tokens.push(ti);
                });
              } else {
                tokens.push(t);
              }
            }
          }
          return true;
        },

        refreshTitle: function () {
          Ember.run.once(this, this._refreshTitleOnce);
        }
      },

      redirectIfLoginRequired: function () {
        var app = this.controllerFor('application');
        if (app.get('loginRequired')) {
          this.replaceWith('login');
        }
      },

      openTopicDraft: function (model) {
        // If there's a draft, open the create topic composer
        if (model.draft) {
          var composer = this.controllerFor('composer');
          if (!composer.get('model.viewOpen')) {
            composer.open({
              action: Composer.CREATE_TOPIC,
              draft: model.draft,
              draftKey: model.draft_key,
              draftSequence: model.draft_sequence
            });
          }
        }
      },

      isPoppedState: function (transition) {
        return !transition._discourse_intercepted && !!transition.intent.url;
      }
    });

    function cleanDOM() {
      if (window.MiniProfiler) {
        window.MiniProfiler.pageTransition();
      }

      // Close some elements that may be open
      $('header ul.icons li').removeClass('active');
      $('[data-toggle="dropdown"]').parent().removeClass('open');
      // close the lightbox
      if ($.magnificPopup && $.magnificPopup.instance) {
        $.magnificPopup.instance.close();
        $('body').removeClass('mfp-zoom-out-cur');
      }

      // Remove any link focus
      // NOTE: the '.not("body")' is here to prevent a bug in IE10 on Win7
      // cf. https://stackoverflow.com/questions/5657371
      $(document.activeElement).not("body").not(".no-blur").blur();

      Discourse.set('notifyCount', 0);
      $('#discourse-modal').modal('hide');
      var hideDropDownFunction = $('html').data('hide-dropdown');
      if (hideDropDownFunction) {
        hideDropDownFunction();
      }

      // TODO: Avoid container lookup here
      var appEvents = Discourse.__container__.lookup('app-events:main');
      appEvents.trigger('dom:clean');
    }

    __exports__["default"] = DiscourseRoute;
  });

Discourse.Route = require('discourse/routes/discourse').default;
define("discourse/routes/build-topic-route", 
  ["discourse/controllers/discovery-sortable","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var queryParams = __dependency1__.queryParams;

    // A helper to build a topic route for a filter
    function filterQueryParams(params, defaultParams) {
      var findOpts = defaultParams || {};
      if (params) {
        Object.keys(queryParams).forEach(function (opt) {
          if (params[opt]) {
            findOpts[opt] = params[opt];
          }
        });
      }
      return findOpts;
    }

    function findTopicList(store, tracking, filter, filterParams, extras) {
      extras = extras || {};
      return new Ember.RSVP.Promise(function (resolve) {
        var session = Discourse.Session.current();

        if (extras.cached) {
          var cachedList = session.get('topicList');

          // Try to use the cached version if it exists and is greater than the topics per page
          if (cachedList && cachedList.get('filter') === filter && (cachedList.get('topics.length') || 0) > cachedList.get('per_page') && _.isEqual(cachedList.get('listParams'), filterParams)) {
            cachedList.set('loaded', true);

            if (tracking) {
              tracking.updateTopics(cachedList.get('topics'));
            }
            return resolve(cachedList);
          }
          session.set('topicList', null);
        } else {
          // Clear the cache
          session.setProperties({ topicList: null, topicListScrollPosition: null });
        }

        // Clean up any string parameters that might slip through
        filterParams = filterParams || {};
        Object.keys(filterParams).forEach(function (k) {
          var val = filterParams[k];
          if (val === "undefined" || val === "null" || val === 'false') {
            filterParams[k] = undefined;
          }
        });

        return resolve(store.findFiltered('topicList', { filter: filter, params: filterParams || {} }));
      }).then(function (list) {
        list.set('listParams', filterParams);
        if (tracking) {
          tracking.sync(list, list.filter);
          tracking.trackIncoming(list.filter);
        }
        Discourse.Session.currentProp('topicList', list);
        return list;
      });
    }

    __exports__["default"] = function (filter, extras) {
      extras = extras || {};
      return Discourse.Route.extend({
        queryParams: queryParams,

        beforeModel: function () {
          this.controllerFor('navigation/default').set('filterMode', filter);
        },

        model: function (data, transition) {
          // attempt to stop early cause we need this to be called before .sync
          this.screenTrack.stop();

          var findOpts = filterQueryParams(data),
              findExtras = { cached: this.isPoppedState(transition) };

          return findTopicList(this.store, this.topicTrackingState, filter, findOpts, findExtras);
        },

        titleToken: function () {
          if (filter === Discourse.Utilities.defaultHomepage()) {
            return;
          }

          var filterText = I18n.t('filters.' + filter.replace('/', '.') + '.title');
          return I18n.t('filters.with_topics', { filter: filterText });
        },

        setupController: function (controller, model) {
          var topicOpts = {
            model: model,
            category: null,
            period: model.get('for_period') || (filter.indexOf('/') > 0 ? filter.split('/')[1] : ''),
            selected: [],
            expandGloballyPinned: true
          };

          var params = model.get('params');
          if (params && Object.keys(params).length) {
            if (params.order !== undefined) {
              topicOpts.order = params.order;
            }
            if (params.ascending !== undefined) {
              topicOpts.ascending = params.ascending;
            }
          }
          this.controllerFor('discovery/topics').setProperties(topicOpts);

          this.openTopicDraft(model);
          this.controllerFor('navigation/default').set('canCreateTopic', model.get('can_create_topic'));
        },

        resetController: function (controller, isExiting) {
          if (isExiting) {
            controller.setProperties({ order: "default", ascending: false });
          }
        },

        renderTemplate: function () {
          this.render('navigation/default', { outlet: 'navigation-bar' });
          this.render('discovery/topics', { controller: 'discovery/topics', outlet: 'list-container' });
        }
      }, extras);
    }

    __exports__.filterQueryParams = filterQueryParams;
    __exports__.findTopicList = findTopicList;
  });
define("discourse/routes/restricted-user", 
  ["discourse/routes/discourse","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseRoute = __dependency1__["default"];

    // A base route that allows us to redirect when access is restricted
    __exports__["default"] = DiscourseRoute.extend({

      afterModel: function () {
        if (!this.modelFor('user').get('can_edit')) {
          this.replaceWith('userActivity');
        }
      }

    });
  });
define("discourse/routes/user-topic-list", 
  ["discourse/mixins/viewing-action-type","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ViewingActionType = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend(ViewingActionType, {
      renderTemplate: function () {
        this.render('user-topics-list');
      },

      setupController: function (controller, model) {
        var userActionType = this.get('userActionType');
        this.controllerFor('user').set('userActionType', userActionType);
        this.controllerFor('user-activity').set('userActionType', userActionType);
        this.controllerFor('user-topics-list').setProperties({
          model: model,
          hideCategory: false,
          showParticipants: false
        });
      }
    });
  });
define("discourse/routes/user-activity-stream", 
  ["discourse/mixins/viewing-action-type","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ViewingActionType = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend(ViewingActionType, {
      model: function () {
        return this.modelFor("user").get("stream");
      },

      afterModel: function () {
        return this.modelFor("user").get("stream").filterBy(this.get("userActionType"));
      },

      renderTemplate: function () {
        this.render("user_stream");
      },

      setupController: function (controller, model) {
        controller.set("model", model);
        this.viewingActionType(this.get("userActionType"));
      },

      actions: {

        didTransition: function () {
          this.controllerFor("user-activity")._showFooter();
          return true;
        },

        removeBookmark: function (userAction) {
          var user = this.modelFor("user");
          Discourse.Post.updateBookmark(userAction.get("post_id"), false).then(function () {
            // remove the user action from the stream
            user.get("stream").remove(userAction);
            // update the counts
            user.get("stats").forEach(function (stat) {
              if (stat.get("action_type") === userAction.action_type) {
                stat.decrementProperty("count");
              }
            });
          });
        }

      }
    });
  });
define("discourse/routes/topic-from-params", 
  ["discourse/lib/url","discourse/models/draft","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];
    var Draft = __dependency2__["default"];

    // This route is used for retrieving a topic based on params
    __exports__["default"] = Discourse.Route.extend({

      // Avoid default model hook
      model: function (params) {
        return params;
      },

      setupController: function (controller, params) {
        params = params || {};
        params.track_visit = true;

        var self = this,
            topic = this.modelFor('topic'),
            postStream = topic.get('postStream'),
            topicController = this.controllerFor('topic'),
            topicProgressController = this.controllerFor('topic-progress'),
            composerController = this.controllerFor('composer');

        // I sincerely hope no topic gets this many posts
        if (params.nearPost === "last") {
          params.nearPost = 999999999;
        }

        params.forceLoad = true;

        postStream.refresh(params).then(function () {
          // TODO we are seeing errors where closest post is null and this is exploding
          // we need better handling and logging for this condition.

          // The post we requested might not exist. Let's find the closest post
          var closestPost = postStream.closestPostForPostNumber(params.nearPost || 1),
              closest = closestPost.get('post_number'),
              progress = postStream.progressIndexOfPost(closestPost);

          topicController.setProperties({
            'model.currentPost': closest,
            enteredAt: new Date().getTime().toString()
          });

          topicProgressController.setProperties({
            progressPosition: progress,
            expanded: false
          });

          // Highlight our post after the next render
          Ember.run.scheduleOnce('afterRender', function () {
            self.appEvents.trigger('post:highlight', closest);
          });
          DiscourseURL.jumpToPost(closest);

          if (!Ember.isEmpty(topic.get('draft'))) {
            composerController.open({
              draft: Draft.getLocal(topic.get('draft_key'), topic.get('draft')),
              draftKey: topic.get('draft_key'),
              draftSequence: topic.get('draft_sequence'),
              topic: topic,
              ignoreIfChanged: true
            });
          }
        }).catch(function (e) {
          Ember.warn('Could not view topic', e);
        });
      }

    });
  });
define("discourse/components/text-field", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.TextField.extend(_createDecoratedObject([{
      key: 'attributeBindings',
      initializer: function () {
        return ['autocorrect', 'autocapitalize', 'autofocus', 'maxLength'];
      }
    }, {
      key: 'placeholder',
      decorators: [computed("placeholderKey")],
      value: function (placeholderKey) {
        return placeholderKey ? I18n.t(placeholderKey) : "";
      }
    }]));
  });
define("discourse/components/visible", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      visibleChanged: (function () {
        this.rerender();
      }).observes("visible"),

      render: function (buffer) {
        if (this._state !== 'inDOM' && this._state !== 'preRender' && this._state !== 'inBuffer') {
          return;
        }
        if (!this.get("visible")) {
          return;
        }

        return this._super(buffer);
      }
    });
  });
define("discourse/components/conditional-loading-spinner", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      classNameBindings: ['containerClass', 'condition:visible'],

      containerClass: (function () {
        return this.get('size') === 'small' ? 'inline-spinner' : undefined;
      }).property('size'),

      render: function (buffer) {
        if (this.get('condition')) {
          buffer.push('<div class="spinner ' + this.get('size') + '"}}></div>');
        } else {
          return this._super(buffer);
        }
      },

      _conditionChanged: (function () {
        this.rerender();
      }).observes('condition')
    });
  });
define("discourse/helpers/user-avatar", 
  ["discourse/lib/helpers","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var registerUnbound = __dependency1__.registerUnbound;

    function renderAvatar(user, options) {
      options = options || {};

      if (user) {

        var username = Em.get(user, options.usernamePath || 'username');
        var avatarTemplate = Em.get(user, options.avatarTemplatePath || 'avatar_template');

        if (!username || !avatarTemplate) {
          return '';
        }

        var title = undefined;
        if (!options.ignoreTitle) {
          // first try to get a title
          title = Em.get(user, 'title');
          // if there was no title provided
          if (!title) {
            // try to retrieve a description
            var description = Em.get(user, 'description');
            // if a description has been provided
            if (description && description.length > 0) {
              // preprend the username before the description
              title = username + " - " + description;
            }
          }
        }

        return Discourse.Utilities.avatarImg({
          size: options.imageSize,
          extraClasses: Em.get(user, 'extras') || options.extraClasses,
          title: title || username,
          avatarTemplate: avatarTemplate
        });
      } else {
        return '';
      }
    }

    registerUnbound('avatar', function (user, params) {
      return new Handlebars.SafeString(renderAvatar.call(this, user, params));
    });

    __exports__.renderAvatar = renderAvatar;
  });
define("discourse/helpers/cold-age-class", 
  ["discourse/lib/helpers","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var registerUnbound = __dependency1__.registerUnbound;

    function daysSinceEpoch(dt) {
      // 1000 * 60 * 60 * 24 = days since epoch
      return dt.getTime() / 86400000;
    }

    registerUnbound('cold-age-class', function (dt, params) {
      var className = params['class'] || 'age';

      if (!dt) {
        return className;
      }

      var startDate = params.startDate || new Date();

      // Show heat on age
      var nowDays = daysSinceEpoch(startDate),
          epochDays = daysSinceEpoch(new Date(dt));

      if (nowDays - epochDays > Discourse.SiteSettings.cold_age_days_high) return className + ' coldmap-high';
      if (nowDays - epochDays > Discourse.SiteSettings.cold_age_days_medium) return className + ' coldmap-med';
      if (nowDays - epochDays > Discourse.SiteSettings.cold_age_days_low) return className + ' coldmap-low';

      return className;
    });

    __exports__.daysSinceEpoch = daysSinceEpoch;
  });
define("discourse/helpers/loading-spinner", 
  ["discourse/lib/helpers","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var htmlHelper = __dependency1__.htmlHelper;

    function renderSpinner(cssClass) {
      var html = "<div class='spinner";
      if (cssClass) {
        html += ' ' + cssClass;
      }
      return html + "'></div>";
    }
    var spinnerHTML = renderSpinner();

    __exports__["default"] = htmlHelper(function (params) {
      var hash = params.hash;
      return renderSpinner(hash && hash.size ? hash.size : undefined);
    });

    __exports__.spinnerHTML = spinnerHTML;
    __exports__.renderSpinner = renderSpinner;
  });
define("discourse/helpers/category-link", 
  ["discourse/lib/helpers","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    __exports__.categoryBadgeHTML = categoryBadgeHTML;
    __exports__.categoryLinkHTML = categoryLinkHTML;
    var registerUnbound = __dependency1__.registerUnbound;
    var iconHTML = __dependency2__.iconHTML;

    var get = Em.get,
        escapeExpression = Handlebars.Utils.escapeExpression;

    function categoryStripe(color, classes) {
      var style = color ? "style='background-color: #" + color + ";'" : "";
      return "<span class='" + classes + "' " + style + "></span>";
    }

    /**
      Generates category badge HTML

      @param {Object} category The category to generate the badge for.
      @param {Object} opts
        @param {String}  [opts.url] The url that we want the category badge to link to.
        @param {Boolean} [opts.allowUncategorized] If false, returns an empty string for the uncategorized category.
        @param {Boolean} [opts.link] If false, the category badge will not be a link.
        @param {Boolean} [opts.hideParaent] If true, parent category will be hidden in the badge.
    **/

    function categoryBadgeHTML(category, opts) {
      opts = opts || {};

      if (!category || !opts.allowUncategorized && Em.get(category, 'id') === Discourse.Site.currentProp("uncategorized_category_id") && Discourse.SiteSettings.suppress_uncategorized_badge) return "";

      var description = get(category, 'description_text'),
          restricted = get(category, 'read_restricted'),
          url = opts.url ? opts.url : Discourse.getURL("/c/") + Discourse.Category.slugFor(category),
          href = opts.link === false ? '' : url,
          tagName = opts.link === false || opts.link === "false" ? 'span' : 'a',
          extraClasses = opts.extraClasses ? ' ' + opts.extraClasses : '',
          color = get(category, 'color'),
          html = "",
          parentCat = null;

      if (!opts.hideParent) {
        parentCat = Discourse.Category.findById(get(category, 'parent_category_id'));
      }

      if (parentCat && parentCat !== category) {
        html += categoryStripe(get(parentCat, 'color'), "badge-category-parent-bg");
      }

      html += categoryStripe(color, "badge-category-bg");

      var classNames = "badge-category clear-badge";
      if (restricted) {
        classNames += " restricted";
      }

      var textColor = "#" + get(category, 'text_color');

      html += "<span" + ' style="color: ' + textColor + ';" ' + 'data-drop-close="true" class="' + classNames + '"' + (description ? 'title="' + escapeExpression(description) + '" ' : '') + ">";

      var name = escapeExpression(get(category, 'name'));

      if (restricted) {
        html += iconHTML('lock') + " " + name;
      } else {
        html += name;
      }
      html += "</span>";

      if (href) {
        href = " href='" + href + "' ";
      }

      extraClasses = Discourse.SiteSettings.category_style ? Discourse.SiteSettings.category_style + extraClasses : extraClasses;

      return "<" + tagName + " class='badge-wrapper " + extraClasses + "' " + href + ">" + html + "</" + tagName + ">";
    }

    function categoryLinkHTML(category, options) {
      var categoryOptions = {};

      // TODO: This is a compatibility layer with the old helper structure.
      // Can be removed once we migrate to `registerUnbound` fully
      if (options && options.hash) {
        options = options.hash;
      }

      if (options) {
        if (options.allowUncategorized) {
          categoryOptions.allowUncategorized = true;
        }
        if (options.link !== undefined) {
          categoryOptions.link = options.link;
        }
        if (options.extraClasses) {
          categoryOptions.extraClasses = options.extraClasses;
        }
        if (options.hideParent) {
          categoryOptions.hideParent = true;
        }
      }
      return new Handlebars.SafeString(categoryBadgeHTML(category, categoryOptions));
    }

    registerUnbound('category-link', categoryLinkHTML);
  });
define("discourse/lib/export-result", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.outputExportResult = outputExportResult;

    function outputExportResult(result) {
      if (result.success) {
        bootbox.alert(I18n.t("admin.export_csv.success"));
      } else {
        bootbox.alert(I18n.t("admin.export_csv.failed"));
      }
    }
  });
define("discourse/lib/autosize", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var set = typeof Set === "function" ? new Set() : (function () {
    	var list = [];

    	return {
    		has: function (key) {
    			return Boolean(list.indexOf(key) > -1);
    		},
    		add: function (key) {
    			list.push(key);
    		},
    		delete: function (key) {
    			list.splice(list.indexOf(key), 1);
    		}
    	};
    })();

    function assign(ta) {
    	var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    	var _ref$setOverflowX = _ref.setOverflowX;
    	var setOverflowX = _ref$setOverflowX === undefined ? true : _ref$setOverflowX;
    	var _ref$setOverflowY = _ref.setOverflowY;
    	var setOverflowY = _ref$setOverflowY === undefined ? true : _ref$setOverflowY;

    	if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || set.has(ta)) return;

    	var heightOffset = null;
    	var overflowY = null;
    	var clientWidth = ta.clientWidth;

    	function init() {
    		var style = window.getComputedStyle(ta, null);

    		overflowY = style.overflowY;

    		if (style.resize === 'vertical') {
    			ta.style.resize = 'none';
    		} else if (style.resize === 'both') {
    			ta.style.resize = 'horizontal';
    		}

    		if (style.boxSizing === 'content-box') {
    			heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
    		} else {
    			heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
    		}
    		// Fix when a textarea is not on document body and heightOffset is Not a Number
    		if (isNaN(heightOffset)) {
    			heightOffset = 0;
    		}

    		update();
    	}

    	function changeOverflow(value) {
    		{
    			// Chrome/Safari-specific fix:
    			// When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
    			// made available by removing the scrollbar. The following forces the necessary text reflow.
    			var width = ta.style.width;
    			ta.style.width = '0px';
    			// Force reflow:
    			/* jshint ignore:start */
    			ta.offsetWidth;
    			/* jshint ignore:end */
    			ta.style.width = width;
    		}

    		overflowY = value;

    		if (setOverflowY) {
    			ta.style.overflowY = value;
    		}

    		resize();
    	}

    	function resize() {
    		var htmlTop = window.pageYOffset;
    		var bodyTop = document.body.scrollTop;
    		var originalHeight = ta.style.height;

    		ta.style.height = 'auto';

    		var endHeight = ta.scrollHeight + heightOffset;

    		if (ta.scrollHeight === 0) {
    			// If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
    			ta.style.height = originalHeight;
    			return;
    		}

    		ta.style.height = endHeight + 'px';

    		// used to check if an update is actually necessary on window.resize
    		clientWidth = ta.clientWidth;

    		// prevents scroll-position jumping
    		document.documentElement.scrollTop = htmlTop;
    		document.body.scrollTop = bodyTop;
    	}

    	function update() {
    		var startHeight = ta.style.height;

    		resize();

    		var style = window.getComputedStyle(ta, null);

    		if (style.height !== ta.style.height) {
    			if (overflowY !== 'visible') {
    				changeOverflow('visible');
    			}
    		} else {
    			if (overflowY !== 'hidden') {
    				changeOverflow('hidden');
    			}
    		}

    		if (startHeight !== ta.style.height) {
    			var evt = document.createEvent('Event');
    			evt.initEvent('autosize:resized', true, false);
    			ta.dispatchEvent(evt);
    		}
    	}

    	var pageResize = function () {
    		if (ta.clientWidth !== clientWidth) {
    			update();
    		}
    	};

    	var destroy = (function (style) {
    		window.removeEventListener('resize', pageResize, false);
    		ta.removeEventListener('input', update, false);
    		ta.removeEventListener('keyup', update, false);
    		ta.removeEventListener('autosize:destroy', destroy, false);
    		ta.removeEventListener('autosize:update', update, false);
    		set.delete(ta);

    		Object.keys(style).forEach(function (key) {
    			ta.style[key] = style[key];
    		});
    	}).bind(ta, {
    		height: ta.style.height,
    		resize: ta.style.resize,
    		overflowY: ta.style.overflowY,
    		overflowX: ta.style.overflowX,
    		wordWrap: ta.style.wordWrap
    	});

    	ta.addEventListener('autosize:destroy', destroy, false);

    	// IE9 does not fire onpropertychange or oninput for deletions,
    	// so binding to onkeyup to catch most of those events.
    	// There is no way that I know of to detect something like 'cut' in IE9.
    	if ('onpropertychange' in ta && 'oninput' in ta) {
    		ta.addEventListener('keyup', update, false);
    	}

    	window.addEventListener('resize', pageResize, false);
    	ta.addEventListener('input', update, false);
    	ta.addEventListener('autosize:update', update, false);
    	set.add(ta);

    	if (setOverflowX) {
    		ta.style.overflowX = 'hidden';
    		ta.style.wordWrap = 'break-word';
    	}

    	init();
    }

    function exportDestroy(ta) {
    	if (!(ta && ta.nodeName && ta.nodeName === 'TEXTAREA')) return;
    	var evt = document.createEvent('Event');
    	evt.initEvent('autosize:destroy', true, false);
    	ta.dispatchEvent(evt);
    }

    function exportUpdate(ta) {
    	if (!(ta && ta.nodeName && ta.nodeName === 'TEXTAREA')) return;
    	var evt = document.createEvent('Event');
    	evt.initEvent('autosize:update', true, false);
    	ta.dispatchEvent(evt);
    }

    var autosize = function (el, options) {
    	if (el) {
    		Array.prototype.forEach.call(el.length ? el : [el], function (x) {
    			return assign(x, options);
    		});
    	}
    	return el;
    };
    autosize.destroy = function (el) {
    	if (el) {
    		Array.prototype.forEach.call(el.length ? el : [el], exportDestroy);
    	}
    	return el;
    };
    autosize.update = function (el) {
    	if (el) {
    		Array.prototype.forEach.call(el.length ? el : [el], exportUpdate);
    	}
    	return el;
    };

    __exports__["default"] = autosize;
  });
define("discourse/lib/binary-search", 
  ["exports"],
  function(__exports__) {
    "use strict";


    __exports__["default"] = binarySearch;
    // The binarySearch() function is licensed under the UNLICENSE
    // https://github.com/Olical/binary-search

    // Modified for use in Discourse

    function binarySearch(list, target, keyProp) {
      var min = 0;
      var max = list.length - 1;
      var guess;
      var keyProperty = keyProp || "id";

      while (min <= max) {
        guess = Math.floor((min + max) / 2);

        if (Em.get(list[guess], keyProperty) === target) {
          return guess;
        } else {
          if (Em.get(list[guess], keyProperty) < target) {
            min = guess + 1;
          } else {
            max = guess - 1;
          }
        }
      }

      return -Math.floor((min + max) / 2);
    }
  });
define("discourse/lib/category-hashtags", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.replaceSpan = replaceSpan;
    __exports__.categoryHashtagTriggerRule = categoryHashtagTriggerRule;
    var SEPARATOR = ":";

    __exports__.SEPARATOR = SEPARATOR;

    function replaceSpan($elem, categorySlug, categoryLink) {
      $elem.replaceWith("<a href=\"" + categoryLink + "\" class=\"hashtag\">#<span>" + categorySlug + "</span></a>");
    }

    ;

    function categoryHashtagTriggerRule(textarea, opts) {
      var result = Discourse.Utilities.caretRowCol(textarea);
      var row = result.rowNum;
      var col = result.colNum;
      var line = textarea.value.split("\n")[row - 1];

      if (opts && opts.backSpace) {
        col = col - 1;
        line = line.slice(0, line.length - 1);

        // Don't trigger autocomplete when backspacing into a `#category |` => `#category|`
        if (/^#{1}\w+/.test(line)) return false;
      }

      if (col < 6) {
        // Don't trigger autocomplete when ATX-style headers are used
        return line.slice(0, col) !== "#".repeat(col);
      } else {
        return true;
      }
    }
  });
define("discourse/lib/category-tag-search", 
  ["discourse/lib/autocomplete","discourse/models/category","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    __exports__.search = search;
    var CANCELLED_STATUS = __dependency1__.CANCELLED_STATUS;
    var Category = __dependency2__["default"];

    var cache = {};
    var cacheTime;
    var oldSearch;

    function updateCache(term, results) {
      cache[term] = results;
      cacheTime = new Date();
      return results;
    }

    function searchTags(term, categories, limit) {
      return new Ember.RSVP.Promise(function (resolve) {
        var clearPromise = setTimeout(function () {
          resolve(CANCELLED_STATUS);
        }, 5000);

        var debouncedSearch = _.debounce(function (q, cats, resultFunc) {
          oldSearch = $.ajax(Discourse.getURL("/tags/filter/search"), {
            type: 'GET',
            cache: true,
            data: { limit: limit, q: q }
          });

          var returnVal = CANCELLED_STATUS;

          oldSearch.then(function (r) {
            var tags = r.results.map(function (tag) {
              return { text: tag.text, count: tag.count };
            });
            returnVal = cats.concat(tags);
          }).always(function () {
            oldSearch = null;
            resultFunc(returnVal);
          });
        }, 300);

        debouncedSearch(term, categories, function (result) {
          clearTimeout(clearPromise);
          resolve(updateCache(term, result));
        });
      });
    };

    function search(term, siteSettings) {
      if (oldSearch) {
        oldSearch.abort();
        oldSearch = null;
      }

      if (new Date() - cacheTime > 30000) cache = {};
      var cached = cache[term];
      if (cached) return cached;

      var limit = 5;
      var categories = Category.search(term, { limit: limit });
      var numOfCategories = categories.length;
      categories = categories.map(function (category) {
        return { model: category };
      });

      if (numOfCategories !== limit && siteSettings.tagging_enabled) {
        return searchTags(term, categories, limit - numOfCategories);
      } else {
        return updateCache(term, categories);
      }
    }

    ;
  });
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

Discourse.CensoredWords = {
  censor: function(text) {
    var censorRegexp,
        censored = Discourse.SiteSettings.censored_words;

    if (censored && censored.length) {
      if (!censorRegexp) {
        var split = censored.split("|");
        if (split && split.length) {
          censorRegexp = new RegExp("\\b(?:" + split.map(function (t) { return "(" + t.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&') + ")"; }).join("|") + ")\\b", "ig");
        }
      }
      if (censorRegexp) {
        var m = censorRegexp.exec(text);
        while (m && m[0]) {
          var replacement = new Array(m[0].length+1).join('&#9632;');
          text = text.replace(new RegExp("\\b" + m[0] + "\\b", "ig"), replacement);
          m = censorRegexp.exec(text);
        }

      }
    }
    return text;
  }
};


// IIFE Wrapped Content Ends

 })(this);
define("discourse/lib/click-track", 
  ["discourse/lib/url","discourse/lib/intercept-click","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    __exports__.isValidLink = isValidLink;
    var DiscourseURL = __dependency1__["default"];
    var wantsNewWindow = __dependency2__.wantsNewWindow;

    function isValidLink($link) {
      return $link.hasClass("track-link") || $link.closest('.hashtag,.badge-category,.onebox-result,.onebox-body').length === 0;
    }

    ;

    __exports__["default"] = {
      trackClick: function (e) {
        // cancel click if triggered as part of selection.
        if (Discourse.Utilities.selectedText() !== "") {
          return false;
        }

        var $link = $(e.currentTarget);

        // don't track lightboxes, group mentions or links with disabled tracking
        if ($link.hasClass('lightbox') || $link.hasClass('mention-group') || $link.hasClass('no-track-link') || $link.hasClass('hashtag')) {
          return true;
        }

        // don't track links in quotes or in elided part
        if ($link.parents('aside.quote,.elided').length) {
          return true;
        }

        var href = $link.attr('href') || $link.data('href'),
            $article = $link.closest('article,.excerpt,#revisions'),
            postId = $article.data('post-id'),
            topicId = $('#topic').data('topic-id') || $article.data('topic-id'),
            userId = $link.data('user-id');

        if (!href || href.trim().length === 0) {
          return false;
        }
        if (href.indexOf("mailto:") === 0) {
          return true;
        }

        if (!userId) userId = $article.data('user-id');

        var ownLink = userId && userId === Discourse.User.currentProp('id'),
            trackingUrl = Discourse.getURL("/clicks/track?url=" + encodeURIComponent(href));
        if (postId && !$link.data('ignore-post-id')) {
          trackingUrl += "&post_id=" + encodeURI(postId);
        }
        if (topicId) {
          trackingUrl += "&topic_id=" + encodeURI(topicId);
        }

        // Update badge clicks unless it's our own
        if (!ownLink) {
          var $badge = $('span.badge', $link);
          if ($badge.length === 1) {
            // don't update counts in category badge nor in oneboxes (except when we force it)
            if (isValidLink($link)) {
              var html = $badge.html();
              if (/^\d+$/.test(html)) {
                $badge.html(parseInt(html, 10) + 1);
              }
            }
          }
        }

        // If they right clicked, change the destination href
        if (e.which === 3) {
          var destination = Discourse.SiteSettings.track_external_right_clicks ? trackingUrl : href;
          $link.attr('href', destination);
          return true;
        }

        // if they want to open in a new tab, do an AJAX request
        if (wantsNewWindow(e)) {
          Discourse.ajax("/clicks/track", {
            data: {
              url: href,
              post_id: postId,
              topic_id: topicId,
              redirect: false
            },
            dataType: 'html'
          });
          return true;
        }

        e.preventDefault();

        // We don't track clicks on quote back buttons
        if ($link.hasClass('back') || $link.hasClass('quote-other-topic')) {
          return true;
        }

        // Remove the href, put it as a data attribute
        if (!$link.data('href')) {
          $link.addClass('no-href');
          $link.data('href', $link.attr('href'));
          $link.attr('href', null);
          // Don't route to this URL
          $link.data('auto-route', true);
        }

        // restore href
        setTimeout(function () {
          $link.removeClass('no-href');
          $link.attr('href', $link.data('href'));
          $link.data('href', null);
        }, 50);

        // warn the user if they can't download the file
        if (Discourse.SiteSettings.prevent_anons_from_downloading_files && $link.hasClass("attachment") && !Discourse.User.current()) {
          bootbox.alert(I18n.t("post.errors.attachment_download_requires_login"));
          return false;
        }

        // If we're on the same site, use the router and track via AJAX
        if (DiscourseURL.isInternal(href) && !$link.hasClass('attachment')) {
          Discourse.ajax("/clicks/track", {
            data: {
              url: href,
              post_id: postId,
              topic_id: topicId,
              redirect: false
            },
            dataType: 'html'
          });
          DiscourseURL.routeTo(href);
          return false;
        }

        // Otherwise, use a custom URL with a redirect
        if (Discourse.User.currentProp('external_links_in_new_tab')) {
          var win = window.open(trackingUrl, '_blank');
          win.focus();
        } else {
          DiscourseURL.redirectTo(trackingUrl);
        }

        return false;
      }
    };
  });
define("discourse/lib/copy-text", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
     * Copy text to the clipboard. Must be called from within a user gesture (Chrome).
     */

    __exports__["default"] = function (text, element) {
      var supported = false;
      try {
        // Chrome: This only returns true within a user gesture.
        // Chrome: queryCommandEnabled() only returns true if a selection is
        //   present, so we use queryCommandSupported() instead for the fail-fast.
        if (document.queryCommandSupported('copy')) {
          supported = true;
        }
      } catch (e) {
        // Ignore
      }
      if (!supported) {
        return;
      }

      var newRange = document.createRange();
      newRange.selectNode(element);
      var selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(newRange);

      try {
        if (document.execCommand("copy")) {
          return true;
        }
      } catch (e) {
        // Ignore
      }
      return false;
    }
  });
define("discourse/lib/decimal-adjust", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor

    __exports__["default"] = function (type, value, exp) {
      // If the exp is undefined or zero...
      if (typeof exp === 'undefined' || +exp === 0) {
        return Math[type](value);
      }
      value = +value;
      exp = +exp;
      // If the value is not a number or the exp is not an integer...
      if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
        return NaN;
      }
      // Shift
      value = value.toString().split('e');
      value = Math[type](+(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp)));
      // Shift back
      value = value.toString().split('e');
      return +(value[0] + 'e' + (value[1] ? +value[1] + exp : exp));
    }
  });
define("discourse/lib/desktop-notifications", 
  ["discourse/lib/url","discourse/lib/key-value-store","discourse/lib/page-tracker","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];
    var KeyValueStore = __dependency2__["default"];
    var onPageChange = __dependency3__.onPageChange;

    var primaryTab = false;
    var liveEnabled = false;
    var havePermission = null;
    var mbClientId = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx";
    var lastAction = -1;

    var focusTrackerKey = "focus-tracker";
    var idleThresholdTime = 1000 * 10; // 10 seconds

    var context = "discourse_desktop_notifications_";
    var keyValueStore = new KeyValueStore(context);

    // Called from an initializer
    function init(messageBus) {
      liveEnabled = false;
      mbClientId = messageBus.clientId;

      if (!Discourse.User.current()) {
        return;
      }

      try {
        keyValueStore.getItem(focusTrackerKey);
      } catch (e) {
        Em.Logger.info('Discourse desktop notifications are disabled - localStorage denied.');
        return;
      }

      if (!("Notification" in window)) {
        Em.Logger.info('Discourse desktop notifications are disabled - not supported by browser');
        return;
      }

      try {
        if (Notification.permission === "granted") {
          havePermission = true;
        } else if (Notification.permission === "denied") {
          havePermission = false;
          return;
        }
      } catch (e) {
        Em.Logger.warn('Unexpected error, Notification is defined on window but not a responding correctly ' + e);
      }

      liveEnabled = true;
      try {
        // Preliminary checks passed, continue with setup
        setupNotifications();
      } catch (e) {
        Em.Logger.error(e);
      }
    }

    // This function is only called if permission was granted
    function setupNotifications() {

      window.addEventListener("storage", function (e) {
        // note: This event only fires when other tabs setItem()
        var key = e.key;
        if (key !== '' + context + focusTrackerKey) {
          return true;
        }
        primaryTab = false;
      });

      window.addEventListener("focus", function () {
        if (!primaryTab) {
          primaryTab = true;
          keyValueStore.setItem(focusTrackerKey, mbClientId);
        }
      });

      if (document && typeof document.hidden !== "undefined" && document["hidden"]) {
        primaryTab = false;
      } else {
        primaryTab = true;
        keyValueStore.setItem(focusTrackerKey, mbClientId);
      }

      if (document) {
        document.addEventListener("scroll", resetIdle);
      }

      onPageChange(resetIdle);
    }

    function resetIdle() {
      lastAction = Date.now();
    }
    function isIdle() {
      return lastAction + idleThresholdTime < Date.now();
    }

    // Call-in point from message bus
    function onNotification(data) {
      if (!liveEnabled) {
        return;
      }
      if (!primaryTab) {
        return;
      }
      if (!isIdle()) {
        return;
      }
      if (keyValueStore.getItem('notifications-disabled')) {
        return;
      }

      var notificationTitle = I18n.t(i18nKey(data.notification_type), {
        site_title: Discourse.SiteSettings.title,
        topic: data.topic_title,
        username: data.username
      });

      var notificationBody = data.excerpt;
      var notificationIcon = Discourse.SiteSettings.logo_small_url || Discourse.SiteSettings.logo_url;
      var notificationTag = "discourse-notification-" + Discourse.SiteSettings.title + "-" + data.topic_id;

      requestPermission().then(function () {
        // This shows the notification!
        var notification = new Notification(notificationTitle, {
          body: notificationBody,
          icon: notificationIcon,
          tag: notificationTag
        });

        function clickEventHandler() {
          DiscourseURL.routeTo(data.post_url);
          // Cannot delay this until the page renders
          // due to trigger-based permissions
          window.focus();
        }

        notification.addEventListener('click', clickEventHandler);
        setTimeout(function () {
          notification.close();
          notification.removeEventListener('click', clickEventHandler);
        }, 10 * 1000);
      });
    }

    // Utility function
    // Wraps Notification.requestPermission in a Promise
    function requestPermission() {
      if (havePermission === true) {
        return Ember.RSVP.resolve();
      } else if (havePermission === false) {
        return Ember.RSVP.reject();
      } else {
        return new Ember.RSVP.Promise(function (resolve, reject) {
          Notification.requestPermission(function (status) {
            if (status === "granted") {
              resolve();
            } else {
              reject();
            }
          });
        });
      }
    }

    function i18nKey(notification_type) {
      return "notifications.popup." + Discourse.Site.current().get("notificationLookup")[notification_type];
    }

    // Exported for controllers/notification.js.es6

    __exports__.init = init;
    __exports__.onNotification = onNotification;
  });
define("discourse/lib/discourse-location", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
    @module Discourse
    */

    var get = Ember.get,
        set = Ember.set;
    var popstateFired = false;
    var supportsHistoryState = window.history && 'state' in window.history;

    var popstateCallbacks = [];

    /**
      `Ember.DiscourseLocation` implements the location API using the browser's
      `history.pushState` API.

      @class DiscourseLocation
      @namespace Discourse
      @extends Ember.Object
    */
    var DiscourseLocation = Ember.Object.extend({

      init: function () {
        set(this, 'location', get(this, 'location') || window.location);
        this.initState();
      },

      /**
        @private
         Used to set state on first call to setURL
         @method initState
      */
      initState: function () {
        var history = get(this, 'history') || window.history;
        if (history && history.scrollRestoration) {
          history.scrollRestoration = "manual";
        }

        set(this, 'history', history);

        var url = this.formatURL(this.getURL());
        var loc = get(this, 'location');

        if (loc && loc.hash) {
          url += loc.hash;
        }

        this.replaceState(url);
      },

      /**
        Will be pre-pended to path upon state change
         @property rootURL
        @default '/'
      */
      rootURL: '/',

      /**
        @private
         Returns the current `location.pathname` without rootURL
         @method getURL
      */
      getURL: function () {
        var location = get(this, 'location');
        var url = location.pathname;

        url = url.replace(Discourse.BaseUri, '');

        var search = location.search || '';
        url += search;

        return url;
      },

      /**
        @private
         Uses `history.pushState` to update the url without a page reload.
         @method setURL
        @param path {String}
      */
      setURL: function (path) {
        var state = this.getState();
        path = this.formatURL(path);

        if (state && state.path !== path) {
          this.pushState(path);
        }
      },

      /**
        @private
         Uses `history.replaceState` to update the url without a page reload
        or history modification.
         @method replaceURL
        @param path {String}
      */
      replaceURL: function (path) {
        var state = this.getState();
        path = this.formatURL(path);

        if (state && state.path !== path) {
          this.replaceState(path);
        }
      },

      /**
       @private
        Get the current `history.state`
       Polyfill checks for native browser support and falls back to retrieving
       from a private _historyState constiable
        @method getState
      */
      getState: function () {
        return supportsHistoryState ? get(this, 'history').state : this._historyState;
      },

      /**
       @private
        Pushes a new state
        @method pushState
       @param path {String}
      */
      pushState: function (path) {
        var state = { path: path };

        // store state if browser doesn't support `history.state`
        if (!supportsHistoryState) {
          this._historyState = state;
        } else {
          get(this, 'history').pushState(state, null, path);
        }

        // used for webkit workaround
        this._previousURL = this.getURL();
      },

      /**
       @private
        Replaces the current state
        @method replaceState
       @param path {String}
      */
      replaceState: function (path) {
        var state = { path: path };

        // store state if browser doesn't support `history.state`
        if (!supportsHistoryState) {
          this._historyState = state;
        } else {
          get(this, 'history').replaceState(state, null, path);
        }

        // used for webkit workaround
        this._previousURL = this.getURL();
      },

      /**
        @private
         Register a callback to be invoked whenever the browser
        history changes, including using forward and back buttons.
         @method onUpdateURL
        @param callback {Function}
      */
      onUpdateURL: function (callback) {
        var guid = Ember.guidFor(this),
            self = this;

        Ember.$(window).on('popstate.ember-location-' + guid, function () {
          // Ignore initial page load popstate event in Chrome
          if (!popstateFired) {
            popstateFired = true;
            if (self.getURL() === self._previousURL) {
              return;
            }
          }
          var url = self.getURL();
          popstateCallbacks.forEach(function (cb) {
            cb(url);
          });
          callback(url);
        });
      },

      /**
        @private
         Used when using `{{action}}` helper.  The url is always appended to the rootURL.
         @method formatURL
        @param url {String}
      */
      formatURL: function (url) {
        var rootURL = get(this, 'rootURL');

        if (url !== '') {
          rootURL = rootURL.replace(/\/$/, '');

          if (rootURL.length > 0 && url.indexOf(rootURL + "/") === 0) {
            rootURL = "";
          }
        }

        return rootURL + url;
      },

      willDestroy: function () {
        var guid = Ember.guidFor(this);

        Ember.$(window).off('popstate.ember-location-' + guid);
      }

    });

    __exports__["default"] = DiscourseLocation;
  });
define("discourse/lib/highlight-syntax", 
  ["discourse/lib/load-script","exports"],
  function(__dependency1__, __exports__) {
    "use strict";


    __exports__["default"] = highlightSyntax;
    /*global hljs:true */

    var loadScript = __dependency1__["default"];
    function highlightSyntax($elem) {
      var selector = Discourse.SiteSettings.autohighlight_all_code ? 'pre code' : 'pre code[class]',
          path = Discourse.HighlightJSPath;

      if (!path) {
        return;
      }

      $(selector, $elem).each(function (i, e) {
        $(e).removeClass('lang-auto');
        loadScript(path).then(function () {
          return hljs.highlightBlock(e);
        });
      });
    }
  });
define("discourse/lib/intercept-click", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.wantsNewWindow = wantsNewWindow;

    __exports__["default"] = interceptClick;
    var DiscourseURL = __dependency1__["default"];

    function wantsNewWindow(e) {
      return e.isDefaultPrevented() || e.shiftKey || e.metaKey || e.ctrlKey || e.button && e.button !== 0;
    }

    /**
      Discourse does some server side rendering of HTML, such as the `cooked` contents of
      posts. The downside of this in an Ember app is the links will not go through the router.
      This jQuery code intercepts clicks on those links and routes them properly.
    **/
    function interceptClick(e) {
      if (wantsNewWindow(e)) {
        return;
      }

      var $currentTarget = $(e.currentTarget),
          href = $currentTarget.attr('href');

      if (!href || href === '#' || $currentTarget.attr('target') || $currentTarget.data('ember-action') || $currentTarget.data('auto-route') || $currentTarget.data('share-url') || $currentTarget.data('user-card') || $currentTarget.hasClass('widget-link') || $currentTarget.hasClass('mention') || !$currentTarget.hasClass('d-link') && $currentTarget.hasClass('ember-view') || $currentTarget.hasClass('lightbox') || href.indexOf("mailto:") === 0 || href.match(/^http[s]?:\/\//i) && !href.match(new RegExp("^http:\\/\\/" + window.location.hostname, "i"))) {
        return;
      }

      e.preventDefault();
      DiscourseURL.routeTo(href);
      return false;
    }
  });
define("discourse/lib/is-element-in-viewport", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = function (element) {
          if (element instanceof jQuery) {
                element = element[0];
          }

          var $window = $(window),
              rect = element.getBoundingClientRect();

          return rect.top >= 0 && rect.left >= 0 && rect.bottom <= $window.height() && rect.right <= $window.width();
    }
  });
define("discourse/lib/keyboard-shortcuts", 
  ["discourse/lib/url","discourse/models/composer","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];
    var Composer = __dependency2__["default"];

    var bindings = {
      '!': { postAction: 'showFlags' },
      '#': { handler: 'toggleProgress', anonymous: true },
      '/': { handler: 'toggleSearch', anonymous: true },
      '=': { handler: 'toggleHamburgerMenu', anonymous: true },
      '?': { handler: 'showHelpModal', anonymous: true },
      '.': { click: '.alert.alert-info.clickable', anonymous: true }, // show incoming/updated topics
      'b': { handler: 'toggleBookmark' },
      'c': { handler: 'createTopic' },
      'ctrl+f': { handler: 'showPageSearch', anonymous: true },
      'command+f': { handler: 'showPageSearch', anonymous: true },
      'd': { postAction: 'deletePost' },
      'e': { postAction: 'editPost' },
      'end': { handler: 'goToLastPost', anonymous: true },
      'f': { handler: 'toggleBookmarkTopic' },
      'g h': { path: '/', anonymous: true },
      'g l': { path: '/latest', anonymous: true },
      'g n': { path: '/new' },
      'g u': { path: '/unread' },
      'g c': { path: '/categories', anonymous: true },
      'g t': { path: '/top', anonymous: true },
      'g b': { path: '/bookmarks' },
      'g p': { path: '/my/activity' },
      'g m': { path: '/my/messages' },
      'home': { handler: 'goToFirstPost', anonymous: true },
      'j': { handler: 'selectDown', anonymous: true },
      'k': { handler: 'selectUp', anonymous: true },
      'l': { click: '.topic-post.selected button.toggle-like' },
      'm m': { click: 'div.notification-options li[data-id="0"] a' }, // mark topic as muted
      'm r': { click: 'div.notification-options li[data-id="1"] a' }, // mark topic as regular
      'm t': { click: 'div.notification-options li[data-id="2"] a' }, // mark topic as tracking
      'm w': { click: 'div.notification-options li[data-id="3"] a' }, // mark topic as watching
      'o,enter': { click: '.topic-list tr.selected a.title', anonymous: true }, // open selected topic
      'p': { handler: 'showCurrentUser' },
      'q': { handler: 'quoteReply' },
      'r': { postAction: 'replyToPost' },
      's': { click: '.topic-post.selected a.post-date', anonymous: true }, // share post
      'shift+j': { handler: 'nextSection', anonymous: true },
      'shift+k': { handler: 'prevSection', anonymous: true },
      'shift+p': { handler: 'pinUnpinTopic' },
      'shift+r': { handler: 'replyToTopic' },
      'shift+s': { click: '#topic-footer-buttons button.share', anonymous: true }, // share topic
      'shift+z shift+z': { handler: 'logout' },
      't': { postAction: 'replyAsNewTopic' },
      'u': { handler: 'goBack', anonymous: true },
      'x r': { click: '#dismiss-new,#dismiss-new-top,#dismiss-posts,#dismiss-posts-top' }, // dismiss new/posts
      'x t': { click: '#dismiss-topics,#dismiss-topics-top' } // dismiss topics
    };

    __exports__["default"] = {
      bindEvents: function (keyTrapper, container) {
        var _this = this;

        this.keyTrapper = keyTrapper;
        this.container = container;
        this._stopCallback();

        this.searchService = this.container.lookup('search-service:main');
        this.appEvents = this.container.lookup('app-events:main');
        this.currentUser = this.container.lookup('current-user:main');

        Object.keys(bindings).forEach(function (key) {
          var binding = bindings[key];
          if (!binding.anonymous && !_this.currentUser) {
            return;
          }

          if (binding.path) {
            _this._bindToPath(binding.path, key);
          } else if (binding.handler) {
            _this._bindToFunction(binding.handler, key);
          } else if (binding.postAction) {
            _this._bindToSelectedPost(binding.postAction, key);
          } else if (binding.click) {
            _this._bindToClick(binding.click, key);
          }
        });
      },

      toggleBookmark: function () {
        this.sendToSelectedPost('toggleBookmark');
        this.sendToTopicListItemView('toggleBookmark');
      },

      toggleBookmarkTopic: function () {
        var topic = this.currentTopic();
        // BIG hack, need a cleaner way
        if (topic && $('.posts-wrapper').length > 0) {
          topic.toggleBookmark();
        } else {
          this.sendToTopicListItemView('toggleBookmark');
        }
      },

      logout: function () {
        this.container.lookup('route:application').send('logout');
      },

      quoteReply: function () {
        this.sendToSelectedPost("replyToPost");
        // lazy but should work for now
        setTimeout(function () {
          $('.d-editor .quote').click();
        }, 500);
      },

      goToFirstPost: function () {
        this._jumpTo('jumpTop');
      },

      goToLastPost: function () {
        this._jumpTo('jumpBottom');
      },

      _jumpTo: function (direction) {
        if ($('.container.posts').length) {
          this.container.lookup('controller:topic-progress').send(direction);
        }
      },

      replyToTopic: function () {
        this._replyToPost();
      },

      selectDown: function () {
        this._moveSelection(1);
      },

      selectUp: function () {
        this._moveSelection(-1);
      },

      goBack: function () {
        history.back();
      },

      nextSection: function () {
        this._changeSection(1);
      },

      prevSection: function () {
        this._changeSection(-1);
      },

      showPageSearch: function (event) {
        var _this2 = this;

        Ember.run(function () {
          _this2.appEvents.trigger('header:keyboard-trigger', { type: 'page-search', event: event });
        });
      },

      createTopic: function () {
        this.container.lookup('controller:composer').open({ action: Composer.CREATE_TOPIC, draftKey: Composer.CREATE_TOPIC });
      },

      pinUnpinTopic: function () {
        this.container.lookup('controller:topic').togglePinnedState();
      },

      toggleProgress: function () {
        this.container.lookup('controller:topic-progress').send('toggleExpansion', { highlight: true });
      },

      toggleSearch: function (event) {
        this.appEvents.trigger('header:keyboard-trigger', { type: 'search', event: event });
      },

      toggleHamburgerMenu: function (event) {
        this.appEvents.trigger('header:keyboard-trigger', { type: 'hamburger', event: event });
      },

      showCurrentUser: function (event) {
        this.appEvents.trigger('header:keyboard-trigger', { type: 'user', event: event });
      },

      showHelpModal: function () {
        this.container.lookup('controller:application').send('showKeyboardShortcutsHelp');
      },

      sendToTopicListItemView: function (action) {
        var elem = $('tr.selected.topic-list-item.ember-view')[0];
        if (elem) {
          var view = Ember.View.views[elem.id];
          view.send(action);
        }
      },

      currentTopic: function () {
        var topicController = this.container.lookup('controller:topic');
        if (topicController) {
          var topic = topicController.get('model');
          if (topic) {
            return topic;
          }
        }
      },

      sendToSelectedPost: function (action) {
        var container = this.container;
        // TODO: We should keep track of the post without a CSS class
        var selectedPostId = parseInt($('.topic-post.selected article.boxed').data('post-id'), 10);
        if (selectedPostId) {
          var topicController = container.lookup('controller:topic');
          var post = topicController.get('model.postStream.posts').findBy('id', selectedPostId);
          if (post) {
            // TODO: Use ember closure actions
            var actionMethod = topicController._actions[action];
            if (!actionMethod) {
              var topicRoute = container.lookup('route:topic');
              actionMethod = topicRoute._actions[action];
            }

            var result = actionMethod.call(topicController, post);
            if (result && result.then) {
              this.appEvents.trigger('post-stream:refresh', { id: selectedPostId });
            }
          }
        }
      },

      _bindToSelectedPost: function (action, binding) {
        var _this3 = this;

        this.keyTrapper.bind(binding, function () {
          return _this3.sendToSelectedPost(action);
        });
      },

      _bindToPath: function (path, key) {
        this.keyTrapper.bind(key, function () {
          return DiscourseURL.routeTo(path);
        });
      },

      _bindToClick: function (selector, binding) {
        binding = binding.split(',');
        this.keyTrapper.bind(binding, function (e) {
          var $sel = $(selector);

          // Special case: We're binding to enter.
          if (e && e.keyCode === 13) {
            // Binding to enter should only be effective when there is something
            // to select.
            if ($sel.length === 0) {
              return;
            }

            // If effective, prevent default.
            e.preventDefault();
          }
          $sel.click();
        });
      },

      _bindToFunction: function (func, binding) {
        if (typeof this[func] === 'function') {
          this.keyTrapper.bind(binding, _.bind(this[func], this));
        }
      },

      _moveSelection: function (direction) {
        var $articles = this._findArticles();

        if (typeof $articles === 'undefined') {
          return;
        }

        var $selected = $articles.filter('.selected');
        var index = $articles.index($selected);

        if ($selected.length !== 0) {
          //boundries check
          // loop is not allowed
          if (direction === -1 && index === 0) {
            return;
          }
          if (direction === 1 && index === $articles.size() - 1) {
            return;
          }
        }

        // if nothing is selected go to the first post on screen
        if ($selected.length === 0) {
          (function () {
            var scrollTop = $(document).scrollTop();

            index = 0;
            $articles.each(function () {
              var top = $(this).position().top;
              if (top >= scrollTop) {
                return false;
              }
              index += 1;
            });

            if (index >= $articles.length) {
              index = $articles.length - 1;
            }

            direction = 0;
          })();
        }

        var $article = $articles.eq(index + direction);

        if ($article.size() > 0) {

          $articles.removeClass('selected');
          $article.addClass('selected');

          if ($article.is('.topic-post')) {
            $('a.tabLoc', $article).focus();
          }

          this._scrollList($article, direction);
        }
      },

      _scrollList: function ($article) {
        // Try to keep the article on screen
        var pos = $article.offset();
        var height = $article.height();
        var headerHeight = $('header.d-header').height();
        var scrollTop = $(window).scrollTop();
        var windowHeight = $(window).height();

        // skip if completely on screen
        if (pos.top - headerHeight > scrollTop && pos.top + height < scrollTop + windowHeight) {
          return;
        }

        var scrollPos = pos.top + height / 2 - windowHeight * 0.5;
        if (height > windowHeight - headerHeight) {
          scrollPos = pos.top - headerHeight;
        }
        if (scrollPos < 0) {
          scrollPos = 0;
        }

        if (this._scrollAnimation) {
          this._scrollAnimation.stop();
        }
        this._scrollAnimation = $("html, body").animate({ scrollTop: scrollPos + "px" }, 100);
      },

      _findArticles: function () {
        var $topicList = $('.topic-list'),
            $topicArea = $('.posts-wrapper');

        if ($topicArea.size() > 0) {
          return $('.posts-wrapper .topic-post, .topic-list tbody tr');
        } else if ($topicList.size() > 0) {
          return $topicList.find('.topic-list-item');
        }
      },

      _changeSection: function (direction) {
        var $sections = $('.nav.nav-pills li'),
            active = $('.nav.nav-pills li.active'),
            index = $sections.index(active) + direction;

        if (index >= 0 && index < $sections.length) {
          $sections.eq(index).find('a').click();
        }
      },

      _stopCallback: function () {
        var oldStopCallback = this.keyTrapper.prototype.stopCallback;

        this.keyTrapper.prototype.stopCallback = function (e, element, combo, sequence) {
          if ((combo === 'ctrl+f' || combo === 'command+f') && element.id === 'search-term') {
            return false;
          }
          return oldStopCallback.call(this, e, element, combo, sequence);
        };
      },

      _replyToPost: function () {
        this.container.lookup('controller:topic').send('replyToPost');
      }
    };
  });
define("discourse/lib/lightbox", 
  ["discourse/lib/load-script","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var loadScript = __dependency1__["default"];

    __exports__["default"] = function ($elem) {
      $("a.lightbox", $elem).each(function (i, e) {
        loadScript("/javascripts/jquery.magnific-popup-min.js").then(function () {
          var $e = $(e);
          // do not lightbox spoiled images
          if ($e.parents(".spoiler").length > 0 || $e.parents(".spoiled").length > 0) {
            return;
          }

          $e.magnificPopup({
            type: "image",
            closeOnContentClick: false,
            removalDelay: 300,
            mainClass: "mfp-zoom-in",

            callbacks: {
              open: function () {
                var wrap = this.wrap,
                    img = this.currItem.img,
                    maxHeight = img.css("max-height");

                wrap.on("click.pinhandler", "img", function () {
                  wrap.toggleClass("mfp-force-scrollbars");
                  img.css("max-height", wrap.hasClass("mfp-force-scrollbars") ? "none" : maxHeight);
                });
              },
              beforeClose: function () {
                this.wrap.off("click.pinhandler");
                this.wrap.removeClass("mfp-force-scrollbars");
              }
            },

            image: {
              titleSrc: function (item) {
                var href = item.el.data("download-href") || item.src;
                var src = [item.el.attr("title"), $("span.informations", item.el).text().replace('x', '&times;')];
                if (!Discourse.SiteSettings.prevent_anons_from_downloading_files || Discourse.User.current()) {
                  src.push('<a class="image-source-link" href="' + href + '">' + I18n.t("lightbox.download") + '</a>');
                }
                return src.join(' &middot; ');
              }
            }

          });
        });
      });
    }
  });
define("discourse/lib/link-category-hashtags", 
  ["discourse/lib/category-hashtags","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.linkSeenCategoryHashtags = linkSeenCategoryHashtags;
    __exports__.fetchUnseenCategoryHashtags = fetchUnseenCategoryHashtags;
    var replaceSpan = __dependency1__.replaceSpan;

    var validCategoryHashtags = {};
    var checkedCategoryHashtags = [];
    var testedKey = 'tested';
    var testedClass = 'hashtag-' + testedKey;

    function updateFound($hashtags, categorySlugs) {
      Ember.run.schedule('afterRender', function () {
        $hashtags.each(function (index, hashtag) {
          var categorySlug = categorySlugs[index];
          var link = validCategoryHashtags[categorySlug];
          var $hashtag = $(hashtag);

          if (link) {
            replaceSpan($hashtag, categorySlug, link);
          } else if (checkedCategoryHashtags.indexOf(categorySlug) !== -1) {
            $hashtag.addClass(testedClass);
          }
        });
      });
    };

    function linkSeenCategoryHashtags($elem) {
      var $hashtags = $('span.hashtag:not(.' + testedClass + ')', $elem);
      var unseen = [];

      if ($hashtags.length) {
        var categorySlugs = $hashtags.map(function (_, hashtag) {
          return $(hashtag).text().substr(1);
        });
        if (categorySlugs.length) {
          _.uniq(categorySlugs).forEach(function (categorySlug) {
            if (checkedCategoryHashtags.indexOf(categorySlug) === -1) {
              unseen.push(categorySlug);
            }
          });
        }
        updateFound($hashtags, categorySlugs);
      }

      return unseen;
    }

    ;

    function fetchUnseenCategoryHashtags(categorySlugs) {
      return Discourse.ajax("/category_hashtags/check", { data: { category_slugs: categorySlugs } }).then(function (response) {
        response.valid.forEach(function (category) {
          validCategoryHashtags[category.slug] = category.url;
        });
        checkedCategoryHashtags.push.apply(checkedCategoryHashtags, categorySlugs);
      });
    }
  });
define("discourse/lib/link-tag-hashtag", 
  ["discourse/lib/category-hashtags","discourse/lib/tag-hashtags","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    __exports__.linkSeenTagHashtags = linkSeenTagHashtags;
    __exports__.fetchUnseenTagHashtags = fetchUnseenTagHashtags;
    var replaceSpan = __dependency1__.replaceSpan;
    var TAG_HASHTAG_POSTFIX = __dependency2__.TAG_HASHTAG_POSTFIX;

    var validTagHashtags = {};
    var checkedTagHashtags = [];
    var testedClass = 'tag-hashtag-tested';

    function updateFound($hashtags, tagValues) {
      Ember.run.schedule('afterRender', function () {
        $hashtags.each(function (index, hashtag) {
          var tagValue = tagValues[index];
          var link = validTagHashtags[tagValue];
          var $hashtag = $(hashtag);

          if (link) {
            replaceSpan($hashtag, tagValue, link);
          } else if (checkedTagHashtags.indexOf(tagValue) !== -1) {
            $hashtag.addClass(testedClass);
          }
        });
      });
    }

    function linkSeenTagHashtags($elem) {
      var $hashtags = $('span.hashtag:not(.' + testedClass + ')', $elem);
      var unseen = [];

      if ($hashtags.length) {
        var tagValues = $hashtags.map(function (_, hashtag) {
          return $(hashtag).text().substr(1).replace('' + TAG_HASHTAG_POSTFIX, "");
        });

        if (tagValues.length) {
          _.uniq(tagValues).forEach(function (tagValue) {
            if (checkedTagHashtags.indexOf(tagValue) === -1) unseen.push(tagValue);
          });
        }
        updateFound($hashtags, tagValues);
      }

      return unseen;
    }

    ;

    function fetchUnseenTagHashtags(tagValues) {
      return Discourse.ajax("/tags/check", { data: { tag_values: tagValues } }).then(function (response) {
        response.valid.forEach(function (tag) {
          validTagHashtags[tag.value] = tag.url;
        });
        checkedTagHashtags.push.apply(checkedTagHashtags, tagValues);
      });
    }
  });
define("discourse/lib/logout", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = logout;

    function logout(siteSettings, keyValueStore) {
      keyValueStore.abandonLocal();

      var redirect = siteSettings.logout_redirect;
      if (Ember.isEmpty(redirect)) {
        window.location.pathname = Discourse.getURL('/');
      } else {
        window.location.href = redirect;
      }
    }
  });
define("discourse/lib/mobile", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.forceMobile = forceMobile;
    __exports__.resetMobile = resetMobile;
    var mobileForced = false;

    //  An object that is responsible for logic related to mobile devices.
    var Mobile = {
      isMobileDevice: false,
      mobileView: false,

      init: function () {
        var $html = $('html');
        this.isMobileDevice = mobileForced || $html.hasClass('mobile-device');
        this.mobileView = mobileForced || $html.hasClass('mobile-view');

        if (Ember.testing || mobileForced) {
          return;
        }

        try {
          if (window.location.search.match(/mobile_view=1/)) {
            localStorage.mobileView = true;
          }
          if (window.location.search.match(/mobile_view=0/)) {
            localStorage.mobileView = false;
          }
          if (localStorage.mobileView) {
            var savedValue = localStorage.mobileView === 'true';
            if (savedValue !== this.mobileView) {
              this.reloadPage(savedValue);
            }
          }
        } catch (err) {
          // localStorage may be disabled, just skip this
          // you get security errors if it is disabled
        }
      },

      toggleMobileView: function () {
        try {
          if (localStorage) {
            localStorage.mobileView = !this.mobileView;
          }
        } catch (err) {
          // localStorage may be disabled, skip
        }
        this.reloadPage(!this.mobileView);
      },

      reloadPage: function (mobile) {
        window.location.assign(window.location.pathname + '?mobile_view=' + (mobile ? '1' : '0'));
      }
    };

    function forceMobile() {
      mobileForced = true;
    }

    function resetMobile() {
      mobileForced = false;
    }

    // Backwards compatibiltity, deprecated
    Object.defineProperty(Discourse, 'Mobile', {
      get: function () {
        Ember.warn("DEPRECATION: `Discourse.Mobile` is deprecated, use `this.site.mobileView` instead");
        return Mobile;
      }
    });

    __exports__["default"] = Mobile;
  });
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  A helper for looking up oneboxes and displaying them

  For now it only stores in a local Javascript Object, in future we can change it so it uses localStorage
  or some other mechanism.

  @class Onebox
  @namespace Discourse
  @module Discourse
**/

Discourse.Onebox = {

  // The cache is just a JS Object
  localCache: {},

  // A cache of failed URLs
  failedCache: {},

  /**
    Perform a lookup of a onebox based an anchor element. It will insert a loading
    indicator and remove it when the loading is complete or fails.

    @method load
    @param {HTMLElement} e the anchor element whose onebox we want to look up
    @param {Boolean} refresh true if we want to force a refresh of the onebox
  **/
  load: function(e, refresh) {

    var $elem = $(e);

    // If the onebox has loaded, return
    if ($elem.data('onebox-loaded')) return;
    if ($elem.hasClass('loading-onebox')) return;

    var url = e.href;

    // Unless we're forcing a refresh...
    if (!refresh) {
      // If we have it in our cache, return it.
      var cached = this.localCache[url];
      if (cached) return cached;

      // If the request failed, don't do anything
      var failed = this.failedCache[url];
      if (failed) return;
    }

    // Add the loading CSS class
    $elem.addClass('loading-onebox');

    // Retrieve the onebox
    var promise = Discourse.ajax("/onebox", {
      dataType: 'html',
      data: { url: url, refresh: refresh },
      cache: true
    });

    // We can call this when loading is complete
    var loadingFinished = function() {
      $elem.removeClass('loading-onebox');
      $elem.data('onebox-loaded');
    };

    var onebox = this;
    promise.then(function(html) {

      // loaded onebox
      loadingFinished();

      onebox.localCache[url] = html;
      $elem.replaceWith(html);

    }, function() {
      // If the request failed log it as such
      onebox.failedCache[url] = true;
      loadingFinished();
    });

  },

  /**
    Return the cached contents of a Onebox

    @method lookupCache
    @param {String} url the url of the onebox
    @return {String} the cached contents of the onebox or null if not found
  **/
  lookupCache: function(url) {
    return this.localCache[url];
  },

  /**
    Store the contents of a Onebox in our local cache.

    @method cache
    @private
    @param {String} url the url of the onebox we crawled
    @param {String} contents the contents we want to cache
  **/
  cache: function(url, contents) {
    this.localCache[url] = contents;
  }

};




// IIFE Wrapped Content Ends

 })(this);
define("discourse/lib/page-tracker", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.startPageTracking = startPageTracking;
    __exports__.onPageChange = onPageChange;
    var PageTracker = Ember.Object.extend(Ember.Evented);
    var _pageTracker = PageTracker.create();

    var _started = false;

    function startPageTracking(router) {
      if (_started) {
        return;
      }

      router.on('didTransition', function () {
        this.send('refreshTitle');
        var url = Discourse.getURL(this.get('url'));

        // Refreshing the title is debounced, so we need to trigger this in the
        // next runloop to have the correct title.
        Em.run.next(function () {
          _pageTracker.trigger('change', url, Discourse.get('_docTitle'));
        });
      });
      _started = true;
    }

    function onPageChange(fn) {
      _pageTracker.on('change', fn);
    }

    // backwards compatibility
    var BackwardsCompat = {
      current: function () {
        console.warn('Using PageTracker.current() is deprecated. Your plugin should use the PluginAPI');
        return _pageTracker;
      }
    };

    Discourse.PageTracker = BackwardsCompat;
    __exports__["default"] = BackwardsCompat;
  });
define("discourse/lib/plugin-api", 
  ["discourse/helpers/fa-icon","discourse/widgets/post-cooked","discourse/components/composer-editor","discourse/widgets/post-menu","discourse/lib/transform-post","discourse/components/d-editor","discourse/components/mount-widget","discourse/widgets/widget","discourse/lib/page-tracker","discourse/widgets/post-stream","virtual-dom","discourse/components/site-header","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __dependency9__, __dependency10__, __dependency11__, __dependency12__, __exports__) {
    "use strict";
    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    __exports__.withPluginApi = withPluginApi;
    __exports__.decorateCooked = decorateCooked;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var iconNode = __dependency1__.iconNode;
    var addDecorator = __dependency2__.addDecorator;
    var ComposerEditor = __dependency3__["default"];
    var addButton = __dependency4__.addButton;
    var includeAttributes = __dependency5__.includeAttributes;
    var addToolbarCallback = __dependency6__.addToolbarCallback;
    var addWidgetCleanCallback = __dependency7__.addWidgetCleanCallback;
    var _createWidget = __dependency8__.createWidget;
    var _decorateWidget = __dependency8__.decorateWidget;
    var changeSetting = __dependency8__.changeSetting;
    var _onPageChange = __dependency9__.onPageChange;
    var _preventCloak = __dependency10__.preventCloak;
    var h = __dependency11__.h;
    var _addFlagProperty = __dependency12__.addFlagProperty;

    var PluginApi = (function () {
      function PluginApi(version, container) {
        _classCallCheck(this, PluginApi);

        this.version = version;
        this.container = container;
        this._currentUser = container.lookup('current-user:main');
        this.h = h;
      }

      /**
       * Use this function to retrieve the currently logged in user within your plugin.
       * If the user is not logged in, it will be `null`.
      **/

      _createClass(PluginApi, [{
        key: 'getCurrentUser',
        value: function getCurrentUser() {
          return this._currentUser;
        }

        /**
         * Used for decorating the `cooked` content of a post after it is rendered using
         * jQuery.
         *
         * `callback` will be called when it is time to decorate with a jQuery selector.
         *
         * Use `options.onlyStream` if you only want to decorate posts within a topic,
         * and not in other places like the user stream.
         *
         * For example, to add a yellow background to all posts you could do this:
         *
         * ```
         * api.decorateCooked($elem => $elem.css({ backgroundColor: 'yellow' }));
         * ```
         **/
      }, {
        key: 'decorateCooked',
        value: function decorateCooked(callback, opts) {
          opts = opts || {};

          addDecorator(callback);

          if (!opts.onlyStream) {
            decorate(ComposerEditor, 'previewRefreshed', callback);
            decorate(this.container.lookupFactory('component:user-stream'), 'didInsertElement', callback);
          }
        }

        /**
         * addPosterIcon(callback)
         *
         * This function can be used to add an icon with a link that will be displayed
         * beside a poster's name. The `callback` is called with the post's user custom
         * fields and post attrions. An icon will be rendered if the callback returns
         * an object with the appropriate attributes.
         *
         * The returned object can have the following attributes:
         *
         *   icon        the font awesome icon to render
         *   emoji       an emoji icon to render
         *   className   (optional) a css class to apply to the icon
         *   url         (optional) where to link the icon
         *   title       (optional) the tooltip title for the icon on hover
         *
         * ```
         * api.addPosterIcon((cfs, attrs) => {
         *   if (cfs.customer) {
         *     return { icon: 'user', className: 'customer', title: 'customer' };
         *   }
         * });
         * ```
         **/
      }, {
        key: 'addPosterIcon',
        value: function addPosterIcon(cb) {
          var site = this.container.lookup('site:main');
          var loc = site && site.mobileView ? 'before' : 'after';

          _decorateWidget('poster-name:' + loc, function (dec) {
            var attrs = dec.attrs;
            var result = cb(attrs.userCustomFields || {}, attrs);

            if (result) {
              var iconBody = undefined;

              if (result.icon) {
                iconBody = iconNode(result.icon);
              } else if (result.emoji) {
                iconBody = result.emoji.split('|').map(function (emoji) {
                  var src = Discourse.Emoji.urlFor(emoji);
                  return dec.h('img', { className: 'emoji', attributes: { src: src } });
                });

                iconBody = result.emoji.split('|').map(function (name) {
                  return dec.attach('emoji', { name: name });
                });
              }

              if (result.text) {
                iconBody = [iconBody, result.text];
              }

              if (result.url) {
                iconBody = dec.h('a', { attributes: { href: result.url } }, iconBody);
              }

              return dec.h('span.poster-icon', { className: result.className, attributes: { title: result.title } }, iconBody);
            }
          });
        }

        /**
         * The main interface for extending widgets with additional HTML.
         *
         * The `name` you pass it should be the name of the widget and a type
         * for the decorator. All widgets support `before` and `after` types.
         *
         * Example:
         *
         * ```
         * api.decorateWidget('post:after', () => {
         *   return "I am displayed after every post!";
         * });
         * ```
         *
         * Your decorator will be called with an instance of a `DecoratorHelper`
         * object, which provides methods you can use to build more interesting
         * formatting.
         *
         * ```
         * api.decorateWidget('post:after', helper => {
         *   return helper.h('p.fancy', `I'm an HTML paragraph on post with id ${helper.attrs.id}`);
         * });
         *
         * (View the source for `DecoratorHelper` for more helper methods you
         * can use in your plugin decorators.)
         *
         **/
      }, {
        key: 'decorateWidget',
        value: function decorateWidget(name, fn) {
          _decorateWidget(name, fn);
        }

        /**
         * Adds a new action to a widget that already exists. You can use this to
         * add additional functionality from your plugin.
         *
         * Example:
         *
         * ```
         * api.attachWidgetAction('post', 'annoyMe', () => {
         *  alert('ANNOYED!');
         * });
         * ```
         **/
      }, {
        key: 'attachWidgetAction',
        value: function attachWidgetAction(widget, actionName, fn) {
          var widgetClass = this.container.lookupFactory('widget:' + widget);
          widgetClass.prototype[actionName] = fn;
        }

        /**
         * Add more attributes to the Post's `attrs` object passed through to widgets.
         * You'll need to do this if you've added attributes to the serializer for a
         * Post and want to use them when you're rendering.
         *
         * Example:
         *
         * ```
         * // attrs.poster_age and attrs.poster_height will be present
         * api.includePostAttributes('poster_age', 'poster_height');
         * ```
         *
         **/
      }, {
        key: 'includePostAttributes',
        value: function includePostAttributes() {
          includeAttributes.apply(undefined, arguments);
        }

        /**
         * Add a new button below a post with your plugin.
         *
         * The `callback` function will be called whenever the post menu is rendered,
         * and if you return an object with the button details it will be rendered.
         *
         * Example:
         *
         * ```
         * api.addPostMenuButton('coffee', () => {
         *   return {
         *     action: 'drinkCoffee',
         *     icon: 'coffee',
         *     className: 'hot-coffee',
         *     title: 'coffee.title',
         *     position: 'first'  // can be `first`, `last` or `second-last-hidden`
         *   };
         * });
         **/
      }, {
        key: 'addPostMenuButton',
        value: function addPostMenuButton(name, callback) {
          addButton(name, callback);
        }

        /**
         * A hook that is called when the editor toolbar is created. You can
         * use this to add custom editor buttons.
         *
         * Example:
         *
         * ```
         * api.onToolbarCreate(toolbar => {
         *   toolbar.addButton({
         *     id: 'pop-text',
         *     group: 'extras',
         *     icon: 'bolt',
         *     action: 'makeItPop',
         *     title: 'pop_format.title'
         *   });
         * });
         **/
      }, {
        key: 'onToolbarCreate',
        value: function onToolbarCreate(callback) {
          addToolbarCallback(callback);
        }

        /**
         * A hook that is called when the post stream is removed from the DOM.
         * This advanced hook should be used if you end up wiring up any
         * events that need to be torn down when the user leaves the topic
         * page.
         **/
      }, {
        key: 'cleanupStream',
        value: function cleanupStream(fn) {
          addWidgetCleanCallback('post-stream', fn);
        }

        /**
          Called whenever the "page" changes. This allows us to set up analytics
          and other tracking.
           To get notified when the page changes, you can install a hook like so:
           ```javascript
            api.onPageChange((url, title) => {
              console.log('the page changed to: ' + url + ' and title ' + title);
            });
          ```
        **/
      }, {
        key: 'onPageChange',
        value: function onPageChange(fn) {
          _onPageChange(fn);
        }

        /**
         * Changes a setting associated with a widget. For example, if
         * you wanted small avatars in the post stream:
         *
         * ```javascript
         * api.changeWidgetSetting('post-avatar', 'size', 'small');
         * ```
         *
         **/
      }, {
        key: 'changeWidgetSetting',
        value: function changeWidgetSetting(widgetName, settingName, newValue) {
          changeSetting(widgetName, settingName, newValue);
        }

        /**
         * Prevents an element in the post stream from being cloaked.
         * This is useful if you are using a plugin such as youtube
         * and don't want the video removed once it has begun
         * playing.
         *
         * ```javascript
         * api.preventCloak(1234);
         * ```
         **/
      }, {
        key: 'preventCloak',
        value: function preventCloak(postId) {
          _preventCloak(postId);
        }

        /**
         * Exposes the widget creating ability to plugins. Plugins can
         * register their own plugins and attach them with decorators.
         * See `createWidget` in `discourse/widgets/widget` for more info.
         **/
      }, {
        key: 'createWidget',
        value: function createWidget(name, args) {
          return _createWidget(name, args);
        }

        /**
         * Adds a property that can be summed for calculating the flag counter
         **/
      }, {
        key: 'addFlagProperty',
        value: function addFlagProperty(property) {
          return _addFlagProperty(property);
        }
      }]);

      return PluginApi;
    })();

    var _pluginv01 = undefined;
    function getPluginApi(version) {
      version = parseFloat(version);
      if (version <= 0.4) {
        if (!_pluginv01) {
          _pluginv01 = new PluginApi(version, Discourse.__container__);
        }
        return _pluginv01;
      } else {
        console.warn('Plugin API v' + version + ' is not supported');
      }
    }

    /**
     * withPluginApi(version, apiCodeCallback, opts)
     *
     * Helper to version our client side plugin API. Pass the version of the API that your
     * plugin is coded against. If that API is available, the `apiCodeCallback` function will
     * be called with the `PluginApi` object.
    */

    function withPluginApi(version, apiCodeCallback, opts) {
      opts = opts || {};

      var api = getPluginApi(version);
      if (api) {
        return apiCodeCallback(api);
      }
    }

    var _decorateId = 0;
    function decorate(klass, evt, cb) {
      var mixin = {};
      mixin["_decorate_" + _decorateId++] = (function ($elem) {
        cb($elem);
      }).on(evt);
      klass.reopen(mixin);
    }

    function decorateCooked() {
      console.warn('`decorateCooked` has been removed. Use `getPluginApi(version).decorateCooked` instead');
    }
  });
define("discourse/lib/render-tag", 
  ["virtual-dom","exports"],
  function(__dependency1__, __exports__) {
    "use strict";


    __exports__["default"] = renderTag;__exports__.tagNode = tagNode;
    var h = __dependency1__.h;
    function renderTag(tag, params) {
      params = params || {};
      tag = Handlebars.Utils.escapeExpression(tag);
      var classes = ['tag-' + tag, 'discourse-tag'];
      var tagName = params.tagName || "a";
      var href = tagName === "a" ? " href='" + Discourse.getURL("/tags/" + tag) + "' " : "";

      if (Discourse.SiteSettings.tag_style || params.style) {
        classes.push(params.style || Discourse.SiteSettings.tag_style);
      }

      var val = "<" + tagName + href + " class='" + classes.join(" ") + "'>" + tag + "</" + tagName + ">";

      if (params.count) {
        val += " <span class='discourse-tag-count'>x" + params.count + "</span>";
      }

      return val;
    }

    ;

    function tagNode(tag, params) {
      var classes = ['tag-' + tag, 'discourse-tag'];
      var tagName = params.tagName || "a";

      if (Discourse.SiteSettings.tag_style || params.style) {
        classes.push(params.style || Discourse.SiteSettings.tag_style);
      }

      if (tagName === 'a') {
        var href = Discourse.getURL('/tags/' + tag);
        return h(tagName, { className: classes.join(' '), attributes: { href: href } }, tag);
      } else {
        return h(tagName, { className: classes.join(' ') }, tag);
      }
    }
  });
define("discourse/lib/round", 
  ["discourse/lib/decimal-adjust","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var decimalAdjust = __dependency1__["default"];

    __exports__["default"] = function (value, exp) {
      return decimalAdjust("round", value, exp);
    }
  });
define("discourse/lib/sharing", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      If you want to add a new sharing source to Discourse, you can do so like this:

      ```javascript
        import Sharing from 'discourse/lib/sharing';

        Sharing.addSource({

          // This id must be present in the `share_links` site setting too
          id: 'twitter',

          // The icon that will be displayed, choose between font awesome class name `faIcon` and custom HTML `htmlIcon`.
          // When both provided, prefer `faIcon`
          faIcon: 'fa-twitter-square'
          htmlIcon: '<img src="example.com/example.jpg">',

          // A callback for generating the remote link from the `link` and `title`
          generateUrl: function(link, title) {
            return "http://twitter.com/intent/tweet?url=" + encodeURIComponent(link) + "&text=" + encodeURIComponent(title);
          },

          // If true, opens in a popup of `popupHeight` size. If false it's opened in a new tab
          shouldOpenInPopup: true,
          popupHeight: 265
        });
      ```
    **/

    var _sources = {};

    __exports__["default"] = {
      addSource: function (source) {
        _sources[source.id] = source;
      },

      activeSources: function (linksSetting) {
        return linksSetting.split('|').map(function (s) {
          return _sources[s];
        }).compact();
      }
    };
  });
define("discourse/lib/static-route-builder", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    var configs = {
      "faq": "faq_url",
      "tos": "tos_url",
      "privacy": "privacy_policy_url"
    };

    __exports__["default"] = function (page) {
      return Discourse.Route.extend({
        renderTemplate: function () {
          this.render("static");
        },

        beforeModel: function (transition) {
          var configKey = configs[page];
          if (configKey && Discourse.SiteSettings[configKey].length > 0) {
            transition.abort();
            DiscourseURL.redirectTo(Discourse.SiteSettings[configKey]);
          }
        },

        activate: function () {
          this._super();
          // Scroll to an element if exists
          DiscourseURL.scrollToId(document.location.hash);
        },

        model: function () {
          return Discourse.StaticPage.find(page);
        },

        setupController: function (controller, model) {
          this.controllerFor("static").set("model", model);
        },

        actions: {
          didTransition: function () {
            this.controllerFor("application").set("showFooter", true);
            return true;
          }
        }
      });
    };
  });
define("discourse/lib/tag-hashtags", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var TAG_HASHTAG_POSTFIX = '::tag';
    __exports__.TAG_HASHTAG_POSTFIX = TAG_HASHTAG_POSTFIX;
  });
define("discourse/lib/transform-post", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.includeAttributes = includeAttributes;
    __exports__.transformBasicPost = transformBasicPost;

    __exports__["default"] = transformPost;
    function actionDescription(action, acted, count) {
      if (acted) {
        if (count <= 1) {
          return I18n.t('post.actions.by_you.' + action);
        } else {
          return I18n.t('post.actions.by_you_and_others.' + action, { count: count - 1 });
        }
      } else {
        return I18n.t('post.actions.by_others.' + action, { count: count });
      }
    }

    var _additionalAttributes = [];

    function includeAttributes() {
      for (var _len = arguments.length, attributes = Array(_len), _key = 0; _key < _len; _key++) {
        attributes[_key] = arguments[_key];
      }

      attributes.forEach(function (a) {
        return _additionalAttributes.push(a);
      });
    }

    function transformBasicPost(post) {
      // Note: it can be dangerous to not use `get` in Ember code, but this is significantly
      // faster and has tests to confirm it works. We only call `get` when the property is a CP
      return {
        id: post.id,
        hidden: post.hidden,
        deleted: post.get('deleted'),
        deleted_at: post.deleted_at,
        user_deleted: post.user_deleted,
        isDeleted: post.deleted_at || post.user_deleted,
        deletedByAvatarTemplate: null,
        deletedByUsername: null,
        primary_group_name: post.primary_group_name,
        wiki: post.wiki,
        firstPost: post.post_number === 1,
        post_number: post.post_number,
        cooked: post.cooked,
        via_email: post.via_email,
        isAutoGenerated: post.is_auto_generated,
        user_id: post.user_id,
        usernameUrl: Discourse.getURL('/users/' + post.username),
        username: post.username,
        avatar_template: post.avatar_template,
        bookmarked: post.bookmarked,
        yours: post.yours,
        shareUrl: post.get('shareUrl'),
        staff: post.staff,
        admin: post.admin,
        moderator: post.moderator,
        new_user: post.trust_level === 0,
        name: post.name,
        user_title: post.user_title,
        created_at: post.created_at,
        updated_at: post.updated_at,
        canDelete: post.can_delete,
        canRecover: post.can_recover,
        canEdit: post.can_edit,
        canFlag: !Ember.isEmpty(post.get('flagsAvailable')),
        version: post.version,
        canRecoverTopic: false,
        canDeletedTopic: false,
        canViewEditHistory: post.can_view_edit_history,
        canWiki: post.can_wiki,
        showLike: false,
        liked: false,
        canToggleLike: false,
        likeCount: false,
        actionsSummary: null,
        read: post.read,
        replyToUsername: null,
        replyToAvatarTemplate: null,
        reply_to_post_number: post.reply_to_post_number,
        cooked_hidden: !!post.cooked_hidden,
        expandablePost: false,
        replyCount: post.reply_count
      };
    }

    function transformPost(currentUser, site, post, prevPost, nextPost) {
      // Note: it can be dangerous to not use `get` in Ember code, but this is significantly
      // faster and has tests to confirm it works. We only call `get` when the property is a CP
      var postType = post.post_type;
      var postTypes = site.post_types;
      var topic = post.topic;
      var details = topic.get('details');

      var postAtts = transformBasicPost(post);

      var createdBy = details.created_by || {};

      postAtts.topicId = topic.id;
      postAtts.topicOwner = createdBy.id === post.user_id;
      postAtts.topicCreatedById = createdBy.id;
      postAtts.post_type = postType;
      postAtts.via_email = post.via_email;
      postAtts.isAutoGenerated = post.is_auto_generated;
      postAtts.isModeratorAction = postType === postTypes.moderator_action;
      postAtts.isWhisper = postType === postTypes.whisper;
      postAtts.isSmallAction = postType === postTypes.small_action;
      postAtts.canBookmark = !!currentUser;
      postAtts.canManage = currentUser && currentUser.get('canManageTopic');
      postAtts.canViewRawEmail = currentUser && (currentUser.id === post.user_id || currentUser.staff);
      postAtts.canReplyAsNewTopic = details.can_reply_as_new_topic;
      postAtts.isWarning = topic.is_warning;
      postAtts.links = post.get('internalLinks');
      postAtts.replyDirectlyBelow = nextPost && nextPost.reply_to_post_number === post.post_number;
      postAtts.replyDirectlyAbove = prevPost && post.reply_to_post_number === prevPost.post_number;
      postAtts.linkCounts = post.link_counts;
      postAtts.actionCode = post.action_code;
      postAtts.actionCodeWho = post.action_code_who;
      postAtts.userCustomFields = post.user_custom_fields;
      postAtts.topicUrl = topic.get('url');

      var showPMMap = topic.archetype === 'private_message' && post.post_number === 1;
      if (showPMMap) {
        postAtts.showPMMap = true;
        postAtts.allowedGroups = details.allowed_groups;
        postAtts.allowedUsers = details.allowed_users;
        postAtts.canRemoveAllowedUsers = details.can_remove_allowed_users;
        postAtts.canInvite = details.can_invite_to;
      }

      var showTopicMap = showPMMap || post.post_number === 1 && topic.archetype === 'regular' && topic.posts_count > 1;
      if (showTopicMap) {
        postAtts.showTopicMap = true;
        postAtts.topicCreatedAt = topic.created_at;
        postAtts.createdByUsername = createdBy.username;
        postAtts.createdByAvatarTemplate = createdBy.avatar_template;

        postAtts.lastPostUrl = topic.get('lastPostUrl');
        postAtts.lastPostUsername = details.last_poster.username;
        postAtts.lastPostAvatarTemplate = details.last_poster.avatar_template;
        postAtts.lastPostAt = topic.last_posted_at;

        postAtts.topicReplyCount = topic.get('replyCount');
        postAtts.topicViews = topic.views;
        postAtts.topicViewsHeat = topic.get('viewsHeat');

        postAtts.participantCount = topic.participant_count;
        postAtts.topicLikeCount = topic.like_count;
        postAtts.topicLinks = details.links;
        if (postAtts.topicLinks) {
          postAtts.topicLinkLength = details.links.length;
        }
        postAtts.topicPostsCount = topic.posts_count;

        postAtts.participants = details.participants;

        var postStream = topic.get('postStream');
        postAtts.userFilters = postStream.userFilters;
        postAtts.topicSummaryEnabled = postStream.summary;
        postAtts.topicWordCount = topic.word_count;
        postAtts.hasTopicSummary = topic.has_summary;
      }

      if (postAtts.isDeleted) {
        postAtts.deletedByAvatarTemplate = post.get('postDeletedBy.avatar_template');
        postAtts.deletedByUsername = post.get('postDeletedBy.username');
      }

      var replyToUser = post.get('reply_to_user');
      if (replyToUser) {
        postAtts.replyToUsername = replyToUser.username;
        postAtts.replyToAvatarTemplate = replyToUser.avatar_template;
      }

      if (post.actions_summary) {
        postAtts.actionsSummary = post.actions_summary.filter(function (a) {
          return a.actionType.name_key !== 'like' && a.count > 0;
        }).map(function (a) {
          var acted = a.acted;
          var action = a.actionType.name_key;
          var count = a.count;

          return { id: a.id,
            postId: post.id,
            action: action,
            acted: acted,
            count: count,
            canUndo: a.can_undo,
            canDeferFlags: a.can_defer_flags,
            description: actionDescription(action, acted, count) };
        });
      }

      var likeAction = post.likeAction;
      if (likeAction) {
        postAtts.liked = likeAction.acted;
        postAtts.canToggleLike = likeAction.get('canToggle');
        postAtts.showLike = postAtts.liked || postAtts.canToggleLike;
        postAtts.likeCount = likeAction.count;
      }

      if (postAtts.post_number === 1) {
        postAtts.canRecoverTopic = topic.deleted_at && details.can_recover;
        postAtts.canDeleteTopic = !topic.deleted_at && details.can_delete;
        postAtts.expandablePost = topic.expandable_first_post;
      } else {
        postAtts.canRecover = postAtts.isDeleted && postAtts.canRecover;
        postAtts.canDelete = !postAtts.isDeleted && postAtts.canDelete;
      }

      _additionalAttributes.forEach(function (a) {
        return postAtts[a] = post[a];
      });

      return postAtts;
    }
  });
define("discourse/router", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.mapRoutes = mapRoutes;
    var rootURL = Discourse.BaseUri;

    var BareRouter = Ember.Router.extend({
      rootURL: rootURL,
      location: Ember.testing ? 'none' : 'discourse-location'
    });

    function mapRoutes() {

      var Router = BareRouter.extend();
      var resources = {};
      var paths = {};

      // If a module is defined as `route-map` in discourse or a plugin, its routes
      // will be built automatically. You can supply a `resource` property to
      // automatically put it in that resource, such as `admin`. That way plugins
      // can define admin routes.
      Object.keys(requirejs._eak_seen).forEach(function (key) {
        if (/route-map$/.test(key)) {
          var module = require(key, null, null, true);
          if (!module || !module.default) {
            throw new Error(key + ' must export a route map.');
          }

          var mapObj = module.default;
          if (typeof mapObj === 'function') {
            mapObj = { resource: 'root', map: mapObj };
          }

          if (!resources[mapObj.resource]) {
            resources[mapObj.resource] = [];
          }
          resources[mapObj.resource].push(mapObj.map);
          if (mapObj.path) {
            paths[mapObj.resource] = mapObj.path;
          }
        }
      });

      return Router.map(function () {
        var router = this;

        // Do the root resources first
        if (resources.root) {
          resources.root.forEach(function (m) {
            m.call(router);
          });
          delete resources.root;
        }

        // Even if no plugins set it up, we need an `adminPlugins` route
        var adminPlugins = 'admin.adminPlugins';
        resources[adminPlugins] = resources[adminPlugins] || [Ember.K];
        paths[adminPlugins] = paths[adminPlugins] || "/plugins";

        var segments = {},
            standalone = [];

        Object.keys(resources).forEach(function (r) {
          var m = /^([^\.]+)\.(.*)$/.exec(r);
          if (m) {
            segments[m[1]] = m[2];
          } else {
            standalone.push(r);
          }
        });

        // Apply other resources next. A little hacky but works!
        standalone.forEach(function (r) {
          router.resource(r, { path: paths[r] }, function () {
            var res = this;
            resources[r].forEach(function (m) {
              m.call(res);
            });

            var s = segments[r];
            if (s) {
              var full = r + '.' + s;
              res.resource(s, { path: paths[full] }, function () {
                var nestedRes = this;
                resources[full].forEach(function (m) {
                  m.call(nestedRes);
                });
              });
            }
          });
        });

        this.route('unknown', { path: '*path' });
      });
    }

    __exports__["default"] = BareRouter;
  });
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  This addition handles auto linking of text. When included, it will parse out links and create
  a hrefs for them.
**/

var urlReplacerArgs = {
  matcher: /^((?:https?:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.])(?:[^\s()<>]+|\([^\s()<>]+\))+(?:\([^\s()<>]+\)|[^`!()\[\]{};:'".,<>?«»“”‘’\s]))/,
  spaceOrTagBoundary: true,

  emitter: function(matches) {
    var url = matches[1],
        displayUrl = url;

    // Don't autolink a markdown link to something
    if (url.match(/\]\[\d$/)) { return; }

    // If we improperly caught a markdown link abort
    if (url.match(/\(http/)) { return; }

    if (url.match(/^www/)) { url = "http://" + url; }
    return ['a', {href: url}, displayUrl];
  }
};

Discourse.Dialect.inlineRegexp(_.merge({start: 'http'}, urlReplacerArgs));
Discourse.Dialect.inlineRegexp(_.merge({start: 'www'}, urlReplacerArgs));


// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

Discourse.BBCode = {};

/**
  Create a simple BBCode tag handler

  @method replaceBBCode
  @param {tag} tag the tag we want to match
  @param {function} emitter the function that creates JsonML for the tag
  @param {Object} opts options to pass to Discourse.Dialect.inlineBetween
    @param {Function} [opts.emitter] The function that will be called with the contents and returns JsonML.
    @param {String} [opts.start] The starting token we want to find
    @param {String} [opts.stop] The ending token we want to find
    @param {String} [opts.between] A shortcut for when the `start` and `stop` are the same.
    @param {Boolean} [opts.rawContents] If true, the contents between the tokens will not be parsed.
    @param {Boolean} [opts.wordBoundary] If true, the match must be on a word boundary
    @param {Boolean} [opts.spaceBoundary] If true, the match must be on a sppace boundary
**/

Discourse.BBCode.register = function(codeName, args, emitter) {

  // Optional second param for args
  if (typeof args === "function") {
    emitter = args;
    args = {};
  }

  Discourse.Dialect.replaceBlock({
    start: new RegExp("\\[" + codeName + "(=[^\\[\\]]+)?\\]([\\s\\S]*)", "igm"),
    stop: new RegExp("\\[\\/" + codeName + "\\]", "igm"),
    emitter: function(blockContents, matches, options) {
      while (blockContents.length && (typeof blockContents[0] === "string" || blockContents[0] instanceof String)) {
        blockContents[0] = String(blockContents[0]).replace(/^\s+/, '');
        if (!blockContents[0].length) {
          blockContents.shift();
        } else {
          break;
        }
      }

      var contents = [];
      if (blockContents.length) {
        var self = this;

        var nextContents = blockContents.slice(1);
        blockContents = this.processBlock(blockContents[0], nextContents).concat(nextContents);

        blockContents.forEach(function (bc) {
          if (typeof bc === "string" || bc instanceof String) {
            var processed = self.processInline(String(bc));
            if (processed.length) {
              contents.push(['p'].concat(processed));
            }
          } else {
            contents.push(bc);
          }
        });
      }
      if (!args.singlePara && contents.length === 1 && contents[0] instanceof Array && contents[0][0] === "para") {
        contents[0].shift();
        contents = contents[0];
      }
      var result = emitter(contents, matches[1] ? matches[1].replace(/^=|\"/g, '') : null, options);
      return args.noWrap ? result : ['p', result];
    }
  });
};

Discourse.BBCode.replaceBBCode = function (tag, emitter, opts) {
  opts = opts || {};
  opts = _.merge(opts, { start: "[" + tag + "]", stop: "[/" + tag + "]", emitter: emitter });
  Discourse.Dialect.inlineBetween(opts);

  tag = tag.toUpperCase();
  opts = _.merge(opts, { start: "[" + tag + "]", stop: "[/" + tag + "]", emitter: emitter });
  Discourse.Dialect.inlineBetween(opts);
};

/**
  Shortcut to call replaceBBCode with `rawContents` as true.

  @method replaceBBCode
  @param {tag} tag the tag we want to match
  @param {function} emitter the function that creates JsonML for the tag
**/
Discourse.BBCode.rawBBCode = function (tag, emitter) {
  Discourse.BBCode.replaceBBCode(tag, emitter, { rawContents: true });
};

/**
  Creates a BBCode handler that accepts parameters. Passes them to the emitter.

  @method replaceBBCodeParamsRaw
  @param {tag} tag the tag we want to match
  @param {function} emitter the function that creates JsonML for the tag
**/
Discourse.BBCode.replaceBBCodeParamsRaw = function (tag, emitter) {
  var opts = {
    rawContents: true,
    emitter: function(contents) {
      var regexp = /^([^\]]+)\]([\S\s]*)$/,
          m = regexp.exec(contents);

      if (m) { return emitter.call(this, m[1], m[2]); }
    }
  };

  Discourse.Dialect.inlineBetween(_.merge(opts, { start: "[" + tag + "=", stop: "[/" + tag + "]" }));

  tag = tag.toUpperCase();
  Discourse.Dialect.inlineBetween(_.merge(opts, { start: "[" + tag + "=", stop: "[/" + tag + "]" }));
};

/**
  Filters an array of JSON-ML nodes, removing nodes that represent empty lines ("\n").

  @method removeEmptyLines
  @param {Array} [contents] Array of JSON-ML nodes
**/
Discourse.BBCode.removeEmptyLines = function (contents) {
  var result = [];
  for (var i=0; i < contents.length; i++) {
    if (contents[i] !== "\n") { result.push(contents[i]); }
  }
  return result;
};

Discourse.BBCode.replaceBBCode('b', function(contents) { return ['span', {'class': 'bbcode-b'}].concat(contents); });
Discourse.BBCode.replaceBBCode('i', function(contents) { return ['span', {'class': 'bbcode-i'}].concat(contents); });
Discourse.BBCode.replaceBBCode('u', function(contents) { return ['span', {'class': 'bbcode-u'}].concat(contents); });
Discourse.BBCode.replaceBBCode('s', function(contents) { return ['span', {'class': 'bbcode-s'}].concat(contents); });
Discourse.Markdown.whiteListTag('span', 'class', /^bbcode-[bius]$/);

Discourse.BBCode.replaceBBCode('ul', function(contents) { return ['ul'].concat(Discourse.BBCode.removeEmptyLines(contents)); });
Discourse.BBCode.replaceBBCode('ol', function(contents) { return ['ol'].concat(Discourse.BBCode.removeEmptyLines(contents)); });
Discourse.BBCode.replaceBBCode('li', function(contents) { return ['li'].concat(Discourse.BBCode.removeEmptyLines(contents)); });

Discourse.BBCode.rawBBCode('img', function(contents) { return ['img', {href: contents}]; });
Discourse.BBCode.rawBBCode('email', function(contents) { return ['a', {href: "mailto:" + contents, 'data-bbcode': true}, contents]; });

Discourse.BBCode.replaceBBCode('url', function(contents) {
  if (!Array.isArray(contents)) { return; }
  if (contents.length === 1 && contents[0][0] === 'a') {
    // single-line bbcode links shouldn't be oneboxed, so we mark this as a bbcode link.
    if (typeof contents[0][1] !== 'object') { contents[0].splice(1, 0, {}); }
    contents[0][1]['data-bbcode'] = true;
  }
  return ['concat'].concat(contents);
});
Discourse.BBCode.replaceBBCodeParamsRaw('url', function(param, contents) {
  var url = param.replace(/(^")|("$)/g, '');
  return ['a', {'href': url}].concat(this.processInline(contents));
});
Discourse.Dialect.on('parseNode', function(event) {
  if (!Array.isArray(event.node)) { return; }
  var result = [ event.node[0] ];
  var nodes = event.node.slice(1);
  var i, j;
  for (i = 0; i < nodes.length; i++) {
    if (Array.isArray(nodes[i]) && nodes[i][0] === 'concat') {
      for (j = 1; j < nodes[i].length; j++) { result.push(nodes[i][j]); }
    } else {
      result.push(nodes[i]);
    }
  }
  for (i = 0; i < result.length; i++) { event.node[i] = result[i]; }
});

Discourse.BBCode.replaceBBCodeParamsRaw("email", function(param, contents) {
  return ['a', {href: "mailto:" + param, 'data-bbcode': true}].concat(contents);
});

// Handles `[code] ... [/code]` blocks
Discourse.Dialect.replaceBlock({
  start: /(\[code\])([\s\S]*)/igm,
  stop: /\[\/code\]/igm,
  rawContents: true,

  emitter: function(blockContents) {
    var inner = blockContents.join("\n");
    return ['p', ['pre', ['code', {'class': Discourse.SiteSettings.default_code_lang}, inner]]];
  }
});


// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  markdown-js doesn't ensure that em/strong codes are present on word boundaries.
  So we create our own handlers here.
**/

// From PageDown
var aLetter = /[a-zA-Z0-9\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0523\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0621-\u064a\u0660-\u0669\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07c0-\u07ea\u07f4-\u07f5\u07fa\u0904-\u0939\u093d\u0950\u0958-\u0961\u0966-\u096f\u0971-\u0972\u097b-\u097f\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09e6-\u09f1\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a66-\u0a6f\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0ae6-\u0aef\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b66-\u0b6f\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0be6-\u0bef\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58-\u0c59\u0c60-\u0c61\u0c66-\u0c6f\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0ce6-\u0cef\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d28\u0d2a-\u0d39\u0d3d\u0d60-\u0d61\u0d66-\u0d6f\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0ed0-\u0ed9\u0edc-\u0edd\u0f00\u0f20-\u0f29\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8b\u1000-\u102a\u103f-\u1049\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u1090-\u1099\u10a0-\u10c5\u10d0-\u10fa\u10fc\u1100-\u1159\u115f-\u11a2\u11a8-\u11f9\u1200-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u1676\u1681-\u169a\u16a0-\u16ea\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u17e0-\u17e9\u1810-\u1819\u1820-\u1877\u1880-\u18a8\u18aa\u1900-\u191c\u1946-\u196d\u1970-\u1974\u1980-\u19a9\u19c1-\u19c7\u19d0-\u19d9\u1a00-\u1a16\u1b05-\u1b33\u1b45-\u1b4b\u1b50-\u1b59\u1b83-\u1ba0\u1bae-\u1bb9\u1c00-\u1c23\u1c40-\u1c49\u1c4d-\u1c7d\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u2094\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2183-\u2184\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2c6f\u2c71-\u2c7d\u2c80-\u2ce4\u2d00-\u2d25\u2d30-\u2d65\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3006\u3031-\u3035\u303b-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31b7\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fc3\ua000-\ua48c\ua500-\ua60c\ua610-\ua62b\ua640-\ua65f\ua662-\ua66e\ua67f-\ua697\ua717-\ua71f\ua722-\ua788\ua78b-\ua78c\ua7fb-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8d0-\ua8d9\ua900-\ua925\ua930-\ua946\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa50-\uaa59\uac00-\ud7a3\uf900-\ufa2d\ufa30-\ufa6a\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]/;


var unhoist = function(obj,from,to){
  var unhoisted = 0;
  var regex = new RegExp(from, "g");

  if(_.isArray(obj)){
    for(var i=0; i<obj.length; i++){
      var item = obj[i];

      if(_.isString(item)){
        // Odd, but we need +1 for the / in front of /*
        var matches = item.match(regex);
        unhoisted -= matches ? matches.length : 0;

        obj[i] = item.replace(regex, to);
        unhoisted += item.length - obj[i].length;
      }
      if(_.isArray(item)){
        unhoisted += unhoist(item, from, to);
      }
    }
  }
  return unhoisted;
};

var replaceMarkdown = function(match, tag) {
  var hash = Discourse.Dialect.guid();

  Discourse.Dialect.registerInline(match, function(text, matched, prev){
    if(!text || text.length < match.length + 1) {
      return;
    }
    var lastText = prev[prev.length-1];
    lastText = typeof lastText === "string" && lastText;
    lastText = lastText && lastText[lastText.length-1];
    if(lastText && (lastText === "/" || lastText.match(aLetter))){
      return;
    }

    if(text[match.length].match(/\s/)) {
      return;
    }

    // hoist out escaped \*
    text = text.replace(new RegExp("\\\\\\" + match[0], "g"), hash);

    var endText = new RegExp("[^\\s|" + match[0] + "]" + match.replace(/\*/g,"\\*") + "([^" + match[0] + "]|$)");

    var finish = text.split("\n")[0].search(endText);
    if(finish && finish >= 0) {
      var newText = text.substring(match.length, finish+1);
      newText = this.processInline(newText);

      var unhoisted_length = unhoist(newText,hash,match[0]);

      var array = typeof tag === "string" ? [tag].concat(newText) : [tag[0], [tag[1]].concat(newText)];

      return [(finish + match.length + 1) - unhoisted_length, array];
    }
  });
};

replaceMarkdown('***', ['strong','em']);
replaceMarkdown('___', ['strong','em']);
replaceMarkdown('**', 'strong');
replaceMarkdown('__', 'strong');
replaceMarkdown('*', 'em');
replaceMarkdown('_', 'em');




// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Supports Discourse's category hashtags (#category-slug) for automatically
  generating a link to the category.
**/

Discourse.Dialect.inlineRegexp({
  start: '#',
  matcher: /^#([\w-:]{1,101})/i,
  spaceOrTagBoundary: true,

  emitter: function(matches) {
    var slug = matches[1],
        hashtag = matches[0],
        attributeClass = 'hashtag',
        categoryHashtagLookup = this.dialect.options.categoryHashtagLookup,
        result = categoryHashtagLookup && categoryHashtagLookup(slug);

    if (result) {
      return ['a', { class: attributeClass, href: result[0] }, '#', ["span", {}, result[1]]];
    } else {
      return ['span', { class: attributeClass }, hashtag];
    }
  }
});


// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

Discourse.Dialect.addPreProcessor(function(text) {
  return Discourse.CensoredWords.censor(text);
});


// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Support for various code blocks
**/


var acceptableCodeClasses;

function init() {
  acceptableCodeClasses = Discourse.SiteSettings.highlighted_languages.split("|");
  if (Discourse.SiteSettings.highlighted_languages.length > 0) {
    var regexpSource = "^lang-(" + "nohighlight|auto|" + Discourse.SiteSettings.highlighted_languages + ")$";
    Discourse.Markdown.whiteListTag('code', 'class', new RegExp(regexpSource, "i"));
  }
}

if (Discourse.SiteSettings) {
  init();
} else {
  Discourse.initializer({initialize: init, name: 'load-acceptable-code-classes'});
}


var textCodeClasses = ["text", "pre", "plain"];

function codeFlattenBlocks(blocks) {
  var result = "";
  blocks.forEach(function(b) {
    result += b;
    if (b.trailing) { result += b.trailing; }
  });
  return result;
}

Discourse.Dialect.replaceBlock({
  start: /^`{3}([^\n\[\]]+)?\n?([\s\S]*)?/gm,
  stop: /^```$/gm,
  withoutLeading: /\[quote/gm, //if leading text contains a quote this should not match
  emitter: function(blockContents, matches) {

    var klass = Discourse.SiteSettings.default_code_lang;

    if (acceptableCodeClasses && matches[1] && acceptableCodeClasses.indexOf(matches[1]) !== -1) {
      klass = matches[1];
    }

    if (textCodeClasses.indexOf(matches[1]) !== -1) {
      return ['p', ['pre', ['code', {'class': 'lang-nohighlight'}, codeFlattenBlocks(blockContents) ]]];
    } else  {
      return ['p', ['pre', ['code', {'class': 'lang-' + klass}, codeFlattenBlocks(blockContents) ]]];
    }
  }
});

Discourse.Dialect.replaceBlock({
  start: /(<pre[^\>]*\>)([\s\S]*)/igm,
  stop: /<\/pre>/igm,
  rawContents: true,
  skipIfTradtionalLinebreaks: true,

  emitter: function(blockContents) {
    return ['p', ['pre', codeFlattenBlocks(blockContents)]];
  }
});

// Ensure that content in a code block is fully escaped. This way it's not white listed
// and we can use HTML and Javascript examples.
Discourse.Dialect.on('parseNode', function (event) {
  var node = event.node,
      path = event.path;

  if (node[0] === 'code') {
    var contents = node[node.length-1],
        regexp;

    if (path && path[path.length-1] && path[path.length-1][0] && path[path.length-1][0] === "pre") {
      regexp = / +$/g;
    } else {
      regexp = /^ +| +$/g;
    }
    node[node.length-1] = Discourse.Utilities.escapeExpression(contents.replace(regexp,''));
  }
});


// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  If a row begins with HTML tags, don't parse it.
**/

var blockTags = ['address', 'article', 'aside', 'audio', 'blockquote', 'canvas', 'dd', 'div',
                 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3',
                 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'iframe', 'noscript', 'ol', 'output',
                 'p', 'pre', 'section', 'table', 'tfoot', 'ul', 'video'],

    splitAtLast = function(tag, block, next, first) {
      var endTag = "</" + tag + ">",
          endTagIndex = first ? block.indexOf(endTag) : block.lastIndexOf(endTag);

      if (endTagIndex !== -1) {
        endTagIndex += endTag.length;

        var leading = block.substr(0, endTagIndex),
            trailing = block.substr(endTagIndex).replace(/^\s+/, '');

        if (trailing.length) {
          next.unshift(trailing);
        }

        return [ leading ];
      }
    };

Discourse.Dialect.registerBlock('html', function(block, next) {
  var split, pos;

  // Fix manual blockquote paragraphing even though it's not strictly correct
  // PERF NOTE: /\S+<blockquote/ is a perf hog for search, try on huge string
  if (pos = block.search(/<blockquote/) >= 0) {
    if(block.substring(0, pos).search(/\s/) === -1) {
      split = splitAtLast('blockquote', block, next, true);
      if (split) { return this.processInline(split[0]); }
    }
  }

  var m = /^<([^>]+)\>/.exec(block);
  if (m && m[1]) {
    var tag = m[1].split(/\s/);
    if (tag && tag[0] && blockTags.indexOf(tag[0]) !== -1) {
      split = splitAtLast(tag[0], block, next);
      if (split) {
        if (split.length === 1 && split[0] === block) { return; }
        return split;
      }
      return [ block.toString() ];
    }
  }
});


// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Supports Discourse's custom @mention syntax for calling out a user in a post.
  It will add a special class to them, and create a link if the user is found in a
  local map.
**/

Discourse.Dialect.inlineRegexp({
  start: '@',
  // NOTE: since we can't use SiteSettings here (they loads later in process)
  // we are being less strict to account for more cases than allowed
  matcher: /^@(\w[\w.-]{0,59})\b/i,
  wordBoundary: true,

  emitter: function(matches) {
    var mention = matches[0].trim(),
        name = matches[1],
        mentionLookup = this.dialect.options.mentionLookup;

    var type = mentionLookup && mentionLookup(name);
    if (type === "user") {
      return ['a', {'class': 'mention', href: Discourse.getURL("/users/") + name.toLowerCase()}, mention];
    } else if (type === "group") {
      return ['a', {'class': 'mention-group', href: Discourse.getURL("/groups/") + name}, mention];
    } else {
      return ['span', {'class': 'mention'}, mention];
    }
  }
});

// We have to prune @mentions that are within links.
Discourse.Dialect.on("parseNode", function(event) {
  var node = event.node,
      path = event.path;

  if (node[1] && node[1]["class"] === 'mention')  {
    var parent = path[path.length - 1];
    // If the parent is an 'a', remove it
    if (parent && parent[0] === 'a') {
      var name = node[2];
      node.length = 0;
      node[0] = "__RAW";
      node[1] = name;
    }
  }

});


// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

Discourse.Dialect.on('parseNode', function (event) {
  var node = event.node,
      path = event.path;

  if (node[0] === 'a') {

    // It's invalid HTML to nest a link within another so strip it out.
    for (var i=0; i<path.length; i++) {
      if (path[i][0] === 'a') {
        var parent = path[path.length - 1],
            pos = parent.indexOf(node);

        // Just leave the link text
        if (pos !== -1) {
          parent[pos] = node[2];
        }
        return;
      }
    }
  }
});


// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Support for the newline behavior in markdown that most expect. Look through all text nodes
  in the tree, replace any new lines with `br`s.
**/

Discourse.Dialect.postProcessText(function (text, event) {
  var opts = event.dialect.options,
      insideCounts = event.insideCounts,
      linebreaks = opts.traditional_markdown_linebreaks || Discourse.SiteSettings.traditional_markdown_linebreaks;

  if (linebreaks || (insideCounts.pre > 0)) { return; }

  if (text === "\n") {
    // If the tag is just a new line, replace it with a `<br>`
    return [['br']];
  } else {


    // If the text node contains new lines, perhaps with text between them, insert the
    // `<br>` tags.
    var split = text.split(/\n+/);
    if (split.length) {
      var replacement = [];
      for (var i=0; i<split.length; i++) {
        if (split[i].length > 0) { replacement.push(split[i]); }
        if (i !== split.length-1) { replacement.push(['br']); }
      }

      return replacement;
    }
  }

});


// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Given a node in the document and its parent, determine whether it is on its
  own line or not.

  @method isOnOneLine
  @namespace Discourse.Dialect
**/

var isOnOneLine = function(link, parent) {
  if (!parent) { return false; }

  var siblings = parent.slice(1);
  if ((!siblings) || (siblings.length < 1)) { return false; }

  var idx = siblings.indexOf(link);
  if (idx === -1) { return false; }

  if (idx > 0) {
    var prev = siblings[idx-1];
    if (prev[0] !== 'br') { return false; }
  }

  if (idx < siblings.length) {
    var next = siblings[idx+1];
    if (next && (!((next[0] === 'br') || (typeof next === 'string' && next.trim() === "")))) { return false; }
  }

  return true;
};

/**
  We only onebox stuff that is on its own line. This navigates the JsonML tree and
  correctly inserts the oneboxes.

  @event parseNode
  @namespace Discourse.Dialect
**/
Discourse.Dialect.on("parseNode", function(event) {
  var node = event.node,
      path = event.path;

  // We only care about links
  if (node[0] !== 'a')  { return; }

  var parent = path[path.length - 1];

  // We don't onebox bbcode
  if (node[1]['data-bbcode']) {
    delete node[1]['data-bbcode'];
    return;
  }

  // We don't onebox mentions
  if (node[1]['class'] === 'mention') { return; }

  // Don't onebox links within a list
  for (var i=0; i<path.length; i++) {
    if (path[i][0] === 'li') { return; }
  }

  // If the link has a different label text than the link itself, don't onebox it.
  var label = node[node.length-1];
  if (label !== node[1]['href']) { return; }

  if (isOnOneLine(node, parent)) {

    node[1]['class'] = 'onebox';
    node[1].target = '_blank';

    if (Discourse && Discourse.Onebox) {
      var contents = Discourse.Onebox.lookupCache(node[1].href);
      if (contents) {
        node[0] = '__RAW';
        node[1] = contents;
        node.length = 2;
      }
    }
  }
});



// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

var esc = Handlebars.Utils.escapeExpression;

Discourse.BBCode.register('quote', {noWrap: true, singlePara: true}, function(contents, bbParams, options) {
  var params = {'class': 'quote'},
      username = null;

  if (bbParams) {
    var paramsSplit = bbParams.split(/\,\s*/);
    username = paramsSplit[0];

    paramsSplit.forEach(function(p,i) {
      if (i > 0) {
        var assignment = p.split(':');
        if (assignment[0] && assignment[1]) {
          var escaped = esc(assignment[0]);
          // don't escape attributes, makes no sense
          if(escaped === assignment[0]) {
            params['data-' + assignment[0]] = esc(assignment[1].trim());
          }
        }
      }
    });
  }

  var avatarImg;
  var postNumber = parseInt(params['data-post'], 10);
  var topicId = parseInt(params['data-topic'], 10);

  if (options.lookupAvatarByPostNumber) {
    // client-side, we can retrieve the avatar from the post
    avatarImg = options.lookupAvatarByPostNumber(postNumber, topicId);
  } else if (options.lookupAvatar) {
    // server-side, we need to lookup the avatar from the username
    avatarImg = options.lookupAvatar(username);
  }

  // If there's no username just return a simple quote
  if (!username) {
    return ['p', ['aside', params, ['blockquote'].concat(contents)]];
  }

  var header = [ 'div', {'class': 'title'},
                 ['div', {'class': 'quote-controls'}],
                 avatarImg ? ['__RAW', avatarImg] : "",
                 username ? I18n.t('user.said', {username: username}) : ""
               ];

  if (options.topicId && postNumber && options.getTopicInfo && topicId !== options.topicId) {
    var topicInfo = options.getTopicInfo(topicId);
    if (topicInfo) {
      var href = topicInfo.href;
      if (postNumber > 0) { href += "/" + postNumber; }
      // get rid of username said stuff
      header.pop();
      header.push(['a', {'href': href}, topicInfo.title]);
    }
  }


  return ['aside', params, header, ['blockquote'].concat(contents)];
});


// IIFE Wrapped Content Ends

 })(this);
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

var tableFlattenBlocks = function(blocks) {
  var result = "";
  blocks.forEach(function(b) {
    result += b;
    if (b.trailing) { result += b.trailing; }
  });

  // bypass newline insertion
  return result.replace(/[\n\r]/g, " ");
};

var emitter = function(contents) {
  // TODO event should be fired when sanitizer loads
  if (window.html4 && window.html4.ELEMENTS.td !== 1) {
     window.html4.ELEMENTS.table = 0;
     window.html4.ELEMENTS.tbody = 1;
     window.html4.ELEMENTS.td = 1;
     window.html4.ELEMENTS.thead = 1;
     window.html4.ELEMENTS.th = 1;
     window.html4.ELEMENTS.tr = 1;
  }
  return ['table', {"class": "md-table"}, tableFlattenBlocks.apply(this, [contents])];
};

var tableBlock = {
  start: /(<table[^>]*>)([\S\s]*)/igm,
  stop: /<\/table>/igm,
  rawContents: true,
  emitter: emitter,
  priority: 1
};

var init = function(){
  if (Discourse.SiteSettings.allow_html_tables) {
    Discourse.Markdown.whiteListTag("table");
    Discourse.Markdown.whiteListTag("table", "class", "md-table");
    Discourse.Markdown.whiteListTag("tbody");
    Discourse.Markdown.whiteListTag("thead");
    Discourse.Markdown.whiteListTag("tr");
    Discourse.Markdown.whiteListTag("th");
    Discourse.Markdown.whiteListTag("td");
    Discourse.Dialect.replaceBlock(tableBlock);

  }
};

if (Discourse.SiteSettings) {
  init();
} else {
  Discourse.initializer({initialize: init, name: 'enable-html-tables'});
}


// IIFE Wrapped Content Ends

 })(this);
define("discourse/controllers/about", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      faqOverriden: Ember.computed.gt('siteSettings.faq_url.length', 0),

      contactInfo: (function () {
        if (this.siteSettings.contact_url) {
          return I18n.t('about.contact_info', { contact_info: "<a href='" + this.siteSettings.contact_url + "' target='_blank'>" + this.siteSettings.contact_url + "</a>" });
        } else if (this.siteSettings.contact_email) {
          return I18n.t('about.contact_info', { contact_info: this.siteSettings.contact_email });
        } else {
          return null;
        }
      }).property()
    });
  });
define("discourse/controllers/application", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'showTop',
      initializer: function () {
        return true;
      }
    }, {
      key: 'showFooter',
      initializer: function () {
        return false;
      }
    }, {
      key: 'styleCategory',
      initializer: function () {
        return null;
      }
    }, {
      key: 'canSignUp',
      decorators: [computed],
      value: function () {
        return !Discourse.SiteSettings.invite_only && Discourse.SiteSettings.allow_new_registrations && !Discourse.SiteSettings.enable_sso;
      }
    }, {
      key: 'loginRequired',
      decorators: [computed],
      value: function () {
        return Discourse.SiteSettings.login_required && !Discourse.User.current();
      }
    }]));
  });
define("discourse/controllers/avatar-selector", 
  ["ember-addons/ember-computed-decorators","discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var ModalFunctionality = __dependency2__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: "selectedUploadId",
      decorators: [computed("selected", "system_avatar_upload_id", "gravatar_avatar_upload_id", "custom_avatar_upload_id")],
      value: function (selected, system, gravatar, custom) {
        switch (selected) {
          case "system":
            return system;
          case "gravatar":
            return gravatar;
          default:
            return custom;
        }
      }
    }, {
      key: "selectedAvatarTemplate",
      decorators: [computed("selected", "system_avatar_template", "gravatar_avatar_template", "custom_avatar_template")],
      value: function (selected, system, gravatar, custom) {
        switch (selected) {
          case "system":
            return system;
          case "gravatar":
            return gravatar;
          default:
            return custom;
        }
      }
    }, {
      key: "allowAvatarUpload",
      decorators: [computed()],
      value: function () {
        return this.siteSettings.allow_uploaded_avatars && Discourse.Utilities.allowsImages();
      }
    }, {
      key: "actions",
      initializer: function () {
        return {
          useUploadedAvatar: function () {
            this.set("selected", "uploaded");
          },
          useGravatar: function () {
            this.set("selected", "gravatar");
          },
          useSystem: function () {
            this.set("selected", "system");
          },

          refreshGravatar: function () {
            var _this = this;

            this.set("gravatarRefreshDisabled", true);
            return Discourse.ajax("/user_avatar/" + this.get("username") + "/refresh_gravatar.json", { method: "POST" }).then(function (result) {
              return _this.setProperties({
                gravatar_avatar_template: result.gravatar_avatar_template,
                gravatar_avatar_upload_id: result.gravatar_upload_id
              });
            }).finally(function () {
              return _this.set("gravatarRefreshDisabled", false);
            });
          }
        };
      }
    }]));
  });
define("discourse/controllers/badges/index", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      badgeGroups: (function () {
        var sorted = _.sortBy(this.get('model'), function (badge) {
          var pos = badge.get('badge_grouping.position');
          var type = badge.get('badge_type_id');
          var name = badge.get('name');

          return ("000" + pos).slice(-4) + (10 - type) + name;
        });

        var grouped = [];
        var group = [],
            groupId;

        sorted.forEach(function (badge) {
          if (groupId !== badge.badge_grouping_id) {
            if (group && group.length > 0) {
              grouped.push({ badges: group, badgeGrouping: group[0].badge_grouping });
            }
            group = [];
            groupId = badge.badge_grouping_id;
          }
          group.push(badge);
        });

        if (group && group.length > 0) {
          grouped.push({ badges: group, badgeGrouping: group[0].badge_grouping });
        }

        return grouped;
      }).property('model')
    });
  });
define("discourse/controllers/badges/show", 
  ["discourse/models/user-badge","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var UserBadge = __dependency1__["default"];
    var computed = __dependency2__.default;
    var observes = __dependency2__.observes;

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'queryParams',
      initializer: function () {
        return ['username'];
      }
    }, {
      key: 'noMoreBadges',
      initializer: function () {
        return false;
      }
    }, {
      key: 'userBadges',
      initializer: function () {
        return null;
      }
    }, {
      key: 'needs',
      initializer: function () {
        return ["application"];
      }
    }, {
      key: 'user',
      decorators: [computed('username')],
      value: function (username) {
        if (username) {
          return this.get('userBadges')[0].get('user');
        }
      }
    }, {
      key: 'grantCount',
      decorators: [computed('username', 'model.grant_count', 'userBadges.grant_count')],
      value: function (username, modelCount, userCount) {
        return username ? userCount : modelCount;
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          loadMore: function () {
            var _this = this;

            if (this.get('loadingMore')) {
              return;
            }
            this.set('loadingMore', true);

            var userBadges = this.get('userBadges');

            UserBadge.findByBadgeId(this.get('model.id'), {
              offset: userBadges.length,
              username: this.get('username')
            }).then(function (result) {
              userBadges.pushObjects(result);
              if (userBadges.length === 0) {
                _this.set('noMoreBadges', true);
              }
            }).finally(function () {
              _this.set('loadingMore', false);
            });
          }
        };
      }
    }, {
      key: 'canLoadMore',
      decorators: [computed('noMoreBadges', 'grantCount', 'userBadges.length')],
      value: function (noMoreBadges, grantCount, userBadgeLength) {
        if (noMoreBadges) {
          return false;
        }
        return grantCount > (userBadgeLength || 0);
      }
    }, {
      key: 'canShowOthers',
      decorators: [computed('user', 'model.grant_count')],
      value: function (user, grantCount) {
        return !!user && grantCount > 1;
      }
    }, {
      key: '_showFooter',
      decorators: [observes('canLoadMore')],
      value: function () {
        this.set("controllers.application.showFooter", !this.get("canLoadMore"));
      }
    }]));
  });
define("discourse/controllers/bulk-notification-level", 
  ["discourse/lib/notification-levels","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var NotificationLevels = __dependency1__["default"];

    // Support for changing the notification level of various topics
    __exports__["default"] = Em.Controller.extend({
      needs: ['topic-bulk-actions'],
      notificationLevelId: null,

      notificationLevels: (function () {
        var result = [];
        Object.keys(NotificationLevels).forEach(function (k) {
          result.push({
            id: NotificationLevels[k].toString(),
            name: I18n.t('topic.notifications.' + k.toLowerCase() + ".title"),
            description: I18n.t('topic.notifications.' + k.toLowerCase() + ".description")
          });
        });
        return result;
      }).property(),

      disabled: Em.computed.empty("notificationLevelId"),

      actions: {
        changeNotificationLevel: function () {
          this.get('controllers.topic-bulk-actions').performAndRefresh({
            type: 'change_notification_level',
            notification_level_id: this.get('notificationLevelId')
          });
        }
      }
    });
  });
define("discourse/controllers/change-owner", 
  ["discourse/mixins/selected-posts-count","discourse/mixins/modal-functionality","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var SelectedPostsCount = __dependency1__["default"];
    var ModalFunctionality = __dependency2__["default"];
    var DiscourseURL = __dependency3__["default"];

    // Modal related to changing the ownership of posts
    __exports__["default"] = Ember.Controller.extend(SelectedPostsCount, ModalFunctionality, {
      needs: ['topic'],

      topicController: Em.computed.alias('controllers.topic'),
      selectedPosts: Em.computed.alias('topicController.selectedPosts'),
      saving: false,
      new_user: null,

      buttonDisabled: (function () {
        if (this.get('saving')) return true;
        return Ember.isEmpty(this.get('new_user'));
      }).property('saving', 'new_user'),

      buttonTitle: (function () {
        if (this.get('saving')) return I18n.t('saving');
        return I18n.t('topic.change_owner.action');
      }).property('saving'),

      onShow: function () {
        this.setProperties({
          saving: false,
          new_user: ''
        });
      },

      actions: {
        changeOwnershipOfPosts: function () {
          this.set('saving', true);

          var postIds = this.get('selectedPosts').map(function (p) {
            return p.get('id');
          }),
              self = this,
              saveOpts = {
            post_ids: postIds,
            username: this.get('new_user')
          };

          Discourse.Topic.changeOwners(this.get('topicController.model.id'), saveOpts).then(function () {
            // success
            self.send('closeModal');
            self.get('topicController').send('deselectAll');
            if (self.get('topicController.multiSelect')) {
              self.get('topicController').send('toggleMultiSelect');
            }
            Em.run.next(function () {
              DiscourseURL.routeTo(self.get("topicController.model.url"));
            });
          }, function () {
            // failure
            self.flash(I18n.t('topic.change_owner.error'), 'alert-error');
            self.set('saving', false);
          });
          return false;
        }
      }
    });
  });
define("discourse/controllers/change-timestamp", 
  ["discourse/mixins/modal-functionality","ember-addons/ember-computed-decorators","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ModalFunctionality = __dependency1__["default"];
    var computed = __dependency2__["default"];
    var DiscourseURL = __dependency3__["default"];

    // Modal related to changing the timestamp of posts
    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['topic'];
      }
    }, {
      key: 'topicController',
      initializer: function () {
        return Em.computed.alias('controllers.topic');
      }
    }, {
      key: 'saving',
      initializer: function () {
        return false;
      }
    }, {
      key: 'date',
      initializer: function () {
        return '';
      }
    }, {
      key: 'time',
      initializer: function () {
        return '';
      }
    }, {
      key: 'buttonTitle',
      decorators: [computed('saving')],
      value: function (saving) {
        return saving ? I18n.t('saving') : I18n.t('topic.change_timestamp.action');
      }
    }, {
      key: 'createdAt',
      decorators: [computed('date', 'time')],
      value: function (date, time) {
        return moment(date + ' ' + time, 'YYYY-MM-DD HH:mm:ss');
      }
    }, {
      key: 'validTimestamp',
      decorators: [computed('createdAt')],
      value: function (createdAt) {
        return moment().diff(createdAt, 'minutes') < 0;
      }
    }, {
      key: 'buttonDisabled',
      decorators: [computed('saving', 'date', 'validTimestamp')],
      value: function () {
        if (this.get('saving') || this.get('validTimestamp')) return true;
        return Ember.isEmpty(this.get('date'));
      }
    }, {
      key: 'onShow',
      initializer: function () {
        return function () {
          this.setProperties({
            date: moment().format('YYYY-MM-DD')
          });
        };
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          changeTimestamp: function () {
            this.set('saving', true);
            var self = this,
                topic = this.get('topicController.model');

            Discourse.Topic.changeTimestamp(topic.get('id'), this.get('createdAt').unix()).then(function () {
              self.send('closeModal');
              self.setProperties({ date: '', time: '', saving: false });
              Em.run.next(function () {
                DiscourseURL.routeTo(topic.get('url'));
              });
            }).catch(function () {
              self.flash(I18n.t('topic.change_timestamp.error'), 'alert-error');
              self.set('saving', false);
            });
            return false;
          }
        };
      }
    }]));
  });
define("discourse/controllers/composer-messages", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // A controller for displaying messages as the user composes a message.
    __exports__["default"] = Ember.ArrayController.extend({
      needs: ['composer'],

      // Whether we've checked our messages
      checkedMessages: false,

      _init: (function () {
        this.reset();
      }).on("init"),

      actions: {
        closeMessage: function (message) {
          this.removeObject(message);
        },

        hideMessage: function (message) {
          this.removeObject(message);
          // kind of hacky but the visibility depends on this
          this.get('messagesByTemplate')[message.get('templateName')] = undefined;
        },

        popup: function (message) {
          var messagesByTemplate = this.get('messagesByTemplate');
          var templateName = message.get('templateName');

          if (!messagesByTemplate[templateName]) {
            this.pushObject(message);
            messagesByTemplate[templateName] = message;
          }
        }
      },

      // Resets all active messages.
      // For example if composing a new post.
      reset: function () {
        this.clear();
        this.setProperties({
          messagesByTemplate: {},
          queuedForTyping: [],
          checkedMessages: false
        });
      },

      // Called after the user has typed a reply.
      // Some messages only get shown after being typed.
      typedReply: function () {
        var _this = this;

        this.get('queuedForTyping').forEach(function (msg) {
          return _this.send("popup", msg);
        });
      },

      groupsMentioned: function (groups) {
        var _this2 = this;

        // reset existing messages, this should always win it is critical
        this.reset();
        groups.forEach(function (group) {
          var msg = I18n.t('composer.group_mentioned', {
            group: "@" + group.name,
            count: group.user_count,
            group_link: Discourse.getURL('/group/' + group.name + '/members')
          });
          _this2.send("popup", Em.Object.create({
            templateName: 'composer/group-mentioned',
            body: msg }));
        });
      },

      // Figure out if there are any messages that should be displayed above the composer.
      queryFor: function (composer) {
        if (this.get('checkedMessages')) {
          return;
        }

        var self = this;
        var queuedForTyping = self.get('queuedForTyping');

        Discourse.ComposerMessage.find(composer).then(function (messages) {
          self.set('checkedMessages', true);
          messages.forEach(function (msg) {
            return msg.wait_for_typing ? queuedForTyping.addObject(msg) : self.send("popup", msg);
          });
        });
      }

    });
  });
define("discourse/controllers/composer", 
  ["discourse/lib/url","discourse/lib/quote","discourse/models/draft","discourse/models/composer","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var DiscourseURL = __dependency1__["default"];
    var Quote = __dependency2__["default"];
    var Draft = __dependency3__["default"];
    var Composer = __dependency4__["default"];
    var computed = __dependency5__.default;
    var observes = __dependency5__.observes;

    function loadDraft(store, opts) {
      opts = opts || {};

      var draft = opts.draft;
      var draftKey = opts.draftKey;
      var draftSequence = opts.draftSequence;

      try {
        if (draft && typeof draft === 'string') {
          draft = JSON.parse(draft);
        }
      } catch (error) {
        draft = null;
        Draft.clear(draftKey, draftSequence);
      }
      if (draft && (draft.title && draft.title !== '' || draft.reply && draft.reply !== '')) {
        var composer = store.createRecord('composer');
        composer.open({
          draftKey: draftKey,
          draftSequence: draftSequence,
          action: draft.action,
          title: draft.title,
          categoryId: draft.categoryId || opts.categoryId,
          postId: draft.postId,
          archetypeId: draft.archetypeId,
          reply: draft.reply,
          metaData: draft.metaData,
          usernames: draft.usernames,
          draft: true,
          composerState: Composer.DRAFT,
          composerTime: draft.composerTime,
          typingTime: draft.typingTime
        });
        return composer;
      }
    }

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['modal', 'topic', 'composer-messages', 'application'];
      }
    }, {
      key: 'replyAsNewTopicDraft',
      initializer: function () {
        return Em.computed.equal('model.draftKey', Composer.REPLY_AS_NEW_TOPIC_KEY);
      }
    }, {
      key: 'checkedMessages',
      initializer: function () {
        return false;
      }
    }, {
      key: 'showEditReason',
      initializer: function () {
        return false;
      }
    }, {
      key: 'editReason',
      initializer: function () {
        return null;
      }
    }, {
      key: 'scopedCategoryId',
      initializer: function () {
        return null;
      }
    }, {
      key: 'similarTopics',
      initializer: function () {
        return null;
      }
    }, {
      key: 'similarTopicsMessage',
      initializer: function () {
        return null;
      }
    }, {
      key: 'lastSimilaritySearch',
      initializer: function () {
        return null;
      }
    }, {
      key: 'optionsVisible',
      initializer: function () {
        return false;
      }
    }, {
      key: 'lastValidatedAt',
      initializer: function () {
        return null;
      }
    }, {
      key: 'isUploading',
      initializer: function () {
        return false;
      }
    }, {
      key: 'topic',
      initializer: function () {
        return null;
      }
    }, {
      key: 'showToolbar',
      initializer: function () {
        return Em.computed({
          get: function () {
            var keyValueStore = this.container.lookup('key-value-store:main');
            var storedVal = keyValueStore.get("toolbar-enabled");
            if (this._toolbarEnabled === undefined && storedVal === undefined) {
              // iPhone 6 is 375, anything narrower and toolbar should
              // be default disabled.
              // That said we should remember the state
              this._toolbarEnabled = $(window).width() > 370;
            }
            return this._toolbarEnabled || storedVal === "true";
          },
          set: function (key, val) {
            var keyValueStore = this.container.lookup('key-value-store:main');
            this._toolbarEnabled = val;
            keyValueStore.set({ key: "toolbar-enabled", value: val ? "true" : "false" });
            return val;
          }
        });
      }
    }, {
      key: 'topicModel',
      initializer: function () {
        return Ember.computed.alias('controllers.topic.model');
      }
    }, {
      key: '_initializeSimilar',
      initializer: function () {
        return (function () {
          this.set('similarTopics', []);
        }).on('init');
      }
    }, {
      key: 'canEditTags',
      decorators: [computed('model.canEditTitle', 'model.creatingPrivateMessage')],
      value: function (canEditTitle, creatingPrivateMessage) {
        return !this.site.mobileView && this.site.get('can_tag_topics') && canEditTitle && !creatingPrivateMessage;
      }
    }, {
      key: 'canWhisper',
      decorators: [computed('model.action')],
      value: function (action) {
        var currentUser = this.currentUser;
        return currentUser && currentUser.get('staff') && this.siteSettings.enable_whispers && action === Composer.REPLY;
      }
    }, {
      key: 'showWarning',
      initializer: function () {
        return (function () {
          if (!Discourse.User.currentProp('staff')) {
            return false;
          }

          var usernames = this.get('model.targetUsernames');
          var hasTargetGroups = this.get('model.hasTargetGroups');

          // We need exactly one user to issue a warning
          if (Ember.isEmpty(usernames) || usernames.split(',').length !== 1 || hasTargetGroups) {
            return false;
          }
          return this.get('model.creatingPrivateMessage');
        }).property('model.creatingPrivateMessage', 'model.targetUsernames');
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {

          toggleWhisper: function () {
            this.toggleProperty('model.whisper');
          },

          toggleToolbar: function () {
            this.toggleProperty('showToolbar');
          },

          showOptions: function (loc) {
            this.appEvents.trigger('popup-menu:open', loc);
            this.set('optionsVisible', true);
          },

          hideOptions: function () {
            this.set('optionsVisible', false);
          },

          // Toggle the reply view
          toggle: function () {
            this.toggle();
          },

          togglePreview: function () {
            this.get('model').togglePreview();
          },

          // Import a quote from the post
          importQuote: function (toolbarEvent) {
            var _this = this;

            var postStream = this.get('topic.postStream');
            var postId = this.get('model.post.id');

            // If there is no current post, use the first post id from the stream
            if (!postId && postStream) {
              postId = postStream.get('stream.firstObject');
            }

            // If we're editing a post, fetch the reply when importing a quote
            if (this.get('model.editingPost')) {
              var replyToPostNumber = this.get('model.post.reply_to_post_number');
              if (replyToPostNumber) {
                var replyPost = postStream.get('posts').findBy('post_number', replyToPostNumber);
                if (replyPost) {
                  postId = replyPost.get('id');
                }
              }
            }

            if (postId) {
              var _ret = (function () {
                _this.set('model.loading', true);
                var composer = _this;

                return {
                  v: _this.store.find('post', postId).then(function (post) {
                    var quote = Quote.build(post, post.get("raw"), { raw: true, full: true });
                    toolbarEvent.addText(quote);
                    composer.set('model.loading', false);
                  })
                };
              })();

              if (typeof _ret === 'object') return _ret.v;
            }
          },

          cancel: function () {
            this.cancelComposer();
          },

          save: function () {
            this.save();
          },

          displayEditReason: function () {
            this.set("showEditReason", true);
          },

          hitEsc: function () {
            var messages = this.get('controllers.composer-messages.model');
            if (messages.length) {
              messages.popObject();
              return;
            }

            if (this.get('model.viewOpen')) {
              this.shrink();
            }
          },

          openIfDraft: function () {
            if (this.get('model.viewDraft')) {
              this.set('model.composeState', Composer.OPEN);
            }
          },

          groupsMentioned: function (groups) {
            if (!this.get('model.creatingPrivateMessage') && !this.get('model.topic.isPrivateMessage')) {
              this.get('controllers.composer-messages').groupsMentioned(groups);
            }
          }

        };
      }
    }, {
      key: 'categories',
      initializer: function () {
        return (function () {
          return Discourse.Category.list();
        }).property();
      }
    }, {
      key: 'toggle',
      value: function () {
        this.closeAutocomplete();
        switch (this.get('model.composeState')) {
          case Composer.OPEN:
            if (Ember.isEmpty(this.get('model.reply')) && Ember.isEmpty(this.get('model.title'))) {
              this.close();
            } else {
              this.shrink();
            }
            break;
          case Composer.DRAFT:
            this.set('model.composeState', Composer.OPEN);
            break;
          case Composer.SAVING:
            this.close();
        }
        return false;
      }
    }, {
      key: 'disableSubmit',
      initializer: function () {
        return Ember.computed.or("model.loading", "isUploading");
      }
    }, {
      key: 'save',
      value: function (force) {
        var _this2 = this;

        var composer = this.get('model');
        var self = this;

        // Clear the warning state if we're not showing the checkbox anymore
        if (!this.get('showWarning')) {
          this.set('model.isWarning', false);
        }

        if (composer.get('cantSubmitPost')) {
          this.set('lastValidatedAt', Date.now());
          return;
        }

        composer.set('disableDrafts', true);

        // for now handle a very narrow use case
        // if we are replying to a topic AND not on the topic pop the window up
        if (!force && composer.get('replyingToTopic')) {
          var _ret2 = (function () {

            var currentTopic = _this2.get('topicModel');
            if (!currentTopic || currentTopic.get('id') !== composer.get('topic.id')) {
              var message = I18n.t("composer.posting_not_on_topic");

              var buttons = [{
                "label": I18n.t("composer.cancel"),
                "class": "cancel",
                "link": true
              }];

              if (currentTopic) {
                buttons.push({
                  "label": I18n.t("composer.reply_here") + "<br/><div class='topic-title overflow-ellipsis'>" + Discourse.Utilities.escapeExpression(currentTopic.get('title')) + "</div>",
                  "class": "btn btn-reply-here",
                  "callback": function () {
                    composer.set('topic', currentTopic);
                    composer.set('post', null);
                    self.save(true);
                  }
                });
              }

              buttons.push({
                "label": I18n.t("composer.reply_original") + "<br/><div class='topic-title overflow-ellipsis'>" + Discourse.Utilities.escapeExpression(_this2.get('model.topic.title')) + "</div>",
                "class": "btn-primary btn-reply-on-original",
                "callback": function () {
                  self.save(true);
                }
              });

              bootbox.dialog(message, buttons, { "classes": "reply-where-modal" });
              return {
                v: undefined
              };
            }
          })();

          if (typeof _ret2 === 'object') return _ret2.v;
        }

        var staged = false;

        // TODO: This should not happen in model
        var imageSizes = {};
        $('#reply-control .d-editor-preview img').each(function (i, e) {
          var $img = $(e);
          var src = $img.prop('src');

          if (src && src.length) {
            imageSizes[src] = { width: $img.width(), height: $img.height() };
          }
        });

        var promise = composer.save({ imageSizes: imageSizes, editReason: this.get("editReason") }).then(function (result) {
          if (result.responseJson.action === "enqueued") {
            self.send('postWasEnqueued', result.responseJson);
            self.destroyDraft();
            self.close();
            self.appEvents.trigger('post-stream:refresh');
            return result;
          }

          // If user "created a new topic/post" or "replied as a new topic" successfully, remove the draft.
          if (result.responseJson.action === "create_post" || self.get('replyAsNewTopicDraft')) {
            self.destroyDraft();
          }
          if (self.get('model.action') === 'edit') {
            self.appEvents.trigger('post-stream:refresh', { id: parseInt(result.responseJson.id) });
          } else {
            self.appEvents.trigger('post-stream:refresh');
          }

          if (result.responseJson.action === "create_post") {
            self.appEvents.trigger('post:highlight', result.payload.post_number);
          }
          self.close();

          var currentUser = Discourse.User.current();
          if (composer.get('creatingTopic')) {
            currentUser.set('topic_count', currentUser.get('topic_count') + 1);
          } else {
            currentUser.set('reply_count', currentUser.get('reply_count') + 1);
          }

          var disableJumpReply = Discourse.User.currentProp('disable_jump_reply');
          if (!composer.get('replyingToTopic') || !disableJumpReply) {
            var post = result.target;
            if (post && !staged) {
              DiscourseURL.routeTo(post.get('url'));
            }
          }
        }).catch(function (error) {
          composer.set('disableDrafts', false);
          self.appEvents.one('composer:opened', function () {
            return bootbox.alert(error);
          });
        });

        if (this.get('controllers.application.currentRouteName').split('.')[0] === 'topic' && composer.get('topic.id') === this.get('topicModel.id')) {
          staged = composer.get('stagedPost');
        }

        this.appEvents.trigger('post-stream:posted', staged);

        this.messageBus.pause();
        promise.finally(function () {
          return _this2.messageBus.resume();
        });

        return promise;
      }
    }, {
      key: 'checkReplyLength',

      // Checks to see if a reply has been typed.
      // This is signaled by a keyUp event in a view.
      value: function () {
        if (!Ember.isEmpty('model.reply')) {
          // Notify the composer messages controller that a reply has been typed. Some
          // messages only appear after typing.
          this.get('controllers.composer-messages').typedReply();
        }
      }
    }, {
      key: 'findSimilarTopics',

      // Fired after a user stops typing.
      // Considers whether to check for similar topics based on the current composer state.
      value: function () {
        // We don't care about similar topics unless creating a topic
        if (!this.get('model.creatingTopic')) {
          return;
        }

        var body = this.get('model.reply') || '';
        var title = this.get('model.title') || '';

        // Ensure the fields are of the minimum length
        if (body.length < Discourse.SiteSettings.min_body_similar_length) {
          return;
        }
        if (title.length < Discourse.SiteSettings.min_title_similar_length) {
          return;
        }

        // TODO pass the 200 in from somewhere
        body = body.substr(0, 200);

        // Done search over and over
        if (title + body === this.get('lastSimilaritySearch')) {
          return;
        }
        this.set('lastSimilaritySearch', title + body);

        var messageController = this.get('controllers.composer-messages'),
            similarTopics = this.get('similarTopics');

        var message = this.get('similarTopicsMessage');
        if (!message) {
          message = Discourse.ComposerMessage.create({
            templateName: 'composer/similar-topics',
            extraClass: 'similar-topics'
          });
          this.set('similarTopicsMessage', message);
        }

        this.store.find('similar-topic', { title: title, raw: body }).then(function (newTopics) {
          similarTopics.clear();
          similarTopics.pushObjects(newTopics.get('content'));

          if (similarTopics.get('length') > 0) {
            message.set('similarTopics', similarTopics);
            messageController.send("popup", message);
          } else if (message) {
            messageController.send("hideMessage", message);
          }
        });
      }
    }, {
      key: 'open',

      /**
        Open the composer view
         @method open
        @param {Object} opts Options for creating a post
          @param {String} opts.action The action we're performing: edit, reply or createTopic
          @param {Discourse.Post} [opts.post] The post we're replying to
          @param {Discourse.Topic} [opts.topic] The topic we're replying to
          @param {String} [opts.quote] If we're opening a reply from a quote, the quote we're making
      **/
      value: function (opts) {
        opts = opts || {};

        if (!opts.draftKey) {
          alert("composer was opened without a draft key");
          throw "composer opened without a proper draft key";
        }

        // If we show the subcategory list, scope the categories drop down to
        // the category we opened the composer with.
        if (this.siteSettings.show_subcategory_list && opts.draftKey !== 'reply_as_new_topic') {
          this.set('scopedCategoryId', opts.categoryId);
        }

        var composerMessages = this.get('controllers.composer-messages'),
            self = this;

        var composerModel = this.get('model');

        this.setProperties({ showEditReason: false, editReason: null });
        composerMessages.reset();

        // If we want a different draft than the current composer, close it and clear our model.
        if (composerModel && opts.draftKey !== composerModel.draftKey && composerModel.composeState === Composer.DRAFT) {
          this.close();
          composerModel = null;
        }

        return new Ember.RSVP.Promise(function (resolve, reject) {
          if (composerModel && composerModel.get('replyDirty')) {

            // If we're already open, we don't have to do anything
            if (composerModel.get('composeState') === Composer.OPEN && composerModel.get('draftKey') === opts.draftKey && !opts.action) {
              return resolve();
            }

            // If it's the same draft, just open it up again.
            if (composerModel.get('composeState') === Composer.DRAFT && composerModel.get('draftKey') === opts.draftKey) {
              composerModel.set('composeState', Composer.OPEN);
              if (!opts.action) return resolve();
            }

            // If it's a different draft, cancel it and try opening again.
            return self.cancelComposer().then(function () {
              return self.open(opts);
            }).then(resolve, reject);
          }

          // we need a draft sequence for the composer to work
          if (opts.draftSequence === undefined) {
            return Draft.get(opts.draftKey).then(function (data) {
              opts.draftSequence = data.draft_sequence;
              opts.draft = data.draft;
              self._setModel(composerModel, opts);
            }).then(resolve, reject);
          }

          self._setModel(composerModel, opts);
          resolve();
        });
      }
    }, {
      key: '_setModel',

      // Given a potential instance and options, set the model for this composer.
      value: function (composerModel, opts) {
        var _this3 = this;

        if (opts.draft) {
          composerModel = loadDraft(this.store, opts);
          if (composerModel) {
            composerModel.set('topic', opts.topic);
          }
        } else {
          composerModel = composerModel || this.store.createRecord('composer');
          composerModel.open(opts);
        }

        this.set('model', composerModel);
        composerModel.set('composeState', Composer.OPEN);
        composerModel.set('isWarning', false);

        if (opts.topicTitle && opts.topicTitle.length <= this.siteSettings.max_topic_title_length) {
          this.set('model.title', opts.topicTitle);
        }

        if (opts.topicCategoryId) {
          this.set('model.categoryId', opts.topicCategoryId);
        } else if (opts.topicCategory) {
          (function () {
            var splitCategory = opts.topicCategory.split("/");
            var category = undefined;

            if (!splitCategory[1]) {
              category = _this3.site.get('categories').findProperty('nameLower', splitCategory[0].toLowerCase());
            } else {
              (function () {
                var categories = Discourse.Category.list();
                var mainCategory = categories.findProperty('nameLower', splitCategory[0].toLowerCase());
                category = categories.find(function (item) {
                  return item && item.get('nameLower') === splitCategory[1].toLowerCase() && item.get('parent_category_id') === mainCategory.id;
                });
              })();
            }

            if (category) {
              _this3.set('model.categoryId', category.get('id'));
            }
          })();
        }

        if (opts.topicBody) {
          this.set('model.reply', opts.topicBody);
        }

        this.get('controllers.composer-messages').queryFor(composerModel);
      }
    }, {
      key: 'viewNewReply',

      // View a new reply we've made
      value: function () {
        DiscourseURL.routeTo(this.get('model.createdPost.url'));
        this.close();
        return false;
      }
    }, {
      key: 'destroyDraft',
      value: function () {
        var key = this.get('model.draftKey');
        if (key) {
          Draft.clear(key, this.get('model.draftSequence'));
        }
      }
    }, {
      key: 'cancelComposer',
      value: function () {
        var self = this;

        return new Ember.RSVP.Promise(function (resolve) {
          if (self.get('model.hasMetaData') || self.get('model.replyDirty')) {
            bootbox.confirm(I18n.t("post.abandon.confirm"), I18n.t("post.abandon.no_value"), I18n.t("post.abandon.yes_value"), function (result) {
              if (result) {
                self.destroyDraft();
                self.get('model').clearState();
                self.close();
                resolve();
              }
            });
          } else {
            // it is possible there is some sort of crazy draft with no body ... just give up on it
            self.destroyDraft();
            self.get('model').clearState();
            self.close();
            resolve();
          }
        });
      }
    }, {
      key: 'shrink',
      value: function () {
        if (this.get('model.replyDirty')) {
          this.collapse();
        } else {
          this.close();
        }
      }
    }, {
      key: '_saveDraft',
      value: function () {
        var model = this.get('model');
        if (model) {
          model.saveDraft();
        };
      }
    }, {
      key: '_shouldSaveDraft',
      decorators: [observes('model.reply', 'model.title')],
      value: function () {
        Ember.run.debounce(this, this._saveDraft, 2000);
      }
    }, {
      key: 'categoryValidation',
      decorators: [computed('model.categoryId', 'lastValidatedAt')],
      value: function (categoryId, lastValidatedAt) {
        if (!this.siteSettings.allow_uncategorized_topics && !categoryId) {
          return Discourse.InputValidation.create({ failed: true, reason: I18n.t('composer.error.category_missing'), lastShownAt: lastValidatedAt });
        }
      }
    }, {
      key: 'collapse',
      value: function () {
        this._saveDraft();
        this.set('model.composeState', Composer.DRAFT);
      }
    }, {
      key: 'close',
      value: function () {
        this.setProperties({ model: null, lastValidatedAt: null });
      }
    }, {
      key: 'closeAutocomplete',
      value: function () {
        $('.d-editor-input').autocomplete({ cancel: true });
      }
    }, {
      key: 'canEdit',
      initializer: function () {
        return (function () {
          return this.get("model.action") === "edit" && Discourse.User.current().get("can_edit");
        }).property("model.action");
      }
    }, {
      key: 'visible',
      initializer: function () {
        return (function () {
          var state = this.get('model.composeState');
          return state && state !== 'closed';
        }).property('model.composeState');
      }
    }]));
  });
define("discourse/controllers/create-account", 
  ["discourse/lib/debounce","discourse/mixins/modal-functionality","discourse/lib/computed","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var debounce = __dependency1__["default"];
    var ModalFunctionality = __dependency2__["default"];
    var setting = __dependency3__.setting;
    var on = __dependency4__.on;

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['login'];
      }
    }, {
      key: 'uniqueUsernameValidation',
      initializer: function () {
        return null;
      }
    }, {
      key: 'globalNicknameExists',
      initializer: function () {
        return false;
      }
    }, {
      key: 'complete',
      initializer: function () {
        return false;
      }
    }, {
      key: 'accountPasswordConfirm',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'accountChallenge',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'formSubmitted',
      initializer: function () {
        return false;
      }
    }, {
      key: 'rejectedEmails',
      initializer: function () {
        return Em.A([]);
      }
    }, {
      key: 'rejectedPasswords',
      initializer: function () {
        return Em.A([]);
      }
    }, {
      key: 'prefilledUsername',
      initializer: function () {
        return null;
      }
    }, {
      key: 'userFields',
      initializer: function () {
        return null;
      }
    }, {
      key: 'isDeveloper',
      initializer: function () {
        return false;
      }
    }, {
      key: 'hasAuthOptions',
      initializer: function () {
        return Em.computed.notEmpty('authOptions');
      }
    }, {
      key: 'canCreateLocal',
      initializer: function () {
        return setting('enable_local_logins');
      }
    }, {
      key: 'showCreateForm',
      initializer: function () {
        return Em.computed.or('hasAuthOptions', 'canCreateLocal');
      }
    }, {
      key: 'maxUsernameLength',
      initializer: function () {
        return setting('max_username_length');
      }
    }, {
      key: 'minUsernameLength',
      initializer: function () {
        return setting('min_username_length');
      }
    }, {
      key: 'resetForm',
      value: function () {
        // We wrap the fields in a structure so we can assign a value
        this.setProperties({
          accountName: '',
          accountEmail: '',
          accountUsername: '',
          accountPassword: '',
          authOptions: null,
          globalNicknameExists: false,
          complete: false,
          formSubmitted: false,
          rejectedEmails: [],
          rejectedPasswords: [],
          prefilledUsername: null,
          isDeveloper: false
        });
        this._createUserFields();
      }
    }, {
      key: 'submitDisabled',
      initializer: function () {
        return (function () {
          if (!this.get('emailValidation.failed') && !this.get('passwordRequired')) return false; // 3rd party auth
          if (this.get('formSubmitted')) return true;
          if (this.get('nameValidation.failed')) return true;
          if (this.get('emailValidation.failed')) return true;
          if (this.get('usernameValidation.failed')) return true;
          if (this.get('passwordValidation.failed')) return true;

          // Validate required fields
          var userFields = this.get('userFields');
          if (userFields) {
            userFields = userFields.filterProperty('field.required');
          }
          if (!Ember.isEmpty(userFields)) {
            var anyEmpty = userFields.any(function (uf) {
              var val = uf.get('value');
              return !val || Ember.isEmpty(val);
            });
            if (anyEmpty) {
              return true;
            }
          }
          return false;
        }).property('passwordRequired', 'nameValidation.failed', 'emailValidation.failed', 'usernameValidation.failed', 'passwordValidation.failed', 'formSubmitted', 'userFields.@each.value');
      }
    }, {
      key: 'usernameRequired',
      initializer: function () {
        return Ember.computed.not('authOptions.omit_username');
      }
    }, {
      key: 'passwordRequired',
      initializer: function () {
        return (function () {
          return Ember.isEmpty(this.get('authOptions.auth_provider'));
        }).property('authOptions.auth_provider');
      }
    }, {
      key: 'passwordInstructions',
      initializer: function () {
        return (function () {
          return this.get('isDeveloper') ? I18n.t('user.password.instructions', { count: Discourse.SiteSettings.min_admin_password_length }) : I18n.t('user.password.instructions', { count: Discourse.SiteSettings.min_password_length });
        }).property('isDeveloper');
      }
    }, {
      key: 'nameInstructions',
      initializer: function () {
        return (function () {
          return I18n.t(Discourse.SiteSettings.full_name_required ? 'user.name.instructions_required' : 'user.name.instructions');
        }).property();
      }
    }, {
      key: 'nameValidation',

      // Validate the name.
      initializer: function () {
        return (function () {
          if (Discourse.SiteSettings.full_name_required && Ember.isEmpty(this.get('accountName'))) {
            return Discourse.InputValidation.create({ failed: true });
          }

          return Discourse.InputValidation.create({ ok: true });
        }).property('accountName');
      }
    }, {
      key: 'emailValidation',

      // Check the email address
      initializer: function () {
        return (function () {
          // If blank, fail without a reason
          var email = undefined;
          if (Ember.isEmpty(this.get('accountEmail'))) {
            return Discourse.InputValidation.create({
              failed: true
            });
          }

          email = this.get("accountEmail");

          if (this.get('rejectedEmails').contains(email)) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.email.invalid')
            });
          }

          if (this.get('authOptions.email') === email && this.get('authOptions.email_valid')) {
            return Discourse.InputValidation.create({
              ok: true,
              reason: I18n.t('user.email.authenticated', {
                provider: this.authProviderDisplayName(this.get('authOptions.auth_provider'))
              })
            });
          }

          if (Discourse.Utilities.emailValid(email)) {
            return Discourse.InputValidation.create({
              ok: true,
              reason: I18n.t('user.email.ok')
            });
          }

          return Discourse.InputValidation.create({
            failed: true,
            reason: I18n.t('user.email.invalid')
          });
        }).property('accountEmail', 'rejectedEmails.[]');
      }
    }, {
      key: 'emailValidated',
      initializer: function () {
        return (function () {
          return this.get('authOptions.email') === this.get("accountEmail") && this.get('authOptions.email_valid');
        }).property('accountEmail', 'authOptions.email', 'authOptions.email_valid');
      }
    }, {
      key: 'authProviderDisplayName',
      value: function (provider) {
        switch (provider) {
          case "Google_oauth2":
            return "Google";
          default:
            return provider;
        }
      }
    }, {
      key: 'prefillUsername',
      initializer: function () {
        return (function () {
          if (this.get('prefilledUsername')) {
            // If username field has been filled automatically, and email field just changed,
            // then remove the username.
            if (this.get('accountUsername') === this.get('prefilledUsername')) {
              this.set('accountUsername', '');
            }
            this.set('prefilledUsername', null);
          }
          if (this.get('emailValidation.ok') && (Ember.isEmpty(this.get('accountUsername')) || this.get('authOptions.email'))) {
            // If email is valid and username has not been entered yet,
            // or email and username were filled automatically by 3rd parth auth,
            // then look for a registered username that matches the email.
            this.fetchExistingUsername();
          }
        }).observes('emailValidation', 'accountEmail');
      }
    }, {
      key: 'fetchExistingUsername',
      initializer: function () {
        return debounce(function () {
          var self = this;
          Discourse.User.checkUsername(null, this.get('accountEmail')).then(function (result) {
            if (result.suggestion && (Ember.isEmpty(self.get('accountUsername')) || self.get('accountUsername') === self.get('authOptions.username'))) {
              self.set('accountUsername', result.suggestion);
              self.set('prefilledUsername', result.suggestion);
            }
          });
        }, 500);
      }
    }, {
      key: 'usernameMatch',
      initializer: function () {
        return (function () {
          if (this.usernameNeedsToBeValidatedWithEmail()) {
            if (this.get('emailValidation.failed')) {
              if (this.shouldCheckUsernameMatch()) {
                return this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                  failed: true,
                  reason: I18n.t('user.username.enter_email')
                }));
              } else {
                return this.set('uniqueUsernameValidation', Discourse.InputValidation.create({ failed: true }));
              }
            } else if (this.shouldCheckUsernameMatch()) {
              this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                failed: true,
                reason: I18n.t('user.username.checking')
              }));
              return this.checkUsernameAvailability();
            }
          }
        }).observes('accountEmail');
      }
    }, {
      key: 'basicUsernameValidation',
      initializer: function () {
        return (function () {
          this.set('uniqueUsernameValidation', null);

          if (this.get('accountUsername') === this.get('prefilledUsername')) {
            return Discourse.InputValidation.create({
              ok: true,
              reason: I18n.t('user.username.prefilled')
            });
          }

          // If blank, fail without a reason
          if (Ember.isEmpty(this.get('accountUsername'))) {
            return Discourse.InputValidation.create({
              failed: true
            });
          }

          // If too short
          if (this.get('accountUsername').length < Discourse.SiteSettings.min_username_length) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.username.too_short')
            });
          }

          // If too long
          if (this.get('accountUsername').length > this.get('maxUsernameLength')) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.username.too_long')
            });
          }

          this.checkUsernameAvailability();
          // Let's check it out asynchronously
          return Discourse.InputValidation.create({
            failed: true,
            reason: I18n.t('user.username.checking')
          });
        }).property('accountUsername');
      }
    }, {
      key: 'shouldCheckUsernameMatch',
      initializer: function () {
        return function () {
          return !Ember.isEmpty(this.get('accountUsername')) && this.get('accountUsername').length >= this.get('minUsernameLength');
        };
      }
    }, {
      key: 'checkUsernameAvailability',
      initializer: function () {
        return debounce(function () {
          var _this = this;
          if (this.shouldCheckUsernameMatch()) {
            return Discourse.User.checkUsername(this.get('accountUsername'), this.get('accountEmail')).then(function (result) {
              _this.set('isDeveloper', false);
              if (result.available) {
                if (result.is_developer) {
                  _this.set('isDeveloper', true);
                }
                return _this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                  ok: true,
                  reason: I18n.t('user.username.available')
                }));
              } else {
                if (result.suggestion) {
                  return _this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                    failed: true,
                    reason: I18n.t('user.username.not_available', result)
                  }));
                } else if (result.errors) {
                  return _this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                    failed: true,
                    reason: result.errors.join(' ')
                  }));
                } else {
                  return _this.set('uniqueUsernameValidation', Discourse.InputValidation.create({
                    failed: true,
                    reason: I18n.t('user.username.enter_email')
                  }));
                }
              }
            });
          }
        }, 500);
      }
    }, {
      key: 'usernameValidation',

      // Actually wait for the async name check before we're 100% sure we're good to go
      initializer: function () {
        return (function () {
          var basicValidation = this.get('basicUsernameValidation');
          var uniqueUsername = this.get('uniqueUsernameValidation');
          return uniqueUsername ? uniqueUsername : basicValidation;
        }).property('uniqueUsernameValidation', 'basicUsernameValidation');
      }
    }, {
      key: 'usernameNeedsToBeValidatedWithEmail',
      value: function () {
        return this.get('globalNicknameExists') || false;
      }
    }, {
      key: 'passwordValidation',

      // Validate the password
      initializer: function () {
        return (function () {
          if (!this.get('passwordRequired')) {
            return Discourse.InputValidation.create({ ok: true });
          }

          // If blank, fail without a reason
          var password = this.get("accountPassword");
          if (Ember.isEmpty(this.get('accountPassword'))) {
            return Discourse.InputValidation.create({ failed: true });
          }

          // If too short
          var passwordLength = this.get('isDeveloper') ? Discourse.SiteSettings.min_admin_password_length : Discourse.SiteSettings.min_password_length;
          if (password.length < passwordLength) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.password.too_short')
            });
          }

          if (this.get('rejectedPasswords').contains(password)) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.password.common')
            });
          }

          if (!Ember.isEmpty(this.get('accountUsername')) && this.get('accountPassword') === this.get('accountUsername')) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.password.same_as_username')
            });
          }

          if (!Ember.isEmpty(this.get('accountEmail')) && this.get('accountPassword') === this.get('accountEmail')) {
            return Discourse.InputValidation.create({
              failed: true,
              reason: I18n.t('user.password.same_as_email')
            });
          }

          // Looks good!
          return Discourse.InputValidation.create({
            ok: true,
            reason: I18n.t('user.password.ok')
          });
        }).property('accountPassword', 'rejectedPasswords.[]', 'accountUsername', 'accountEmail', 'isDeveloper');
      }
    }, {
      key: 'fetchConfirmationValue',
      decorators: [on('init')],
      value: function () {
        var _this2 = this;

        return Discourse.ajax('/users/hp.json').then(function (json) {
          _this2.set('accountPasswordConfirm', json.value);
          _this2.set('accountChallenge', json.challenge.split("").reverse().join(""));
        });
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          externalLogin: function (provider) {
            this.get('controllers.login').send('externalLogin', provider);
          },

          createAccount: function () {
            var self = this,
                attrs = this.getProperties('accountName', 'accountEmail', 'accountPassword', 'accountUsername', 'accountPasswordConfirm', 'accountChallenge'),
                userFields = this.get('userFields');

            // Add the userfields to the data
            if (!Ember.isEmpty(userFields)) {
              attrs.userFields = {};
              userFields.forEach(function (f) {
                attrs.userFields[f.get('field.id')] = f.get('value');
              });
            }

            this.set('formSubmitted', true);
            return Discourse.User.createAccount(attrs).then(function (result) {
              self.set('isDeveloper', false);
              if (result.success) {
                // Trigger the browser's password manager using the hidden static login form:
                var $hidden_login_form = $('#hidden-login-form');
                $hidden_login_form.find('input[name=username]').val(attrs.accountUsername);
                $hidden_login_form.find('input[name=password]').val(attrs.accountPassword);
                $hidden_login_form.find('input[name=redirect]').val(Discourse.getURL('/users/account-created'));
                $hidden_login_form.submit();
              } else {
                self.flash(result.message || I18n.t('create_account.failed'), 'error');
                if (result.is_developer) {
                  self.set('isDeveloper', true);
                }
                if (result.errors && result.errors.email && result.errors.email.length > 0 && result.values) {
                  self.get('rejectedEmails').pushObject(result.values.email);
                }
                if (result.errors && result.errors.password && result.errors.password.length > 0) {
                  self.get('rejectedPasswords').pushObject(attrs.accountPassword);
                }
                self.set('formSubmitted', false);
              }
              if (result.active && !Discourse.SiteSettings.must_approve_users) {
                return window.location.reload();
              }
            }, function () {
              self.set('formSubmitted', false);
              return self.flash(I18n.t('create_account.failed'), 'error');
            });
          }
        };
      }
    }, {
      key: '_createUserFields',
      initializer: function () {
        return (function () {
          if (!this.site) {
            return;
          }

          var userFields = this.site.get('user_fields');
          if (userFields) {
            userFields = _.sortBy(userFields, 'position').map(function (f) {
              return Ember.Object.create({ value: null, field: f });
            });
          }
          this.set('userFields', userFields);
        }).on('init');
      }
    }]));
  });
define("discourse/controllers/discovery", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend({
      needs: ['navigation/category', 'discovery/topics', 'application'],
      loading: false,

      category: Em.computed.alias('controllers.navigation/category.category'),
      noSubcategories: Em.computed.alias('controllers.navigation/category.noSubcategories'),

      loadedAllItems: Em.computed.not("controllers.discovery/topics.model.canLoadMore"),

      _showFooter: (function () {
        this.set("controllers.application.showFooter", this.get("loadedAllItems"));
      }).observes("loadedAllItems"),

      showMoreUrl: function (period) {
        var url = '',
            category = this.get('category');
        if (category) {
          url = '/c/' + Discourse.Category.slugFor(category) + (this.get('noSubcategories') ? '/none' : '') + '/l';
        }
        url += '/top/' + period;
        return url;
      },

      actions: {
        changePeriod: function (p) {
          DiscourseURL.routeTo(this.showMoreUrl(p));
        }
      }

    });
  });
define("discourse/controllers/discovery/categories", 
  ["discourse/controllers/discovery","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscoveryController = __dependency1__["default"];

    __exports__["default"] = DiscoveryController.extend({
      needs: ['modal', 'discovery'],

      withLogo: Em.computed.filterBy('model.categories', 'logo_url'),
      showPostsColumn: Em.computed.empty('withLogo'),

      // this makes sure the composer isn't scoping to a specific category
      category: null,

      actions: {

        refresh: function () {
          // Don't refresh if we're still loading
          if (this.get('controllers.discovery.loading')) {
            return;
          }

          // If we `send('loading')` here, due to returning true it bubbles up to the
          // router and ember throws an error due to missing `handlerInfos`.
          // Lesson learned: Don't call `loading` yourself.
          this.set('controllers.discovery.loading', true);

          var CategoryList = require('discourse/models/category-list').default;
          var parentCategory = this.get('model.parentCategory');
          var promise = parentCategory ? CategoryList.listForParent(this.store, parentCategory) : CategoryList.list(this.store);

          var self = this;
          promise.then(function (list) {
            self.set('model', list);
            self.send('loadingComplete');
          });
        }
      },

      canEdit: (function () {
        return Discourse.User.currentProp('staff');
      }).property(),

      latestTopicOnly: (function () {
        return this.get('model.categories').find(function (c) {
          return c.get('featuredTopics.length') > 1;
        }) === undefined;
      }).property('model.categories.@each.featuredTopics.length')

    });
  });
define("discourse/controllers/discovery/topics", 
  ["discourse/controllers/discovery","discourse/controllers/discovery-sortable","discourse/mixins/bulk-topic-selection","discourse/lib/computed","discourse/lib/show-modal","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    var DiscoveryController = __dependency1__["default"];
    var queryParams = __dependency2__.queryParams;
    var BulkTopicSelection = __dependency3__["default"];
    var endWith = __dependency4__.endWith;
    var showModal = __dependency5__["default"];

    var controllerOpts = {
      needs: ['discovery'],
      period: null,

      canStar: Em.computed.alias('controllers.discovery/topics.currentUser.id'),
      showTopicPostBadges: Em.computed.not('controllers.discovery/topics.new'),

      redirectedReason: Em.computed.alias('currentUser.redirected_to_top.reason'),

      order: 'default',
      ascending: false,
      expandGloballyPinned: false,
      expandAllPinned: false,

      actions: {

        changeSort: function (sortBy) {
          if (sortBy === this.get('order')) {
            this.toggleProperty('ascending');
          } else {
            this.setProperties({ order: sortBy, ascending: false });
          }

          this.get('model').refreshSort(sortBy, this.get('ascending'));
        },

        // Show newly inserted topics
        showInserted: function () {
          var tracker = this.topicTrackingState;

          // Move inserted into topics
          this.get('content').loadBefore(tracker.get('newIncoming'));
          tracker.resetTracking();
          return false;
        },

        refresh: function () {
          var _this = this;

          var filter = this.get('model.filter');

          this.setProperties({ order: "default", ascending: false });

          // Don't refresh if we're still loading
          if (this.get('controllers.discovery.loading')) {
            return;
          }

          // If we `send('loading')` here, due to returning true it bubbles up to the
          // router and ember throws an error due to missing `handlerInfos`.
          // Lesson learned: Don't call `loading` yourself.
          this.set('controllers.discovery.loading', true);

          this.store.findFiltered('topicList', { filter: filter }).then(function (list) {
            var TopicList = require('discourse/models/topic-list').default;
            TopicList.hideUniformCategory(list, _this.get('category'));

            _this.setProperties({ model: list });
            _this.resetSelected();

            if (_this.topicTrackingState) {
              _this.topicTrackingState.sync(list, filter);
            }

            _this.send('loadingComplete');
          });
        },

        resetNew: function () {
          var _this2 = this;

          this.topicTrackingState.resetNew();
          Discourse.Topic.resetNew().then(function () {
            return _this2.send('refresh');
          });
        },

        dismissReadPosts: function () {
          showModal('dismiss-read', { title: 'topics.bulk.dismiss_read' });
        }
      },

      isFilterPage: function (filter, filterType) {
        if (!filter) {
          return false;
        }
        return filter.match(new RegExp(filterType + '$', 'gi')) ? true : false;
      },

      showDismissRead: (function () {
        return this.isFilterPage(this.get('model.filter'), 'unread') && this.get('model.topics.length') > 0;
      }).property('model.filter', 'model.topics.length'),

      showResetNew: (function () {
        return this.get('model.filter') === 'new' && this.get('model.topics.length') > 0;
      }).property('model.filter', 'model.topics.length'),

      showDismissAtTop: (function () {
        return (this.isFilterPage(this.get('model.filter'), 'new') || this.isFilterPage(this.get('model.filter'), 'unread')) && this.get('model.topics.length') >= 30;
      }).property('model.filter', 'model.topics.length'),

      hasTopics: Em.computed.gt('model.topics.length', 0),
      allLoaded: Em.computed.empty('model.more_topics_url'),
      latest: endWith('model.filter', 'latest'),
      new: endWith('model.filter', 'new'),
      top: Em.computed.notEmpty('period'),
      yearly: Em.computed.equal('period', 'yearly'),
      quarterly: Em.computed.equal('period', 'quarterly'),
      monthly: Em.computed.equal('period', 'monthly'),
      weekly: Em.computed.equal('period', 'weekly'),
      daily: Em.computed.equal('period', 'daily'),

      footerMessage: (function () {
        if (!this.get('allLoaded')) {
          return;
        }

        var category = this.get('category');
        if (category) {
          return I18n.t('topics.bottom.category', { category: category.get('name') });
        } else {
          var split = (this.get('model.filter') || '').split('/');
          if (this.get('model.topics.length') === 0) {
            return I18n.t("topics.none." + split[0], {
              category: split[1]
            });
          } else {
            return I18n.t("topics.bottom." + split[0], {
              category: split[1]
            });
          }
        }
      }).property('allLoaded', 'model.topics.length'),

      footerEducation: (function () {
        if (!this.get('allLoaded') || this.get('model.topics.length') > 0 || !Discourse.User.current()) {
          return;
        }

        var split = (this.get('model.filter') || '').split('/');

        if (split[0] !== 'new' && split[0] !== 'unread') {
          return;
        }

        return I18n.t("topics.none.educate." + split[0], {
          userPrefsUrl: Discourse.getURL("/users/") + Discourse.User.currentProp("username_lower") + "/preferences"
        });
      }).property('allLoaded', 'model.topics.length')

    };

    Object.keys(queryParams).forEach(function (p) {
      // If we don't have a default value, initialize it to null
      if (typeof controllerOpts[p] === 'undefined') {
        controllerOpts[p] = null;
      }
    });

    __exports__["default"] = DiscoveryController.extend(controllerOpts, BulkTopicSelection);
  });
define("discourse/controllers/edit-category", 
  ["discourse/mixins/modal-functionality","discourse/lib/url","discourse/lib/ajax-error","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];
    var DiscourseURL = __dependency2__["default"];
    var extractError = __dependency3__.extractError;

    // Modal for editing / creating a category
    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      selectedTab: null,
      saving: false,
      deleting: false,
      panels: null,

      _initPanels: (function () {
        this.set('panels', []);
      }).on('init'),

      onShow: function () {
        this.changeSize();
        this.titleChanged();
      },

      changeSize: (function () {
        if (!Ember.isEmpty(this.get('model.description'))) {
          this.set('controllers.modal.modalClass', 'edit-category-modal full');
        } else {
          this.set('controllers.modal.modalClass', 'edit-category-modal small');
        }
      }).observes('model.description'),

      title: (function () {
        if (this.get('model.id')) {
          return I18n.t("category.edit_long") + " : " + this.get('model.name');
        }
        return I18n.t("category.create") + (this.get('model.name') ? " : " + this.get('model.name') : '');
      }).property('model.id', 'model.name'),

      titleChanged: (function () {
        this.set('controllers.modal.title', this.get('title'));
      }).observes('title'),

      disabled: (function () {
        if (this.get('saving') || this.get('deleting')) return true;
        if (!this.get('model.name')) return true;
        if (!this.get('model.color')) return true;
        return false;
      }).property('saving', 'model.name', 'model.color', 'deleting'),

      deleteDisabled: (function () {
        return this.get('deleting') || this.get('saving') || false;
      }).property('disabled', 'saving', 'deleting'),

      categoryName: (function () {
        var name = this.get('name') || "";
        return name.trim().length > 0 ? name : I18n.t("preview");
      }).property('name'),

      saveLabel: (function () {
        if (this.get('saving')) return "saving";
        if (this.get('model.isUncategorizedCategory')) return "save";
        return this.get('model.id') ? "category.save" : "category.create";
      }).property('saving', 'model.id'),

      actions: {
        saveCategory: function () {
          var self = this,
              model = this.get('model'),
              parentCategory = Discourse.Category.list().findBy('id', parseInt(model.get('parent_category_id'), 10));

          this.set('saving', true);
          model.set('parentCategory', parentCategory);

          this.get('model').save().then(function (result) {
            self.set('saving', false);
            self.send('closeModal');
            model.setProperties({ slug: result.category.slug, id: result.category.id });
            DiscourseURL.redirectTo("/c/" + Discourse.Category.slugFor(model));
          }).catch(function (error) {
            self.flash(extractError(error), 'error');
            self.set('saving', false);
          });
        },

        deleteCategory: function () {
          var self = this;
          this.set('deleting', true);

          this.send('hideModal');
          bootbox.confirm(I18n.t("category.delete_confirm"), I18n.t("no_value"), I18n.t("yes_value"), function (result) {
            if (result) {
              self.get('model').destroy().then(function () {
                // success
                self.send('closeModal');
                DiscourseURL.redirectTo("/categories");
              }, function (error) {
                self.flash(extractError(error), 'error');
                self.send('reopenModal');
                self.displayErrors([I18n.t("category.delete_error")]);
                self.set('deleting', false);
              });
            } else {
              self.send('reopenModal');
              self.set('deleting', false);
            }
          });
        }
      }

    });
  });
define("discourse/controllers/edit-topic-auto-close", 
  ["ember-addons/ember-computed-decorators","discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var observes = __dependency1__.observes;
    var ModalFunctionality = __dependency2__["default"];

    // Modal related to auto closing of topics
    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: 'auto_close_valid',
      initializer: function () {
        return true;
      }
    }, {
      key: 'auto_close_invalid',
      initializer: function () {
        return Em.computed.not('auto_close_valid');
      }
    }, {
      key: 'disable_submit',
      initializer: function () {
        return Em.computed.or('auto_close_invalid', 'loading');
      }
    }, {
      key: 'loading',
      initializer: function () {
        return false;
      }
    }, {
      key: 'setAutoCloseTime',
      decorators: [observes("model.details.auto_close_at", "model.details.auto_close_hours")],
      value: function () {
        var autoCloseTime = null;

        if (this.get("model.details.auto_close_based_on_last_post")) {
          autoCloseTime = this.get("model.details.auto_close_hours");
        } else if (this.get("model.details.auto_close_at")) {
          var closeTime = new Date(this.get("model.details.auto_close_at"));
          if (closeTime > new Date()) {
            autoCloseTime = moment(closeTime).format("YYYY-MM-DD HH:mm");
          }
        }

        this.set("model.auto_close_time", autoCloseTime);
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          saveAutoClose: function () {
            this.setAutoClose(this.get("model.auto_close_time"));
          },
          removeAutoClose: function () {
            this.setAutoClose(null);
          }
        };
      }
    }, {
      key: 'setAutoClose',
      value: function (time) {
        var _this = this;

        var self = this;
        this.set('loading', true);
        Discourse.ajax({
          url: '/t/' + this.get('model.id') + '/autoclose',
          type: 'PUT',
          dataType: 'json',
          data: {
            auto_close_time: time,
            auto_close_based_on_last_post: this.get("model.details.auto_close_based_on_last_post"),
            timezone_offset: new Date().getTimezoneOffset()
          }
        }).then(function (result) {
          self.set('loading', false);
          if (result.success) {
            _this.send('closeModal');
            _this.set('model.details.auto_close_at', result.auto_close_at);
            _this.set('model.details.auto_close_hours', result.auto_close_hours);
          } else {
            bootbox.alert(I18n.t('composer.auto_close.error'));
          }
        }).catch(function () {
          // TODO - incorrectly responds to network errors as bad input
          bootbox.alert(I18n.t('composer.auto_close.error'));
          self.set('loading', false);
        });
      }
    }, {
      key: 'willCloseImmediately',
      initializer: function () {
        return (function () {
          if (!this.get('model.details.auto_close_based_on_last_post')) {
            return false;
          }
          var closeDate = new Date(this.get('model.last_posted_at'));
          closeDate.setHours(closeDate.getHours() + this.get('model.auto_close_time'));
          return closeDate < new Date();
        }).property('model.details.auto_close_based_on_last_post', 'model.auto_close_time', 'model.last_posted_at');
      }
    }, {
      key: 'willCloseI18n',
      initializer: function () {
        return (function () {
          if (this.get('model.details.auto_close_based_on_last_post')) {
            return I18n.t('topic.auto_close_immediate', { hours: this.get('model.auto_close_time') });
          }
        }).property('model.details.auto_close_based_on_last_post', 'model.auto_close_time');
      }
    }]));
  });
define("discourse/controllers/exception", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var ButtonBackBright = {
      classes: "btn-primary",
      action: "back",
      key: "errors.buttons.back"
    },
        ButtonBackDim = {
      classes: "",
      action: "back",
      key: "errors.buttons.back"
    },
        ButtonTryAgain = {
      classes: "btn-primary",
      action: "tryLoading",
      key: "errors.buttons.again",
      icon: "refresh"
    },
        ButtonLoadPage = {
      classes: "btn-primary",
      action: "tryLoading",
      key: "errors.buttons.fixed"
    };

    // The controller for the nice error page
    __exports__["default"] = Ember.Controller.extend({
      thrown: null,
      lastTransition: null,

      isNetwork: (function () {
        // never made it on the wire
        if (this.get('thrown.readyState') === 0) return true;
        // timed out
        if (this.get('thrown.jqTextStatus') === "timeout") return true;
        return false;
      }).property(),
      isNotFound: Em.computed.equal('thrown.status', 404),
      isForbidden: Em.computed.equal('thrown.status', 403),
      isServer: Em.computed.gte('thrown.status', 500),
      isUnknown: Em.computed.none('isNetwork', 'isServer'),

      // TODO
      // make ajax requests to /srv/status with exponential backoff
      // if one succeeds, set networkFixed to true, which puts a "Fixed!" message on the page
      networkFixed: false,
      loading: false,

      _init: (function () {
        this.set('loading', false);
      }).on('init'),

      reason: (function () {
        if (this.get('isNetwork')) {
          return I18n.t('errors.reasons.network');
        } else if (this.get('isServer')) {
          return I18n.t('errors.reasons.server');
        } else if (this.get('isNotFound')) {
          return I18n.t('errors.reasons.not_found');
        } else if (this.get('isForbidden')) {
          return I18n.t('errors.reasons.forbidden');
        } else {
          // TODO
          return I18n.t('errors.reasons.unknown');
        }
      }).property('isNetwork', 'isServer', 'isUnknown'),

      requestUrl: Em.computed.alias('thrown.requestedUrl'),

      desc: (function () {
        if (this.get('networkFixed')) {
          return I18n.t('errors.desc.network_fixed');
        } else if (this.get('isNetwork')) {
          return I18n.t('errors.desc.network');
        } else if (this.get('isNotFound')) {
          return I18n.t('errors.desc.not_found');
        } else if (this.get('isServer')) {
          return I18n.t('errors.desc.server', { status: this.get('thrown.status') + " " + this.get('thrown.statusText') });
        } else {
          // TODO
          return I18n.t('errors.desc.unknown');
        }
      }).property('networkFixed', 'isNetwork', 'isServer', 'isUnknown'),

      enabledButtons: (function () {
        if (this.get('networkFixed')) {
          return [ButtonLoadPage];
        } else if (this.get('isNetwork')) {
          return [ButtonBackDim, ButtonTryAgain];
        } else {
          return [ButtonBackBright, ButtonTryAgain];
        }
      }).property('networkFixed', 'isNetwork', 'isServer', 'isUnknown'),

      actions: {
        back: function () {
          window.history.back();
        },

        tryLoading: function () {
          this.set('loading', true);
          var self = this;
          Em.run.schedule('afterRender', function () {
            self.get('lastTransition').retry();
            self.set('loading', false);
          });
        }
      }
    });
  });
define("discourse/controllers/feature-topic", 
  ["discourse/mixins/modal-functionality","discourse/helpers/category-link","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ModalFunctionality = __dependency1__["default"];
    var categoryLinkHTML = __dependency2__.categoryLinkHTML;
    var computed = __dependency3__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ["topic"];
      }
    }, {
      key: 'loading',
      initializer: function () {
        return true;
      }
    }, {
      key: 'pinnedInCategoryCount',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'pinnedGloballyCount',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'bannerCount',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'reset',
      value: function () {
        this.setProperties({
          "model.pinnedInCategoryUntil": null,
          "model.pinnedGloballyUntil": null,
          pinInCategoryTipShownAt: false,
          pinGloballyTipShownAt: false
        });
      }
    }, {
      key: 'categoryLink',
      decorators: [computed("model.category")],
      value: function (category) {
        return categoryLinkHTML(category, { allowUncategorized: true });
      }
    }, {
      key: 'unPinMessage',
      decorators: [computed("categoryLink", "model.pinned_globally", "model.pinned_until")],
      value: function (categoryLink, pinnedGlobally, pinnedUntil) {
        var name = "topic.feature_topic.unpin";
        if (pinnedGlobally) name += "_globally";
        if (moment(pinnedUntil) > moment()) name += "_until";
        var until = moment(pinnedUntil).format("LL");

        return I18n.t(name, { categoryLink: categoryLink, until: until });
      }
    }, {
      key: 'pinMessage',
      decorators: [computed("categoryLink")],
      value: function (categoryLink) {
        return I18n.t("topic.feature_topic.pin", { categoryLink: categoryLink });
      }
    }, {
      key: 'alreadyPinnedMessage',
      decorators: [computed("categoryLink", "pinnedInCategoryCount")],
      value: function (categoryLink, count) {
        var key = count === 0 ? "topic.feature_topic.not_pinned" : "topic.feature_topic.already_pinned";
        return I18n.t(key, { categoryLink: categoryLink, count: count });
      }
    }, {
      key: 'pinDisabled',
      decorators: [computed("parsedPinnedInCategoryUntil")],
      value: function (parsedPinnedInCategoryUntil) {
        return !this._isDateValid(parsedPinnedInCategoryUntil);
      }
    }, {
      key: 'pinGloballyDisabled',
      decorators: [computed("parsedPinnedGloballyUntil")],
      value: function (parsedPinnedGloballyUntil) {
        return !this._isDateValid(parsedPinnedGloballyUntil);
      }
    }, {
      key: 'parsedPinnedInCategoryUntil',
      decorators: [computed("model.pinnedInCategoryUntil")],
      value: function (pinnedInCategoryUntil) {
        return this._parseDate(pinnedInCategoryUntil);
      }
    }, {
      key: 'parsedPinnedGloballyUntil',
      decorators: [computed("model.pinnedGloballyUntil")],
      value: function (pinnedGloballyUntil) {
        return this._parseDate(pinnedGloballyUntil);
      }
    }, {
      key: 'pinInCategoryValidation',
      decorators: [computed("pinDisabled")],
      value: function (pinDisabled) {
        if (pinDisabled) {
          return Discourse.InputValidation.create({ failed: true, reason: I18n.t("topic.feature_topic.pin_validation") });
        }
      }
    }, {
      key: 'pinGloballyValidation',
      decorators: [computed("pinGloballyDisabled")],
      value: function (pinGloballyDisabled) {
        if (pinGloballyDisabled) {
          return Discourse.InputValidation.create({ failed: true, reason: I18n.t("topic.feature_topic.pin_validation") });
        }
      }
    }, {
      key: '_parseDate',
      value: function (date) {
        return moment(date, ["YYYY-MM-DD", "YYYY-MM-DD HH:mm"]);
      }
    }, {
      key: '_isDateValid',
      value: function (parsedDate) {
        return parsedDate.isValid() && parsedDate > moment();
      }
    }, {
      key: 'onShow',
      value: function () {
        var _this = this;

        this.set("loading", true);

        return Discourse.ajax("/topics/feature_stats.json", {
          data: { category_id: this.get("model.category.id") }
        }).then(function (result) {
          if (result) {
            _this.setProperties({
              pinnedInCategoryCount: result.pinned_in_category_count,
              pinnedGloballyCount: result.pinned_globally_count,
              bannerCount: result.banner_count
            });
          }
        }).finally(function () {
          return _this.set("loading", false);
        });
      }
    }, {
      key: '_forwardAction',
      value: function (name) {
        this.get("controllers.topic").send(name);
        this.send("closeModal");
      }
    }, {
      key: '_confirmBeforePinning',
      value: function (count, name, action) {
        var _this2 = this;

        if (count < 4) {
          this._forwardAction(action);
        } else {
          this.send("hideModal");
          bootbox.confirm(I18n.t("topic.feature_topic.confirm_" + name, { count: count }), I18n.t("no_value"), I18n.t("yes_value"), function (confirmed) {
            return confirmed ? _this2._forwardAction(action) : _this2.send("reopenModal");
          });
        }
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          pin: function () {
            if (this.get("pinDisabled")) {
              this.set("pinInCategoryTipShownAt", Date.now());
            } else {
              this._forwardAction("togglePinned");
            }
          },

          pinGlobally: function () {
            if (this.get("pinGloballyDisabled")) {
              this.set("pinGloballyTipShownAt", Date.now());
            } else {
              this._confirmBeforePinning(this.get("pinnedGloballyCount"), "pin_globally", "pinGlobally");
            }
          },

          unpin: function () {
            this._forwardAction("togglePinned");
          },
          makeBanner: function () {
            this._forwardAction("makeBanner");
          },
          removeBanner: function () {
            this._forwardAction("removeBanner");
          }
        };
      }
    }]));
  });
define("discourse/controllers/flag", 
  ["discourse/mixins/modal-functionality","discourse/models/action-summary","discourse/models/post-action-type","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];
    var ActionSummary = __dependency2__["default"];
    var MAX_MESSAGE_LENGTH = __dependency3__.MAX_MESSAGE_LENGTH;

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      userDetails: null,
      selected: null,
      flagTopic: null,
      message: null,
      isWarning: false,
      topicActionByName: null,

      onShow: function () {
        this.set('selected', null);
      },

      flagsAvailable: (function () {
        var _this = this;

        if (!this.get('flagTopic')) {
          // flagging post
          var flagsAvailable = this.get('model.flagsAvailable');

          // "message user" option should be at the top
          var notifyUserIndex = flagsAvailable.indexOf(flagsAvailable.filterProperty('name_key', 'notify_user')[0]);
          if (notifyUserIndex !== -1) {
            var notifyUser = flagsAvailable[notifyUserIndex];
            flagsAvailable.splice(notifyUserIndex, 1);
            flagsAvailable.splice(0, 0, notifyUser);
          }
          return flagsAvailable;
        } else {
          var _ret = (function () {
            // flagging topic
            var self = _this,
                lookup = Em.Object.create();

            _.each(_this.get("model.actions_summary"), function (a) {
              a.flagTopic = self.get('model');
              a.actionType = self.site.topicFlagTypeById(a.id);
              var actionSummary = ActionSummary.create(a);
              lookup.set(a.actionType.get('name_key'), actionSummary);
            });
            _this.set('topicActionByName', lookup);

            return {
              v: _this.site.get('topic_flag_types').filter(function (item) {
                return _.any(self.get("model.actions_summary"), function (a) {
                  return a.id === item.get('id') && a.can_act;
                });
              })
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
      }).property('post', 'flagTopic', 'model.actions_summary.@each.can_act'),

      staffFlagsAvailable: (function () {
        return this.get('model.flagsAvailable').length > 1;
      }).property('post', 'flagTopic', 'model.actions_summary.@each.can_act'),

      submitEnabled: (function () {
        var selected = this.get('selected');
        if (!selected) return false;

        if (selected.get('is_custom_flag')) {
          var len = this.get('message.length') || 0;
          return len >= Discourse.SiteSettings.min_private_message_post_length && len <= MAX_MESSAGE_LENGTH;
        }
        return true;
      }).property('selected.is_custom_flag', 'message.length'),

      submitDisabled: Em.computed.not('submitEnabled'),

      // Staff accounts can "take action"
      canTakeAction: (function () {
        if (this.get("flagTopic")) return false;

        // We can only take actions on non-custom flags
        if (this.get('selected.is_custom_flag')) return false;
        return Discourse.User.currentProp('staff');
      }).property('selected.is_custom_flag'),

      submitText: (function () {
        if (this.get('selected.is_custom_flag')) {
          return "<i class='fa fa-envelope'></i>" + I18n.t(this.get('flagTopic') ? "flagging_topic.notify_action" : "flagging.notify_action");
        } else {
          return "<i class='fa fa-flag'></i>" + I18n.t(this.get('flagTopic') ? "flagging_topic.action" : "flagging.action");
        }
      }).property('selected.is_custom_flag'),

      actions: {
        takeAction: function () {
          this.send('createFlag', { takeAction: true });
          this.set('model.hidden', true);
        },

        createFlag: function (opts) {
          var _this2 = this;

          var postAction = undefined; // an instance of ActionSummary

          if (!this.get('flagTopic')) {
            postAction = this.get('model.actions_summary').findProperty('id', this.get('selected.id'));
          } else {
            postAction = this.get('topicActionByName.' + this.get('selected.name_key'));
          }

          var params = this.get('selected.is_custom_flag') ? { message: this.get('message') } : {};
          if (opts) {
            params = $.extend(params, opts);
          }

          this.send('hideModal');

          postAction.act(this.get('model'), params).then(function () {
            _this2.send('closeModal');
            if (params.message) {
              _this2.set('message', '');
            }
            _this2.appEvents.trigger('post-stream:refresh', { id: _this2.get('model.id') });
          }).catch(function (errors) {
            _this2.send('closeModal');
            if (errors && errors.responseText) {
              bootbox.alert($.parseJSON(errors.responseText).errors);
            } else {
              bootbox.alert(I18n.t('generic_error'));
            }
          });
        },

        createFlagAsWarning: function () {
          this.send('createFlag', { isWarning: true });
          this.set('model.hidden', true);
        },

        changePostActionType: function (action) {
          this.set('selected', action);
        }
      },

      canDeleteSpammer: (function () {
        if (this.get("flagTopic")) return false;

        if (Discourse.User.currentProp('staff') && this.get('selected.name_key') === 'spam') {
          return this.get('userDetails.can_be_deleted') && this.get('userDetails.can_delete_all_posts');
        } else {
          return false;
        }
      }).property('selected.name_key', 'userDetails.can_be_deleted', 'userDetails.can_delete_all_posts'),

      canSendWarning: (function () {
        if (this.get("flagTopic")) return false;

        return Discourse.User.currentProp('staff') && this.get('selected.name_key') === 'notify_user';
      }).property('selected.name_key'),

      usernameChanged: (function () {
        this.set('userDetails', null);
        this.fetchUserDetails();
      }).observes('model.username'),

      fetchUserDetails: function () {
        var _this3 = this;

        if (Discourse.User.currentProp('staff') && this.get('model.username')) {
          var AdminUser = require('admin/models/admin-user').default;
          AdminUser.find(this.get('model.user_id')).then(function (user) {
            return _this3.set('userDetails', user);
          });
        }
      }

    });
  });
define("discourse/controllers/forgot-password", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {

      // You need a value in the field to submit it.
      submitDisabled: (function () {
        return Ember.isEmpty((this.get('accountEmailOrUsername') || '').trim()) || this.get('disabled');
      }).property('accountEmailOrUsername', 'disabled'),

      onShow: function () {
        if ($.cookie('email')) {
          this.set('accountEmailOrUsername', $.cookie('email'));
        }
      },

      actions: {
        submit: function () {
          var self = this;

          if (this.get('submitDisabled')) return false;

          this.set('disabled', true);

          var success = function (data) {
            // don't tell people what happened, this keeps it more secure (ensure same on server)
            var escaped = Discourse.Utilities.escapeExpression(self.get('accountEmailOrUsername'));
            var isEmail = self.get('accountEmailOrUsername').match(/@/);

            var key = 'forgot_password.complete_' + (isEmail ? 'email' : 'username');
            var extraClass;

            if (data.user_found === true) {
              key += '_found';
              self.set('accountEmailOrUsername', '');
              bootbox.alert(I18n.t(key, { email: escaped, username: escaped }));
              self.send("closeModal");
            } else {
              if (data.user_found === false) {
                key += '_not_found';
                extraClass = 'error';
              }

              self.flash(I18n.t(key, { email: escaped, username: escaped }), extraClass);
            }
          };

          var fail = function (e) {
            self.flash(e.responseJSON.errors[0], 'error');
          };

          Discourse.ajax('/session/forgot_password', {
            data: { login: this.get('accountEmailOrUsername').trim() },
            type: 'POST'
          }).then(success, fail).finally(function () {
            setTimeout(function () {
              self.set('disabled', false);
            }, 1000);
          });

          return false;
        }
      }

    });
  });
define("discourse/controllers/full-page-search", 
  ["discourse/lib/search","discourse/lib/show-modal","ember-addons/ember-computed-decorators","discourse/models/category","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var translateResults = __dependency1__.translateResults;
    var searchContextDescription = __dependency1__.searchContextDescription;
    var getSearchKey = __dependency1__.getSearchKey;
    var isValidSearchTerm = __dependency1__.isValidSearchTerm;
    var showModal = __dependency2__["default"];
    var computed = __dependency3__.default;
    var observes = __dependency3__.observes;
    var Category = __dependency4__["default"];

    var SortOrders = [{ name: I18n.t('search.relevance'), id: 0 }, { name: I18n.t('search.latest_post'), id: 1, term: 'order:latest' }, { name: I18n.t('search.most_liked'), id: 2, term: 'order:likes' }, { name: I18n.t('search.most_viewed'), id: 3, term: 'order:views' }];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ["application"];
      }
    }, {
      key: 'loading',
      initializer: function () {
        return Em.computed.not("model");
      }
    }, {
      key: 'queryParams',
      initializer: function () {
        return ["q", "context_id", "context", "skip_context"];
      }
    }, {
      key: 'q',
      initializer: function () {
        return null;
      }
    }, {
      key: 'selected',
      initializer: function () {
        return [];
      }
    }, {
      key: 'context_id',
      initializer: function () {
        return null;
      }
    }, {
      key: 'context',
      initializer: function () {
        return null;
      }
    }, {
      key: 'searching',
      initializer: function () {
        return false;
      }
    }, {
      key: 'sortOrder',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'sortOrders',
      initializer: function () {
        return SortOrders;
      }
    }, {
      key: 'resultCount',
      decorators: [computed('model.posts')],
      value: function (posts) {
        return posts && posts.length;
      }
    }, {
      key: 'hasAutofocus',
      decorators: [computed('q')],
      value: function (q) {
        return Em.isEmpty(q);
      }
    }, {
      key: 'searchContextEnabled',
      decorators: [computed('skip_context', 'context')],
      initializer: function () {
        return {
          get: function (skip, context) {
            return !skip && context || skip === "false";
          },
          set: function (val) {
            this.set('skip_context', val ? "false" : "true");
          }
        };
      }
    }, {
      key: 'searchContextDescription',
      decorators: [computed('context', 'context_id')],
      value: function (context, id) {
        var name = id;
        if (context === 'category') {
          var category = Category.findById(id);
          if (!category) {
            return;
          }

          name = category.get('name');
        }
        return searchContextDescription(context, name);
      }
    }, {
      key: 'searchActive',
      decorators: [computed('q')],
      value: function (q) {
        return isValidSearchTerm(q);
      }
    }, {
      key: 'searchButtonDisabled',
      decorators: [computed('searchTerm', 'searching')],
      value: function (searchTerm, searching) {
        return !!(searching || !isValidSearchTerm(searchTerm));
      }
    }, {
      key: 'noSortQ',
      decorators: [computed('q')],
      value: function (q) {
        if (q) {
          SortOrders.forEach(function (order) {
            if (q.indexOf(order.term) > -1) {
              q = q.replace(order.term, "");
              q = q.trim();
            }
          });
        }
        return Discourse.Utilities.escapeExpression(q);
      }
    }, {
      key: '_searchOnSortChange',
      initializer: function () {
        return true;
      }
    }, {
      key: 'setSearchTerm',
      value: function (term) {
        var _this = this;

        this._searchOnSortChange = false;
        if (term) {
          SortOrders.forEach(function (order) {
            if (term.indexOf(order.term) > -1) {
              _this.set('sortOrder', order.id);
              term = term.replace(order.term, "");
              term = term.trim();
            }
          });
        }
        this._searchOnSortChange = true;
        this.set('searchTerm', term);
      }
    }, {
      key: 'triggerSearch',
      decorators: [observes('sortOrder')],
      value: function () {
        if (this._searchOnSortChange) {
          this.search();
        }
      }
    }, {
      key: 'modelChanged',
      decorators: [observes('model')],
      value: function () {
        if (this.get("searchTerm") !== this.get("q")) {
          this.setSearchTerm(this.get("q"));
        }
      }
    }, {
      key: 'showLikeCount',
      decorators: [computed('q')],
      value: function (q) {
        return q && q.indexOf("order:likes") > -1;
      }
    }, {
      key: 'qChanged',
      decorators: [observes('q')],
      value: function () {
        var model = this.get("model");
        if (model && this.get("model.q") !== this.get("q")) {
          this.setSearchTerm(this.get("q"));
          this.send("search");
        }
      }
    }, {
      key: '_showFooter',
      decorators: [observes('loading')],
      value: function () {
        this.set("controllers.application.showFooter", !this.get("loading"));
      }
    }, {
      key: 'canBulkSelect',
      initializer: function () {
        return Em.computed.alias('currentUser.staff');
      }
    }, {
      key: 'search',
      value: function () {
        var _this2 = this;

        if (this.get("searching")) return;
        this.set("searching", true);

        var router = Discourse.__container__.lookup('router:main');

        var args = { q: this.get("searchTerm") };

        var sortOrder = this.get("sortOrder");
        if (sortOrder && SortOrders[sortOrder].term) {
          args.q += " " + SortOrders[sortOrder].term;
        }

        this.set("q", args.q);
        this.set("model", null);

        var skip = this.get("skip_context");
        if (!skip && this.get('context') || skip === "false") {
          args.search_context = {
            type: this.get('context'),
            id: this.get('context_id')
          };
        }

        var searchKey = getSearchKey(args);

        Discourse.ajax("/search", { data: args }).then(function (results) {
          var model = translateResults(results) || {};
          router.transientCache('lastSearch', { searchKey: searchKey, model: model }, 5);
          _this2.set("model", model);
        }).finally(function () {
          _this2.set("searching", false);
        });
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {

          selectAll: function () {
            this.get('selected').addObjects(this.get('model.posts').map(function (r) {
              return r.topic;
            }));
            // Doing this the proper way is a HUGE pain,
            // we can hack this to work by observing each on the array
            // in the component, however, when we select ANYTHING, we would force
            // 50 traversals of the list
            // This hack is cheap and easy
            $('.fps-result input[type=checkbox]').prop('checked', true);
          },

          clearAll: function () {
            this.get('selected').clear();
            $('.fps-result input[type=checkbox]').prop('checked', false);
          },

          toggleBulkSelect: function () {
            this.toggleProperty('bulkSelectEnabled');
            this.get('selected').clear();
          },

          refresh: function () {
            this.set('bulkSelectEnabled', false);
            this.get('selected').clear();
            this.search();
          },

          showSearchHelp: function () {
            // TODO: dupe code should be centralized
            Discourse.ajax("/static/search_help.html", { dataType: 'html' }).then(function (model) {
              showModal('searchHelp', { model: model });
            });
          },

          search: function () {
            if (this.get("searchButtonDisabled")) return;
            this.search();
          }
        };
      }
    }]));
  });
define("discourse/controllers/group-index", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var fmt = __dependency1__.fmt;

    __exports__["default"] = Ember.ArrayController.extend({
      needs: ['group'],
      loading: false,
      emptyText: fmt('type', 'groups.empty.%@'),

      actions: {
        loadMore: function () {
          var _this = this;

          if (this.get('loading')) {
            return;
          }
          this.set('loading', true);
          var posts = this.get('model');
          if (posts && posts.length) {
            var beforePostId = posts[posts.length - 1].get('id');
            var group = this.get('controllers.group.model');

            var opts = { beforePostId: beforePostId, type: this.get('type') };
            group.findPosts(opts).then(function (newPosts) {
              posts.addObjects(newPosts);
              _this.set('loading', false);
            });
          }
        }
      }
    });
  });
define("discourse/controllers/group", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__.default;
    var observes = __dependency1__.observes;

    var Tab = Em.Object.extend(_createDecoratedObject([{
      key: 'location',
      decorators: [computed('name')],
      value: function (name) {
        return 'group.' + name;
      }
    }, {
      key: 'message',
      decorators: [computed('name')],
      value: function (name) {
        return I18n.t('groups.' + name);
      }
    }]));

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'counts',
      initializer: function () {
        return null;
      }
    }, {
      key: 'showing',
      initializer: function () {
        return 'posts';
      }
    }, {
      key: 'countsChanged',
      decorators: [observes('counts')],
      value: function () {
        var counts = this.get('counts');
        this.get('tabs').forEach(function (tab) {
          tab.set('count', counts.get(tab.get('name')));
        });
      }
    }, {
      key: 'showingChanged',
      decorators: [observes('showing')],
      value: function () {
        var showing = this.get('showing');

        this.get('tabs').forEach(function (tab) {
          tab.set('active', showing === tab.get('name'));
        });
      }
    }, {
      key: 'tabs',
      initializer: function () {
        return [Tab.create({ name: 'posts', active: true, 'location': 'group.index' }), Tab.create({ name: 'topics' }), Tab.create({ name: 'mentions' }), Tab.create({ name: 'members' }), Tab.create({ name: 'messages' })];
      }
    }]));
  });
define("discourse/controllers/group/members", 
  ["discourse/lib/ajax-error","ember-addons/ember-computed-decorators","discourse/models/group","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var popupAjaxError = __dependency1__.popupAjaxError;
    var computed = __dependency2__["default"];
    var Group = __dependency3__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'loading',
      initializer: function () {
        return false;
      }
    }, {
      key: 'limit',
      initializer: function () {
        return null;
      }
    }, {
      key: 'offset',
      initializer: function () {
        return null;
      }
    }, {
      key: 'isOwner',
      decorators: [computed('model.owners.[]')],
      value: function (owners) {
        if (this.get('currentUser.admin')) {
          return true;
        }
        var currentUserId = this.get('currentUser.id');
        if (currentUserId) {
          return !!owners.findBy('id', currentUserId);
        }
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          removeMember: function (user) {
            this.get('model').removeMember(user);
          },

          addMembers: function () {
            var _this = this;

            var usernames = this.get('usernames');
            if (usernames && usernames.length > 0) {
              this.get('model').addMembers(usernames).then(function () {
                return _this.set('usernames', []);
              }).catch(popupAjaxError);
            }
          },

          loadMore: function () {
            var _this2 = this;

            if (this.get("loading")) {
              return;
            }
            if (this.get("model.members.length") >= this.get("model.user_count")) {
              return;
            }

            this.set("loading", true);

            Group.loadMembers(this.get("model.name"), this.get("model.members.length"), this.get("limit")).then(function (result) {
              _this2.get("model.members").addObjects(result.members.map(function (member) {
                return Discourse.User.create(member);
              }));
              _this2.setProperties({
                loading: false,
                user_count: result.meta.total,
                limit: result.meta.limit,
                offset: Math.min(result.meta.offset + result.meta.limit, result.meta.total)
              });
            });
          }
        };
      }
    }]));
  });
define("discourse/controllers/header", 
  ["discourse/components/site-header","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.addFlagProperty = addFlagProperty;
    var realAddFlagProperty = __dependency1__.addFlagProperty;

    function addFlagProperty(prop) {
      Ember.warn("importing `addFlagProperty` is deprecated. Use the PluginAPI instead");
      realAddFlagProperty(prop);
    }
  });
define("discourse/controllers/history", 
  ["discourse/mixins/modal-functionality","discourse/helpers/category-link","ember-addons/ember-computed-decorators","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ModalFunctionality = __dependency1__["default"];
    var categoryBadgeHTML = __dependency2__.categoryBadgeHTML;
    var computed = __dependency3__["default"];
    var propertyGreaterThan = __dependency4__.propertyGreaterThan;
    var propertyLessThan = __dependency4__.propertyLessThan;

    function customTagArray(fieldName) {
      return (function () {
        var val = this.get(fieldName);
        if (!val) {
          return val;
        }
        if (!Array.isArray(val)) {
          val = [val];
        }
        return val;
      }).property(fieldName);
    }

    // This controller handles displaying of history
    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: 'loading',
      initializer: function () {
        return true;
      }
    }, {
      key: 'viewMode',
      initializer: function () {
        return "side_by_side";
      }
    }, {
      key: '_changeViewModeOnMobile',
      initializer: function () {
        return (function () {
          if (this.site.mobileView) {
            this.set("viewMode", "inline");
          }
        }).on("init");
      }
    }, {
      key: 'previousTagChanges',
      initializer: function () {
        return customTagArray('model.tags_changes.previous');
      }
    }, {
      key: 'currentTagChanges',
      initializer: function () {
        return customTagArray('model.tags_changes.current');
      }
    }, {
      key: 'revisionsText',
      decorators: [computed('previousVersion', 'model.current_version', 'model.version_count')],
      value: function (previous, current, total) {
        return I18n.t("post.revisions.controls.comparing_previous_to_current_out_of_total", {
          previous: previous, current: current, total: total
        });
      }
    }, {
      key: 'refresh',
      value: function (postId, postVersion) {
        var _this = this;

        this.set("loading", true);

        Discourse.Post.loadRevision(postId, postVersion).then(function (result) {
          _this.setProperties({ loading: false, model: result });
        });
      }
    }, {
      key: 'hide',
      value: function (postId, postVersion) {
        var _this2 = this;

        Discourse.Post.hideRevision(postId, postVersion).then(function () {
          return _this2.refresh(postId, postVersion);
        });
      }
    }, {
      key: 'show',
      value: function (postId, postVersion) {
        var _this3 = this;

        Discourse.Post.showRevision(postId, postVersion).then(function () {
          return _this3.refresh(postId, postVersion);
        });
      }
    }, {
      key: 'revert',
      value: function (post, postVersion) {
        var _this4 = this;

        post.revertToRevision(postVersion).then(function (result) {
          _this4.refresh(post.get('id'), postVersion);
          if (result.topic) {
            post.set('topic.slug', result.topic.slug);
            post.set('topic.title', result.topic.title);
            post.set('topic.fancy_title', result.topic.fancy_title);
          }
          if (result.category_id) {
            post.set('topic.category', Discourse.Category.findById(result.category_id));
          }
          _this4.send("closeModal");
        }).catch(function (e) {
          if (e.jqXHR.responseJSON && e.jqXHR.responseJSON.errors && e.jqXHR.responseJSON.errors[0]) {
            bootbox.alert(e.jqXHR.responseJSON.errors[0]);
          }
        });
      }
    }, {
      key: 'createdAtDate',
      decorators: [computed('model.created_at')],
      value: function (createdAt) {
        return moment(createdAt).format("LLLL");
      }
    }, {
      key: 'previousVersion',
      decorators: [computed('model.current_version')],
      value: function (current) {
        return current - 1;
      }
    }, {
      key: 'displayGoToPrevious',
      decorators: [computed('model.current_revision', 'model.previous_revision')],
      value: function (current, prev) {
        return prev && current > prev;
      }
    }, {
      key: 'displayRevisions',
      initializer: function () {
        return Ember.computed.gt("model.version_count", 2);
      }
    }, {
      key: 'displayGoToFirst',
      initializer: function () {
        return propertyGreaterThan("model.current_revision", "model.first_revision");
      }
    }, {
      key: 'displayGoToNext',
      initializer: function () {
        return propertyLessThan("model.current_revision", "model.next_revision");
      }
    }, {
      key: 'displayGoToLast',
      initializer: function () {
        return propertyLessThan("model.current_revision", "model.next_revision");
      }
    }, {
      key: 'hideGoToFirst',
      initializer: function () {
        return Ember.computed.not("displayGoToFirst");
      }
    }, {
      key: 'hideGoToPrevious',
      initializer: function () {
        return Ember.computed.not("displayGoToPrevious");
      }
    }, {
      key: 'hideGoToNext',
      initializer: function () {
        return Ember.computed.not("displayGoToNext");
      }
    }, {
      key: 'hideGoToLast',
      initializer: function () {
        return Ember.computed.not("displayGoToLast");
      }
    }, {
      key: 'loadFirstDisabled',
      initializer: function () {
        return Ember.computed.or("loading", "hideGoToFirst");
      }
    }, {
      key: 'loadPreviousDisabled',
      initializer: function () {
        return Ember.computed.or("loading", "hideGoToPrevious");
      }
    }, {
      key: 'loadNextDisabled',
      initializer: function () {
        return Ember.computed.or("loading", "hideGoToNext");
      }
    }, {
      key: 'loadLastDisabled',
      initializer: function () {
        return Ember.computed.or("loading", "hideGoToLast");
      }
    }, {
      key: 'displayShow',
      decorators: [computed('model.previous_hidden')],
      value: function (prevHidden) {
        return prevHidden && this.currentUser && this.currentUser.get('staff');
      }
    }, {
      key: 'displayHide',
      decorators: [computed('model.previous_hidden')],
      value: function (prevHidden) {
        return !prevHidden && this.currentUser && this.currentUser.get('staff');
      }
    }, {
      key: 'displayRevert',
      decorators: [computed()],
      value: function () {
        return this.currentUser && this.currentUser.get('staff');
      }
    }, {
      key: 'isEitherRevisionHidden',
      initializer: function () {
        return Ember.computed.or("model.previous_hidden", "model.current_hidden");
      }
    }, {
      key: 'hiddenClasses',
      decorators: [computed('model.previous_hidden', 'model.current_hidden', 'displayingInline')],
      value: function (prevHidden, currentHidden, displayingInline) {
        if (displayingInline) {
          return this.get("isEitherRevisionHidden") ? "hidden-revision-either" : null;
        } else {
          var result = [];
          if (prevHidden) {
            result.push("hidden-revision-previous");
          }
          if (currentHidden) {
            result.push("hidden-revision-current");
          }
          return result.join(" ");
        }
      }
    }, {
      key: 'displayingInline',
      initializer: function () {
        return Em.computed.equal("viewMode", "inline");
      }
    }, {
      key: 'displayingSideBySide',
      initializer: function () {
        return Em.computed.equal("viewMode", "side_by_side");
      }
    }, {
      key: 'displayingSideBySideMarkdown',
      initializer: function () {
        return Em.computed.equal("viewMode", "side_by_side_markdown");
      }
    }, {
      key: 'inlineClass',
      decorators: [computed("displayingInline")],
      value: function (displayingInline) {
        return displayingInline ? "btn-primary" : "";
      }
    }, {
      key: 'sideBySideClass',
      decorators: [computed("displayingSideBySide")],
      value: function (displayingSideBySide) {
        return displayingSideBySide ? "btn-primary" : "";
      }
    }, {
      key: 'sideBySideMarkdownClass',
      decorators: [computed("displayingSideBySideMarkdown")],
      value: function (displayingSideBySideMarkdown) {
        return displayingSideBySideMarkdown ? "btn-primary" : "";
      }
    }, {
      key: 'previousCategory',
      decorators: [computed('model.category_id_changes')],
      value: function (changes) {
        if (changes) {
          var category = Discourse.Category.findById(changes["previous"]);
          return categoryBadgeHTML(category, { allowUncategorized: true });
        }
      }
    }, {
      key: 'currentCategory',
      decorators: [computed('model.category_id_changes')],
      value: function (changes) {
        if (changes) {
          var category = Discourse.Category.findById(changes["current"]);
          return categoryBadgeHTML(category, { allowUncategorized: true });
        }
      }
    }, {
      key: 'wikiDisabled',
      decorators: [computed('model.wiki_changes')],
      value: function (changes) {
        return changes && !changes['current'];
      }
    }, {
      key: 'postTypeDisabled',
      decorators: [computed('model.post_type_changes')],
      value: function (changes) {
        return changes && changes['current'] !== this.site.get('post_types.moderator_action');
      }
    }, {
      key: 'titleDiff',
      decorators: [computed('viewMode', 'model.title_changes')],
      value: function (viewMode) {
        if (viewMode === "side_by_side_markdown") {
          viewMode = "side_by_side";
        }
        return this.get("model.title_changes." + viewMode);
      }
    }, {
      key: 'bodyDiff',
      decorators: [computed('viewMode', 'model.body_changes')],
      value: function (viewMode) {
        return this.get("model.body_changes." + viewMode);
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          loadFirstVersion: function () {
            this.refresh(this.get("model.post_id"), this.get("model.first_revision"));
          },
          loadPreviousVersion: function () {
            this.refresh(this.get("model.post_id"), this.get("model.previous_revision"));
          },
          loadNextVersion: function () {
            this.refresh(this.get("model.post_id"), this.get("model.next_revision"));
          },
          loadLastVersion: function () {
            this.refresh(this.get("model.post_id"), this.get("model.last_revision"));
          },

          hideVersion: function () {
            this.hide(this.get("model.post_id"), this.get("model.current_revision"));
          },
          showVersion: function () {
            this.show(this.get("model.post_id"), this.get("model.current_revision"));
          },

          revertToVersion: function () {
            this.revert(this.get("post"), this.get("model.current_revision"));
          },

          displayInline: function () {
            this.set("viewMode", "inline");
          },
          displaySideBySide: function () {
            this.set("viewMode", "side_by_side");
          },
          displaySideBySideMarkdown: function () {
            this.set("viewMode", "side_by_side_markdown");
          }
        };
      }
    }]));
  });
define("discourse/controllers/invite", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      needs: ['user-invited-show'],

      // If this isn't defined, it will proxy to the user model on the preferences
      // page which is wrong.
      emailOrUsername: null,
      inviteIcon: "envelope",

      isAdmin: (function () {
        return Discourse.User.currentProp("admin");
      }).property(),

      disabled: (function () {
        if (this.get('model.saving')) return true;
        if (Ember.isEmpty(this.get('emailOrUsername'))) return true;
        var emailOrUsername = this.get('emailOrUsername').trim();
        // when inviting to forum, email must be valid
        if (!this.get('invitingToTopic') && !Discourse.Utilities.emailValid(emailOrUsername)) return true;
        // normal users (not admin) can't invite users to private topic via email
        if (!this.get('isAdmin') && this.get('isPrivateTopic') && Discourse.Utilities.emailValid(emailOrUsername)) return true;
        // when inviting to private topic via email, group name must be specified
        if (this.get('isPrivateTopic') && Ember.isEmpty(this.get('model.groupNames')) && Discourse.Utilities.emailValid(emailOrUsername)) return true;
        if (this.get('model.details.can_invite_to')) return false;
        return false;
      }).property('isAdmin', 'emailOrUsername', 'invitingToTopic', 'isPrivateTopic', 'model.groupNames', 'model.saving'),

      disabledCopyLink: (function () {
        if (this.get('model.saving')) return true;
        if (Ember.isEmpty(this.get('emailOrUsername'))) return true;
        var emailOrUsername = this.get('emailOrUsername').trim();
        // email must be valid
        if (!Discourse.Utilities.emailValid(emailOrUsername)) return true;
        // normal users (not admin) can't invite users to private topic via email
        if (!this.get('isAdmin') && this.get('isPrivateTopic') && Discourse.Utilities.emailValid(emailOrUsername)) return true;
        // when inviting to private topic via email, group name must be specified
        if (this.get('isPrivateTopic') && Ember.isEmpty(this.get('model.groupNames')) && Discourse.Utilities.emailValid(emailOrUsername)) return true;
        return false;
      }).property('emailOrUsername', 'model.saving', 'isPrivateTopic', 'model.groupNames'),

      buttonTitle: (function () {
        return this.get('model.saving') ? 'topic.inviting' : 'topic.invite_reply.action';
      }).property('model.saving'),

      // We are inviting to a topic if the model isn't the current user.
      // The current user would mean we are inviting to the forum in general.
      invitingToTopic: (function () {
        return this.get('model') !== this.currentUser;
      }).property('model'),

      showCopyInviteButton: (function () {
        return !Discourse.SiteSettings.enable_sso && !this.get('isMessage');
      }).property('isMessage'),

      topicId: Ember.computed.alias('model.id'),

      // Is Private Topic? (i.e. visible only to specific group members)
      isPrivateTopic: Em.computed.and('invitingToTopic', 'model.category.read_restricted'),

      // Is Private Message?
      isMessage: Em.computed.equal('model.archetype', 'private_message'),

      // Allow Existing Members? (username autocomplete)
      allowExistingMembers: (function () {
        return this.get('invitingToTopic');
      }).property('invitingToTopic'),

      // Show Groups? (add invited user to private group)
      showGroups: (function () {
        return this.get('isAdmin') && (Discourse.Utilities.emailValid(this.get('emailOrUsername')) || this.get('isPrivateTopic') || !this.get('invitingToTopic')) && !Discourse.SiteSettings.enable_sso && Discourse.SiteSettings.enable_local_logins && !this.get('isMessage');
      }).property('isAdmin', 'emailOrUsername', 'isPrivateTopic', 'isMessage', 'invitingToTopic'),

      // Instructional text for the modal.
      inviteInstructions: (function () {
        if (Discourse.SiteSettings.enable_sso || !Discourse.SiteSettings.enable_local_logins) {
          // inviting existing user when SSO enabled
          return I18n.t('topic.invite_reply.sso_enabled');
        } else if (this.get('isMessage')) {
          // inviting to a message
          return I18n.t('topic.invite_private.email_or_username');
        } else if (this.get('invitingToTopic')) {
          // inviting to a private/public topic
          if (this.get('isPrivateTopic') && !this.get('isAdmin')) {
            // inviting to a private topic and is not admin
            return I18n.t('topic.invite_reply.to_username');
          } else {
            // when inviting to a topic, display instructions based on provided entity
            if (Ember.isEmpty(this.get('emailOrUsername'))) {
              return I18n.t('topic.invite_reply.to_topic_blank');
            } else if (Discourse.Utilities.emailValid(this.get('emailOrUsername'))) {
              this.set("inviteIcon", "envelope");
              return I18n.t('topic.invite_reply.to_topic_email');
            } else {
              this.set("inviteIcon", "hand-o-right");
              return I18n.t('topic.invite_reply.to_topic_username');
            }
          }
        } else {
          // inviting to forum
          return I18n.t('topic.invite_reply.to_forum');
        }
      }).property('isMessage', 'invitingToTopic', 'emailOrUsername'),

      // Instructional text for the group selection.
      groupInstructions: (function () {
        return this.get('isPrivateTopic') ? I18n.t('topic.automatically_add_to_groups_required') : I18n.t('topic.automatically_add_to_groups_optional');
      }).property('isPrivateTopic'),

      groupFinder: function (term) {
        var Group = require('discourse/models/group').default;
        return Group.findAll({ search: term, ignore_automatic: true });
      },

      successMessage: (function () {
        if (this.get('model.inviteLink')) {
          return I18n.t('user.invited.generated_link_message', { inviteLink: this.get('model.inviteLink'), invitedEmail: this.get('emailOrUsername') });
        } else if (this.get('isMessage')) {
          return I18n.t('topic.invite_private.success');
        } else if (Discourse.Utilities.emailValid(this.get('emailOrUsername'))) {
          return I18n.t('topic.invite_reply.success_email', { emailOrUsername: this.get('emailOrUsername') });
        } else {
          return I18n.t('topic.invite_reply.success_username');
        }
      }).property('model.inviteLink', 'isMessage', 'emailOrUsername'),

      errorMessage: (function () {
        return this.get('isMessage') ? I18n.t('topic.invite_private.error') : I18n.t('topic.invite_reply.error');
      }).property('isMessage'),

      placeholderKey: (function () {
        return Discourse.SiteSettings.enable_sso || !Discourse.SiteSettings.enable_local_logins ? 'topic.invite_reply.username_placeholder' : 'topic.invite_private.email_or_username_placeholder';
      }).property(),

      // Reset the modal to allow a new user to be invited.
      reset: function () {
        this.set('emailOrUsername', null);
        this.get('model').setProperties({
          groupNames: null,
          error: false,
          saving: false,
          finished: false,
          inviteLink: null
        });
      },

      actions: {

        createInvite: function () {
          var _this = this;

          var Invite = require('discourse/models/invite').default;
          var self = this;

          if (this.get('disabled')) {
            return;
          }

          var groupNames = this.get('model.groupNames'),
              userInvitedController = this.get('controllers.user-invited-show'),
              model = this.get('model');

          model.setProperties({ saving: true, error: false });

          return this.get('model').createInvite(this.get('emailOrUsername').trim(), groupNames).then(function (result) {
            model.setProperties({ saving: false, finished: true });
            if (!_this.get('invitingToTopic')) {
              Invite.findInvitedBy(_this.currentUser, userInvitedController.get('filter')).then(function (invite_model) {
                userInvitedController.set('model', invite_model);
                userInvitedController.set('totalInvites', invite_model.invites.length);
              });
            } else if (_this.get('isMessage') && result && result.user) {
              _this.get('model.details.allowed_users').pushObject(Ember.Object.create(result.user));
            }
          }).catch(function (e) {
            if (e.jqXHR.responseJSON && e.jqXHR.responseJSON.errors) {
              self.set("errorMessage", e.jqXHR.responseJSON.errors[0]);
            } else {
              self.set("errorMessage", self.get('isMessage') ? I18n.t('topic.invite_private.error') : I18n.t('topic.invite_reply.error'));
            }
            model.setProperties({ saving: false, error: true });
          });
        },

        generateInvitelink: function () {
          var _this2 = this;

          var Invite = require('discourse/models/invite').default;
          var self = this;

          if (this.get('disabled')) {
            return;
          }

          var groupNames = this.get('model.groupNames'),
              userInvitedController = this.get('controllers.user-invited-show'),
              model = this.get('model');

          var topicId = null;
          if (this.get('invitingToTopic')) {
            topicId = this.get('model.id');
          }

          model.setProperties({ saving: true, error: false });

          return this.get('model').generateInviteLink(this.get('emailOrUsername').trim(), groupNames, topicId).then(function (result) {
            model.setProperties({ saving: false, finished: true, inviteLink: result });
            Invite.findInvitedBy(_this2.currentUser, userInvitedController.get('filter')).then(function (invite_model) {
              userInvitedController.set('model', invite_model);
              userInvitedController.set('totalInvites', invite_model.invites.length);
            });
          }).catch(function (e) {
            if (e.jqXHR.responseJSON && e.jqXHR.responseJSON.errors) {
              self.set("errorMessage", e.jqXHR.responseJSON.errors[0]);
            } else {
              self.set("errorMessage", self.get('isMessage') ? I18n.t('topic.invite_private.error') : I18n.t('topic.invite_reply.error'));
            }
            model.setProperties({ saving: false, error: true });
          });
        }
      }

    });
  });
define("discourse/controllers/keyboard-shortcuts-help", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      needs: ['modal'],

      onShow: function () {
        this.set('controllers.modal.modalClass', 'keyboard-shortcuts-modal');
      }
    });
  });
define("discourse/controllers/login", 
  ["discourse/mixins/modal-functionality","discourse/lib/show-modal","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];
    var showModal = __dependency2__["default"];
    var setting = __dependency3__.setting;

    // This is happening outside of the app via popup
    var AuthErrors = ['requires_invite', 'awaiting_approval', 'awaiting_confirmation', 'admin_not_allowed_from_ip_address', 'not_allowed_from_ip_address'];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      needs: ['modal', 'createAccount', 'forgotPassword', 'application'],
      authenticate: null,
      loggingIn: false,
      loggedIn: false,

      canLoginLocal: setting('enable_local_logins'),
      loginRequired: Em.computed.alias('controllers.application.loginRequired'),

      resetForm: function () {
        this.set('authenticate', null);
        this.set('loggingIn', false);
        this.set('loggedIn', false);
      },

      /**
       Determines whether at least one login button is enabled
      **/
      hasAtLeastOneLoginButton: (function () {
        return Em.get("Discourse.LoginMethod.all").length > 0;
      }).property("Discourse.LoginMethod.all.[]"),

      loginButtonText: (function () {
        return this.get('loggingIn') ? I18n.t('login.logging_in') : I18n.t('login.title');
      }).property('loggingIn'),

      loginDisabled: Em.computed.or('loggingIn', 'loggedIn'),

      showSignupLink: (function () {
        return this.get('controllers.application.canSignUp') && !this.get('loggingIn') && Ember.isEmpty(this.get('authenticate'));
      }).property('loggingIn', 'authenticate'),

      showSpinner: (function () {
        return this.get('loggingIn') || this.get('authenticate');
      }).property('loggingIn', 'authenticate'),

      actions: {
        login: function () {
          var self = this;

          if (Ember.isEmpty(this.get('loginName')) || Ember.isEmpty(this.get('loginPassword'))) {
            self.flash(I18n.t('login.blank_username_or_password'), 'error');
            return;
          }

          this.set('loggingIn', true);

          Discourse.ajax("/session", {
            data: { login: this.get('loginName'), password: this.get('loginPassword') },
            type: 'POST'
          }).then(function (result) {
            // Successful login
            if (result.error) {
              self.set('loggingIn', false);
              if (result.reason === 'not_activated') {
                self.send('showNotActivated', {
                  username: self.get('loginName'),
                  sentTo: result.sent_to_email,
                  currentEmail: result.current_email
                });
              } else if (result.reason === 'suspended') {
                self.send("closeModal");
                bootbox.alert(result.error);
              } else {
                self.flash(result.error, 'error');
              }
            } else {
              self.set('loggedIn', true);
              // Trigger the browser's password manager using the hidden static login form:
              var $hidden_login_form = $('#hidden-login-form');
              var destinationUrl = $.cookie('destination_url');
              var shouldRedirectToUrl = self.session.get("shouldRedirectToUrl");
              var ssoDestinationUrl = $.cookie('sso_destination_url');
              $hidden_login_form.find('input[name=username]').val(self.get('loginName'));
              $hidden_login_form.find('input[name=password]').val(self.get('loginPassword'));

              if (ssoDestinationUrl) {
                $.cookie('sso_destination_url', null);
                window.location.assign(ssoDestinationUrl);
                return;
              } else if (destinationUrl) {
                // redirect client to the original URL
                $.cookie('destination_url', null);
                $hidden_login_form.find('input[name=redirect]').val(destinationUrl);
              } else if (shouldRedirectToUrl) {
                self.session.set("shouldRedirectToUrl", null);
                $hidden_login_form.find('input[name=redirect]').val(shouldRedirectToUrl);
              } else {
                $hidden_login_form.find('input[name=redirect]').val(window.location.href);
              }

              if (navigator.userAgent.match(/(iPad|iPhone|iPod)/g) && navigator.userAgent.match(/Safari/g)) {
                // In case of Safari on iOS do not submit hidden login form
                window.location.href = $hidden_login_form.find('input[name=redirect]').val();
              } else {
                $hidden_login_form.submit();
              }
              return;
            }
          }, function (e) {
            // Failed to login
            if (e.jqXHR && e.jqXHR.status === 429) {
              self.flash(I18n.t('login.rate_limit'), 'error');
            } else {
              self.flash(I18n.t('login.error'), 'error');
            }
            self.set('loggingIn', false);
          });

          return false;
        },

        externalLogin: function (loginMethod) {
          var _this = this;

          var name = loginMethod.get("name");
          var customLogin = loginMethod.get("customLogin");

          if (customLogin) {
            customLogin();
          } else {
            var authUrl = loginMethod.get('customUrl') || Discourse.getURL("/auth/" + name);
            if (loginMethod.get("fullScreenLogin")) {
              window.location = authUrl;
            } else {
              (function () {
                _this.set('authenticate', name);
                var left = _this.get('lastX') - 400;
                var top = _this.get('lastY') - 200;

                var height = loginMethod.get("frameHeight") || 400;
                var width = loginMethod.get("frameWidth") || 800;
                var w = window.open(authUrl, "_blank", "menubar=no,status=no,height=" + height + ",width=" + width + ",left=" + left + ",top=" + top);
                var self = _this;
                var timer = setInterval(function () {
                  if (!w || w.closed) {
                    clearInterval(timer);
                    self.set('authenticate', null);
                  }
                }, 1000);
              })();
            }
          }
        },

        createAccount: function () {
          var createAccountController = this.get('controllers.createAccount');
          if (createAccountController) {
            createAccountController.resetForm();
            var loginName = this.get('loginName');
            if (loginName && loginName.indexOf('@') > 0) {
              createAccountController.set("accountEmail", loginName);
            } else {
              createAccountController.set("accountUsername", loginName);
            }
          }
          this.send('showCreateAccount');
        },

        forgotPassword: function () {
          var forgotPasswordController = this.get('controllers.forgotPassword');
          if (forgotPasswordController) {
            forgotPasswordController.set("accountEmailOrUsername", this.get("loginName"));
          }
          this.send("showForgotPassword");
        }
      },

      authMessage: (function () {
        if (Ember.isEmpty(this.get('authenticate'))) return "";
        var method = Discourse.get('LoginMethod.all').findProperty("name", this.get("authenticate"));
        if (method) {
          return method.get('message');
        }
      }).property('authenticate'),

      authenticationComplete: function (options) {

        var self = this;
        function loginError(errorMsg, className) {
          showModal('login');
          Ember.run.next(function () {
            self.flash(errorMsg, className || 'success');
            self.set('authenticate', null);
          });
        }

        for (var i = 0; i < AuthErrors.length; i++) {
          var cond = AuthErrors[i];
          if (options[cond]) {
            return loginError(I18n.t("login." + cond));
          }
        }

        if (options.suspended) {
          return loginError(options.suspended_message, 'error');
        }

        // Reload the page if we're authenticated
        if (options.authenticated) {
          var destinationUrl = $.cookie('destination_url');
          var shouldRedirectToUrl = self.session.get("shouldRedirectToUrl");
          if (self.get('loginRequired') && destinationUrl) {
            // redirect client to the original URL
            $.cookie('destination_url', null);
            window.location.href = destinationUrl;
          } else if (shouldRedirectToUrl) {
            self.session.set("shouldRedirectToUrl", null);
            window.location.href = shouldRedirectToUrl;
          } else if (window.location.pathname === Discourse.getURL('/login')) {
            window.location.pathname = Discourse.getURL('/');
          } else {
            window.location.reload();
          }
          return;
        }

        var createAccountController = this.get('controllers.createAccount');
        createAccountController.setProperties({
          accountEmail: options.email,
          accountUsername: options.username,
          accountName: options.name,
          authOptions: Ember.Object.create(options)
        });
        showModal('createAccount');
      }

    });
  });
define("discourse/controllers/merge-topic", 
  ["discourse/mixins/selected-posts-count","discourse/mixins/modal-functionality","discourse/models/topic","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var SelectedPostsCount = __dependency1__["default"];
    var ModalFunctionality = __dependency2__["default"];
    var movePosts = __dependency3__.movePosts;
    var mergeTopic = __dependency3__.mergeTopic;
    var DiscourseURL = __dependency4__["default"];

    // Modal related to merging of topics
    __exports__["default"] = Ember.Controller.extend(SelectedPostsCount, ModalFunctionality, {
      needs: ['topic'],

      saving: false,
      selectedTopicId: null,

      topicController: Em.computed.alias('controllers.topic'),
      selectedPosts: Em.computed.alias('topicController.selectedPosts'),
      selectedReplies: Em.computed.alias('topicController.selectedReplies'),
      allPostsSelected: Em.computed.alias('topicController.allPostsSelected'),

      buttonDisabled: (function () {
        if (this.get('saving')) return true;
        return Ember.isEmpty(this.get('selectedTopicId'));
      }).property('selectedTopicId', 'saving'),

      buttonTitle: (function () {
        if (this.get('saving')) return I18n.t('saving');
        return I18n.t('topic.merge_topic.title');
      }).property('saving'),

      onShow: function () {
        this.set('controllers.modal.modalClass', 'split-modal');
      },

      actions: {
        movePostsToExistingTopic: function () {
          var topicId = this.get('model.id');

          this.set('saving', true);

          var promise = null;
          if (this.get('allPostsSelected')) {
            promise = mergeTopic(topicId, this.get('selectedTopicId'));
          } else {
            var postIds = this.get('selectedPosts').map(function (p) {
              return p.get('id');
            });
            var replyPostIds = this.get('selectedReplies').map(function (p) {
              return p.get('id');
            });

            promise = movePosts(topicId, {
              destination_topic_id: this.get('selectedTopicId'),
              post_ids: postIds,
              reply_post_ids: replyPostIds
            });
          }

          var self = this;
          promise.then(function (result) {
            // Posts moved
            self.send('closeModal');
            self.get('topicController').send('toggleMultiSelect');
            Em.run.next(function () {
              DiscourseURL.routeTo(result.url);
            });
          }).catch(function () {
            self.flash(I18n.t('topic.merge_topic.error'));
          }).finally(function () {
            self.set('saving', false);
          });
          return false;
        }
      }

    });
  });
define("discourse/controllers/modal", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend();
  });
define("discourse/controllers/navigation/categories", 
  ["discourse/controllers/navigation/default","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var NavigationDefaultController = __dependency1__["default"];

    __exports__["default"] = NavigationDefaultController.extend();
  });
define("discourse/controllers/navigation/category", 
  ["ember-addons/ember-computed-decorators","discourse/controllers/navigation/default","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var NavigationDefaultController = __dependency2__["default"];
    var setting = __dependency3__.setting;

    __exports__["default"] = NavigationDefaultController.extend(_createDecoratedObject([{
      key: 'subcategoryListSetting',
      initializer: function () {
        return setting('show_subcategory_list');
      }
    }, {
      key: 'showingParentCategory',
      initializer: function () {
        return Em.computed.none('category.parentCategory');
      }
    }, {
      key: 'showingSubcategoryList',
      initializer: function () {
        return Em.computed.and('subcategoryListSetting', 'showingParentCategory');
      }
    }, {
      key: 'navItems',
      decorators: [computed("showingSubcategoryList", "category", "noSubcategories")],
      value: function (showingSubcategoryList, category, noSubcategories) {
        return Discourse.NavItem.buildList(category, { noSubcategories: noSubcategories });
      }
    }]));
  });
define("discourse/controllers/not-activated", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      emailSent: false,

      onShow: function () {
        this.set("emailSent", false);
      },

      actions: {
        sendActivationEmail: function () {
          Discourse.ajax('/users/action/send_activation_email', { data: { username: this.get('username') }, type: 'POST' });
          this.set('emailSent', true);
        }
      }

    });
  });
define("discourse/controllers/post-enqueued", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      description: Ember.computed('model.reason', function () {
        var reason = this.get('model.reason');
        return reason ? I18n.t('queue_reason.' + reason + '.description') : I18n.t('queue.approval.description');
      })
    });
  });
define("discourse/controllers/preferences", 
  ["discourse/lib/computed","discourse/mixins/can-check-emails","discourse/lib/ajax-error","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var setting = __dependency1__.setting;
    var CanCheckEmails = __dependency2__["default"];
    var popupAjaxError = __dependency3__.popupAjaxError;
    var computed = __dependency4__["default"];

    __exports__["default"] = Ember.Controller.extend(CanCheckEmails, _createDecoratedObject([{
      key: 'selectedCategories',
      decorators: [computed("model.watchedCategories", "model.trackedCategories", "model.mutedCategories")],
      value: function (watched, tracked, muted) {
        return [].concat(watched, tracked, muted);
      }
    }, {
      key: 'saved',

      // By default we haven't saved anything
      initializer: function () {
        return false;
      }
    }, {
      key: 'newNameInput',
      initializer: function () {
        return null;
      }
    }, {
      key: 'userFields',
      decorators: [computed("model.user_fields.@each.value")],
      value: function () {
        var _this = this;

        var siteUserFields = this.site.get('user_fields');
        if (!Ember.isEmpty(siteUserFields)) {
          var _ret = (function () {
            var userFields = _this.get('model.user_fields');

            // Staff can edit fields that are not `editable`
            if (!_this.get('currentUser.staff')) {
              siteUserFields = siteUserFields.filterProperty('editable', true);
            }
            return {
              v: siteUserFields.sortBy('position').map(function (field) {
                var value = userFields ? userFields[field.get('id').toString()] : null;
                return Ember.Object.create({ value: value, field: field });
              })
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
      }
    }, {
      key: 'cannotDeleteAccount',
      initializer: function () {
        return Em.computed.not('currentUser.can_delete_account');
      }
    }, {
      key: 'deleteDisabled',
      initializer: function () {
        return Em.computed.or('model.isSaving', 'deleting', 'cannotDeleteAccount');
      }
    }, {
      key: 'canEditName',
      initializer: function () {
        return setting('enable_names');
      }
    }, {
      key: 'nameInstructions',
      decorators: [computed()],
      value: function () {
        return I18n.t(this.siteSettings.full_name_required ? 'user.name.instructions_required' : 'user.name.instructions');
      }
    }, {
      key: 'canSelectTitle',
      decorators: [computed("model.has_title_badges")],
      value: function (hasTitleBadges) {
        return this.siteSettings.enable_badges && hasTitleBadges;
      }
    }, {
      key: 'canChangePassword',
      decorators: [computed()],
      value: function () {
        return !this.siteSettings.enable_sso && this.siteSettings.enable_local_logins;
      }
    }, {
      key: 'canReceiveDigest',
      decorators: [computed()],
      value: function () {
        return !this.siteSettings.disable_digest_emails;
      }
    }, {
      key: 'availableLocales',
      decorators: [computed()],
      value: function () {
        return this.siteSettings.available_locales.split('|').map(function (s) {
          return { name: s, value: s };
        });
      }
    }, {
      key: 'previousRepliesOptions',
      initializer: function () {
        return [{ name: I18n.t('user.email_previous_replies.always'), value: 0 }, { name: I18n.t('user.email_previous_replies.unless_emailed'), value: 1 }, { name: I18n.t('user.email_previous_replies.never'), value: 2 }];
      }
    }, {
      key: 'digestFrequencies',
      initializer: function () {
        return [{ name: I18n.t('user.email_digests.every_30_minutes'), value: 30 }, { name: I18n.t('user.email_digests.every_hour'), value: 60 }, { name: I18n.t('user.email_digests.daily'), value: 1440 }, { name: I18n.t('user.email_digests.every_three_days'), value: 4320 }, { name: I18n.t('user.email_digests.weekly'), value: 10080 }, { name: I18n.t('user.email_digests.every_two_weeks'), value: 20160 }];
      }
    }, {
      key: 'likeNotificationFrequencies',
      initializer: function () {
        return [{ name: I18n.t('user.like_notification_frequency.always'), value: 0 }, { name: I18n.t('user.like_notification_frequency.first_time_and_daily'), value: 1 }, { name: I18n.t('user.like_notification_frequency.first_time'), value: 2 }, { name: I18n.t('user.like_notification_frequency.never'), value: 3 }];
      }
    }, {
      key: 'autoTrackDurations',
      initializer: function () {
        return [{ name: I18n.t('user.auto_track_options.never'), value: -1 }, { name: I18n.t('user.auto_track_options.immediately'), value: 0 }, { name: I18n.t('user.auto_track_options.after_30_seconds'), value: 30000 }, { name: I18n.t('user.auto_track_options.after_1_minute'), value: 60000 }, { name: I18n.t('user.auto_track_options.after_2_minutes'), value: 120000 }, { name: I18n.t('user.auto_track_options.after_3_minutes'), value: 180000 }, { name: I18n.t('user.auto_track_options.after_4_minutes'), value: 240000 }, { name: I18n.t('user.auto_track_options.after_5_minutes'), value: 300000 }, { name: I18n.t('user.auto_track_options.after_10_minutes'), value: 600000 }];
      }
    }, {
      key: 'considerNewTopicOptions',
      initializer: function () {
        return [{ name: I18n.t('user.new_topic_duration.not_viewed'), value: -1 }, { name: I18n.t('user.new_topic_duration.after_1_day'), value: 60 * 24 }, { name: I18n.t('user.new_topic_duration.after_2_days'), value: 60 * 48 }, { name: I18n.t('user.new_topic_duration.after_1_week'), value: 7 * 60 * 24 }, { name: I18n.t('user.new_topic_duration.after_2_weeks'), value: 2 * 7 * 60 * 24 }, { name: I18n.t('user.new_topic_duration.last_here'), value: -2 }];
      }
    }, {
      key: 'saveButtonText',
      decorators: [computed("model.isSaving")],
      value: function (isSaving) {
        return isSaving ? I18n.t('saving') : I18n.t('save');
      }
    }, {
      key: 'reset',
      value: function () {
        this.setProperties({
          passwordProgress: null
        });
      }
    }, {
      key: 'passwordProgress',
      initializer: function () {
        return null;
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {

          checkMailingList: function () {
            var _this2 = this;

            Em.run.next(function () {
              var postsPerDay = _this2.get('model.mailing_list_posts_per_day');
              if (!postsPerDay || postsPerDay < 2) {
                _this2.set('model.user_option.mailing_list_mode', true);
                return;
              }

              bootbox.confirm(I18n.t("user.enable_mailing_list", { count: postsPerDay }), I18n.t("no_value"), I18n.t("yes_value"), function (success) {
                if (success) {
                  _this2.set('model.user_option.mailing_list_mode', true);
                }
              });
            });
          },

          save: function () {
            var _this3 = this;

            this.set('saved', false);

            var model = this.get('model');
            var userFields = this.get('userFields');

            // Update the user fields
            if (!Ember.isEmpty(userFields)) {
              (function () {
                var modelFields = model.get('user_fields');
                if (!Ember.isEmpty(modelFields)) {
                  userFields.forEach(function (uf) {
                    modelFields[uf.get('field.id').toString()] = uf.get('value');
                  });
                }
              })();
            }

            // Cook the bio for preview
            model.set('name', this.get('newNameInput'));
            return model.save().then(function () {
              if (Discourse.User.currentProp('id') === model.get('id')) {
                Discourse.User.currentProp('name', model.get('name'));
              }
              model.set('bio_cooked', Discourse.Markdown.cook(Discourse.Markdown.sanitize(model.get('bio_raw'))));
              _this3.set('saved', true);
            }).catch(popupAjaxError);
          },

          changePassword: function () {
            var _this4 = this;

            if (!this.get('passwordProgress')) {
              this.set('passwordProgress', I18n.t("user.change_password.in_progress"));
              return this.get('model').changePassword().then(function () {
                // password changed
                _this4.setProperties({
                  changePasswordProgress: false,
                  passwordProgress: I18n.t("user.change_password.success")
                });
              }).catch(function () {
                // password failed to change
                _this4.setProperties({
                  changePasswordProgress: false,
                  passwordProgress: I18n.t("user.change_password.error")
                });
              });
            }
          },

          delete: function () {
            var _this5 = this;

            this.set('deleting', true);
            var self = this,
                message = I18n.t('user.delete_account_confirm'),
                model = this.get('model'),
                buttons = [{ label: I18n.t("cancel"),
              class: "cancel-inline",
              link: true,
              callback: function () {
                _this5.set('deleting', false);
              }
            }, { label: '<i class="fa fa-exclamation-triangle"></i> ' + I18n.t("user.delete_account"),
              class: "btn btn-danger",
              callback: function () {
                model.delete().then(function () {
                  bootbox.alert(I18n.t('user.deleted_yourself'), function () {
                    window.location.pathname = Discourse.getURL('/');
                  });
                }, function () {
                  bootbox.alert(I18n.t('user.delete_yourself_not_allowed'));
                  self.set('deleting', false);
                });
              }
            }];
            bootbox.dialog(message, buttons, { "classes": "delete-account" });
          }
        };
      }
    }]));
  });
define("discourse/controllers/preferences/about", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      saving: false,
      newBio: null,

      saveButtonText: (function () {
        return this.get('saving') ? I18n.t("saving") : I18n.t('user.change');
      }).property('saving')

    });
  });
define("discourse/controllers/preferences/badge-title", 
  ["discourse/mixins/badge-select-controller","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var BadgeSelectController = __dependency1__["default"];

    __exports__["default"] = Ember.ArrayController.extend(BadgeSelectController, {

      filteredList: (function () {
        return this.get('model').filterBy('badge.allow_title', true);
      }).property('model'),

      actions: {
        save: function () {
          this.setProperties({ saved: false, saving: true });

          var self = this;
          Discourse.ajax(this.get('user.path') + "/preferences/badge_title", {
            type: "PUT",
            data: { user_badge_id: self.get('selectedUserBadgeId') }
          }).then(function () {
            self.setProperties({
              saved: true,
              saving: false,
              "user.title": self.get('selectedUserBadge.badge.name')
            });
          }, function () {
            bootbox.alert(I18n.t('generic_error'));
          });
        }
      }
    });
  });
define("discourse/controllers/preferences/card-badge", 
  ["discourse/mixins/badge-select-controller","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var BadgeSelectController = __dependency1__["default"];

    __exports__["default"] = Ember.ArrayController.extend(BadgeSelectController, {
      filteredList: (function () {
        return this.get('model').filter(function (b) {
          return !Ember.isEmpty(b.get('badge.image'));
        });
      }).property('model'),

      actions: {
        save: function () {
          this.setProperties({ saved: false, saving: true });

          var self = this;
          Discourse.ajax(this.get('user.path') + "/preferences/card-badge", {
            type: "PUT",
            data: { user_badge_id: self.get('selectedUserBadgeId') }
          }).then(function () {
            self.setProperties({
              saved: true,
              saving: false,
              "user.card_image_badge": self.get('selectedUserBadge.badge.image')
            });
          }).catch(function () {
            self.set('saving', false);
            bootbox.alert(I18n.t('generic_error'));
          });
        }
      }
    });
  });
define("discourse/controllers/preferences/email", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;

    __exports__["default"] = Ember.Controller.extend({
      taken: false,
      saving: false,
      error: false,
      success: false,
      newEmail: null,

      newEmailEmpty: Em.computed.empty('newEmail'),
      saveDisabled: Em.computed.or('saving', 'newEmailEmpty', 'taken', 'unchanged'),
      unchanged: propertyEqual('newEmailLower', 'currentUser.email'),

      newEmailLower: (function () {
        return this.get('newEmail').toLowerCase().trim();
      }).property('newEmail'),

      saveButtonText: (function () {
        if (this.get('saving')) return I18n.t("saving");
        return I18n.t("user.change");
      }).property('saving'),

      actions: {
        changeEmail: function () {
          var self = this;
          this.set('saving', true);
          return this.get('content').changeEmail(this.get('newEmail')).then(function () {
            self.set('success', true);
          }, function (e) {
            self.setProperties({ error: true, saving: false });
            if (e.jqXHR.responseJSON && e.jqXHR.responseJSON.errors && e.jqXHR.responseJSON.errors[0]) {
              self.set('errorMessage', e.jqXHR.responseJSON.errors[0]);
            } else {
              self.set('errorMessage', I18n.t('user.change_email.error'));
            }
          });
        }
      }

    });
  });
define("discourse/controllers/preferences/username", 
  ["discourse/lib/computed","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var setting = __dependency1__.setting;
    var propertyEqual = __dependency1__.propertyEqual;
    var DiscourseURL = __dependency2__["default"];

    __exports__["default"] = Ember.Controller.extend({
      taken: false,
      saving: false,
      error: false,
      errorMessage: null,
      newUsername: null,

      maxLength: setting('max_username_length'),
      minLength: setting('min_username_length'),
      newUsernameEmpty: Em.computed.empty('newUsername'),
      saveDisabled: Em.computed.or('saving', 'newUsernameEmpty', 'taken', 'unchanged', 'errorMessage'),
      unchanged: propertyEqual('newUsername', 'username'),

      checkTaken: (function () {
        if (this.get('newUsername') && this.get('newUsername').length < this.get('minLength')) {
          this.set('errorMessage', I18n.t('user.name.too_short'));
        } else {
          var self = this;
          this.set('taken', false);
          this.set('errorMessage', null);
          if (Ember.isEmpty(this.get('newUsername'))) return;
          if (this.get('unchanged')) return;
          Discourse.User.checkUsername(this.get('newUsername'), undefined, this.get('content.id')).then(function (result) {
            if (result.errors) {
              self.set('errorMessage', result.errors.join(' '));
            } else if (result.available === false) {
              self.set('taken', true);
            }
          });
        }
      }).observes('newUsername'),

      saveButtonText: (function () {
        if (this.get('saving')) return I18n.t("saving");
        return I18n.t("user.change");
      }).property('saving'),

      actions: {
        changeUsername: function () {
          var self = this;
          return bootbox.confirm(I18n.t("user.change_username.confirm"), I18n.t("no_value"), I18n.t("yes_value"), function (result) {
            if (result) {
              self.set('saving', true);
              self.get('content').changeUsername(self.get('newUsername')).then(function () {
                DiscourseURL.redirectTo("/users/" + self.get('newUsername').toLowerCase() + "/preferences");
              }, function () {
                // error
                self.set('error', true);
                self.set('saving', false);
              });
            }
          });
        }
      }

    });
  });
define("discourse/controllers/quote-button", 
  ["discourse/lib/load-script","discourse/lib/quote","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var loadScript = __dependency1__["default"];
    var Quote = __dependency2__["default"];
    var computed = __dependency3__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['topic', 'composer'];
      }
    }, {
      key: '_loadSanitizer',
      initializer: function () {
        return (function () {
          loadScript('defer/html-sanitizer-bundle');
        }).on('init');
      }
    }, {
      key: 'post',
      decorators: [computed('buffer', 'postId')],
      value: function (buffer, postId) {
        if (!postId || Ember.isEmpty(buffer)) {
          return null;
        }

        var postStream = this.get('controllers.topic.model.postStream');
        var post = postStream.findLoadedPost(postId);

        return post;
      }
    }, {
      key: 'selectText',

      // Save the currently selected text and displays the
      //  "quote reply" button
      value: function (postId) {
        // anonymous users cannot "quote-reply"
        if (!this.currentUser) return;

        // don't display the "quote-reply" button if we can't reply
        var topicDetails = this.get('controllers.topic.model.details');
        if (!(topicDetails.get('can_reply_as_new_topic') || topicDetails.get('can_create_post'))) {
          return;
        }

        var selection = window.getSelection();

        // no selections
        if (selection.isCollapsed) {
          this.set('buffer', '');
          return;
        }

        // retrieve the selected range
        var range = selection.getRangeAt(0),
            cloned = range.cloneRange(),
            $ancestor = $(range.commonAncestorContainer);

        if ($ancestor.closest('.cooked').length === 0) {
          this.set('buffer', '');
          return;
        }

        var selectedText = Discourse.Utilities.selectedText();
        if (this.get('buffer') === selectedText) return;

        // we need to retrieve the post data from the posts collection in the topic controller
        this.set('postId', postId);
        this.set('buffer', selectedText);

        // create a marker element
        var markerElement = document.createElement("span");
        // containing a single invisible character
        markerElement.appendChild(document.createTextNode("\ufeff"));

        var isMobileDevice = this.site.isMobileDevice;
        var capabilities = this.capabilities,
            isIOS = capabilities.isIOS,
            isAndroid = capabilities.isAndroid;

        // collapse the range at the beginning/end of the selection
        range.collapse(!isMobileDevice);
        // and insert it at the start of our selection range
        range.insertNode(markerElement);

        // retrieve the position of the marker
        var markerOffset = $(markerElement).offset(),
            $quoteButton = $('.quote-button');

        // remove the marker
        markerElement.parentNode.removeChild(markerElement);

        // work around Chrome that would sometimes lose the selection
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(cloned);

        // move the quote button above the marker
        Em.run.schedule('afterRender', function () {
          var topOff = markerOffset.top;
          var leftOff = markerOffset.left;

          if (isMobileDevice || isIOS || isAndroid) {
            topOff = topOff + 20;
            leftOff = Math.min(leftOff + 10, $(window).width() - $quoteButton.outerWidth());
          } else {
            topOff = topOff - $quoteButton.outerHeight() - 5;
          }

          $quoteButton.offset({ top: topOff, left: leftOff });
        });
      }
    }, {
      key: 'quoteText',
      value: function () {
        var _this = this;

        var Composer = require('discourse/models/composer').default;
        var postId = this.get('postId');
        var post = this.get('post');

        // defer load if needed, if in an expanded replies section
        if (!post) {
          var postStream = this.get('controllers.topic.model.postStream');
          return postStream.loadPost(postId).then(function (p) {
            _this.set('post', p);
            return _this.quoteText();
          });
        }

        // If we can't create a post, delegate to reply as new topic
        if (!this.get('controllers.topic.model.details.can_create_post')) {
          this.get('controllers.topic').send('replyAsNewTopic', post);
          return;
        }

        var composerController = this.get('controllers.composer');
        var composerOpts = {
          action: Composer.REPLY,
          draftKey: post.get('topic.draft_key')
        };

        if (post.get('post_number') === 1) {
          composerOpts.topic = post.get("topic");
        } else {
          composerOpts.post = post;
        }

        // If the composer is associated with a different post, we don't change it.
        var composerPost = composerController.get('content.post');
        if (composerPost && composerPost.get('id') !== this.get('post.id')) {
          composerOpts.post = composerPost;
        }

        var buffer = this.get('buffer');
        var quotedText = Quote.build(post, buffer);
        composerOpts.quote = quotedText;
        if (composerController.get('content.viewOpen') || composerController.get('content.viewDraft')) {
          this.appEvents.trigger('composer:insert-text', quotedText);
        } else {
          composerController.open(composerOpts);
        }
        this.set('buffer', '');
        return false;
      }
    }, {
      key: 'deselectText',
      value: function () {
        // clear selected text
        window.getSelection().removeAllRanges();
        // clean up the buffer
        this.set('buffer', '');
      }
    }]));
  });
define("discourse/controllers/raw-email", 
  ["discourse/mixins/modal-functionality","discourse/models/post","admin/models/incoming-email","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];
    var Post = __dependency2__["default"];
    var IncomingEmail = __dependency3__["default"];

    // This controller handles displaying of raw email
    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      rawEmail: "",

      loadRawEmail: function (postId) {
        var _this = this;

        return Post.loadRawEmail(postId).then(function (result) {
          return _this.set("rawEmail", result.raw_email);
        });
      },

      loadIncomingRawEmail: function (incomingEmailId) {
        var _this2 = this;

        return IncomingEmail.loadRawEmail(incomingEmailId).then(function (result) {
          return _this2.set("rawEmail", result.raw_email);
        });
      }

    });
  });
define("discourse/controllers/rename-tag", 
  ["discourse/mixins/modal-functionality","discourse/mixins/buffered-content","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];
    var BufferedContent = __dependency2__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, BufferedContent, {

      renameDisabled: (function () {
        var filterRegexp = new RegExp(this.site.tags_filter_regexp, "g"),
            newId = this.get('buffered.id').replace(filterRegexp, '').trim();

        return newId.length === 0 || newId === this.get('model.id');
      }).property('buffered.id', 'id'),

      actions: {
        performRename: function () {
          var tag = this.get('model'),
              self = this;
          tag.update({ id: this.get('buffered.id') }).then(function () {
            self.send('closeModal');
            self.transitionToRoute('tags.show', tag.get('id'));
          }).catch(function () {
            self.flash(I18n.t('generic_error'), 'error');
          });
        }
      }
    });
  });
define("discourse/controllers/reorder-categories", 
  ["discourse/mixins/modal-functionality","discourse/lib/ajax-error","ember-addons/ember-computed-decorators","ember","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ModalFunctionality = __dependency1__["default"];
    // import BufferedProxy from 'ember-buffered-proxy/proxy';
    var popupAjaxError = __dependency2__.popupAjaxError;
    var on = __dependency3__.on;
    var computed = __dependency3__.default;
    var Ember = __dependency4__["default"];

    var BufferedProxy = window.BufferedProxy;var SortableArrayProxy = Ember.ArrayProxy.extend(Ember.SortableMixin);

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, Ember.Evented, _createDecoratedObject([{
      key: '_fixOrder',
      decorators: [on('init')],
      value: function () {
        this.send('fixIndices');
      }
    }, {
      key: 'categoriesBuffered',
      decorators: [computed("site.categories")],
      value: function (categories) {
        var bufProxy = Ember.ObjectProxy.extend(BufferedProxy);
        return categories.map(function (c) {
          return bufProxy.create({ content: c });
        });
      }
    }, {
      key: 'categoriesOrdered',
      initializer: function () {
        return (function () {
          return SortableArrayProxy.create({
            sortProperties: ['content.position'],
            content: this.get('categoriesBuffered')
          });
        }).property('categoriesBuffered');
      }
    }, {
      key: 'showFixIndices',
      initializer: function () {
        return (function () {
          var cats = this.get('categoriesOrdered');
          var len = cats.get('length');
          for (var i = 0; i < len; i++) {
            if (cats.objectAt(i).get('position') !== i) {
              return true;
            }
          }
          return false;
        }).property('categoriesOrdered.@each.position');
      }
    }, {
      key: 'showApplyAll',
      initializer: function () {
        return (function () {
          var anyChanged = false;
          this.get('categoriesBuffered').forEach(function (bc) {
            anyChanged = anyChanged || bc.get('hasBufferedChanges');
          });
          return anyChanged;
        }).property('categoriesBuffered.@each.hasBufferedChanges');
      }
    }, {
      key: 'saveDisabled',
      initializer: function () {
        return Ember.computed.or('showApplyAll', 'showFixIndices');
      }
    }, {
      key: 'moveDir',
      value: function (cat, dir) {
        var cats = this.get('categoriesOrdered');
        var curIdx = cats.indexOf(cat);
        var desiredIdx = curIdx + dir;
        if (desiredIdx >= 0 && desiredIdx < cats.get('length')) {
          var curPos = cat.get('position');
          cat.set('position', curPos + dir);
          var otherCat = cats.objectAt(desiredIdx);
          otherCat.set('position', curPos - dir);
          this.send('commit');
        }
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {

          moveUp: function (cat) {
            this.moveDir(cat, -1);
          },
          moveDown: function (cat) {
            this.moveDir(cat, 1);
          },

          fixIndices: function () {
            var cats = this.get('categoriesOrdered');
            var len = cats.get('length');
            for (var i = 0; i < len; i++) {
              cats.objectAt(i).set('position', i);
            }
            this.send('commit');
          },

          commit: function () {
            this.get('categoriesBuffered').forEach(function (bc) {
              if (bc.get('hasBufferedChanges')) {
                bc.applyBufferedChanges();
              }
            });
            this.propertyDidChange('categoriesBuffered');
          },

          saveOrder: function () {
            var _this = this;

            var data = {};
            this.get('categoriesBuffered').forEach(function (cat) {
              data[cat.get('id')] = cat.get('position');
            });
            Discourse.ajax('/categories/reorder', { type: 'POST', data: { mapping: JSON.stringify(data) } }).then(function () {
              return _this.send("closeModal");
            }).catch(popupAjaxError);
          }
        };
      }
    }]));
  });
define("discourse/controllers/search-help", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      needs: ['modal'],

      showGoogleSearch: (function () {
        return !Discourse.SiteSettings.login_required;
      }).property()
    });
  });
define("discourse/controllers/share", 
  ["discourse/lib/sharing","discourse/lib/formatter","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var Sharing = __dependency1__["default"];
    var longDateNoYear = __dependency2__.longDateNoYear;
    var computed = __dependency3__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['topic'];
      }
    }, {
      key: 'title',
      decorators: [computed('type', 'postNumber')],
      value: function (type, postNumber) {
        if (type === 'topic') {
          return I18n.t('share.topic');
        }
        if (postNumber) {
          return I18n.t('share.post', { postNumber: postNumber });
        } else {
          return I18n.t('share.topic');
        }
      }
    }, {
      key: 'displayDate',
      decorators: [computed('date')],
      value: function (date) {
        return longDateNoYear(new Date(date));
      }
    }, {
      key: 'actions',

      // Close the share controller
      initializer: function () {
        return {
          close: function () {
            this.setProperties({ link: '', postNumber: '' });
            return false;
          },

          share: function (source) {
            var url = source.generateUrl(this.get('link'), this.get('title'));
            if (source.shouldOpenInPopup) {
              window.open(url, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,width=600,height=' + (source.popupHeight || 315));
            } else {
              window.open(url, '_blank');
            }
          }
        };
      }
    }, {
      key: 'sources',
      decorators: [computed],
      value: function () {
        return Sharing.activeSources(this.siteSettings.share_links);
      }
    }]));
  });
define("discourse/controllers/split-topic", 
  ["discourse/mixins/selected-posts-count","discourse/mixins/modal-functionality","discourse/lib/ajax-error","discourse/models/topic","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    var SelectedPostsCount = __dependency1__["default"];
    var ModalFunctionality = __dependency2__["default"];
    var extractError = __dependency3__.extractError;
    var movePosts = __dependency4__.movePosts;
    var DiscourseURL = __dependency5__["default"];

    // Modal related to auto closing of topics
    __exports__["default"] = Ember.Controller.extend(SelectedPostsCount, ModalFunctionality, {
      needs: ['topic'],
      topicName: null,
      saving: false,
      categoryId: null,

      topicController: Em.computed.alias('controllers.topic'),
      selectedPosts: Em.computed.alias('topicController.selectedPosts'),
      selectedReplies: Em.computed.alias('topicController.selectedReplies'),
      allPostsSelected: Em.computed.alias('topicController.allPostsSelected'),

      buttonDisabled: (function () {
        if (this.get('saving')) return true;
        return Ember.isEmpty(this.get('topicName'));
      }).property('saving', 'topicName'),

      buttonTitle: (function () {
        if (this.get('saving')) return I18n.t('saving');
        return I18n.t('topic.split_topic.action');
      }).property('saving'),

      onShow: function () {
        this.setProperties({
          'controllers.modal.modalClass': 'split-modal',
          saving: false,
          categoryId: null,
          topicName: ''
        });
      },

      actions: {
        movePostsToNewTopic: function () {
          this.set('saving', true);

          var postIds = this.get('selectedPosts').map(function (p) {
            return p.get('id');
          }),
              replyPostIds = this.get('selectedReplies').map(function (p) {
            return p.get('id');
          }),
              self = this,
              categoryId = this.get('categoryId'),
              saveOpts = {
            title: this.get('topicName'),
            post_ids: postIds,
            reply_post_ids: replyPostIds
          };

          if (!Ember.isNone(categoryId)) {
            saveOpts.category_id = categoryId;
          }

          movePosts(this.get('model.id'), saveOpts).then(function (result) {
            // Posts moved
            self.send('closeModal');
            self.get('topicController').send('toggleMultiSelect');
            Ember.run.next(function () {
              DiscourseURL.routeTo(result.url);
            });
          }).catch(function (xhr) {
            self.flash(extractError(xhr, I18n.t('topic.split_topic.error')));
          }).finally(function () {
            self.set('saving', false);
          });
          return false;
        }
      }

    });
  });
define("discourse/controllers/static", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['application'];
      }
    }, {
      key: 'showLoginButton',
      initializer: function () {
        return Em.computed.equal("model.path", "login");
      }
    }, {
      key: 'showSignupButton',
      decorators: [computed("model.path")],
      value: function () {
        return this.get("model.path") === "login" && this.get('controllers.application.canSignUp');
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          markFaqRead: function () {
            var currentUser = this.currentUser;
            if (currentUser) {
              Discourse.ajax("/users/read-faq", { method: "POST" }).then(function () {
                currentUser.set('read_faq', true);
              });
            }
          }
        };
      }
    }]));
  });
define("discourse/controllers/tags-index", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      sortProperties: ['count:desc', 'id'],

      sortedTags: Ember.computed.sort('model', 'sortProperties'),

      actions: {
        sortByCount: function () {
          this.set('sortProperties', ['count:desc', 'id']);
        },

        sortById: function () {
          this.set('sortProperties', ['id']);
        }
      }
    });
  });
define("discourse/controllers/tags-show", 
  ["discourse/mixins/bulk-topic-selection","discourse/models/nav-item","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var BulkTopicSelection = __dependency1__["default"];
    var NavItem = __dependency2__.default;
    var extraNavItemProperties = __dependency2__.extraNavItemProperties;
    var customNavItemHref = __dependency2__.customNavItemHref;

    if (extraNavItemProperties) {
      extraNavItemProperties(function (text, opts) {
        if (opts && opts.tagId) {
          return { tagId: opts.tagId };
        } else {
          return {};
        }
      });
    }

    if (customNavItemHref) {
      customNavItemHref(function (navItem) {
        if (navItem.get('tagId')) {
          var name = navItem.get('name');

          if (!Discourse.Site.currentProp('filters').contains(name)) {
            return null;
          }

          var path = "/tags/",
              category = navItem.get("category");

          if (category) {
            path += "c/";
            path += Discourse.Category.slugFor(category);
            if (navItem.get('noSubcategories')) {
              path += '/none';
            }
            path += "/";
          }

          path += navItem.get('tagId') + "/l/";
          return path + name.replace(' ', '-');
        } else {
          return null;
        }
      });
    }

    __exports__["default"] = Ember.Controller.extend(BulkTopicSelection, {
      needs: ["application"],

      tag: null,
      list: null,
      canAdminTag: Ember.computed.alias("currentUser.staff"),
      filterMode: null,
      navMode: 'latest',
      loading: false,
      canCreateTopic: false,
      order: 'default',
      ascending: false,
      status: null,
      state: null,
      search: null,
      max_posts: null,
      q: null,

      queryParams: ['order', 'ascending', 'status', 'state', 'search', 'max_posts', 'q'],

      navItems: (function () {
        return NavItem.buildList(this.get('category'), { tagId: this.get('tag.id'), filterMode: this.get('filterMode') });
      }).property('category', 'tag.id', 'filterMode'),

      showTagFilter: (function () {
        return Discourse.SiteSettings.show_filter_by_tag;
      }).property('category'),

      categories: (function () {
        return Discourse.Category.list();
      }).property(),

      showAdminControls: (function () {
        return this.get('canAdminTag') && !this.get('category');
      }).property('canAdminTag', 'category'),

      loadMoreTopics: function () {
        return this.get("list").loadMore();
      },

      _showFooter: (function () {
        this.set("controllers.application.showFooter", !this.get("list.canLoadMore"));
      }).observes("list.canLoadMore"),

      footerMessage: (function () {
        if (this.get('loading') || this.get('list.topics.length') !== 0) {
          return;
        }

        if (this.get('list.topics.length') === 0) {
          return I18n.t('tagging.topics.none.' + this.get('navMode'), { tag: this.get('tag.id') });
        } else {
          return I18n.t('tagging.topics.bottom.' + this.get('navMode'), { tag: this.get('tag.id') });
        }
      }).property('navMode', 'list.topics.length', 'loading'),

      actions: {
        changeSort: function (sortBy) {
          if (sortBy === this.get('order')) {
            this.toggleProperty('ascending');
          } else {
            this.setProperties({ order: sortBy, ascending: false });
          }
          this.send('invalidateModel');
        },

        refresh: function () {
          var self = this;
          // TODO: this probably doesn't work anymore
          return this.store.findFiltered('topicList', { filter: 'tags/' + this.get('tag.id') }).then(function (list) {
            self.set("list", list);
            self.resetSelected();
          });
        },

        deleteTag: function () {
          var self = this;
          bootbox.confirm(I18n.t("tagging.delete_confirm"), function (result) {
            if (!result) {
              return;
            }

            self.get("tag").destroyRecord().then(function () {
              self.transitionToRoute("tags.index");
            }).catch(function () {
              bootbox.alert(I18n.t("generic_error"));
            });
          });
        },

        changeTagNotification: function (id) {
          var tagNotification = this.get("tagNotification");
          tagNotification.update({ notification_level: id });
        }
      }
    });
  });
define("discourse/controllers/topic-bulk-actions", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    var _buttons = [];

    function addBulkButton(action, key) {
      _buttons.push({ action: action, label: "topics.bulk." + key });
    }

    // Default buttons
    addBulkButton('showChangeCategory', 'change_category');
    addBulkButton('deleteTopics', 'delete');
    addBulkButton('closeTopics', 'close_topics');
    addBulkButton('archiveTopics', 'archive_topics');
    addBulkButton('showNotificationLevel', 'notification_level');
    addBulkButton('resetRead', 'reset_read');
    addBulkButton('unlistTopics', 'unlist_topics');
    addBulkButton('showTagTopics', 'change_tags');

    // Modal for performing bulk actions on topics
    __exports__["default"] = Ember.ArrayController.extend(ModalFunctionality, {
      tags: null,
      buttonRows: null,

      emptyTags: Ember.computed.empty('tags'),

      onShow: function () {
        this.set('controllers.modal.modalClass', 'topic-bulk-actions-modal small');

        var buttonRows = [];
        var row = [];
        _buttons.forEach(function (b) {
          row.push(b);
          if (row.length === 4) {
            buttonRows.push(row);
            row = [];
          }
        });
        if (row.length) {
          buttonRows.push(row);
        }

        this.set('buttonRows', buttonRows);
        this.send('changeBulkTemplate', 'modal/bulk_actions_buttons');
      },

      perform: function (operation) {
        var _this = this;

        this.set('loading', true);

        var topics = this.get('model');
        return Discourse.Topic.bulkOperation(this.get('model'), operation).then(function (result) {
          _this.set('loading', false);
          if (result && result.topic_ids) {
            return result.topic_ids.map(function (t) {
              return topics.findBy('id', t);
            });
          }
          return result;
        }).catch(function () {
          bootbox.alert(I18n.t('generic_error'));
          _this.set('loading', false);
        });
      },

      forEachPerformed: function (operation, cb) {
        var _this2 = this;

        this.perform(operation).then(function (topics) {
          if (topics) {
            topics.forEach(cb);
            (_this2.get('refreshClosure') || Ember.k)();
            _this2.send('closeModal');
          }
        });
      },

      performAndRefresh: function (operation) {
        var _this3 = this;

        return this.perform(operation).then(function () {
          (_this3.get('refreshClosure') || Ember.k)();
          _this3.send('closeModal');
        });
      },

      actions: {
        showTagTopics: function () {
          this.set('tags', '');
          this.send('changeBulkTemplate', 'bulk-tag');
        },

        changeTags: function () {
          this.performAndRefresh({ type: 'change_tags', tags: this.get('tags') });
        },

        showChangeCategory: function () {
          this.send('changeBulkTemplate', 'modal/bulk_change_category');
          this.set('controllers.modal.modalClass', 'topic-bulk-actions-modal full');
        },

        showNotificationLevel: function () {
          this.send('changeBulkTemplate', 'modal/bulk_notification_level');
        },

        deleteTopics: function () {
          this.performAndRefresh({ type: 'delete' });
        },

        closeTopics: function () {
          this.forEachPerformed({ type: 'close' }, function (t) {
            return t.set('closed', true);
          });
        },

        archiveTopics: function () {
          this.forEachPerformed({ type: 'archive' }, function (t) {
            return t.set('archived', true);
          });
        },

        unlistTopics: function () {
          this.forEachPerformed({ type: 'unlist' }, function (t) {
            return t.set('visible', false);
          });
        },

        changeCategory: function () {
          var _this4 = this;

          var categoryId = parseInt(this.get('newCategoryId'), 10) || 0;
          var category = Discourse.Category.findById(categoryId);

          this.perform({ type: 'change_category', category_id: categoryId }).then(function (topics) {
            topics.forEach(function (t) {
              return t.set('category', category);
            });
            (_this4.get('refreshClosure') || Ember.k)();
            _this4.send('closeModal');
          });
        },

        resetRead: function () {
          this.performAndRefresh({ type: 'reset_read' });
        }
      }
    });

    __exports__.addBulkButton = addBulkButton;
  });
define("discourse/controllers/topic-entrance", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    function entranceDate(dt, showTime) {
      var today = new Date();

      if (dt.toDateString() === today.toDateString()) {
        return moment(dt).format(I18n.t("dates.time"));
      }

      if (dt.getYear() === today.getYear()) {
        // No year
        return moment(dt).format(showTime ? I18n.t("dates.long_date_without_year_with_linebreak") : I18n.t("dates.long_no_year_no_time"));
      }

      return moment(dt).format(showTime ? I18n.t('dates.long_date_with_year_with_linebreak') : I18n.t('dates.long_date_with_year_without_time'));
    }

    __exports__["default"] = Ember.Controller.extend({
      position: null,

      createdDate: (function () {
        return new Date(this.get('model.created_at'));
      }).property('model.created_at'),

      bumpedDate: (function () {
        return new Date(this.get('model.bumped_at'));
      }).property('model.bumped_at'),

      showTime: (function () {
        var diffMs = this.get('bumpedDate').getTime() - this.get('createdDate').getTime();
        return diffMs < 1000 * 60 * 60 * 24 * 2;
      }).property('createdDate', 'bumpedDate'),

      topDate: (function () {
        return entranceDate(this.get('createdDate'), this.get('showTime'));
      }).property('createdDate'),

      bottomDate: (function () {
        return entranceDate(this.get('bumpedDate'), this.get('showTime'));
      }).property('bumpedDate'),

      actions: {
        show: function (data) {
          // Show the chooser but only if the model changes
          if (this.get('model') !== data.topic) {
            this.set('model', data.topic);
            this.set('position', data.position);
          }
        },

        enterTop: function () {
          DiscourseURL.routeTo(this.get('model.url'));
        },

        enterBottom: function () {
          DiscourseURL.routeTo(this.get('model.lastPostUrl'));
        }
      }
    });
  });
define("discourse/controllers/topic-progress", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend({
      needs: ['topic'],
      progressPosition: null,
      expanded: false,
      toPostIndex: null,

      actions: {
        toggleExpansion: function (opts) {
          this.toggleProperty('expanded');
          if (this.get('expanded')) {
            this.set('toPostIndex', this.get('progressPosition'));
            if (opts && opts.highlight) {
              // TODO: somehow move to view?
              Em.run.next(function () {
                $('.jump-form input').select().focus();
              });
            }
          }
        },

        jumpPost: function () {
          var postIndex = parseInt(this.get('toPostIndex'), 10);

          // Validate the post index first
          if (isNaN(postIndex) || postIndex < 1) {
            postIndex = 1;
          }
          if (postIndex > this.get('model.postStream.filteredPostsCount')) {
            postIndex = this.get('model.postStream.filteredPostsCount');
          }
          this.set('toPostIndex', postIndex);
          var stream = this.get('model.postStream'),
              postId = stream.findPostIdForPostNumber(postIndex);

          if (!postId) {
            Em.Logger.warn("jump-post code broken - requested an index outside the stream array");
            return;
          }

          var post = stream.findLoadedPost(postId);
          if (post) {
            this.jumpTo(this.get('model').urlForPostNumber(post.get('post_number')));
          } else {
            var self = this;
            // need to load it
            stream.findPostsByIds([postId]).then(function (arr) {
              post = arr[0];
              self.jumpTo(self.get('model').urlForPostNumber(post.get('post_number')));
            });
          }
        },

        jumpTop: function () {
          this.jumpTo(this.get('model.firstPostUrl'));
        },

        jumpBottom: function () {
          this.jumpTo(this.get('model.lastPostUrl'));
        }
      },

      // Route and close the expansion
      jumpTo: function (url) {
        this.set('expanded', false);
        DiscourseURL.routeTo(url);
      },

      streamPercentage: (function () {
        if (!this.get('model.postStream.loaded')) {
          return 0;
        }
        if (this.get('model.postStream.highest_post_number') === 0) {
          return 0;
        }
        var perc = this.get('progressPosition') / this.get('model.postStream.filteredPostsCount');
        return perc > 1.0 ? 1.0 : perc;
      }).property('model.postStream.loaded', 'progressPosition', 'model.postStream.filteredPostsCount'),

      jumpTopDisabled: (function () {
        return this.get('progressPosition') <= 3;
      }).property('progressPosition'),

      filteredPostCountChanged: (function () {
        if (this.get('model.postStream.filteredPostsCount') < this.get('progressPosition')) {
          this.set('progressPosition', this.get('model.postStream.filteredPostsCount'));
        }
      }).observes('model.postStream.filteredPostsCount'),

      jumpBottomDisabled: (function () {
        return this.get('progressPosition') >= this.get('model.postStream.filteredPostsCount') || this.get('progressPosition') >= this.get('model.highest_post_number');
      }).property('model.postStream.filteredPostsCount', 'model.highest_post_number', 'progressPosition'),

      hideProgress: (function () {
        if (!this.get('model.postStream.loaded')) return true;
        if (!this.get('model.currentPost')) return true;
        if (this.get('model.postStream.filteredPostsCount') < 2) return true;
        return false;
      }).property('model.postStream.loaded', 'model.currentPost', 'model.postStream.filteredPostsCount'),

      hugeNumberOfPosts: (function () {
        return this.get('model.postStream.filteredPostsCount') >= Discourse.SiteSettings.short_progress_text_threshold;
      }).property('model.highest_post_number'),

      jumpToBottomTitle: (function () {
        if (this.get('hugeNumberOfPosts')) {
          return I18n.t('topic.progress.jump_bottom_with_number', { post_number: this.get('model.highest_post_number') });
        } else {
          return I18n.t('topic.progress.jump_bottom');
        }
      }).property('hugeNumberOfPosts', 'model.highest_post_number')

    });
  });
define("discourse/controllers/topic-unsubscribe", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({

      stopNotificiationsText: (function () {
        return I18n.t("topic.unsubscribe.stop_notifications", { title: this.get("model.fancyTitle") });
      }).property("model.fancyTitle")

    });
  });
define("discourse/controllers/topic", 
  ["discourse/mixins/buffered-content","discourse/mixins/selected-posts-count","discourse/helpers/loading-spinner","discourse/models/topic","discourse/lib/quote","discourse/lib/ajax-error","ember-addons/ember-computed-decorators","discourse/models/composer","discourse/lib/url","discourse/helpers/category-link","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __dependency9__, __dependency10__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var BufferedContent = __dependency1__["default"];
    var SelectedPostsCount = __dependency2__["default"];
    var spinnerHTML = __dependency3__.spinnerHTML;
    var Topic = __dependency4__["default"];
    var Quote = __dependency5__["default"];
    var popupAjaxError = __dependency6__.popupAjaxError;
    var computed = __dependency7__["default"];
    var Composer = __dependency8__["default"];
    var DiscourseURL = __dependency9__["default"];
    var categoryBadgeHTML = __dependency10__.categoryBadgeHTML;

    __exports__["default"] = Ember.Controller.extend(SelectedPostsCount, BufferedContent, _createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['modal', 'composer', 'quote-button', 'topic-progress', 'application'];
      }
    }, {
      key: 'multiSelect',
      initializer: function () {
        return false;
      }
    }, {
      key: 'allPostsSelected',
      initializer: function () {
        return false;
      }
    }, {
      key: 'editingTopic',
      initializer: function () {
        return false;
      }
    }, {
      key: 'selectedPosts',
      initializer: function () {
        return null;
      }
    }, {
      key: 'selectedReplies',
      initializer: function () {
        return null;
      }
    }, {
      key: 'queryParams',
      initializer: function () {
        return ['filter', 'username_filters', 'show_deleted'];
      }
    }, {
      key: 'loadedAllPosts',
      initializer: function () {
        return Em.computed.or('model.postStream.loadedAllPosts', 'model.postStream.loadingLastPost');
      }
    }, {
      key: 'enteredAt',
      initializer: function () {
        return null;
      }
    }, {
      key: 'retrying',
      initializer: function () {
        return false;
      }
    }, {
      key: 'adminMenuVisible',
      initializer: function () {
        return false;
      }
    }, {
      key: 'showRecover',
      initializer: function () {
        return Em.computed.and('model.deleted', 'model.details.can_recover');
      }
    }, {
      key: 'isFeatured',
      initializer: function () {
        return Em.computed.or("model.pinned_at", "model.isBanner");
      }
    }, {
      key: '_titleChanged',
      initializer: function () {
        return (function () {
          var title = this.get('model.title');
          if (!Ember.isEmpty(title)) {

            // Note normally you don't have to trigger this, but topic titles can be updated
            // and are sometimes lazily loaded.
            this.send('refreshTitle');
          }
        }).observes('model.title', 'category');
      }
    }, {
      key: 'showSelectedPostsAtBottom',
      decorators: [computed('site.mobileView', 'model.posts_count')],
      value: function (mobileView, postsCount) {
        return mobileView && postsCount > 3;
      }
    }, {
      key: 'postsToRender',
      decorators: [computed('model.postStream.posts')],
      value: function () {
        return this.capabilities.isAndroid ? this.get('model.postStream.posts') : this.get('model.postStream.postsWithPlaceholders');
      }
    }, {
      key: 'androidLoading',
      decorators: [computed('model.postStream.loadingFilter')],
      value: function (loading) {
        return this.capabilities.isAndroid && loading;
      }
    }, {
      key: 'show_deleted',
      decorators: [computed('model.postStream.summary')],
      initializer: function () {
        return {
          set: function (value) {
            var postStream = this.get('model.postStream');
            if (!postStream) {
              return;
            }
            postStream.set('show_deleted', value);
            return postStream.get('show_deleted') ? true : undefined;
          },
          get: function () {
            return this.get('postStream.show_deleted') ? true : undefined;
          }
        };
      }
    }, {
      key: 'filter',
      decorators: [computed('model.postStream.summary')],
      initializer: function () {
        return {
          set: function (value) {
            var postStream = this.get('model.postStream');
            if (!postStream) {
              return;
            }
            postStream.set('summary', value === "summary");
            return postStream.get('summary') ? "summary" : undefined;
          },
          get: function () {
            return this.get('postStream.summary') ? "summary" : undefined;
          }
        };
      }
    }, {
      key: 'browseMoreMessage',
      decorators: [computed('model', 'topicTrackingState.messageCount')],
      value: function (model) {

        // TODO decide what to show for pms
        if (model.get('isPrivateMessage')) {
          return;
        }

        var opts = { latestLink: '<a href="' + Discourse.getURL("/latest") + '">' + I18n.t("topic.view_latest_topics") + '</a>' };
        var category = model.get('category');

        if (category && Em.get(category, 'id') === Discourse.Site.currentProp("uncategorized_category_id")) {
          category = null;
        }

        if (category) {
          opts.catLink = categoryBadgeHTML(category);
        } else {
          opts.catLink = "<a href=\"" + Discourse.getURL("/categories") + "\">" + I18n.t("topic.browse_all_categories") + "</a>";
        }

        var unreadTopics = this.topicTrackingState.countUnread();
        var newTopics = this.topicTrackingState.countNew();

        if (newTopics + unreadTopics > 0) {
          var hasBoth = unreadTopics > 0 && newTopics > 0;

          return I18n.messageFormat("topic.read_more_MF", {
            "BOTH": hasBoth,
            "UNREAD": unreadTopics,
            "NEW": newTopics,
            "CATEGORY": category ? true : false,
            latestLink: opts.latestLink,
            catLink: opts.catLink
          });
        } else if (category) {
          return I18n.t("topic.read_more_in_category", opts);
        } else {
          return I18n.t("topic.read_more", opts);
        }
      }
    }, {
      key: 'pmPath',
      decorators: [computed('model')],
      value: function (model) {
        return this.currentUser && this.currentUser.pmPath(model);
      }
    }, {
      key: 'suggestedTitle',
      decorators: [computed('model')],
      value: function (model) {
        return model.get('isPrivateMessage') ? '<i class=\'private-message-glyph fa fa-envelope\'></i> ' + I18n.t("suggested_topics.pm_title") : I18n.t("suggested_topics.title");
      }
    }, {
      key: 'username_filters',
      decorators: [computed('model.postStream.streamFilters.username_filters')],
      initializer: function () {
        return {
          set: function (value) {
            var postStream = this.get('model.postStream');
            if (!postStream) {
              return;
            }
            postStream.set('streamFilters.username_filters', value);
            return postStream.get('streamFilters.username_filters');
          },
          get: function () {
            return this.get('postStream.streamFilters.username_filters');
          }
        };
      }
    }, {
      key: '_clearSelected',
      initializer: function () {
        return (function () {
          this.set('selectedPosts', []);
          this.set('selectedReplies', []);
        }).on('init');
      }
    }, {
      key: 'showCategoryChooser',
      initializer: function () {
        return Ember.computed.not("model.isPrivateMessage");
      }
    }, {
      key: 'gotoInbox',
      value: function (name) {
        var url = '/users/' + this.get('currentUser.username_lower') + '/messages';
        if (name) {
          url = url + '/group/' + name;
        }
        DiscourseURL.routeTo(url);
      }
    }, {
      key: 'selectedQuery',
      initializer: function () {
        return (function () {
          var _this = this;

          return function (post) {
            return _this.postSelected(post);
          };
        }).property();
      }
    }, {
      key: 'canEditTags',
      decorators: [computed('model.isPrivateMessage')],
      value: function (isPrivateMessage) {
        return !isPrivateMessage && this.site.get('can_tag_topics');
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {

          fillGapBefore: function (args) {
            return this.get('model.postStream').fillGapBefore(args.post, args.gap);
          },

          fillGapAfter: function (args) {
            return this.get('model.postStream').fillGapAfter(args.post, args.gap);
          },

          // Called the the topmost visible post on the page changes.
          topVisibleChanged: function (event) {
            var post = event.post;
            var refresh = event.refresh;

            if (!post) {
              return;
            }

            var postStream = this.get('model.postStream');
            var firstLoadedPost = postStream.get('posts.firstObject');

            var currentPostNumber = post.get('post_number');
            this.set('model.currentPost', currentPostNumber);
            this.send('postChangedRoute', currentPostNumber);

            if (post.get('post_number') === 1) {
              return;
            }

            if (firstLoadedPost && firstLoadedPost === post) {
              postStream.prependMore().then(function () {
                return refresh();
              });
            }
          },

          //  Called the the bottommost visible post on the page changes.
          bottomVisibleChanged: function (event) {
            var post = event.post;
            var refresh = event.refresh;

            var postStream = this.get('model.postStream');
            var lastLoadedPost = postStream.get('posts.lastObject');

            this.set('controllers.topic-progress.progressPosition', postStream.progressIndexOfPost(post));

            if (lastLoadedPost && lastLoadedPost === post && postStream.get('canAppendMore')) {
              postStream.appendMore().then(function () {
                return refresh();
              });
              // show loading stuff
              refresh();
            }
          },

          toggleSummary: function () {
            return this.get('model.postStream').toggleSummary();
          },

          removeAllowedUser: function (user) {
            return this.get('model.details').removeAllowedUser(user);
          },

          showTopicAdminMenu: function () {
            this.set('adminMenuVisible', true);
          },

          hideTopicAdminMenu: function () {
            this.set('adminMenuVisible', false);
          },

          deleteTopic: function () {
            this.deleteTopic();
          },

          archiveMessage: function () {
            var _this2 = this;

            var topic = this.get('model');
            topic.archiveMessage().then(function () {
              _this2.gotoInbox(topic.get("inboxGroupName"));
            });
          },

          moveToInbox: function () {
            var _this3 = this;

            var topic = this.get('model');
            topic.moveToInbox().then(function () {
              _this3.gotoInbox(topic.get("inboxGroupName"));
            });
          },

          // Post related methods
          replyToPost: function (post) {
            var composerController = this.get('controllers.composer'),
                quoteController = this.get('controllers.quote-button'),
                quotedText = Quote.build(quoteController.get('post'), quoteController.get('buffer')),
                topic = post ? post.get('topic') : this.get('model');

            quoteController.set('buffer', '');

            if (composerController.get('content.topic.id') === topic.get('id') && composerController.get('content.action') === Composer.REPLY) {
              composerController.set('content.post', post);
              composerController.set('content.composeState', Composer.OPEN);
              this.appEvents.trigger('composer:insert-text', quotedText.trim());
            } else {

              var opts = {
                action: Composer.REPLY,
                draftKey: topic.get('draft_key'),
                draftSequence: topic.get('draft_sequence')
              };

              if (quotedText) {
                opts.quote = quotedText;
              }

              if (post && post.get("post_number") !== 1) {
                opts.post = post;
              } else {
                opts.topic = topic;
              }

              composerController.open(opts);
            }
            return false;
          },

          recoverPost: function (post) {
            // Recovering the first post recovers the topic instead
            if (post.get('post_number') === 1) {
              this.recoverTopic();
              return;
            }
            post.recover();
          },

          deletePost: function (post) {
            var _this4 = this;

            // Deleting the first post deletes the topic
            if (post.get('post_number') === 1) {
              return this.deleteTopic();
            } else if (!post.can_delete) {
              // check if current user can delete post
              return false;
            }

            var user = Discourse.User.current(),
                replyCount = post.get('reply_count'),
                self = this;

            // If the user is staff and the post has replies, ask if they want to delete replies too.
            if (user.get('staff') && replyCount > 0) {
              bootbox.dialog(I18n.t("post.controls.delete_replies.confirm", { count: replyCount }), [{ label: I18n.t("cancel"),
                'class': 'btn-danger right' }, { label: I18n.t("post.controls.delete_replies.no_value"),
                callback: function () {
                  post.destroy(user);
                }
              }, { label: I18n.t("post.controls.delete_replies.yes_value"),
                'class': 'btn-primary',
                callback: function () {
                  Discourse.Post.deleteMany([post], [post]);
                  self.get('model.postStream.posts').forEach(function (p) {
                    if (p === post || p.get('reply_to_post_number') === post.get('post_number')) {
                      p.setDeletedState(user);
                    }
                  });
                }
              }]);
            } else {
              return post.destroy(user).then(function () {
                _this4.appEvents.trigger('post-stream:refresh');
              }).catch(function (error) {
                popupAjaxError(error);
                post.undoDeleteState();
              });
            }
          },

          editPost: function (post) {
            if (!Discourse.User.current()) {
              return bootbox.alert(I18n.t('post.controls.edit_anonymous'));
            }

            // check if current user can edit post
            if (!post.can_edit) {
              return false;
            }

            var composer = this.get('controllers.composer'),
                composerModel = composer.get('model'),
                opts = {
              post: post,
              action: Composer.EDIT,
              draftKey: post.get('topic.draft_key'),
              draftSequence: post.get('topic.draft_sequence')
            };

            // Cancel and reopen the composer for the first post
            if (composerModel && (post.get('firstPost') || composerModel.get('editingFirstPost'))) {
              composer.cancelComposer().then(function () {
                return composer.open(opts);
              });
            } else {
              composer.open(opts);
            }
          },

          toggleBookmark: function (post) {
            var _this5 = this;

            if (!this.currentUser) {
              alert(I18n.t("bookmarks.not_bookmarked"));
              return;
            }
            if (post) {
              return post.toggleBookmark().catch(popupAjaxError);
            } else {
              return this.get("model").toggleBookmark().then(function (changedIds) {
                if (!changedIds) {
                  return;
                }
                changedIds.forEach(function (id) {
                  return _this5.appEvents.trigger('post-stream:refresh', { id: id });
                });
              });
            }
          },

          jumpTop: function () {
            this.get('controllers.topic-progress').send('jumpTop');
          },

          selectAll: function () {
            var posts = this.get('model.postStream.posts');
            var selectedPosts = this.get('selectedPosts');
            if (posts) {
              selectedPosts.addObjects(posts);
            }
            this.set('allPostsSelected', true);
            this.appEvents.trigger('post-stream:refresh', { force: true });
          },

          deselectAll: function () {
            this.get('selectedPosts').clear();
            this.get('selectedReplies').clear();
            this.set('allPostsSelected', false);
            this.appEvents.trigger('post-stream:refresh', { force: true });
          },

          toggleParticipant: function (user) {
            this.get('model.postStream').toggleParticipant(Em.get(user, 'username'));
          },

          editTopic: function () {
            if (!this.get('model.details.can_edit')) return false;

            this.set('editingTopic', true);
            return false;
          },

          cancelEditingTopic: function () {
            this.set('editingTopic', false);
            this.rollbackBuffer();
          },

          toggleMultiSelect: function () {
            this.toggleProperty('multiSelect');
            this.appEvents.trigger('post-stream:refresh', { force: true });
          },

          finishedEditingTopic: function () {
            if (!this.get('editingTopic')) {
              return;
            }

            // save the modifications
            var self = this,
                props = this.get('buffered.buffer');

            Topic.update(this.get('model'), props).then(function () {
              // Note we roll back on success here because `update` saves
              // the properties to the topic.
              self.rollbackBuffer();
              self.set('editingTopic', false);
            }).catch(popupAjaxError);
          },

          toggledSelectedPost: function (post) {
            this.performTogglePost(post);
          },

          toggledSelectedPostReplies: function (post) {
            var selectedReplies = this.get('selectedReplies');
            if (this.performTogglePost(post)) {
              selectedReplies.addObject(post);
            } else {
              selectedReplies.removeObject(post);
            }
          },

          deleteSelected: function () {
            var _this6 = this;

            bootbox.confirm(I18n.t("post.delete.confirm", { count: this.get('selectedPostsCount') }), function (result) {
              if (result) {

                // If all posts are selected, it's the same thing as deleting the topic
                if (_this6.get('allPostsSelected')) {
                  return _this6.deleteTopic();
                }

                var selectedPosts = _this6.get('selectedPosts');
                var selectedReplies = _this6.get('selectedReplies');
                var postStream = _this6.get('model.postStream');

                Discourse.Post.deleteMany(selectedPosts, selectedReplies);
                postStream.get('posts').forEach(function (p) {
                  if (_this6.postSelected(p)) {
                    p.set('deleted_at', new Date());
                  }
                });

                _this6.send('toggleMultiSelect');
              }
            });
          },

          expandHidden: function (post) {
            post.expandHidden();
          },

          toggleVisibility: function () {
            this.get('content').toggleStatus('visible');
          },

          toggleClosed: function () {
            this.get('content').toggleStatus('closed');
          },

          recoverTopic: function () {
            this.get('content').recover();
          },

          makeBanner: function () {
            this.get('content').makeBanner();
          },

          removeBanner: function () {
            this.get('content').removeBanner();
          },

          togglePinned: function () {
            var value = this.get('model.pinned_at') ? false : true,
                topic = this.get('content'),
                until = this.get('model.pinnedInCategoryUntil');

            // optimistic update
            topic.setProperties({
              pinned_at: value ? moment() : null,
              pinned_globally: false,
              pinned_until: value ? until : null
            });

            return topic.saveStatus("pinned", value, until);
          },

          pinGlobally: function () {
            var topic = this.get('content'),
                until = this.get('model.pinnedGloballyUntil');

            // optimistic update
            topic.setProperties({
              pinned_at: moment(),
              pinned_globally: true,
              pinned_until: until
            });

            return topic.saveStatus("pinned_globally", true, until);
          },

          toggleArchived: function () {
            this.get('content').toggleStatus('archived');
          },

          clearPin: function () {
            this.get('content').clearPin();
          },

          togglePinnedForUser: function () {
            if (this.get('model.pinned_at')) {
              var topic = this.get('content');
              if (topic.get('pinned')) {
                topic.clearPin();
              } else {
                topic.rePin();
              }
            }
          },

          replyAsNewTopic: function (post) {
            var composerController = this.get('controllers.composer'),
                quoteController = this.get('controllers.quote-button'),
                quotedText = Quote.build(quoteController.get('post'), quoteController.get('buffer')),
                self = this;

            quoteController.deselectText();

            composerController.open({
              action: Composer.CREATE_TOPIC,
              draftKey: Composer.REPLY_AS_NEW_TOPIC_KEY,
              categoryId: this.get('model.category.id')
            }).then(function () {
              return Em.isEmpty(quotedText) ? "" : quotedText;
            }).then(function (q) {
              var postUrl = location.protocol + '//' + location.host + post.get('url');
              var postLink = '[' + Handlebars.escapeExpression(self.get('model.title')) + '](' + postUrl + ')';
              composerController.get('model').prependText(I18n.t("post.continue_discussion", { postLink: postLink }) + '\n\n' + q, { new_line: true });
            });
          },

          retryLoading: function () {
            var self = this;
            self.set('retrying', true);
            this.get('model.postStream').refresh().then(function () {
              self.set('retrying', false);
            }, function () {
              self.set('retrying', false);
            });
          },

          toggleWiki: function (post) {
            return post.updatePostField('wiki', !post.get('wiki'));
          },

          togglePostType: function (post) {
            var regular = this.site.get('post_types.regular');
            var moderator = this.site.get('post_types.moderator_action');

            return post.updatePostField('post_type', post.get('post_type') === moderator ? regular : moderator);
          },

          rebakePost: function (post) {
            return post.rebake();
          },

          unhidePost: function (post) {
            return post.unhide();
          },

          changePostOwner: function (post) {
            this.get('selectedPosts').addObject(post);
            this.send('changeOwner');
          },

          convertToPublicTopic: function () {
            this.get('content').convertTopic("public");
          },

          convertToPrivateMessage: function () {
            this.get('content').convertTopic("private");
          }
        };
      }
    }, {
      key: 'togglePinnedState',
      value: function () {
        this.send('togglePinnedForUser');
      }
    }, {
      key: 'canMergeTopic',
      initializer: function () {
        return (function () {
          if (!this.get('model.details.can_move_posts')) return false;
          return this.get('selectedPostsCount') > 0;
        }).property('selectedPostsCount');
      }
    }, {
      key: 'canSplitTopic',
      initializer: function () {
        return (function () {
          if (!this.get('model.details.can_move_posts')) return false;
          if (this.get('allPostsSelected')) return false;
          return this.get('selectedPostsCount') > 0;
        }).property('selectedPostsCount');
      }
    }, {
      key: 'canChangeOwner',
      initializer: function () {
        return (function () {
          if (!Discourse.User.current() || !Discourse.User.current().admin) return false;
          return this.get('selectedPostsUsername') !== undefined;
        }).property('selectedPostsUsername');
      }
    }, {
      key: 'categories',
      initializer: function () {
        return (function () {
          return Discourse.Category.list();
        }).property();
      }
    }, {
      key: 'canSelectAll',
      initializer: function () {
        return Em.computed.not('allPostsSelected');
      }
    }, {
      key: 'canDeselectAll',
      initializer: function () {
        return (function () {
          if (this.get('selectedPostsCount') > 0) return true;
          if (this.get('allPostsSelected')) return true;
        }).property('selectedPostsCount', 'allPostsSelected');
      }
    }, {
      key: 'canDeleteSelected',
      initializer: function () {
        return (function () {
          var selectedPosts = this.get('selectedPosts');

          if (this.get('allPostsSelected')) return true;
          if (this.get('selectedPostsCount') === 0) return false;

          var canDelete = true;
          selectedPosts.forEach(function (p) {
            if (!p.get('can_delete')) {
              canDelete = false;
              return false;
            }
          });
          return canDelete;
        }).property('selectedPostsCount');
      }
    }, {
      key: 'hasError',
      initializer: function () {
        return Ember.computed.or('model.notFoundHtml', 'model.message');
      }
    }, {
      key: 'noErrorYet',
      initializer: function () {
        return Ember.computed.not('hasError');
      }
    }, {
      key: 'multiSelectChanged',
      initializer: function () {
        return (function () {
          // Deselect all posts when multi select is turned off
          if (!this.get('multiSelect')) {
            this.send('deselectAll');
          }
        }).observes('multiSelect');
      }
    }, {
      key: 'deselectPost',
      value: function (post) {
        this.get('selectedPosts').removeObject(post);

        var selectedReplies = this.get('selectedReplies');
        selectedReplies.removeObject(post);

        var selectedReply = selectedReplies.findProperty('post_number', post.get('reply_to_post_number'));
        if (selectedReply) {
          selectedReplies.removeObject(selectedReply);
        }

        this.set('allPostsSelected', false);
      }
    }, {
      key: 'postSelected',
      value: function (post) {
        if (this.get('allPostsSelected')) {
          return true;
        }
        if (this.get('selectedPosts').contains(post)) {
          return true;
        }
        if (this.get('selectedReplies').findProperty('post_number', post.get('reply_to_post_number'))) {
          return true;
        }

        return false;
      }
    }, {
      key: 'loadingHTML',
      initializer: function () {
        return (function () {
          return spinnerHTML;
        }).property();
      }
    }, {
      key: 'recoverTopic',
      value: function () {
        this.get('content').recover();
      }
    }, {
      key: 'deleteTopic',
      value: function () {
        this.unsubscribe();
        this.get('content').destroy(Discourse.User.current());
      }
    }, {
      key: 'subscribe',

      // Receive notifications for this topic
      value: function () {
        var _this7 = this;

        // Unsubscribe before subscribing again
        this.unsubscribe();

        var refresh = function (args) {
          return _this7.appEvents.trigger('post-stream:refresh', args);
        };

        this.messageBus.subscribe("/topic/" + this.get('model.id'), function (data) {
          var topic = _this7.get('model');

          if (data.notification_level_change) {
            topic.set('details.notification_level', data.notification_level_change);
            topic.set('details.notifications_reason_id', data.notifications_reason_id);
            return;
          }

          var postStream = _this7.get('model.postStream');
          switch (data.type) {
            case "acted":
              postStream.triggerChangedPost(data.id, data.updated_at).then(function () {
                return refresh({ id: data.id, refreshLikes: true });
              });
              break;
            case "revised":
            case "rebaked":
              {
                postStream.triggerChangedPost(data.id, data.updated_at).then(function () {
                  return refresh({ id: data.id });
                });
                break;
              }
            case "deleted":
              {
                postStream.triggerDeletedPost(data.id, data.post_number).then(function () {
                  return refresh({ id: data.id });
                });
                break;
              }
            case "recovered":
              {
                postStream.triggerRecoveredPost(data.id, data.post_number).then(function () {
                  return refresh({ id: data.id });
                });
                break;
              }
            case "created":
              {
                postStream.triggerNewPostInStream(data.id).then(function () {
                  return refresh();
                });
                if (_this7.get('currentUser.id') !== data.user_id) {
                  Discourse.notifyBackgroundCountIncrement();
                }
                break;
              }
            case "move_to_inbox":
              {
                topic.set("message_archived", false);
                break;
              }
            case "archived":
              {
                topic.set("message_archived", true);
                break;
              }
            default:
              {
                Em.Logger.warn("unknown topic bus message type", data);
              }
          }

          if (data.reload_topic) {
            topic.reload().then(function () {
              _this7.send('postChangedRoute', topic.get('post_number') || 1);
            });
          }
        });
      }
    }, {
      key: 'unsubscribe',
      value: function () {
        var topicId = this.get('content.id');
        if (!topicId) return;

        // there is a condition where the view never calls unsubscribe, navigate to a topic from a topic
        this.messageBus.unsubscribe('/topic/*');
      }
    }, {
      key: 'reply',

      // Topic related
      value: function () {
        this.replyToPost();
      }
    }, {
      key: 'performTogglePost',
      value: function (post) {
        var selectedPosts = this.get('selectedPosts');
        if (this.postSelected(post)) {
          this.deselectPost(post);
          return false;
        } else {
          selectedPosts.addObject(post);
          // If the user manually selects all posts, all posts are selected
          this.set('allPostsSelected', selectedPosts.length === this.get('model.posts_count'));
          return true;
        }
      }
    }, {
      key: 'readPosts',
      value: function (topicId, postNumbers) {
        var _this8 = this;

        var topic = this.get("model");
        var postStream = topic.get("postStream");

        if (topic.get('id') === topicId) {

          // TODO identity map for postNumber
          postStream.get('posts').forEach(function (post) {
            if (!post.read && postNumbers.indexOf(post.post_number) !== -1) {
              post.set('read', true);
              _this8.appEvents.trigger('post-stream:refresh', { id: post.id });
            }
          });

          var max = _.max(postNumbers);
          if (max > topic.get("last_read_post_number")) {
            topic.set("last_read_post_number", max);
          }

          if (this.siteSettings.automatically_unpin_topics && this.currentUser && this.currentUser.automatically_unpin_topics) {
            // automatically unpin topics when the user reaches the bottom
            if (topic.get("pinned") && max >= topic.get("highest_post_number")) {
              Em.run.next(function () {
                return topic.clearPin();
              });
            }
          }
        }
      }
    }, {
      key: '_showFooter',
      initializer: function () {
        return (function () {
          var showFooter = this.get("model.postStream.loaded") && this.get("model.postStream.loadedAllPosts");
          this.set("controllers.application.showFooter", showFooter);
        }).observes("model.postStream.{loaded,loadedAllPosts}");
      }
    }]));
  });
define("discourse/controllers/upload-customization", 
  ["discourse/mixins/modal-functionality","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      notReady: Em.computed.not('ready'),
      needs: ['adminCustomizeCssHtml'],

      ready: (function () {
        try {
          var parsed = JSON.parse(this.get('customizationFile'));
          return !!parsed["site_customization"];
        } catch (e) {
          return false;
        }
      }).property('customizationFile'),

      actions: {
        createCustomization: function () {
          var object = JSON.parse(this.get('customizationFile')).site_customization;

          // Slight fixup before creating object
          object.enabled = false;
          delete object.id;
          delete object.key;

          var controller = this.get('controllers.adminCustomizeCssHtml');
          controller.send('newCustomization', object);
        }
      }

    });
  });
define("discourse/controllers/upload-selector", 
  ["discourse/mixins/modal-functionality","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    __exports__.uploadTranslate = uploadTranslate;

    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ModalFunctionality = __dependency1__["default"];
    var computed = __dependency2__.default;

    function uploadTranslate(key, options) {
      options = options || {};
      if (Discourse.Utilities.allowsAttachments()) {
        key += "_with_attachments";
      }
      return I18n.t('upload_selector.' + key, options);
    }

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, _createDecoratedObject([{
      key: 'showMore',
      initializer: function () {
        return false;
      }
    }, {
      key: 'local',
      initializer: function () {
        return true;
      }
    }, {
      key: 'imageUrl',
      initializer: function () {
        return null;
      }
    }, {
      key: 'imageLink',
      initializer: function () {
        return null;
      }
    }, {
      key: 'remote',
      initializer: function () {
        return Ember.computed.not("local");
      }
    }, {
      key: 'uploadIcon',
      decorators: [computed],
      value: function () {
        return Discourse.Utilities.allowsAttachments() ? "upload" : "picture-o";
      }
    }, {
      key: 'tip',
      decorators: [computed('controller.local')],
      value: function (local) {
        var source = local ? "local" : "remote";
        var authorized_extensions = Discourse.Utilities.authorizesAllExtensions() ? "" : '(' + Discourse.Utilities.authorizedExtensions() + ')';
        return uploadTranslate(source + '_tip', { authorized_extensions: authorized_extensions });
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          upload: function () {
            if (this.get('local')) {
              $('.wmd-controls').fileupload('add', { fileInput: $('#filename-input') });
            } else {
              var imageUrl = this.get('imageUrl') || '';
              var imageLink = this.get('imageLink') || '';
              var toolbarEvent = this.get('toolbarEvent');

              if (this.get('showMore') && imageLink.length > 3) {
                toolbarEvent.addText('[![](' + imageUrl + ')](' + imageLink + ')');
              } else {
                toolbarEvent.addText(imageUrl);
              }
            }
            this.send('closeModal');
          },

          useLocal: function () {
            this.setProperties({ local: true, showMore: false });
          },
          useRemote: function () {
            this.set("local", false);
          },
          toggleShowMore: function () {
            this.toggleProperty("showMore");
          }
        };
      }
    }]));
  });
define("discourse/controllers/user-activity", 
  ["discourse/lib/export-csv","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var exportUserArchive = __dependency1__.exportUserArchive;

    __exports__["default"] = Ember.Controller.extend({
      userActionType: null,
      needs: ["application", "user"],
      currentPath: Em.computed.alias('controllers.application.currentPath'),
      viewingSelf: Em.computed.alias("controllers.user.viewingSelf"),
      showBookmarks: Em.computed.alias("controllers.user.showBookmarks"),

      _showFooter: (function () {
        var showFooter;
        if (this.get("userActionType")) {
          var stat = _.find(this.get("model.stats"), { action_type: this.get("userActionType") });
          showFooter = stat && stat.count <= this.get("model.stream.itemsLoaded");
        } else {
          showFooter = this.get("model.statsCountNonPM") <= this.get("model.stream.itemsLoaded");
        }
        this.set("controllers.application.showFooter", showFooter);
      }).observes("userActionType", "model.stream.itemsLoaded"),

      actions: {
        exportUserArchive: function () {
          bootbox.confirm(I18n.t("admin.export_csv.user_archive_confirm"), I18n.t("no_value"), I18n.t("yes_value"), function (confirmed) {
            if (confirmed) {
              exportUserArchive();
            }
          });
        }
      }

    });
  });
define("discourse/controllers/user-badges", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.ArrayController.extend({
      needs: ["user"],
      user: Em.computed.alias("controllers.user.model"),
      sortProperties: ['badge.badge_type.sort_order', 'badge.name'],
      orderBy: function (ub1, ub2) {
        var sr1 = ub1.get('badge.badge_type.sort_order');
        var sr2 = ub2.get('badge.badge_type.sort_order');

        if (sr1 > sr2) {
          return -1;
        }

        if (sr2 > sr1) {
          return 1;
        }

        return ub1.get('badge.name') < ub2.get('badge.name') ? -1 : 1;
      }
    });
  });
define("discourse/controllers/user-card", 
  ["discourse/lib/url","discourse/lib/computed","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var DiscourseURL = __dependency1__["default"];
    var propertyNotEqual = __dependency2__.propertyNotEqual;
    var setting = __dependency2__.setting;
    var computed = __dependency3__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['topic', 'application'];
      }
    }, {
      key: 'visible',
      initializer: function () {
        return false;
      }
    }, {
      key: 'user',
      initializer: function () {
        return null;
      }
    }, {
      key: 'username',
      initializer: function () {
        return null;
      }
    }, {
      key: 'avatar',
      initializer: function () {
        return null;
      }
    }, {
      key: 'userLoading',
      initializer: function () {
        return null;
      }
    }, {
      key: 'cardTarget',
      initializer: function () {
        return null;
      }
    }, {
      key: 'post',
      initializer: function () {
        return null;
      }
    }, {
      key: 'topicPostCount',

      // If inside a topic
      initializer: function () {
        return null;
      }
    }, {
      key: 'postStream',
      initializer: function () {
        return Em.computed.alias('controllers.topic.model.postStream');
      }
    }, {
      key: 'enoughPostsForFiltering',
      initializer: function () {
        return Em.computed.gte('topicPostCount', 2);
      }
    }, {
      key: 'viewingTopic',
      initializer: function () {
        return Em.computed.match('controllers.application.currentPath', /^topic\./);
      }
    }, {
      key: 'viewingAdmin',
      initializer: function () {
        return Em.computed.match('controllers.application.currentPath', /^admin\./);
      }
    }, {
      key: 'showFilter',
      initializer: function () {
        return Em.computed.and('viewingTopic', 'postStream.hasNoFilters', 'enoughPostsForFiltering');
      }
    }, {
      key: 'showName',
      initializer: function () {
        return propertyNotEqual('user.name', 'user.username');
      }
    }, {
      key: 'hasUserFilters',
      initializer: function () {
        return Em.computed.gt('postStream.userFilters.length', 0);
      }
    }, {
      key: 'isSuspended',
      initializer: function () {
        return Em.computed.notEmpty('user.suspend_reason');
      }
    }, {
      key: 'showBadges',
      initializer: function () {
        return setting('enable_badges');
      }
    }, {
      key: 'showMoreBadges',
      initializer: function () {
        return Em.computed.gt('moreBadgesCount', 0);
      }
    }, {
      key: 'showDelete',
      initializer: function () {
        return Em.computed.and("viewingAdmin", "showName", "user.canBeDeleted");
      }
    }, {
      key: 'linkWebsite',
      initializer: function () {
        return Em.computed.not('user.isBasic');
      }
    }, {
      key: 'hasLocationOrWebsite',
      initializer: function () {
        return Em.computed.or('user.location', 'user.website_name');
      }
    }, {
      key: 'publicUserFields',
      decorators: [computed('user.user_fields.@each.value')],
      value: function () {
        var _this = this;

        var siteUserFields = this.site.get('user_fields');
        if (!Ember.isEmpty(siteUserFields)) {
          var _ret = (function () {
            var userFields = _this.get('user.user_fields');
            return {
              v: siteUserFields.filterProperty('show_on_user_card', true).sortBy('position').map(function (field) {
                Ember.set(field, 'dasherized_name', field.get('name').dasherize());
                var value = userFields ? userFields[field.get('id')] : null;
                return Ember.isEmpty(value) ? null : Ember.Object.create({ value: value, field: field });
              }).compact()
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
      }
    }, {
      key: 'removeNoFollow',
      decorators: [computed("user.trust_level")],
      value: function (trustLevel) {
        return trustLevel > 2 && !this.siteSettings.tl3_links_no_follow;
      }
    }, {
      key: 'moreBadgesCount',
      initializer: function () {
        return (function () {
          return this.get('user.badge_count') - this.get('user.featured_user_badges.length');
        }).property('user.badge_count', 'user.featured_user_badges.[]');
      }
    }, {
      key: 'hasCardBadgeImage',
      initializer: function () {
        return (function () {
          var img = this.get('user.card_badge.image');
          return img && img.indexOf('fa-') !== 0;
        }).property('user.card_badge.image');
      }
    }, {
      key: 'show',
      value: function (username, postId, target) {
        var _this2 = this;

        // XSS protection (should be encapsulated)
        username = username.toString().replace(/[^A-Za-z0-9_\.\-]/g, "");

        // No user card for anon
        if (this.siteSettings.hide_user_profiles_from_public && !this.currentUser) {
          return;
        }

        // Don't show on mobile
        if (this.site.mobileView) {
          var url = "/users/" + username;
          DiscourseURL.routeTo(url);
          return;
        }

        var currentUsername = this.get('username'),
            wasVisible = this.get('visible'),
            previousTarget = this.get('cardTarget'),
            post = this.get('viewingTopic') && postId ? this.get('postStream').findLoadedPost(postId) : null;

        if (username === currentUsername && this.get('userLoading') === username) {
          // debounce
          return;
        }

        if (wasVisible) {
          this.close();
          if (target === previousTarget) {
            return; // Same target, close it without loading the new user card
          }
        }

        this.setProperties({ username: username, userLoading: username, cardTarget: target, post: post });

        var args = { stats: false };
        args.include_post_count_for = this.get('controllers.topic.model.id');
        args.skip_track_visit = true;

        return Discourse.User.findByUsername(username, args).then(function (user) {
          if (user.topic_post_count) {
            _this2.set('topicPostCount', user.topic_post_count[args.include_post_count_for]);
          }
          _this2.setProperties({ user: user, avatar: user, visible: true });
        }).catch(function (error) {
          _this2.close();
          throw error;
        }).finally(function () {
          _this2.set('userLoading', null);
        });
      }
    }, {
      key: 'close',
      value: function () {
        this.setProperties({
          visible: false,
          user: null,
          username: null,
          avatar: null,
          userLoading: null,
          cardTarget: null,
          post: null,
          topicPostCount: null
        });
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          togglePosts: function (user) {
            var postStream = this.get('postStream');
            postStream.toggleParticipant(user.get('username'));
            this.close();
          },

          cancelFilter: function () {
            var postStream = this.get('postStream');
            postStream.cancelFilter();
            postStream.refresh();
            this.close();
          },

          showUser: function () {
            this.transitionToRoute('user', this.get('user'));
            this.close();
          }
        };
      }
    }]));
  });
define("discourse/controllers/user-invited-show", 
  ["discourse/models/invite","discourse/lib/debounce","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var Invite = __dependency1__["default"];
    var debounce = __dependency2__["default"];

    // This controller handles actions related to a user's invitations
    __exports__["default"] = Ember.Controller.extend({
      user: null,
      model: null,
      filter: null,
      totalInvites: null,
      invitesCount: null,
      canLoadMore: true,
      invitesLoading: false,

      init: function () {
        this._super();
        this.set('searchTerm', '');
      },

      uploadText: (function () {
        return I18n.t("user.invited.bulk_invite.text");
      }).property(),

      /**
        Observe the search term box with a debouncer and change the results.
         @observes searchTerm
      **/
      _searchTermChanged: debounce(function () {
        var self = this;
        Invite.findInvitedBy(self.get('user'), this.get('filter'), this.get('searchTerm')).then(function (invites) {
          self.set('model', invites);
        });
      }, 250).observes('searchTerm'),

      inviteRedeemed: Em.computed.equal('filter', 'redeemed'),

      /**
        Can the currently logged in user invite users to the site
         @property canInviteToForum
      **/
      canInviteToForum: (function () {
        return Discourse.User.currentProp('can_invite_to_forum');
      }).property(),

      /**
        Can the currently logged in user bulk invite users to the site (only Admin is allowed to perform this operation)
         @property canBulkInvite
      **/
      canBulkInvite: (function () {
        return Discourse.User.currentProp('admin');
      }).property(),

      /**
        Should the search filter input box be displayed?
         @property showSearch
      **/
      showSearch: (function () {
        return this.get('totalInvites') > 9;
      }).property('totalInvites'),

      pendingLabel: (function () {
        if (this.get('invitesCount.total') > 50) {
          return I18n.t('user.invited.pending_tab_with_count', { count: this.get('invitesCount.pending') });
        } else {
          return I18n.t('user.invited.pending_tab');
        }
      }).property('invitesCount'),

      redeemedLabel: (function () {
        if (this.get('invitesCount.total') > 50) {
          return I18n.t('user.invited.redeemed_tab_with_count', { count: this.get('invitesCount.redeemed') });
        } else {
          return I18n.t('user.invited.redeemed_tab');
        }
      }).property('invitesCount'),

      actions: {

        rescind: function (invite) {
          invite.rescind();
          return false;
        },

        reinvite: function (invite) {
          invite.reinvite();
          return false;
        },

        loadMore: function () {
          var self = this;
          var model = self.get('model');

          if (self.get('canLoadMore') && !self.get('invitesLoading')) {
            self.set('invitesLoading', true);
            Invite.findInvitedBy(self.get('user'), self.get('filter'), self.get('searchTerm'), model.invites.length).then(function (invite_model) {
              self.set('invitesLoading', false);
              model.invites.pushObjects(invite_model.invites);
              if (invite_model.invites.length === 0 || invite_model.invites.length < Discourse.SiteSettings.invites_per_page) {
                self.set('canLoadMore', false);
              }
            });
          }
        }
      }

    });
  });
define("discourse/controllers/user-notifications", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.ArrayController.extend({
      needs: ['application'],

      _showFooter: (function () {
        this.set("controllers.application.showFooter", !this.get("model.canLoadMore"));
      }).observes("model.canLoadMore"),

      currentPath: Em.computed.alias('controllers.application.currentPath'),

      actions: {
        resetNew: function () {
          var _this = this;

          Discourse.ajax('/notifications/mark-read', { method: 'PUT' }).then(function () {
            _this.setEach('read', true);
          });
        },

        loadMore: function () {
          this.get('model').loadMore();
        }
      }
    });
  });
define("discourse/controllers/user-posts", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Controller.extend({
      needs: ["application"],

      _showFooter: (function () {
        this.set("controllers.application.showFooter", !this.get("model.canLoadMore"));
      }).observes("model.canLoadMore")
    });
  });
define("discourse/controllers/user-private-messages", 
  ["ember-addons/ember-computed-decorators","discourse/models/topic","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var Topic = __dependency2__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ["application", "user-topics-list", "user"];
      }
    }, {
      key: 'pmView',
      initializer: function () {
        return false;
      }
    }, {
      key: 'viewingSelf',
      initializer: function () {
        return Em.computed.alias('controllers.user.viewingSelf');
      }
    }, {
      key: 'isGroup',
      initializer: function () {
        return Em.computed.equal('pmView', 'groups');
      }
    }, {
      key: 'currentPath',
      initializer: function () {
        return Em.computed.alias('controllers.application.currentPath');
      }
    }, {
      key: 'selected',
      initializer: function () {
        return Em.computed.alias('controllers.user-topics-list.selected');
      }
    }, {
      key: 'bulkSelectEnabled',
      initializer: function () {
        return Em.computed.alias('controllers.user-topics-list.bulkSelectEnabled');
      }
    }, {
      key: 'showNewPM',
      initializer: function () {
        return (function () {
          return this.get('controllers.user.viewingSelf') && Discourse.User.currentProp('can_send_private_messages');
        }).property('controllers.user.viewingSelf');
      }
    }, {
      key: 'hasSelection',
      decorators: [computed('selected.[]', 'bulkSelectEnabled')],
      value: function (selected, bulkSelectEnabled) {
        return bulkSelectEnabled && selected && selected.length > 0;
      }
    }, {
      key: 'canMoveToInbox',
      decorators: [computed('hasSelection', 'pmView', 'archive')],
      value: function (hasSelection, pmView, archive) {
        return hasSelection && (pmView === "archive" || archive);
      }
    }, {
      key: 'canArchive',
      decorators: [computed('hasSelection', 'pmView', 'archive')],
      value: function (hasSelection, pmView, archive) {
        return hasSelection && pmView !== "archive" && !archive;
      }
    }, {
      key: 'bulkOperation',
      value: function (operation) {
        var _this = this;

        var selected = this.get('selected');
        var params = { type: operation };
        if (this.get('isGroup')) {
          params.group = this.get('groupFilter');
        }

        Topic.bulkOperation(selected, params).then(function () {
          var model = _this.get('controllers.user-topics-list.model');
          var topics = model.get('topics');
          topics.removeObjects(selected);
          selected.clear();
          model.loadMore();
        }, function () {
          bootbox.alert(I18n.t("user.messages.failed_to_move"));
        });
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          archive: function () {
            this.bulkOperation("archive_messages");
          },
          toInbox: function () {
            this.bulkOperation("move_messages_to_inbox");
          },
          toggleBulkSelect: function () {
            this.toggleProperty("bulkSelectEnabled");
          },
          selectAll: function () {
            $('input.bulk-select:not(checked)').click();
          }
        };
      }
    }]));
  });
define("discourse/controllers/user-summary", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    // should be kept in sync with 'UserSummary::MAX_SUMMARY_RESULTS'
    var MAX_SUMMARY_RESULTS = 6;
    // should be kept in sync with 'UserSummary::MAX_BADGES'
    var MAX_BADGES = 6;

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'needs',
      initializer: function () {
        return ['user'];
      }
    }, {
      key: 'user',
      initializer: function () {
        return Ember.computed.alias('controllers.user.model');
      }
    }, {
      key: 'moreTopics',
      decorators: [computed("model.topics.length")],
      value: function (topicsLength) {
        return topicsLength >= MAX_SUMMARY_RESULTS;
      }
    }, {
      key: 'moreReplies',
      decorators: [computed("model.replies.length")],
      value: function (repliesLength) {
        return repliesLength >= MAX_SUMMARY_RESULTS;
      }
    }, {
      key: 'moreBadges',
      decorators: [computed("model.badges.length")],
      value: function (badgesLength) {
        return badgesLength >= MAX_BADGES;
      }
    }]));
  });
define("discourse/controllers/user-topics-list", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Lists of topics on a user's page.
    __exports__["default"] = Ember.Controller.extend({
      needs: ["application", "user"],
      hideCategory: false,
      showPosters: false,

      _showFooter: (function () {
        this.set("controllers.application.showFooter", !this.get("model.canLoadMore"));
      }).observes("model.canLoadMore"),

      actions: {
        loadMore: function () {
          this.get('model').loadMore();
        }
      }

    });
  });
define("discourse/controllers/user", 
  ["discourse/mixins/can-check-emails","ember-addons/ember-computed-decorators","discourse/models/user-action","discourse/models/user","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var CanCheckEmails = __dependency1__["default"];
    var computed = __dependency2__["default"];
    var UserAction = __dependency3__["default"];
    var User = __dependency4__["default"];

    __exports__["default"] = Ember.Controller.extend(CanCheckEmails, _createDecoratedObject([{
      key: 'indexStream',
      initializer: function () {
        return false;
      }
    }, {
      key: 'userActionType',
      initializer: function () {
        return null;
      }
    }, {
      key: 'needs',
      initializer: function () {
        return ['application', 'user-notifications', 'user-topics-list'];
      }
    }, {
      key: 'currentPath',
      initializer: function () {
        return Em.computed.alias('controllers.application.currentPath');
      }
    }, {
      key: 'viewingSelf',
      decorators: [computed("content.username")],
      value: function (username) {
        return username === User.currentProp('username');
      }
    }, {
      key: 'collapsedInfo',
      decorators: [computed('indexStream', 'viewingSelf', 'forceExpand')],
      value: function (indexStream, viewingSelf, forceExpand) {
        return (!indexStream || viewingSelf) && !forceExpand;
      }
    }, {
      key: 'linkWebsite',
      initializer: function () {
        return Em.computed.not('model.isBasic');
      }
    }, {
      key: 'removeNoFollow',
      decorators: [computed("model.trust_level")],
      value: function (trustLevel) {
        return trustLevel > 2 && !this.siteSettings.tl3_links_no_follow;
      }
    }, {
      key: 'showBookmarks',
      decorators: [computed('viewingSelf', 'currentUser.admin')],
      value: function (viewingSelf, isAdmin) {
        return viewingSelf || isAdmin;
      }
    }, {
      key: 'showPrivateMessages',
      decorators: [computed('viewingSelf', 'currentUser.admin')],
      value: function (viewingSelf, isAdmin) {
        return this.siteSettings.enable_private_messages && (viewingSelf || isAdmin);
      }
    }, {
      key: 'showNotificationsTab',
      decorators: [computed('viewingSelf', 'currentUser.staff')],
      value: function (viewingSelf, staff) {
        return viewingSelf || staff;
      }
    }, {
      key: 'showBadges',
      decorators: [computed("content.badge_count")],
      value: function (badgeCount) {
        return Discourse.SiteSettings.enable_badges && badgeCount > 0;
      }
    }, {
      key: 'privateMessageView',
      decorators: [computed("userActionType")],
      value: function (userActionType) {
        return userActionType === UserAction.TYPES.messages_sent || userActionType === UserAction.TYPES.messages_received;
      }
    }, {
      key: 'showActionTypeSummary',
      decorators: [computed("indexStream", "userActionType")],
      value: function (indexStream, userActionType, showPMs) {
        return (indexStream || userActionType) && !showPMs;
      }
    }, {
      key: 'canInviteToForum',
      decorators: [computed()],
      value: function () {
        return User.currentProp('can_invite_to_forum');
      }
    }, {
      key: 'canDeleteUser',
      initializer: function () {
        return Ember.computed.and("model.can_be_deleted", "model.can_delete_all_posts");
      }
    }, {
      key: 'publicUserFields',
      decorators: [computed('model.user_fields.@each.value')],
      value: function () {
        var _this = this;

        var siteUserFields = this.site.get('user_fields');
        if (!Ember.isEmpty(siteUserFields)) {
          var _ret = (function () {
            var userFields = _this.get('model.user_fields');
            return {
              v: siteUserFields.filterProperty('show_on_profile', true).sortBy('position').map(function (field) {
                field.dasherized_name = field.get('name').dasherize();
                var value = userFields ? userFields[field.get('id').toString()] : null;
                return Ember.isEmpty(value) ? null : Ember.Object.create({ value: value, field: field });
              }).compact()
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          expandProfile: function () {
            this.set('forceExpand', true);
          },

          adminDelete: function () {
            // I really want this deferred, don't want to bring in all this code till used
            var AdminUser = require('admin/models/admin-user').default;
            AdminUser.find(this.get('model.id')).then(function (user) {
              return user.destroy({ deletePosts: true });
            });
          }

        };
      }
    }]));
  });
define("discourse/controllers/users", 
  ["discourse/lib/debounce","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var debounce = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend({
      needs: ["application"],
      queryParams: ["period", "order", "asc", "name"],
      period: "weekly",
      order: "likes_received",
      asc: null,
      name: "",

      showTimeRead: Ember.computed.equal("period", "all"),

      _setName: debounce(function () {
        this.set("name", this.get("nameInput"));
      }, 500).observes("nameInput"),

      _showFooter: (function () {
        this.set("controllers.application.showFooter", !this.get("model.canLoadMore"));
      }).observes("model.canLoadMore"),

      actions: {
        loadMore: function () {
          this.get("model").loadMore();
        }
      }
    });
  });
define("discourse/models/admin-post", 
  ["discourse/models/post","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Post = __dependency1__["default"];

    __exports__["default"] = Post.extend({

      _attachCategory: (function () {
        var categoryId = this.get("category_id");
        if (categoryId) {
          this.set("category", Discourse.Category.findById(categoryId));
        }
      }).on("init"),

      presentName: Em.computed.any('name', 'username'),

      sameUser: (function () {
        return this.get("username") === Discourse.User.currentProp("username");
      }).property("username"),

      descriptionKey: (function () {
        if (this.get("reply_to_post_number")) {
          return this.get("sameUser") ? "you_replied_to_post" : "user_replied_to_post";
        } else {
          return this.get("sameUser") ? "you_replied_to_topic" : "user_replied_to_topic";
        }
      }).property("reply_to_post_number", "sameUser")

    });
  });
define("discourse/models/archetype", 
  ["discourse/lib/computed","discourse/models/rest","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;
    var RestModel = __dependency2__["default"];

    __exports__["default"] = RestModel.extend({
      hasOptions: Em.computed.gt('options.length', 0),
      isDefault: propertyEqual('id', 'site.default_archetype'),
      notDefault: Em.computed.not('isDefault')
    });
  });
define("discourse/models/category-list", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var CategoryList = Ember.ArrayProxy.extend({
      init: function () {
        this.set('content', []);
        this._super();
      }
    });

    CategoryList.reopenClass({
      categoriesFrom: function (store, result) {
        var categories = CategoryList.create();
        var users = Discourse.Model.extractByKey(result.featured_users, Discourse.User);
        var list = Discourse.Category.list();

        result.category_list.categories.forEach(function (c) {
          if (c.parent_category_id) {
            c.parentCategory = list.findBy('id', c.parent_category_id);
          }

          if (c.subcategory_ids) {
            c.subcategories = c.subcategory_ids.map(function (scid) {
              return list.findBy('id', parseInt(scid, 10));
            });
          }

          if (c.featured_user_ids) {
            c.featured_users = c.featured_user_ids.map(function (u) {
              return users[u];
            });
          }

          if (c.topics) {
            c.topics = c.topics.map(function (t) {
              return Discourse.Topic.create(t);
            });
          }

          categories.pushObject(store.createRecord('category', c));
        });
        return categories;
      },

      listForParent: function (store, category) {
        var _this = this;

        return Discourse.ajax('/categories.json?parent_category_id=' + category.get("id")).then(function (result) {
          return CategoryList.create({
            categories: _this.categoriesFrom(store, result),
            parentCategory: category
          });
        });
      },

      list: function (store) {
        var _this2 = this;

        var getCategories = function () {
          return Discourse.ajax("/categories.json");
        };
        return PreloadStore.getAndRemove("categories_list", getCategories).then(function (result) {
          return CategoryList.create({
            categories: _this2.categoriesFrom(store, result),
            can_create_category: result.category_list.can_create_category,
            can_create_topic: result.category_list.can_create_topic,
            draft_key: result.category_list.draft_key,
            draft: result.category_list.draft,
            draft_sequence: result.category_list.draft_sequence
          });
        });
      }
    });

    __exports__["default"] = CategoryList;
  });
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  Represents a pop up message displayed over the composer

  @class ComposerMessage
  @extends Ember.Object
  @namespace Discourse
  @module Discourse
**/

Discourse.ComposerMessage = Em.Object.extend({});

Discourse.ComposerMessage.reopenClass({
  /**
    Look for composer messages given the current composing settings.

    @method find
    @param {Discourse.Composer} composer The current composer
    @returns {Discourse.ComposerMessage} the composer message to display (or null)
  **/
  find: function(composer) {

    var data = { composerAction: composer.get('action') },
        topicId = composer.get('topic.id'),
        postId = composer.get('post.id');

    if (topicId) { data.topic_id = topicId; }
    if (postId)  { data.post_id = postId; }

    return Discourse.ajax('/composer-messages', { data: data }).then(function (messages) {
      return messages.map(function (message) {
        return Discourse.ComposerMessage.create(message);
      });
    });
  }

});


// IIFE Wrapped Content Ends

 })(this);
define("discourse/models/group", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    var Group = Discourse.Model.extend(_createDecoratedObject([{
      key: 'limit',
      initializer: function () {
        return 50;
      }
    }, {
      key: 'offset',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'user_count',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'owners',
      initializer: function () {
        return [];
      }
    }, {
      key: 'hasOwners',
      initializer: function () {
        return Ember.computed.notEmpty('owners');
      }
    }, {
      key: 'emailDomains',
      decorators: [computed("automatic_membership_email_domains")],
      value: function (value) {
        return Em.isEmpty(value) ? "" : value;
      }
    }, {
      key: 'type',
      initializer: function () {
        return (function () {
          return this.get("automatic") ? "automatic" : "custom";
        }).property("automatic");
      }
    }, {
      key: 'userCountDisplay',
      decorators: [computed('user_count')],
      value: function (userCount) {
        // don't display zero its ugly
        if (userCount > 0) {
          return userCount;
        }
      }
    }, {
      key: 'findMembers',
      value: function () {
        if (Em.isEmpty(this.get('name'))) {
          return;
        }

        var self = this,
            offset = Math.min(this.get("user_count"), Math.max(this.get("offset"), 0));

        return Group.loadMembers(this.get("name"), offset, this.get("limit")).then(function (result) {
          var ownerIds = {};
          result.owners.forEach(function (owner) {
            return ownerIds[owner.id] = true;
          });

          self.setProperties({
            user_count: result.meta.total,
            limit: result.meta.limit,
            offset: result.meta.offset,
            members: result.members.map(function (member) {
              if (ownerIds[member.id]) {
                member.owner = true;
              }
              return Discourse.User.create(member);
            }),
            owners: result.owners.map(function (owner) {
              return Discourse.User.create(owner);
            })
          });
        });
      }
    }, {
      key: 'removeOwner',
      value: function (member) {
        var self = this;
        return Discourse.ajax('/admin/groups/' + this.get('id') + '/owners.json', {
          type: "DELETE",
          data: { user_id: member.get("id") }
        }).then(function () {
          // reload member list
          self.findMembers();
        });
      }
    }, {
      key: 'removeMember',
      value: function (member) {
        var self = this;
        return Discourse.ajax('/groups/' + this.get('id') + '/members.json', {
          type: "DELETE",
          data: { user_id: member.get("id") }
        }).then(function () {
          // reload member list
          self.findMembers();
        });
      }
    }, {
      key: 'addMembers',
      value: function (usernames) {
        var self = this;
        return Discourse.ajax('/groups/' + this.get('id') + '/members.json', {
          type: "PUT",
          data: { usernames: usernames }
        }).then(function () {
          self.findMembers();
        });
      }
    }, {
      key: 'addOwners',
      value: function (usernames) {
        var self = this;
        return Discourse.ajax('/admin/groups/' + this.get('id') + '/owners.json', {
          type: "PUT",
          data: { usernames: usernames }
        }).then(function () {
          self.findMembers();
        });
      }
    }, {
      key: 'asJSON',
      value: function () {
        return {
          name: this.get('name'),
          alias_level: this.get('alias_level'),
          visible: !!this.get('visible'),
          automatic_membership_email_domains: this.get('emailDomains'),
          automatic_membership_retroactive: !!this.get('automatic_membership_retroactive'),
          title: this.get('title'),
          primary_group: !!this.get('primary_group'),
          grant_trust_level: this.get('grant_trust_level'),
          incoming_email: this.get("incoming_email")
        };
      }
    }, {
      key: 'create',
      value: function () {
        var self = this;
        return Discourse.ajax("/admin/groups", { type: "POST", data: this.asJSON() }).then(function (resp) {
          self.set('id', resp.basic_group.id);
        });
      }
    }, {
      key: 'save',
      value: function () {
        return Discourse.ajax("/admin/groups/" + this.get('id'), { type: "PUT", data: this.asJSON() });
      }
    }, {
      key: 'destroy',
      value: function () {
        if (!this.get('id')) {
          return;
        }
        return Discourse.ajax("/admin/groups/" + this.get('id'), { type: "DELETE" });
      }
    }, {
      key: 'findPosts',
      value: function (opts) {
        opts = opts || {};

        var type = opts['type'] || 'posts';

        var data = {};
        if (opts.beforePostId) {
          data.before_post_id = opts.beforePostId;
        }

        return Discourse.ajax('/groups/' + this.get('name') + '/' + type + '.json', { data: data }).then(function (posts) {
          return posts.map(function (p) {
            p.user = Discourse.User.create(p.user);
            p.topic = Discourse.Topic.create(p.topic);
            return Em.Object.create(p);
          });
        });
      }
    }, {
      key: 'setNotification',
      value: function (notification_level) {
        this.set("notification_level", notification_level);
        return Discourse.ajax('/groups/' + this.get("name") + '/notifications', {
          data: { notification_level: notification_level },
          type: "POST"
        });
      }
    }]));

    Group.reopenClass({
      findAll: function (opts) {
        return Discourse.ajax("/admin/groups.json", { data: opts }).then(function (groups) {
          return groups.map(function (g) {
            return Group.create(g);
          });
        });
      },

      findGroupCounts: function (name) {
        return Discourse.ajax("/groups/" + name + "/counts.json").then(function (result) {
          return Em.Object.create(result.counts);
        });
      },

      find: function (name) {
        return Discourse.ajax("/groups/" + name + ".json").then(function (result) {
          return Group.create(result.basic_group);
        });
      },

      loadMembers: function (name, offset, limit) {
        return Discourse.ajax('/groups/' + name + '/members.json', {
          data: {
            limit: limit || 50,
            offset: offset || 0
          }
        });
      }
    });

    __exports__["default"] = Group;
  });
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

/**
  A trivial model we use to handle input validation

  @class InputValidation
  @extends Discourse.Model
  @namespace Discourse
  @module Discourse
**/

Discourse.InputValidation = Discourse.Model.extend({});




// IIFE Wrapped Content Ends

 })(this);
define("discourse/models/live-post-counts", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var LivePostCounts = Discourse.Model.extend({});

    LivePostCounts.reopenClass({
      find: function () {
        return Discourse.ajax("/about/live_post_counts.json").then(function (result) {
          return LivePostCounts.create(result);
        });
      }
    });

    __exports__["default"] = LivePostCounts;
  });
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

Discourse.LoginMethod = Ember.Object.extend({
  title: function() {
    var titleSetting = this.get('titleSetting');
    if (!Ember.isEmpty(titleSetting)) {
      var result = Discourse.SiteSettings[titleSetting];
      if (!Ember.isEmpty(result)) { return result; }
    }

    return this.get("titleOverride") || I18n.t("login." + this.get("name") + ".title");
  }.property(),

  message: function() {
    return this.get("messageOverride") || I18n.t("login." + this.get("name") + ".message");
  }.property()
});

// Note, you can add login methods by adding to the list
//  just Em.get("Discourse.LoginMethod.all") and then
//  pushObject for any new methods
Discourse.LoginMethod.reopenClass({
  register: function(method) {
    if (this.methods){
      this.methods.pushObject(method);
    } else {
      this.preRegister = this.preRegister || [];
      this.preRegister.push(method);
    }
  },

  all: function(){
    if (this.methods) { return this.methods; }

    var methods = this.methods = Em.A();

    [ "google_oauth2",
      "facebook",
      "cas",
      "twitter",
      "yahoo",
      "instagram",
      "github"
    ].forEach(function(name){
      if (Discourse.SiteSettings["enable_" + name + "_logins"]) {

        var params = {name: name};

        if (name === "google_oauth2") {
          params.frameWidth = 850;
          params.frameHeight = 500;
        } else if (name === "facebook") {
          params.frameHeight = 450;
        }

        methods.pushObject(Discourse.LoginMethod.create(params));
      }
    });

    if (this.preRegister){
      this.preRegister.forEach(function(method){
        var enabledSetting = method.get('enabledSetting');
        if (enabledSetting) {
          if (Discourse.SiteSettings[enabledSetting]) {
            methods.pushObject(method);
          }
        } else {
          methods.pushObject(method);
        }
      });
      delete this.preRegister;
    }
    return methods;
  }.property()
});



// IIFE Wrapped Content Ends

 })(this);
define("discourse/models/nav-item", 
  ["discourse/lib/formatter","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.extraNavItemProperties = extraNavItemProperties;
    __exports__.customNavItemHref = customNavItemHref;
    var toTitleCase = __dependency1__.toTitleCase;

    var NavItem = Discourse.Model.extend({

      displayName: (function () {
        var categoryName = this.get('categoryName'),
            name = this.get('name'),
            count = this.get('count') || 0;

        if (name === 'latest' && !Discourse.Site.currentProp('mobileView')) {
          count = 0;
        }

        var extra = { count: count };
        var titleKey = count === 0 ? '.title' : '.title_with_count';

        if (categoryName) {
          name = 'category';
          extra.categoryName = toTitleCase(categoryName);
        }
        return I18n.t("filters." + name.replace("/", ".") + titleKey, extra);
      }).property('categoryName', 'name', 'count'),

      categoryName: (function () {
        var split = this.get('name').split('/');
        return split[0] === 'category' ? split[1] : null;
      }).property('name'),

      categorySlug: (function () {
        var split = this.get('name').split('/');
        if (split[0] === 'category' && split[1]) {
          var cat = Discourse.Site.current().categories.findProperty('nameLower', split[1].toLowerCase());
          return cat ? Discourse.Category.slugFor(cat) : null;
        }
        return null;
      }).property('name'),

      href: (function () {
        var customHref = null;
        _.each(NavItem.customNavItemHrefs, function (cb) {
          customHref = cb.call(this, this);
          if (customHref) {
            return false;
          }
        }, this);
        if (customHref) {
          return customHref;
        }
        return Discourse.getURL("/") + this.get('filterMode');
      }).property('filterMode'),

      // href from this item
      filterMode: (function () {
        var name = this.get('name');

        if (name.split('/')[0] === 'category') {
          return 'c/' + this.get('categorySlug');
        } else {
          var mode = "",
              category = this.get("category");

          if (category) {
            mode += "c/";
            mode += Discourse.Category.slugFor(this.get('category'));
            if (this.get('noSubcategories')) {
              mode += '/none';
            }
            mode += "/l/";
          }
          return mode + name.replace(' ', '-');
        }
      }).property('name'),

      count: (function () {
        var state = this.get('topicTrackingState');
        if (state) {
          return state.lookupCount(this.get('name'), this.get('category'));
        }
      }).property('topicTrackingState.messageCount')

    });

    NavItem.reopenClass({

      extraArgsCallbacks: [],
      customNavItemHrefs: [],

      // create a nav item from the text, will return null if there is not valid nav item for this particular text
      fromText: function (text, opts) {
        var split = text.split(","),
            name = split[0],
            testName = name.split("/")[0],
            anonymous = !Discourse.User.current();

        if (anonymous && !Discourse.Site.currentProp('anonymous_top_menu_items').contains(testName)) return null;
        if (!Discourse.Category.list() && testName === "categories") return null;
        if (!Discourse.Site.currentProp('top_menu_items').contains(testName)) return null;

        var args = { name: name, hasIcon: name === "unread" },
            extra = null,
            self = this;
        if (opts.category) {
          args.category = opts.category;
        }
        if (opts.noSubcategories) {
          args.noSubcategories = true;
        }
        _.each(NavItem.extraArgsCallbacks, function (cb) {
          extra = cb.call(self, text, opts);
          _.merge(args, extra);
        });

        var store = Discourse.__container__.lookup('store:main');
        return store.createRecord('nav-item', args);
      },

      buildList: function (category, args) {
        args = args || {};

        if (category) {
          args.category = category;
        }

        var items = Discourse.SiteSettings.top_menu.split("|");

        if (args.filterMode && !_.some(items, function (i) {
          return i.indexOf(args.filterMode) !== -1;
        })) {
          items.push(args.filterMode);
        }

        return items.map(function (i) {
          return Discourse.NavItem.fromText(i, args);
        }).filter(function (i) {
          return i !== null && !(category && i.get("name").indexOf("categor") === 0);
        });
      }

    });

    __exports__["default"] = NavItem;

    function extraNavItemProperties(cb) {
      NavItem.extraArgsCallbacks.push(cb);
    }

    function customNavItemHref(cb) {
      NavItem.customNavItemHrefs.push(cb);
    }
  });

Discourse.NavItem = require('discourse/models/nav-item').default;
define("discourse/models/session", 
  ["discourse/models/rest","discourse/mixins/singleton","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];
    var Singleton = __dependency2__["default"];

    // A data model representing current session data. You can put transient
    // data here you might want later. It is not stored or serialized anywhere.
    var Session = RestModel.extend({
      init: function () {
        this.set('highestSeenByTopic', {});
      }
    });

    Session.reopenClass(Singleton);
    __exports__["default"] = Session;
  });

Discourse.Session = require('discourse/models/session').default;
define("discourse/models/site", 
  ["ember-addons/ember-computed-decorators","discourse/models/archetype","discourse/models/post-action-type","discourse/mixins/singleton","discourse/models/rest","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var Archetype = __dependency2__["default"];
    var PostActionType = __dependency3__["default"];
    var Singleton = __dependency4__["default"];
    var RestModel = __dependency5__["default"];

    var Site = RestModel.extend(_createDecoratedObject([{
      key: 'isReadOnly',
      initializer: function () {
        return Em.computed.alias('is_readonly');
      }
    }, {
      key: 'notificationLookup',
      decorators: [computed("notification_types")],
      value: function (notificationTypes) {
        var result = [];
        _.each(notificationTypes, function (v, k) {
          return result[v] = k;
        });
        return result;
      }
    }, {
      key: 'flagTypes',
      decorators: [computed("post_action_types.[]")],
      value: function () {
        var postActionTypes = this.get('post_action_types');
        if (!postActionTypes) return [];
        return postActionTypes.filterProperty('is_flag', true);
      }
    }, {
      key: 'topicCountDesc',
      initializer: function () {
        return ['topic_count:desc'];
      }
    }, {
      key: 'categoriesByCount',
      initializer: function () {
        return Ember.computed.sort('categories', 'topicCountDesc');
      }
    }, {
      key: 'sortedCategories',
      decorators: [computed("categoriesByCount", "categories.[]")],
      value: function (cats) {
        var result = [],
            remaining = {};

        cats.forEach(function (c) {
          var parentCategoryId = parseInt(c.get('parent_category_id'), 10);
          if (!parentCategoryId) {
            result.pushObject(c);
          } else {
            remaining[parentCategoryId] = remaining[parentCategoryId] || [];
            remaining[parentCategoryId].pushObject(c);
          }
        });

        Object.keys(remaining).forEach(function (parentCategoryId) {
          var category = result.findBy('id', parseInt(parentCategoryId, 10)),
              index = result.indexOf(category);

          if (index !== -1) {
            result.replace(index + 1, 0, remaining[parentCategoryId]);
          }
        });

        return result;
      }
    }, {
      key: 'postActionTypeById',
      value: function (id) {
        return this.get("postActionByIdLookup.action" + id);
      }
    }, {
      key: 'topicFlagTypeById',
      value: function (id) {
        return this.get("topicFlagByIdLookup.action" + id);
      }
    }, {
      key: 'removeCategory',
      value: function (id) {
        var categories = this.get('categories');
        var existingCategory = categories.findProperty('id', id);
        if (existingCategory) {
          categories.removeObject(existingCategory);
          delete this.get('categoriesById').categoryId;
        }
      }
    }, {
      key: 'updateCategory',
      value: function (newCategory) {
        var categories = this.get('categories');
        var categoryId = Em.get(newCategory, 'id');
        var existingCategory = categories.findProperty('id', categoryId);

        // Don't update null permissions
        if (newCategory.permission === null) {
          delete newCategory.permission;
        }

        if (existingCategory) {
          existingCategory.setProperties(newCategory);
        } else {
          // TODO insert in right order?
          newCategory = this.store.createRecord('category', newCategory);
          categories.pushObject(newCategory);
          this.get('categoriesById')[categoryId] = newCategory;
        }
      }
    }]));

    Site.reopenClass(Singleton, {

      // The current singleton will retrieve its attributes from the `PreloadStore`.
      createCurrent: function () {
        var store = Discourse.__container__.lookup('store:main');
        return store.createRecord('site', PreloadStore.get('site'));
      },

      create: function () {
        var result = this._super.apply(this, arguments);
        var store = result.store;

        if (result.categories) {
          result.categoriesById = {};
          result.categories = _.map(result.categories, function (c) {
            return result.categoriesById[c.id] = store.createRecord('category', c);
          });

          // Associate the categories with their parents
          result.categories.forEach(function (c) {
            if (c.get('parent_category_id')) {
              c.set('parentCategory', result.categoriesById[c.get('parent_category_id')]);
            }
          });
        }

        if (result.trust_levels) {
          result.trustLevels = result.trust_levels.map(function (tl) {
            return Discourse.TrustLevel.create(tl);
          });
          delete result.trust_levels;
        }

        if (result.post_action_types) {
          result.postActionByIdLookup = Em.Object.create();
          result.post_action_types = _.map(result.post_action_types, function (p) {
            var actionType = PostActionType.create(p);
            result.postActionByIdLookup.set("action" + p.id, actionType);
            return actionType;
          });
        }

        if (result.topic_flag_types) {
          result.topicFlagByIdLookup = Em.Object.create();
          result.topic_flag_types = _.map(result.topic_flag_types, function (p) {
            var actionType = PostActionType.create(p);
            result.topicFlagByIdLookup.set("action" + p.id, actionType);
            return actionType;
          });
        }

        if (result.archetypes) {
          result.archetypes = _.map(result.archetypes, function (a) {
            a.site = result;
            return Archetype.create(a);
          });
        }

        if (result.user_fields) {
          result.user_fields = result.user_fields.map(function (uf) {
            return Ember.Object.create(uf);
          });
        }

        return result;
      }
    });

    __exports__["default"] = Site;

    // Sort subcategories under parents
  });

Discourse.Site = require('discourse/models/site').default;
(function () {

var $ = window.jQuery;
// IIFE Wrapped Content Begins:

Discourse.StaticPage = Em.Object.extend();

Discourse.StaticPage.reopenClass({
  find: function(path) {
    return new Em.RSVP.Promise(function(resolve) {
      // Models shouldn't really be doing Ajax request, but this is a huge speed boost if we
      // preload content.
      var $preloaded = $("noscript[data-path=\"/" + path + "\"]");
      if ($preloaded.length) {
        var text = $preloaded.text();
        text = text.match(/<!-- preload-content: -->((?:.|[\n\r])*)<!-- :preload-content -->/)[1];
        resolve(Discourse.StaticPage.create({path: path, html: text}));
      } else {
        Discourse.ajax(path + ".html", {dataType: 'html'}).then(function (result) {
          resolve(Discourse.StaticPage.create({path: path, html: result}));
        });
      }
    });
  }
});


// IIFE Wrapped Content Ends

 })(this);
define("discourse/models/topic-list", 
  ["discourse/models/rest","discourse/models/model","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];
    var Model = __dependency2__["default"];

    function topicsFrom(result, store) {
      if (!result) {
        return;
      }

      // Stitch together our side loaded data
      var categories = Discourse.Category.list(),
          users = Model.extractByKey(result.users, Discourse.User);

      return result.topic_list.topics.map(function (t) {
        t.category = categories.findBy('id', t.category_id);
        t.posters.forEach(function (p) {
          p.user = users[p.user_id];
        });
        if (t.participants) {
          t.participants.forEach(function (p) {
            p.user = users[p.user_id];
          });
        }
        return store.createRecord('topic', t);
      });
    }

    var TopicList = RestModel.extend({
      canLoadMore: Em.computed.notEmpty("more_topics_url"),

      forEachNew: function (topics, callback) {
        var topicIds = [];

        _.each(this.get('topics'), function (topic) {
          return topicIds[topic.get('id')] = true;
        });

        _.each(topics, function (topic) {
          if (!topicIds[topic.id]) {
            callback(topic);
          }
        });
      },

      refreshSort: function (order, ascending) {
        var params = this.get('params') || {};

        if (params.q) {
          // search is unique, nothing else allowed with it
          params = { q: params.q };
        } else {
          params.order = order || params.order;
          params.ascending = ascending;
        }

        this.set('params', params);
      },

      loadMore: function () {
        var _this = this;

        if (this.get('loadingMore')) {
          return Ember.RSVP.resolve();
        }

        var moreUrl = this.get('more_topics_url');
        if (moreUrl) {
          var _ret = (function () {
            var self = _this;
            _this.set('loadingMore', true);

            var store = _this.store;
            return {
              v: Discourse.ajax({ url: moreUrl }).then(function (result) {
                var topicsAdded = 0;

                if (result) {
                  var _ret2 = (function () {
                    // the new topics loaded from the server
                    var newTopics = topicsFrom(result, store),
                        topics = self.get("topics");

                    self.forEachNew(newTopics, function (t) {
                      t.set('highlight', topicsAdded++ === 0);
                      topics.pushObject(t);
                    });

                    self.setProperties({
                      loadingMore: false,
                      more_topics_url: result.topic_list.more_topics_url
                    });

                    Discourse.Session.currentProp('topicList', self);
                    return {
                      v: self.get('more_topics_url')
                    };
                  })();

                  if (typeof _ret2 === 'object') return _ret2.v;
                }
              })
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        } else {
          // Return a promise indicating no more results
          return Ember.RSVP.resolve();
        }
      },

      // loads topics with these ids "before" the current topics
      loadBefore: function (topic_ids) {
        var topicList = this,
            topics = this.get('topics');

        // refresh dupes
        topics.removeObjects(topics.filter(function (topic) {
          return topic_ids.indexOf(topic.get('id')) >= 0;
        }));

        var url = '' + Discourse.getURL("/") + this.get('filter') + '?topic_ids=' + topic_ids.join(",");
        var store = this.store;

        return Discourse.ajax({ url: url }).then(function (result) {
          var i = 0;
          topicList.forEachNew(topicsFrom(result, store), function (t) {
            // highlight the first of the new topics so we can get a visual feedback
            t.set('highlight', true);
            topics.insertAt(i, t);
            i++;
          });
          Discourse.Session.currentProp('topicList', topicList);
        });
      }
    });

    TopicList.reopenClass({

      munge: function (json, store) {
        json.inserted = json.inserted || [];
        json.can_create_topic = json.topic_list.can_create_topic;
        json.more_topics_url = json.topic_list.more_topics_url;
        json.draft_key = json.topic_list.draft_key;
        json.draft_sequence = json.topic_list.draft_sequence;
        json.draft = json.topic_list.draft;
        json.for_period = json.topic_list.for_period;
        json.loaded = true;
        json.per_page = json.topic_list.per_page;
        json.topics = topicsFrom(json, store);

        return json;
      },

      find: function (filter, params) {
        var store = Discourse.__container__.lookup('store:main');
        return store.findFiltered('topicList', { filter: filter, params: params });
      },

      // hide the category when it has no children
      hideUniformCategory: function (list, category) {
        list.set('hideCategory', category && !category.get("has_children"));
      }

    });

    __exports__["default"] = TopicList;
  });
define("discourse/models/topic-tracking-state", 
  ["discourse/lib/notification-levels","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    __exports__.startTracking = startTracking;

    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var NotificationLevels = __dependency1__["default"];
    var computed = __dependency2__["default"];
    var on = __dependency2__.on;

    function isNew(topic) {
      return topic.last_read_post_number === null && (topic.notification_level !== 0 && !topic.notification_level || topic.notification_level >= NotificationLevels.TRACKING);
    }

    function isUnread(topic) {
      return topic.last_read_post_number !== null && topic.last_read_post_number < topic.highest_post_number && topic.notification_level >= NotificationLevels.TRACKING;
    }

    var TopicTrackingState = Discourse.Model.extend(_createDecoratedObject([{
      key: "messageCount",
      initializer: function () {
        return 0;
      }
    }, {
      key: "_setup",
      decorators: [on("init")],
      value: function () {
        this.unreadSequence = [];
        this.newSequence = [];
        this.states = {};
      }
    }, {
      key: "establishChannels",
      value: function () {
        var tracker = this;

        var process = function (data) {
          if (data.message_type === "delete") {
            tracker.removeTopic(data.topic_id);
            tracker.incrementMessageCount();
          }

          if (data.message_type === "new_topic" || data.message_type === "latest") {
            var muted_category_ids = Discourse.User.currentProp("muted_category_ids");
            if (_.include(muted_category_ids, data.payload.category_id)) {
              return;
            }
          }

          // fill parent_category_id we need it for counting new/unread
          if (data.payload && data.payload.category_id) {
            var category = Discourse.Category.findById(data.payload.category_id);

            if (category && category.parent_category_id) {
              data.payload.parent_category_id = category.parent_category_id;
            }
          }

          if (data.message_type === "latest") {
            tracker.notify(data);
          }

          if (data.message_type === "new_topic" || data.message_type === "unread" || data.message_type === "read") {
            tracker.notify(data);
            var old = tracker.states["t" + data.topic_id];

            // don't add tracking state for read stuff that was not tracked in first place
            if (old || data.message_type !== "read") {
              if (!_.isEqual(old, data.payload)) {
                tracker.states["t" + data.topic_id] = data.payload;
                tracker.incrementMessageCount();
              }
            }
          }
        };

        this.messageBus.subscribe("/new", process);
        this.messageBus.subscribe("/latest", process);
        if (this.currentUser) {
          this.messageBus.subscribe("/unread/" + this.currentUser.get('id'), process);
        }

        this.messageBus.subscribe("/delete", function (msg) {
          var old = tracker.states["t" + msg.topic_id];
          if (old) {
            old.deleted = true;
          }
          tracker.incrementMessageCount();
        });

        this.messageBus.subscribe("/recover", function (msg) {
          var old = tracker.states["t" + msg.topic_id];
          if (old) {
            delete old.deleted;
          }
          tracker.incrementMessageCount();
        });
      }
    }, {
      key: "updateSeen",
      value: function (topicId, highestSeen) {
        if (!topicId || !highestSeen) {
          return;
        }
        var state = this.states["t" + topicId];
        if (state && (!state.last_read_post_number || state.last_read_post_number < highestSeen)) {
          state.last_read_post_number = highestSeen;
          this.incrementMessageCount();
        }
      }
    }, {
      key: "notify",
      value: function (data) {
        if (!this.newIncoming) {
          return;
        }
        if (data.archetype === "private_message") {
          return;
        }

        var filter = this.get("filter");
        var filterCategory = this.get("filterCategory");
        var categoryId = data.payload && data.payload.category_id;

        if (filterCategory && filterCategory.get("id") !== categoryId) {
          var category = categoryId && Discourse.Category.findById(categoryId);
          if (!category || category.get("parentCategory.id") !== filterCategory.get('id')) {
            return;
          }
        }

        if (filter === Discourse.Utilities.defaultHomepage()) {
          var suppressed_from_homepage_category_ids = Discourse.Site.currentProp("suppressed_from_homepage_category_ids");
          if (_.include(suppressed_from_homepage_category_ids, data.payload.category_id)) {
            return;
          }
        }

        if ((filter === "all" || filter === "latest" || filter === "new") && data.message_type === "new_topic") {
          this.addIncoming(data.topic_id);
        }

        if ((filter === "all" || filter === "unread") && data.message_type === "unread") {
          var old = this.states["t" + data.topic_id];
          if (!old || old.highest_post_number === old.last_read_post_number) {
            this.addIncoming(data.topic_id);
          }
        }

        if (filter === "latest" && data.message_type === "latest") {
          this.addIncoming(data.topic_id);
        }

        this.set("incomingCount", this.newIncoming.length);
      }
    }, {
      key: "addIncoming",
      value: function (topicId) {
        if (this.newIncoming.indexOf(topicId) === -1) {
          this.newIncoming.push(topicId);
        }
      }
    }, {
      key: "resetTracking",
      value: function () {
        this.newIncoming = [];
        this.set("incomingCount", 0);
      }
    }, {
      key: "trackIncoming",

      // track how many new topics came for this filter
      value: function (filter) {
        this.newIncoming = [];
        var split = filter.split('/');

        if (split.length >= 4) {
          filter = split[split.length - 1];
          // c/cat/subcat/l/latest
          var category = Discourse.Category.findSingleBySlug(split.splice(1, split.length - 3).join('/'));
          this.set("filterCategory", category);
        } else {
          this.set("filterCategory", null);
        }

        this.set("filter", filter);
        this.set("incomingCount", 0);
      }
    }, {
      key: "hasIncoming",
      decorators: [computed("incomingCount")],
      value: function (incomingCount) {
        return incomingCount && incomingCount > 0;
      }
    }, {
      key: "removeTopic",
      value: function (topic_id) {
        delete this.states["t" + topic_id];
      }
    }, {
      key: "updateTopics",

      // If we have a cached topic list, we can update it from our tracking
      // information.
      value: function (topics) {
        if (Em.isEmpty(topics)) {
          return;
        }

        var states = this.states;
        topics.forEach(function (t) {
          var state = states['t' + t.get('id')];

          if (state) {
            var lastRead = t.get('last_read_post_number');
            if (lastRead !== state.last_read_post_number) {
              var postsCount = t.get('posts_count');
              var newPosts = postsCount - state.highest_post_number,
                  unread = postsCount - state.last_read_post_number;

              if (newPosts < 0) {
                newPosts = 0;
              }
              if (!state.last_read_post_number) {
                unread = 0;
              }
              if (unread < 0) {
                unread = 0;
              }

              t.setProperties({
                highest_post_number: state.highest_post_number,
                last_read_post_number: state.last_read_post_number,
                new_posts: newPosts,
                unread: unread,
                unseen: !state.last_read_post_number
              });
            }
          }
        });
      }
    }, {
      key: "sync",
      value: function (list, filter) {
        var tracker = this,
            states = tracker.states;

        if (!list || !list.topics) {
          return;
        }

        // compensate for delayed "new" topics
        // client side we know they are not new, server side we think they are
        for (var i = list.topics.length - 1; i >= 0; i--) {
          var state = states["t" + list.topics[i].id];
          if (state && state.last_read_post_number > 0) {
            if (filter === "new") {
              list.topics.splice(i, 1);
            } else {
              list.topics[i].set('unseen', false);
              list.topics[i].set('dont_sync', true);
            }
          }
        }

        list.topics.forEach(function (topic) {
          var row = tracker.states["t" + topic.id] || {};
          row.topic_id = topic.id;
          row.notification_level = topic.notification_level;

          if (topic.unseen) {
            row.last_read_post_number = null;
          } else if (topic.unread || topic.new_posts) {
            row.last_read_post_number = topic.highest_post_number - ((topic.unread || 0) + (topic.new_posts || 0));
          } else {
            if (!topic.dont_sync) {
              delete tracker.states["t" + topic.id];
            }
            return;
          }

          row.highest_post_number = topic.highest_post_number;
          if (topic.category) {
            row.category_id = topic.category.id;
          }

          tracker.states["t" + topic.id] = row;
        });

        // Correct missing states, safeguard in case message bus is corrupt
        if ((filter === "new" || filter === "unread") && !list.more_topics_url) {
          (function () {

            var ids = {};
            list.topics.forEach(function (r) {
              return ids["t" + r.id] = true;
            });

            _.each(tracker.states, function (v, k) {

              // we are good if we are on the list
              if (ids[k]) {
                return;
              }

              if (filter === "unread" && isUnread(v)) {
                // pretend read
                v.last_read_post_number = v.highest_post_number;
              }

              if (filter === "new" && isNew(v)) {
                // pretend not new
                v.last_read_post_number = 1;
              }
            });
          })();
        }

        this.incrementMessageCount();
      }
    }, {
      key: "incrementMessageCount",
      value: function () {
        this.set("messageCount", this.get("messageCount") + 1);
      }
    }, {
      key: "countNew",
      value: function (category_id) {
        return _.chain(this.states).where(isNew).where(function (topic) {
          return topic.archetype !== "private_message" && !topic.deleted && (topic.category_id === category_id || topic.parent_category_id === category_id || !category_id);
        }).value().length;
      }
    }, {
      key: "resetNew",
      value: function () {
        var _this = this;

        Object.keys(this.states).forEach(function (id) {
          if (_this.states[id].last_read_post_number === null) {
            delete _this.states[id];
          }
        });
      }
    }, {
      key: "countUnread",
      value: function (category_id) {
        return _.chain(this.states).where(isUnread).where(function (topic) {
          return topic.archetype !== "private_message" && !topic.deleted && (topic.category_id === category_id || topic.parent_category_id === category_id || !category_id);
        }).value().length;
      }
    }, {
      key: "countCategory",
      value: function (category_id) {
        var sum = 0;
        _.each(this.states, function (topic) {
          if (topic.category_id === category_id && !topic.deleted) {
            sum += topic.last_read_post_number === null || topic.last_read_post_number < topic.highest_post_number ? 1 : 0;
          }
        });
        return sum;
      }
    }, {
      key: "lookupCount",
      value: function (name, category) {
        if (name === "latest") {
          return this.lookupCount("new", category) + this.lookupCount("unread", category);
        }

        var categoryId = category ? Em.get(category, "id") : null;
        var categoryName = category ? Em.get(category, "name") : null;

        if (name === "new") {
          return this.countNew(categoryId);
        } else if (name === "unread") {
          return this.countUnread(categoryId);
        } else {
          categoryName = name.split("/")[1];
          if (categoryName) {
            return this.countCategory(categoryId);
          }
        }
      }
    }, {
      key: "loadStates",
      value: function (data) {
        var states = this.states;
        var idMap = Discourse.Category.idMap();

        // I am taking some shortcuts here to avoid 500 gets for
        // a large list
        if (data) {
          _.each(data, function (topic) {
            var category = idMap[topic.category_id];
            if (category && category.parent_category_id) {
              topic.parent_category_id = category.parent_category_id;
            }
            states["t" + topic.topic_id] = topic;
          });
        }
      }
    }]));

    function startTracking(tracking) {
      var data = PreloadStore.get('topicTrackingStates');
      tracking.loadStates(data);
      tracking.initialStatesLength = data && data.length;
      tracking.establishChannels();
      PreloadStore.remove('topicTrackingStates');
    }

    __exports__["default"] = TopicTrackingState;
  });
define("discourse/models/trust-level", 
  ["discourse/models/rest","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];
    var fmt = __dependency2__.fmt;

    __exports__["default"] = RestModel.extend({
      detailedName: fmt('id', 'name', '%@ - %@')
    });
  });

Discourse.TrustLevel = require('discourse/models/trust-level').default;
define("discourse/models/user-action-stat", 
  ["discourse/models/rest","discourse/models/user-action","discourse/lib/computed","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];
    var UserAction = __dependency2__["default"];
    var i18n = __dependency3__.i18n;

    __exports__["default"] = RestModel.extend({

      isPM: (function () {
        var actionType = this.get('action_type');
        return actionType === UserAction.TYPES.messages_sent || actionType === UserAction.TYPES.messages_received;
      }).property('action_type'),

      description: i18n('action_type', 'user_action_groups.%@'),

      isResponse: (function () {
        var actionType = this.get('action_type');
        return actionType === UserAction.TYPES.replies || actionType === UserAction.TYPES.quotes;
      }).property('action_type')

    });
  });
define("discourse/models/user-posts-stream", 
  ["discourse/lib/computed","discourse/models/admin-post","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var url = __dependency1__.url;
    var AdminPost = __dependency2__["default"];

    __exports__["default"] = Discourse.Model.extend({
      loaded: false,

      _initialize: (function () {
        this.setProperties({
          itemsLoaded: 0,
          canLoadMore: true,
          content: []
        });
      }).on("init"),

      url: url("user.username_lower", "filter", "itemsLoaded", "/posts/%@/%@?offset=%@"),

      filterBy: function (filter) {
        if (this.get("loaded") && this.get("filter") === filter) {
          return Ember.RSVP.resolve();
        }

        this.setProperties({
          filter: filter,
          itemsLoaded: 0,
          canLoadMore: true,
          content: []
        });

        return this.findItems();
      },

      findItems: function () {
        var self = this;
        if (this.get("loading") || !this.get("canLoadMore")) {
          return Ember.RSVP.reject();
        }

        this.set("loading", true);

        return Discourse.ajax(this.get("url"), { cache: false }).then(function (result) {
          if (result) {
            var posts = result.map(function (post) {
              return AdminPost.create(post);
            });
            self.get("content").pushObjects(posts);
            self.setProperties({
              loaded: true,
              itemsLoaded: self.get("itemsLoaded") + posts.length,
              canLoadMore: posts.length > 0
            });
          }
        }).finally(function () {
          self.set("loading", false);
        });
      }

    });
  });
define("discourse/models/user-stream", 
  ["discourse/lib/computed","discourse/models/rest","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var url = __dependency1__.url;
    var RestModel = __dependency2__["default"];
    var UserAction = __dependency3__["default"];

    __exports__["default"] = RestModel.extend({
      loaded: false,

      _initialize: (function () {
        this.setProperties({ itemsLoaded: 0, content: [] });
      }).on("init"),

      filterParam: (function () {
        var filter = this.get('filter');
        if (filter === Discourse.UserAction.TYPES.replies) {
          return [UserAction.TYPES.replies, UserAction.TYPES.quotes].join(",");
        }

        if (!filter) {
          return [UserAction.TYPES.topics, UserAction.TYPES.posts].join(",");
        }

        return filter;
      }).property('filter'),

      baseUrl: url('itemsLoaded', 'user.username_lower', '/user_actions.json?offset=%@&username=%@'),

      filterBy: function (filter) {
        this.setProperties({ filter: filter, itemsLoaded: 0, content: [], lastLoadedUrl: null });
        return this.findItems();
      },

      remove: function (userAction) {
        // 1) remove the user action from the child groups
        this.get("content").forEach(function (ua) {
          ["likes", "stars", "edits", "bookmarks"].forEach(function (group) {
            var items = ua.get("childGroups." + group + ".items");
            if (items) {
              items.removeObject(userAction);
            }
          });
        });

        // 2) remove the parents that have no children
        var content = this.get("content").filter(function (ua) {
          return ["likes", "stars", "edits", "bookmarks"].any(function (group) {
            return ua.get("childGroups." + group + ".items.length") > 0;
          });
        });

        this.setProperties({ content: content, itemsLoaded: content.length });
      },

      findItems: function () {
        var self = this;

        var findUrl = this.get('baseUrl');
        if (this.get('filterParam')) {
          findUrl += "&filter=" + this.get('filterParam');
        }

        // Don't load the same stream twice. We're probably at the end.
        var lastLoadedUrl = this.get('lastLoadedUrl');
        if (lastLoadedUrl === findUrl) {
          return Ember.RSVP.resolve();
        }

        if (this.get('loading')) {
          return Ember.RSVP.resolve();
        }
        this.set('loading', true);
        return Discourse.ajax(findUrl, { cache: 'false' }).then(function (result) {
          if (result && result.user_actions) {
            (function () {
              var copy = Em.A();
              result.user_actions.forEach(function (action) {
                action.title = Discourse.Emoji.unescape(Handlebars.Utils.escapeExpression(action.title));
                copy.pushObject(UserAction.create(action));
              });

              self.get('content').pushObjects(UserAction.collapseStream(copy));
              self.setProperties({
                loaded: true,
                itemsLoaded: self.get('itemsLoaded') + result.user_actions.length
              });
            })();
          }
        }).finally(function () {
          self.set('loading', false);
          self.set('lastLoadedUrl', findUrl);
        });
      }

    });
  });
define("discourse/models/user", 
  ["discourse/lib/computed","discourse/models/rest","discourse/models/user-stream","discourse/models/user-posts-stream","discourse/mixins/singleton","discourse/lib/formatter","ember-addons/ember-computed-decorators","discourse/models/badge","discourse/models/user-badge","discourse/models/user-action-stat","discourse/models/user-action","discourse/models/group","discourse/models/topic","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __dependency9__, __dependency10__, __dependency11__, __dependency12__, __dependency13__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var url = __dependency1__.url;
    var RestModel = __dependency2__["default"];
    var UserStream = __dependency3__["default"];
    var UserPostsStream = __dependency4__["default"];
    var Singleton = __dependency5__["default"];
    var longDate = __dependency6__.longDate;
    var computed = __dependency7__.default;
    var observes = __dependency7__.observes;
    var Badge = __dependency8__["default"];
    var UserBadge = __dependency9__["default"];
    var UserActionStat = __dependency10__["default"];
    var UserAction = __dependency11__["default"];
    var Group = __dependency12__["default"];
    var Topic = __dependency13__["default"];

    var User = RestModel.extend(_createDecoratedObject([{
      key: 'hasPMs',
      initializer: function () {
        return Em.computed.gt("private_messages_stats.all", 0);
      }
    }, {
      key: 'hasStartedPMs',
      initializer: function () {
        return Em.computed.gt("private_messages_stats.mine", 0);
      }
    }, {
      key: 'hasUnreadPMs',
      initializer: function () {
        return Em.computed.gt("private_messages_stats.unread", 0);
      }
    }, {
      key: 'hasPosted',
      initializer: function () {
        return Em.computed.gt("post_count", 0);
      }
    }, {
      key: 'hasNotPosted',
      initializer: function () {
        return Em.computed.not("hasPosted");
      }
    }, {
      key: 'canBeDeleted',
      initializer: function () {
        return Em.computed.and("can_be_deleted", "hasNotPosted");
      }
    }, {
      key: 'redirected_to_top',
      initializer: function () {
        return {
          reason: null
        };
      }
    }, {
      key: 'stream',
      decorators: [computed()],
      value: function () {
        return UserStream.create({ user: this });
      }
    }, {
      key: 'postsStream',
      decorators: [computed()],
      value: function () {
        return UserPostsStream.create({ user: this });
      }
    }, {
      key: 'staff',
      initializer: function () {
        return Em.computed.or('admin', 'moderator');
      }
    }, {
      key: 'destroySession',
      value: function () {
        return Discourse.ajax('/session/' + this.get('username'), { type: 'DELETE' });
      }
    }, {
      key: 'searchContext',
      decorators: [computed("username_lower")],
      value: function (username) {
        return {
          type: 'user',
          id: username,
          user: this
        };
      }
    }, {
      key: 'displayName',
      decorators: [computed("username", "name")],
      value: function (username, name) {
        if (Discourse.SiteSettings.enable_names && !Ember.isEmpty(name)) {
          return name;
        }
        return username;
      }
    }, {
      key: 'profileBackground',
      decorators: [computed('profile_background')],
      value: function (bgUrl) {
        if (Em.isEmpty(bgUrl) || !Discourse.SiteSettings.allow_profile_backgrounds) {
          return;
        }
        return ('background-image: url(' + Discourse.getURLWithCDN(bgUrl) + ')').htmlSafe();
      }
    }, {
      key: 'path',
      decorators: [computed()],
      value: function () {
        // no need to observe, requires a hard refresh to update
        return Discourse.getURL('/users/' + this.get('username_lower'));
      }
    }, {
      key: 'pmPath',
      value: function (topic) {
        var userId = this.get('id');
        var username = this.get('username_lower');

        var details = topic && topic.get('details');
        var allowedUsers = details && details.get('allowed_users');
        var groups = details && details.get('allowed_groups');

        // directly targetted so go to inbox
        if (!groups || allowedUsers && allowedUsers.findBy("id", userId)) {
          return Discourse.getURL('/users/' + username + '/messages');
        } else {
          if (groups && groups[0]) {
            return Discourse.getURL('/users/' + username + '/messages/group/' + groups[0].name);
          }
        }
      }
    }, {
      key: 'adminPath',
      initializer: function () {
        return url('id', 'username_lower', "/admin/users/%@1/%@2");
      }
    }, {
      key: 'mutedTopicsPath',
      initializer: function () {
        return url('/latest?state=muted');
      }
    }, {
      key: 'username_lower',
      decorators: [computed("username")],
      value: function (username) {
        return username.toLowerCase();
      }
    }, {
      key: 'trustLevel',
      decorators: [computed("trust_level")],
      value: function (trustLevel) {
        return Discourse.Site.currentProp('trustLevels').findProperty('id', parseInt(trustLevel, 10));
      }
    }, {
      key: 'isBasic',
      initializer: function () {
        return Em.computed.equal('trust_level', 0);
      }
    }, {
      key: 'isLeader',
      initializer: function () {
        return Em.computed.equal('trust_level', 3);
      }
    }, {
      key: 'isElder',
      initializer: function () {
        return Em.computed.equal('trust_level', 4);
      }
    }, {
      key: 'canManageTopic',
      initializer: function () {
        return Em.computed.or('staff', 'isElder');
      }
    }, {
      key: 'isSuspended',
      initializer: function () {
        return Em.computed.equal('suspended', true);
      }
    }, {
      key: 'suspended',
      decorators: [computed("suspended_till")],
      value: function (suspendedTill) {
        return suspendedTill && moment(suspendedTill).isAfter();
      }
    }, {
      key: 'suspendedTillDate',
      decorators: [computed("suspended_till")],
      value: function (suspendedTill) {
        return longDate(suspendedTill);
      }
    }, {
      key: 'changeUsername',
      value: function (new_username) {
        return Discourse.ajax('/users/' + this.get('username_lower') + '/preferences/username', {
          type: 'PUT',
          data: { new_username: new_username }
        });
      }
    }, {
      key: 'changeEmail',
      value: function (email) {
        return Discourse.ajax('/users/' + this.get('username_lower') + '/preferences/email', {
          type: 'PUT',
          data: { email: email }
        });
      }
    }, {
      key: 'copy',
      value: function () {
        return Discourse.User.create(this.getProperties(Object.keys(this)));
      }
    }, {
      key: 'save',
      value: function () {
        var _this = this;

        var data = this.getProperties('bio_raw', 'website', 'location', 'name', 'locale', 'custom_fields', 'user_fields', 'muted_usernames', 'profile_background', 'card_background');

        ['email_always', 'mailing_list_mode', 'external_links_in_new_tab', 'email_digests', 'email_direct', 'email_in_reply_to', 'email_private_messages', 'email_previous_replies', 'dynamic_favicon', 'enable_quoting', 'disable_jump_reply', 'automatically_unpin_topics', 'digest_after_minutes', 'new_topic_duration_minutes', 'auto_track_topics_after_msecs', 'like_notification_frequency', 'include_tl0_in_digests'].forEach(function (s) {
          data[s] = _this.get('user_option.' + s);
        });

        ['muted', 'watched', 'tracked'].forEach(function (s) {
          var cats = _this.get(s + 'Categories').map(function (c) {
            return c.get('id');
          });
          // HACK: denote lack of categories
          if (cats.length === 0) {
            cats = [-1];
          }
          data[s + '_category_ids'] = cats;
        });

        if (!Discourse.SiteSettings.edit_history_visible_to_public) {
          data['edit_history_public'] = this.get('user_option.edit_history_public');
        }

        // TODO: We can remove this when migrated fully to rest model.
        this.set('isSaving', true);
        return Discourse.ajax('/users/' + this.get('username_lower'), {
          data: data,
          type: 'PUT'
        }).then(function (result) {
          _this.set('bio_excerpt', result.user.bio_excerpt);
          var userProps = Em.getProperties(_this.get('user_option'), 'enable_quoting', 'external_links_in_new_tab', 'dynamic_favicon');
          Discourse.User.current().setProperties(userProps);
        }).finally(function () {
          _this.set('isSaving', false);
        });
      }
    }, {
      key: 'changePassword',
      value: function () {
        return Discourse.ajax("/session/forgot_password", {
          dataType: 'json',
          data: { login: this.get('username') },
          type: 'POST'
        });
      }
    }, {
      key: 'loadUserAction',
      value: function (id) {
        var _this2 = this;

        var stream = this.get('stream');
        return Discourse.ajax('/user_actions/' + id + '.json', { cache: 'false' }).then(function (result) {
          if (result && result.user_action) {
            var ua = result.user_action;

            if ((_this2.get('stream.filter') || ua.action_type) !== ua.action_type) return;
            if (!_this2.get('stream.filter') && !_this2.inAllStream(ua)) return;

            ua.title = Discourse.Emoji.unescape(Handlebars.Utils.escapeExpression(ua.title));
            var action = UserAction.collapseStream([UserAction.create(ua)]);
            stream.set('itemsLoaded', stream.get('itemsLoaded') + 1);
            stream.get('content').insertAt(0, action[0]);
          }
        });
      }
    }, {
      key: 'inAllStream',
      value: function (ua) {
        return ua.action_type === UserAction.TYPES.posts || ua.action_type === UserAction.TYPES.topics;
      }
    }, {
      key: 'displayGroups',
      decorators: [computed("groups.[]")],
      value: function () {
        var groups = this.get('groups');
        var filtered = groups.filter(function (group) {
          return !group.automatic || group.name === "moderators";
        });
        return filtered.length === 0 ? null : filtered;
      }
    }, {
      key: 'statsCountNonPM',
      decorators: [computed("statsExcludingPms.@each.count")],
      value: function () {
        var _this3 = this;

        if (Ember.isEmpty(this.get('statsExcludingPms'))) return 0;
        var count = 0;
        _.each(this.get('statsExcludingPms'), function (val) {
          if (_this3.inAllStream(val)) {
            count += val.count;
          }
        });
        return count;
      }
    }, {
      key: 'statsExcludingPms',
      decorators: [computed("stats.@each.isPM")],
      value: function () {
        if (Ember.isEmpty(this.get('stats'))) return [];
        return this.get('stats').rejectProperty('isPM');
      }
    }, {
      key: 'findDetails',
      value: function (options) {
        var user = this;

        return PreloadStore.getAndRemove('user_' + user.get('username'), function () {
          return Discourse.ajax('/users/' + user.get('username') + '.json', { data: options });
        }).then(function (json) {

          if (!Em.isEmpty(json.user.stats)) {
            json.user.stats = Discourse.User.groupStats(_.map(json.user.stats, function (s) {
              if (s.count) s.count = parseInt(s.count, 10);
              return UserActionStat.create(s);
            }));
          }

          if (!Em.isEmpty(json.user.groups)) {
            json.user.groups = json.user.groups.map(function (g) {
              return Group.create(g);
            });
          }

          if (json.user.invited_by) {
            json.user.invited_by = Discourse.User.create(json.user.invited_by);
          }

          if (!Em.isEmpty(json.user.featured_user_badge_ids)) {
            (function () {
              var userBadgesMap = {};
              UserBadge.createFromJson(json).forEach(function (userBadge) {
                userBadgesMap[userBadge.get('id')] = userBadge;
              });
              json.user.featured_user_badges = json.user.featured_user_badge_ids.map(function (id) {
                return userBadgesMap[id];
              });
            })();
          }

          if (json.user.card_badge) {
            json.user.card_badge = Badge.create(json.user.card_badge);
          }

          user.setProperties(json.user);
          return user;
        });
      }
    }, {
      key: 'findStaffInfo',
      value: function () {
        var _this4 = this;

        if (!Discourse.User.currentProp("staff")) {
          return Ember.RSVP.resolve(null);
        }
        return Discourse.ajax('/users/' + this.get("username_lower") + '/staff-info.json').then(function (info) {
          _this4.setProperties(info);
        });
      }
    }, {
      key: 'pickAvatar',
      value: function (upload_id, type, avatar_template) {
        var _this5 = this;

        return Discourse.ajax('/users/' + this.get("username_lower") + '/preferences/avatar/pick', {
          type: 'PUT',
          data: { upload_id: upload_id, type: type }
        }).then(function () {
          return _this5.setProperties({
            avatar_template: avatar_template,
            uploaded_avatar_id: upload_id
          });
        });
      }
    }, {
      key: 'isAllowedToUploadAFile',
      value: function (type) {
        return this.get('staff') || this.get('trust_level') > 0 || Discourse.SiteSettings['newuser_max_' + type + 's'] > 0;
      }
    }, {
      key: 'createInvite',
      value: function (email, group_names) {
        return Discourse.ajax('/invites', {
          type: 'POST',
          data: { email: email, group_names: group_names }
        });
      }
    }, {
      key: 'generateInviteLink',
      value: function (email, group_names, topic_id) {
        return Discourse.ajax('/invites/link', {
          type: 'POST',
          data: { email: email, group_names: group_names, topic_id: topic_id }
        });
      }
    }, {
      key: 'updateMutedCategories',
      decorators: [observes("muted_category_ids")],
      value: function () {
        this.set("mutedCategories", Discourse.Category.findByIds(this.muted_category_ids));
      }
    }, {
      key: 'updateTrackedCategories',
      decorators: [observes("tracked_category_ids")],
      value: function () {
        this.set("trackedCategories", Discourse.Category.findByIds(this.tracked_category_ids));
      }
    }, {
      key: 'updateWatchedCategories',
      decorators: [observes("watched_category_ids")],
      value: function () {
        this.set("watchedCategories", Discourse.Category.findByIds(this.watched_category_ids));
      }
    }, {
      key: 'canDeleteAccount',
      decorators: [computed("can_delete_account", "reply_count", "topic_count")],
      value: function (canDeleteAccount, replyCount, topicCount) {
        return !Discourse.SiteSettings.enable_sso && canDeleteAccount && (replyCount || 0) + (topicCount || 0) <= 1;
      }
    }, {
      key: "delete",
      initializer: function () {
        return function () {
          if (this.get('can_delete_account')) {
            return Discourse.ajax("/users/" + this.get('username'), {
              type: 'DELETE',
              data: { context: window.location.pathname }
            });
          } else {
            return Ember.RSVP.reject(I18n.t('user.delete_yourself_not_allowed'));
          }
        };
      }
    }, {
      key: 'dismissBanner',
      value: function (bannerKey) {
        this.set("dismissed_banner_key", bannerKey);
        Discourse.ajax('/users/' + this.get('username'), {
          type: 'PUT',
          data: { dismissed_banner_key: bannerKey }
        });
      }
    }, {
      key: 'checkEmail',
      value: function () {
        var _this6 = this;

        return Discourse.ajax('/users/' + this.get("username_lower") + '/emails.json', {
          type: "PUT",
          data: { context: window.location.pathname }
        }).then(function (result) {
          if (result) {
            _this6.setProperties({
              email: result.email,
              associated_accounts: result.associated_accounts
            });
          }
        });
      }
    }, {
      key: 'summary',
      value: function () {
        return Discourse.ajax('/users/' + this.get("username_lower") + '/summary.json').then(function (json) {
          var summary = json["user_summary"];
          var topicMap = {};
          var badgeMap = {};

          json.topics.forEach(function (t) {
            return topicMap[t.id] = Topic.create(t);
          });
          Badge.createFromJson(json).forEach(function (b) {
            return badgeMap[b.id] = b;
          });

          summary.topics = summary.topic_ids.map(function (id) {
            return topicMap[id];
          });

          summary.replies.forEach(function (r) {
            r.topic = topicMap[r.topic_id];
            r.url = r.topic.urlForPostNumber(r.post_number);
            r.createdAt = new Date(r.created_at);
          });

          summary.links.forEach(function (l) {
            l.topic = topicMap[l.topic_id];
            l.post_url = l.topic.urlForPostNumber(l.post_number);
          });

          if (summary.badges) {
            summary.badges = summary.badges.map(function (ub) {
              var badge = badgeMap[ub.badge_id];
              badge.count = ub.count;
              return badge;
            });
          }

          return summary;
        });
      }
    }]));

    User.reopenClass(Singleton, {

      // Find a `Discourse.User` for a given username.
      findByUsername: function (username, options) {
        var user = User.create({ username: username });
        return user.findDetails(options);
      },

      // TODO: Use app.register and junk Singleton
      createCurrent: function () {
        var userJson = PreloadStore.get('currentUser');
        if (userJson) {
          var store = Discourse.__container__.lookup('store:main');
          return store.createRecord('user', userJson);
        }
        return null;
      },

      checkUsername: function (username, email, for_user_id) {
        return Discourse.ajax('/users/check_username', {
          data: { username: username, email: email, for_user_id: for_user_id }
        });
      },

      groupStats: function (stats) {
        var responses = UserActionStat.create({
          count: 0,
          action_type: UserAction.TYPES.replies
        });

        stats.filterProperty('isResponse').forEach(function (stat) {
          responses.set('count', responses.get('count') + stat.get('count'));
        });

        var result = Em.A();
        result.pushObjects(stats.rejectProperty('isResponse'));

        var insertAt = 0;
        result.forEach(function (item, index) {
          if (item.action_type === UserAction.TYPES.topics || item.action_type === UserAction.TYPES.posts) {
            insertAt = index + 1;
          }
        });
        if (responses.count > 0) {
          result.insertAt(insertAt, responses);
        }
        return result;
      },

      createAccount: function (attrs) {
        return Discourse.ajax("/users", {
          data: {
            name: attrs.accountName,
            email: attrs.accountEmail,
            password: attrs.accountPassword,
            username: attrs.accountUsername,
            password_confirmation: attrs.accountPasswordConfirm,
            challenge: attrs.accountChallenge,
            user_fields: attrs.userFields
          },
          type: 'POST'
        });
      }
    });

    __exports__["default"] = User;

    // The user's stat count, excluding PMs.

    // The user's stats, excluding PMs.
  });

Discourse.User = require('discourse/models/user').default;
define("discourse/components/activity-filter", 
  ["discourse/mixins/string-buffer","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      tagName: 'li',
      classNameBindings: ['active', 'noGlyph'],

      rerenderTriggers: ['content.count', 'count'],
      noGlyph: Em.computed.empty('icon'),

      isIndexStream: (function () {
        return !this.get('content');
      }).property('content.count'),

      active: (function () {
        if (this.get('isIndexStream')) {
          return !this.get('userActionType');
        }
        var content = this.get('content');
        if (content) {
          return parseInt(this.get('userActionType'), 10) === parseInt(Em.get(content, 'action_type'), 10);
        }
      }).property('userActionType', 'isIndexStream'),

      activityCount: (function () {
        return this.get('content.count') || this.get('count') || 0;
      }).property('content.count', 'count'),

      typeKey: (function () {
        var actionType = this.get('content.action_type');
        if (actionType === UserAction.TYPES.messages_received) {
          return "";
        }

        var result = UserAction.TYPES_INVERTED[actionType];
        if (!result) {
          return "";
        }

        // We like our URLS to have hyphens, not underscores
        return "/" + result.replace("_", "-");
      }).property('content.action_type'),

      url: (function () {
        return "/users/" + this.get('user.username_lower') + "/activity" + this.get('typeKey');
      }).property('typeKey', 'user.username_lower'),

      description: (function () {
        return this.get('content.description') || I18n.t("user.filters.all");
      }).property('content.description'),

      renderString: function (buffer) {
        buffer.push("<a href='" + this.get('url') + "'>");
        var icon = this.get('icon');
        if (icon) {
          buffer.push("<i class='glyph fa fa-" + icon + "'></i> ");
        }
        buffer.push(this.get('description') + " <span class='count'>(" + this.get('activityCount') + ")</span></a>");
      },

      icon: (function () {
        switch (parseInt(this.get('content.action_type'), 10)) {
          case UserAction.TYPES.likes_received:
            return "heart";
          case UserAction.TYPES.bookmarks:
            return "bookmark";
          case UserAction.TYPES.edits:
            return "pencil";
          case UserAction.TYPES.replies:
            return "reply";
          case UserAction.TYPES.mentions:
            return "at";
        }
      }).property("content.action_type")
    });
  });
define("discourse/components/auto-close-form", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var observes = __dependency1__.observes;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: "limited",
      initializer: function () {
        return false;
      }
    }, {
      key: "autoCloseValid",
      initializer: function () {
        return false;
      }
    }, {
      key: "autoCloseUnits",
      decorators: [computed("limited")],
      value: function (limited) {
        var key = limited ? "composer.auto_close.limited.units" : "composer.auto_close.all.units";
        return I18n.t(key);
      }
    }, {
      key: "autoCloseExamples",
      decorators: [computed("limited")],
      value: function (limited) {
        var key = limited ? "composer.auto_close.limited.examples" : "composer.auto_close.all.examples";
        return I18n.t(key);
      }
    }, {
      key: "_updateAutoCloseValid",
      decorators: [observes("autoCloseTime", "limited")],
      value: function () {
        var limited = this.get("limited"),
            autoCloseTime = this.get("autoCloseTime"),
            isValid = this._isAutoCloseValid(autoCloseTime, limited);
        this.set("autoCloseValid", isValid);
      }
    }, {
      key: "_isAutoCloseValid",
      value: function (autoCloseTime, limited) {
        var t = (autoCloseTime || "").toString().trim();
        if (t.length === 0) {
          // "empty" is always valid
          return true;
        } else if (limited) {
          // only # of hours in limited mode
          return t.match(/^(\d+\.)?\d+$/);
        } else {
          if (t.match(/^\d{4}-\d{1,2}-\d{1,2}(?: \d{1,2}:\d{2}(\s?[AP]M)?){0,1}$/i)) {
            // timestamp must be in the future
            return moment(t).isAfter();
          } else {
            // either # of hours or absolute time
            return (t.match(/^(\d+\.)?\d+$/) || t.match(/^\d{1,2}:\d{2}(\s?[AP]M)?$/i)) !== null;
          }
        }
      }
    }]));
  });
define("discourse/components/avatar-uploader", 
  ["ember-addons/ember-computed-decorators","discourse/mixins/upload","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var UploadMixin = __dependency2__["default"];

    __exports__["default"] = Em.Component.extend(UploadMixin, _createDecoratedObject([{
      key: "type",
      initializer: function () {
        return "avatar";
      }
    }, {
      key: "tagName",
      initializer: function () {
        return "span";
      }
    }, {
      key: "imageIsNotASquare",
      initializer: function () {
        return false;
      }
    }, {
      key: "uploadButtonText",
      decorators: [computed("uploading")],
      value: function (uploading) {
        return uploading ? I18n.t("uploading") : I18n.t("user.change_avatar.upload_picture");
      }
    }, {
      key: "uploadDone",
      value: function (upload) {
        this.setProperties({
          imageIsNotASquare: upload.width !== upload.height,
          uploadedAvatarTemplate: upload.url,
          uploadedAvatarId: upload.id
        });

        this.sendAction("done");
      }
    }, {
      key: "data",
      decorators: [computed("user_id")],
      value: function (user_id) {
        return { user_id: user_id };
      }
    }]));
  });
define("discourse/components/badge-button", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'span',
      classNameBindings: [':user-badge', 'badge.badgeTypeClassName'],
      title: (function () {
        return $("<div>" + this.get('badge.description') + "</div>").text();
      }).property('badge.description'),
      attributeBindings: ['data-badge-name', 'title'],
      'data-badge-name': Em.computed.alias('badge.name')
    });
  });
define("discourse/components/badge-card", 
  ["ember-addons/ember-computed-decorators","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var DiscourseURL = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'size',
      initializer: function () {
        return 'medium';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return [':badge-card', 'size', 'navigateOnClick:hyperlink'];
      }
    }, {
      key: 'click',
      value: function (e) {
        if (e.target && e.target.nodeName === "A") {
          return true;
        }

        if (!this.get('navigateOnClick')) {
          return false;
        }

        var url = this.get('badge.url');
        var username = this.get('username');
        if (username) {
          url = url + "?username=" + encodeURIComponent(username);
        }
        DiscourseURL.routeTo(url);
        return true;
      }
    }, {
      key: 'displayCount',
      decorators: [computed('count', 'badge.grant_count')],
      value: function (count, grantCount) {
        if (count == null) {
          return grantCount;
        }
        if (count > 1) {
          return count;
        }
      }
    }, {
      key: 'summary',
      decorators: [computed('size')],
      value: function (size) {
        if (size === 'large') {
          var longDescription = this.get('badge.long_description');
          if (!_.isEmpty(longDescription)) {
            return Discourse.Emoji.unescape(longDescription);
          }
        }
        return this.get('badge.description');
      }
    }]));
  });
define("discourse/components/basic-topic-list", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      loadingMore: Ember.computed.alias('topicList.loadingMore'),
      loading: Ember.computed.not('loaded'),

      loaded: (function () {
        var topicList = this.get('topicList');
        if (topicList) {
          return topicList.get('loaded');
        } else {
          return true;
        }
      }).property('topicList.loaded'),

      _topicListChanged: (function () {
        this._initFromTopicList(this.get('topicList'));
      }).observes('topicList.[]'),

      _initFromTopicList: function (topicList) {
        if (topicList !== null) {
          this.set('topics', topicList.get('topics'));
          this.rerender();
        }
      },

      init: function () {
        this._super();
        var topicList = this.get('topicList');
        if (topicList) {
          this._initFromTopicList(topicList);
        } else {
          // Without a topic list, we assume it's loaded always.
          this.set('loaded', true);
        }
      },

      click: function (e) {
        // Mobile basic-topic-list doesn't use the `topic-list-item` view so
        // the event for the topic entrance is never wired up.
        if (!this.site.mobileView) {
          return;
        }

        var target = $(e.target);

        if (target.hasClass('posts-map')) {
          var topicId = target.closest('tr').attr('data-topic-id');
          if (topicId) {
            if (target.prop('tagName') !== 'A') {
              target = target.find('a');
            }

            var topic = this.get('topics').findProperty('id', parseInt(topicId));
            this.sendAction('postsAction', { topic: topic, position: target.offset() });
          }
          return false;
        }
      }

    });
  });
define("discourse/components/bread-crumbs", 
  ["exports"],
  function(__exports__) {
    "use strict";
    //  A breadcrumb including category drop downs
    __exports__["default"] = Ember.Component.extend({
      classNameBindings: ['hidden:hidden', ':category-breadcrumb'],
      tagName: 'ol',
      parentCategory: Em.computed.alias('category.parentCategory'),

      parentCategories: Em.computed.filter('categories', function (c) {
        if (c.id === this.site.get("uncategorized_category_id") && !this.siteSettings.allow_uncategorized_topics) {
          // Don't show "uncategorized" if allow_uncategorized_topics setting is false.
          return false;
        }
        return !c.get('parentCategory');
      }),

      hidden: (function () {
        return this.site.mobileView && !this.get('category');
      }).property('category'),

      firstCategory: (function () {
        return this.get('parentCategory') || this.get('category');
      }).property('parentCategory', 'category'),

      secondCategory: (function () {
        if (this.get('parentCategory')) return this.get('category');
        return null;
      }).property('category', 'parentCategory'),

      childCategories: (function () {
        if (this.get('hideSubcategories')) {
          return [];
        }
        var firstCategory = this.get('firstCategory');
        if (!firstCategory) {
          return [];
        }

        return this.get('categories').filter(function (c) {
          return c.get('parentCategory') === firstCategory;
        });
      }).property('firstCategory', 'hideSubcategories'),

      render: function (buffer) {
        if (this.get('hidden')) {
          return;
        }
        this._super(buffer);
      }

    });
  });
define("discourse/components/bulk-select-button", 
  ["discourse/lib/show-modal","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var showModal = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend({
      actions: {
        showBulkActions: function () {
          var _this = this;

          var controller = showModal('topic-bulk-actions', { model: this.get('selected'), title: 'topics.bulk.actions' });
          controller.set('refreshClosure', function () {
            return _this.sendAction();
          });
        }
      }
    });
  });
define("discourse/components/categories-admin-dropdown", 
  ["discourse/helpers/fa-icon","discourse/components/dropdown-button","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var iconHTML = __dependency1__.iconHTML;
    var DropdownButton = __dependency2__["default"];
    var computed = __dependency3__["default"];

    __exports__["default"] = DropdownButton.extend(_createDecoratedObject([{
      key: 'buttonExtraClasses',
      initializer: function () {
        return 'no-text';
      }
    }, {
      key: 'title',
      initializer: function () {
        return '';
      }
    }, {
      key: 'text',
      initializer: function () {
        return iconHTML('bars') + ' ' + iconHTML('caret-down');
      }
    }, {
      key: 'classNames',
      initializer: function () {
        return ['category-notification-menu', 'category-admin-menu'];
      }
    }, {
      key: 'dropDownContent',
      decorators: [computed()],
      value: function () {
        var includeReorder = this.get('siteSettings.fixed_category_positions');
        var items = [{ id: 'create',
          title: I18n.t('category.create'),
          description: I18n.t('category.create_long'),
          styleClasses: 'fa fa-plus' }];
        if (includeReorder) {
          items.push({
            id: 'reorder',
            title: I18n.t('categories.reorder.title'),
            description: I18n.t('categories.reorder.title_long'),
            styleClasses: 'fa fa-random'
          });
        }
        return items;
      }
    }, {
      key: 'actionNames',
      initializer: function () {
        return {
          create: 'createCategory',
          reorder: 'reorderCategories'
        };
      }
    }, {
      key: 'clicked',
      value: function (id) {
        this.sendAction('actionNames.' + id);
      }
    }]));
  });
define("discourse/components/category-chooser", 
  ["discourse/components/combo-box","discourse/helpers/category-link","ember-addons/ember-computed-decorators","discourse/models/permission-type","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ComboboxView = __dependency1__["default"];
    var categoryBadgeHTML = __dependency2__.categoryBadgeHTML;
    var computed = __dependency3__["default"];
    var observes = __dependency3__.observes;
    var on = __dependency3__.on;
    var PermissionType = __dependency4__["default"];

    __exports__["default"] = ComboboxView.extend(_createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['combobox category-combobox'];
      }
    }, {
      key: 'dataAttributes',
      initializer: function () {
        return ['id', 'description_text'];
      }
    }, {
      key: 'overrideWidths',
      initializer: function () {
        return true;
      }
    }, {
      key: 'castInteger',
      initializer: function () {
        return true;
      }
    }, {
      key: 'content',
      decorators: [computed("scopedCategoryId", "categories")],
      value: function (scopedCategoryId, categories) {
        // Always scope to the parent of a category, if present
        if (scopedCategoryId) {
          var scopedCat = Discourse.Category.findById(scopedCategoryId);
          scopedCategoryId = scopedCat.get('parent_category_id') || scopedCat.get('id');
        }

        return categories.filter(function (c) {
          if (scopedCategoryId && c.get('id') !== scopedCategoryId && c.get('parent_category_id') !== scopedCategoryId) {
            return false;
          }
          if (c.get('isUncategorizedCategory')) {
            return false;
          }
          return c.get('permission') === PermissionType.FULL;
        });
      }
    }, {
      key: '_updateCategories',
      decorators: [observes("site.sortedCategories"), on("init")],
      value: function () {
        if (!this.get('categories')) {
          var categories = Discourse.SiteSettings.fixed_category_positions_on_create ? Discourse.Category.list() : Discourse.Category.listByActivity();
          this.set('categories', categories);
        }
      }
    }, {
      key: 'none',
      decorators: [computed("rootNone")],
      value: function (rootNone) {
        if (Discourse.SiteSettings.allow_uncategorized_topics) {
          if (rootNone) {
            return "category.none";
          } else {
            return Discourse.Category.findUncategorized();
          }
        } else {
          return 'category.choose';
        }
      }
    }, {
      key: 'comboTemplate',
      value: function (item) {
        var category = undefined;

        // If we have no id, but text with the uncategorized name, we can use that badge.
        if (Ember.isEmpty(item.id)) {
          var uncat = Discourse.Category.findUncategorized();
          if (uncat && uncat.get('name') === item.text) {
            category = uncat;
          }
        } else {
          category = Discourse.Category.findById(parseInt(item.id, 10));
        }

        if (!category) return item.text;
        var result = categoryBadgeHTML(category, { link: false, allowUncategorized: true, hideParent: true });
        var parentCategoryId = category.get('parent_category_id');

        if (parentCategoryId) {
          result = categoryBadgeHTML(Discourse.Category.findById(parentCategoryId), { link: false }) + "&nbsp;" + result;
        }

        result += ' <span class=\'topic-count\'>&times; ' + category.get('topic_count') + '</span>';

        var description = category.get('description');
        // TODO wtf how can this be null?;
        if (description && description !== 'null') {
          result += '<div class="category-desc">' + description.substr(0, 200) + (description.length > 200 ? '&hellip;' : '') + '</div>';
        }

        return result;
      }
    }]));
  });
define("discourse/components/category-drop", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var setting = __dependency1__.setting;
    var get = Ember.get;

    __exports__["default"] = Ember.Component.extend({
      classNameBindings: ['category::no-category', 'categories:has-drop', 'categoryStyle'],
      categoryStyle: setting('category_style'),
      expanded: false,

      tagName: 'li',

      iconClass: (function () {
        if (this.get('expanded')) {
          return "fa fa-caret-down";
        }
        return "fa fa-caret-right";
      }).property('expanded'),

      allCategoriesUrl: (function () {
        if (this.get('subCategory')) {
          return this.get('parentCategory.url') || "/";
        } else {
          return "/";
        }
      }).property('parentCategory.url', 'subCategory'),

      noCategoriesUrl: (function () {
        return this.get('parentCategory.url') + "/none";
      }).property('parentCategory.url'),

      allCategoriesLabel: (function () {
        if (this.get('subCategory')) {
          return I18n.t('categories.all_subcategories', { categoryName: this.get('parentCategory.name') });
        }
        return I18n.t('categories.all');
      }).property('category'),

      dropdownButtonClass: (function () {
        var result = 'badge-category category-dropdown-button';
        if (Em.isNone(this.get('category'))) {
          result += ' home';
        }
        return result;
      }).property('category'),

      categoryColor: (function () {
        var category = this.get('category');

        if (category) {
          var color = get(category, 'color');

          if (color) {
            var style = "";
            if (color) {
              style += "background-color: #" + color + ";";
            }
            return style.htmlSafe();
          }
        }

        return "background-color: #eee;".htmlSafe();
      }).property('category'),

      badgeStyle: (function () {
        var category = this.get('category');

        if (category) {
          var color = get(category, 'color'),
              textColor = get(category, 'text_color');

          if (color || textColor) {
            var style = "";
            if (color) {
              style += "background-color: #" + color + "; border-color: #" + color + ";";
            }
            if (textColor) {
              style += "color: #" + textColor + "; ";
            }
            return style.htmlSafe();
          }
        }

        return "background-color: #eee; color: #333".htmlSafe();
      }).property('category'),

      clickEventName: (function () {
        return "click.category-drop-" + (this.get('category.id') || "all");
      }).property('category.id'),

      actions: {
        expand: function () {
          var self = this;

          if (!this.get('renderCategories')) {
            this.set('renderCategories', true);
            Em.run.next(function () {
              self.send('expand');
            });
            return;
          }

          if (this.get('expanded')) {
            this.close();
            return;
          }

          if (this.get('categories')) {
            this.set('expanded', true);
          }
          var $dropdown = this.$()[0];

          this.$('a[data-drop-close]').on('click.category-drop', function () {
            self.close();
          });

          Em.run.next(function () {
            self.$('.cat a').add('html').on(self.get('clickEventName'), function (e) {
              var $target = $(e.target),
                  closest = $target.closest($dropdown);

              if ($(e.currentTarget).hasClass('badge-wrapper')) {
                self.close();
              }

              return $(e.currentTarget).hasClass('badge-category') || closest.length && closest[0] === $dropdown ? true : self.close();
            });
          });
        }
      },

      removeEvents: function () {
        $('html').off(this.get('clickEventName'));
        this.$('a[data-drop-close]').off('click.category-drop');
      },

      close: function () {
        this.removeEvents();
        this.set('expanded', false);
      },

      willDestroyElement: function () {
        this.removeEvents();
      }

    });
  });
define("discourse/components/category-group", 
  ["discourse/helpers/category-link","discourse/models/category","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var categoryBadgeHTML = __dependency1__.categoryBadgeHTML;
    var Category = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend({

      _initializeAutocomplete: (function () {
        var self = this,
            template = this.container.lookup('template:category-group-autocomplete.raw'),
            regexp = new RegExp('href=[\'"]' + Discourse.getURL('/c/') + '([^\'"]+)');

        this.$('input').autocomplete({
          items: this.get('categories'),
          single: false,
          allowAny: false,
          dataSource: function (term) {
            return Category.list().filter(function (category) {
              var regex = new RegExp(term, "i");
              return category.get("name").match(regex) && !_.contains(self.get('blacklist') || [], category) && !_.contains(self.get('categories'), category);
            });
          },
          onChangeItems: function (items) {
            var categories = _.map(items, function (link) {
              var slug = link.match(regexp)[1];
              return Category.findSingleBySlug(slug);
            });
            Em.run.next(function () {
              return self.set("categories", categories);
            });
          },
          template: template,
          transformComplete: function (category) {
            return categoryBadgeHTML(category, { allowUncategorized: true });
          }
        });
      }).on('didInsertElement')

    });
  });
define("discourse/components/category-logo-link", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.Component.extend({
      tagName: 'a',
      attributeBindings: ['href'],
      href: (function () {
        return Discourse.getURL('/c/') + Discourse.Category.slugFor(this.get('category'));
      }).property(),

      render: function (buffer) {
        var categoryLogo = this.get('category.logo_url');
        buffer.push('<img class="category-logo" src=\'' + categoryLogo + '\'/>');
      }
    });
  });
define("discourse/components/category-notifications-button", 
  ["discourse/components/notifications-button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var NotificationsButton = __dependency1__["default"];

    __exports__["default"] = NotificationsButton.extend({
      classNames: ['notification-options', 'category-notification-menu'],
      buttonIncludesText: false,
      hidden: Em.computed.alias('category.deleted'),
      notificationLevel: Em.computed.alias('category.notification_level'),
      i18nPrefix: 'category.notifications',

      clicked: function (id) {
        this.get('category').setNotification(id);
      }
    });
  });
define("discourse/components/category-panel-base", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.buildCategoryPanel = buildCategoryPanel;
    var CategoryPanelBase = Ember.Component.extend({
      classNameBindings: [':modal-tab', 'activeTab::invisible']
    });

    __exports__["default"] = CategoryPanelBase;

    function buildCategoryPanel(tab, extras) {
      return CategoryPanelBase.extend({
        activeTab: Ember.computed.equal('selectedTab', tab)
      }, extras || {});
    }
  });
define("discourse/components/category-title-link", 
  ["discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var iconHTML = __dependency1__.iconHTML;

    __exports__["default"] = Em.Component.extend({
      tagName: 'h3',

      render: function (buffer) {
        var category = this.get('category');
        var categoryUrl = Discourse.getURL('/c/') + Discourse.Category.slugFor(category);
        var categoryName = Handlebars.Utils.escapeExpression(category.get('name'));

        if (category.get('read_restricted')) {
          buffer.push(iconHTML('lock'));
        }

        buffer.push('<a href=\'' + categoryUrl + '\'>');
        buffer.push('<span class=\'category-name\'>' + categoryName + '</span>');
        buffer.push('</a>');
      }
    });
  });
define("discourse/components/category-unread", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'span'
    });
  });
define("discourse/components/cdn-img", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'img',
      attributeBindings: ['cdnSrc:src'],

      cdnSrc: (function () {
        return Discourse.getURLWithCDN(this.get('src'));
      }).property('src')
    });
  });
define("discourse/components/check-mark", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'span';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return [':check-display', 'status'];
      }
    }, {
      key: 'status',
      decorators: [computed('checked')],
      value: function (checked) {
        return checked ? 'status-checked' : 'status-unchecked';
      }
    }, {
      key: 'render',
      value: function (buffer) {
        var icon = this.get('checked') ? 'check' : 'times';
        buffer.push('<i class=\'fa fa-' + icon + '\'></i>');
      }
    }]));
  });
define("discourse/components/choose-topic", 
  ["discourse/lib/debounce","discourse/lib/search","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var debounce = __dependency1__["default"];
    var searchForTerm = __dependency2__.searchForTerm;

    __exports__["default"] = Ember.Component.extend({
      loading: null,
      noResults: null,
      topics: null,

      topicTitleChanged: (function () {
        this.setProperties({
          loading: true,
          noResults: true,
          selectedTopicId: null
        });
        this.search(this.get('topicTitle'));
      }).observes('topicTitle'),

      topicsChanged: (function () {
        var topics = this.get('topics');
        if (topics) {
          this.set('noResults', topics.length === 0);
        }
        this.set('loading', false);
      }).observes('topics'),

      search: debounce(function (title) {
        var self = this,
            currentTopicId = this.get("currentTopicId");

        if (Em.isEmpty(title)) {
          self.setProperties({ topics: null, loading: false });
          return;
        }

        searchForTerm(title, { typeFilter: 'topic', searchForId: true }).then(function (results) {
          if (results && results.posts && results.posts.length > 0) {
            self.set('topics', results.posts.mapBy('topic').filter(function (t) {
              return t.get("id") !== currentTopicId;
            }));
          } else {
            self.setProperties({ topics: null, loading: false });
          }
        });
      }, 300),

      actions: {
        chooseTopic: function (topic) {
          var topicId = Em.get(topic, 'id');
          this.set('selectedTopicId', topicId);
          Ember.run.next(function () {
            return $('#choose-topic-' + topicId).prop('checked', 'true');
          });
          return false;
        }
      }

    });
  });
define("discourse/components/color-picker", 
  ["discourse/views/container","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseContainerView = __dependency1__["default"];

    __exports__["default"] = DiscourseContainerView.extend({
      classNames: 'colors-container',

      _createButtons: (function () {
        var colors = this.get('colors'),
            isUsed,
            usedColors = this.get('usedColors') || [];

        if (!colors) return;

        var self = this;
        colors.forEach(function (color) {
          isUsed = usedColors.indexOf(color.toUpperCase()) >= 0;

          self.attachViewWithArgs({
            tagName: 'button',
            attributeBindings: ['style', 'title'],
            classNames: ['colorpicker'].concat(isUsed ? ['used-color'] : ['unused-color']),
            style: ('background-color: #' + color + ';').htmlSafe(),
            title: isUsed ? I18n.t("category.already_used") : null,
            click: function () {
              self.set("value", color);
              return false;
            }
          });
        });
      }).on('init')
    });
  });
define("discourse/components/composer-editor", 
  ["discourse/lib/user-search","ember-addons/ember-computed-decorators","discourse/lib/link-mentions","discourse/lib/link-category-hashtags","discourse/lib/link-tag-hashtag","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var userSearch = __dependency1__["default"];
    var computed = __dependency2__.default;
    var on = __dependency2__.on;
    var linkSeenMentions = __dependency3__.linkSeenMentions;
    var fetchUnseenMentions = __dependency3__.fetchUnseenMentions;
    var linkSeenCategoryHashtags = __dependency4__.linkSeenCategoryHashtags;
    var fetchUnseenCategoryHashtags = __dependency4__.fetchUnseenCategoryHashtags;
    var fetchUnseenTagHashtags = __dependency5__.fetchUnseenTagHashtags;
    var linkSeenTagHashtags = __dependency5__.linkSeenTagHashtags;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['wmd-controls'];
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return ['showToolbar:toolbar-visible', ':wmd-controls', 'showPreview', 'showPreview::hide-preview'];
      }
    }, {
      key: 'uploadProgress',
      initializer: function () {
        return 0;
      }
    }, {
      key: 'showPreview',
      initializer: function () {
        return true;
      }
    }, {
      key: '_xhr',
      initializer: function () {
        return null;
      }
    }, {
      key: 'uploadPlaceholder',
      decorators: [computed],
      value: function () {
        return '[' + I18n.t('uploading') + ']() ';
      }
    }, {
      key: '_setupPreview',
      decorators: [on('init')],
      value: function () {
        var val = this.site.mobileView ? false : this.keyValueStore.get('composer.showPreview') || 'true';
        this.set('showPreview', val === 'true');
      }
    }, {
      key: 'toggleText',
      decorators: [computed('showPreview')],
      initializer: function () {
        return function (showPreview) {
          return showPreview ? I18n.t('composer.hide_preview') : I18n.t('composer.show_preview');
        };
      }
    }, {
      key: '_renderUnseenTagHashtags',
      value: function ($preview, unseen) {
        fetchUnseenTagHashtags(unseen).then(function () {
          linkSeenTagHashtags($preview);
        });
      }
    }, {
      key: 'paintTagHashtags',
      decorators: [on('previewRefreshed')],
      value: function ($preview) {
        if (!this.siteSettings.tagging_enabled) {
          return;
        }

        var unseenTagHashtags = linkSeenTagHashtags($preview);
        if (unseenTagHashtags.length) {
          Ember.run.debounce(this, this._renderUnseenTagHashtags, $preview, unseenTagHashtags, 500);
        }
      }
    }, {
      key: 'markdownOptions',
      decorators: [computed],
      value: function () {
        var _this = this;

        return {
          lookupAvatarByPostNumber: function (postNumber, topicId) {
            var topic = _this.get('topic');
            if (!topic) {
              return;
            }

            var posts = topic.get('postStream.posts');
            if (posts && topicId === topic.get('id')) {
              var quotedPost = posts.findProperty("post_number", postNumber);
              if (quotedPost) {
                return Discourse.Utilities.tinyAvatar(quotedPost.get('avatar_template'));
              }
            }
          }
        };
      }
    }, {
      key: '_composerEditorInit',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this2 = this;

        var topicId = this.get('topic.id');
        var template = this.container.lookup('template:user-selector-autocomplete.raw');
        var $input = this.$('.d-editor-input');
        $input.autocomplete({
          template: template,
          dataSource: function (term) {
            return userSearch({ term: term, topicId: topicId, includeGroups: true });
          },
          key: "@",
          transformComplete: function (v) {
            return v.username || v.name;
          }
        });

        $input.on('scroll', function () {
          return Ember.run.throttle(_this2, _this2._syncEditorAndPreviewScroll, 20);
        });

        // Focus on the body unless we have a title
        if (!this.get('composer.canEditTitle') && !this.capabilities.isIOS) {
          this.$('.d-editor-input').putCursorAtEnd();
        }

        this._bindUploadTarget();
        this.appEvents.trigger('composer:opened');
      }
    }, {
      key: 'validation',
      decorators: [computed('composer.reply', 'composer.replyLength', 'composer.missingReplyCharacters', 'composer.minimumPostLength', 'lastValidatedAt')],
      value: function (reply, replyLength, missingReplyCharacters, minimumPostLength, lastValidatedAt) {
        var postType = this.get('composer.post.post_type');
        if (postType === this.site.get('post_types.small_action')) {
          return;
        }

        var reason = undefined;
        if (replyLength < 1) {
          reason = I18n.t('composer.error.post_missing');
        } else if (missingReplyCharacters > 0) {
          reason = I18n.t('composer.error.post_length', { min: minimumPostLength });
          var tl = Discourse.User.currentProp("trust_level");
          if (tl === 0 || tl === 1) {
            reason += "<br/>" + I18n.t('composer.error.try_like');
          }
        }

        if (reason) {
          return Discourse.InputValidation.create({ failed: true, reason: reason, lastShownAt: lastValidatedAt });
        }
      }
    }, {
      key: '_syncEditorAndPreviewScroll',
      value: function () {
        var $input = this.$('.d-editor-input');
        if (!$input) {
          return;
        }

        var $preview = this.$('.d-editor-preview');

        if ($input.scrollTop() === 0) {
          $preview.scrollTop(0);
          return;
        }

        var inputHeight = $input[0].scrollHeight;
        var previewHeight = $preview[0].scrollHeight;
        if ($input.height() + $input.scrollTop() + 100 > inputHeight) {
          // cheat, special case for bottom
          $preview.scrollTop(previewHeight);
          return;
        }

        var scrollPosition = $input.scrollTop();
        var factor = previewHeight / inputHeight;
        var desired = scrollPosition * factor;
        $preview.scrollTop(desired + 50);
      }
    }, {
      key: '_renderUnseenMentions',
      initializer: function () {
        return function ($preview, unseen) {
          var _this3 = this;

          fetchUnseenMentions($preview, unseen).then(function () {
            linkSeenMentions($preview, _this3.siteSettings);
            _this3._warnMentionedGroups($preview);
          });
        };
      }
    }, {
      key: '_renderUnseenCategoryHashtags',
      initializer: function () {
        return function ($preview, unseen) {
          fetchUnseenCategoryHashtags(unseen).then(function () {
            linkSeenCategoryHashtags($preview);
          });
        };
      }
    }, {
      key: '_warnMentionedGroups',
      value: function ($preview) {
        var _this4 = this;

        Ember.run.scheduleOnce('afterRender', function () {
          _this4._warnedMentions = _this4._warnedMentions || [];
          var found = [];
          $preview.find('.mention-group.notify').each(function (idx, e) {
            var $e = $(e);
            var name = $e.data('name');
            found.push(name);
            if (_this4._warnedMentions.indexOf(name) === -1) {
              _this4._warnedMentions.push(name);
              _this4.sendAction('groupsMentioned', [{ name: name, user_count: $e.data('mentionable-user-count') }]);
            }
          });

          _this4._warnedMentions = found;
        });
      }
    }, {
      key: '_resetUpload',
      value: function (removePlaceholder) {
        this._validUploads--;
        if (this._validUploads === 0) {
          this.setProperties({ uploadProgress: 0, isUploading: false, isCancellable: false });
        }
        if (removePlaceholder) {
          this.set('composer.reply', this.get('composer.reply').replace(this.get('uploadPlaceholder'), ""));
        }
      }
    }, {
      key: '_bindUploadTarget',
      value: function () {
        var _this5 = this;

        this._unbindUploadTarget(); // in case it's still bound, let's clean it up first

        var $element = this.$();
        var csrf = this.session.get('csrfToken');
        var uploadPlaceholder = this.get('uploadPlaceholder');

        $element.fileupload({
          url: Discourse.getURL('/uploads.json?client_id=' + this.messageBus.clientId + '&authenticity_token=' + encodeURIComponent(csrf)),
          dataType: "json",
          pasteZone: $element
        });

        $element.on('fileuploadsubmit', function (e, data) {
          var isUploading = Discourse.Utilities.validateUploadedFiles(data.files);
          data.formData = { type: "composer" };
          _this5.setProperties({ uploadProgress: 0, isUploading: isUploading });
          return isUploading;
        });

        $element.on("fileuploadprogressall", function (e, data) {
          _this5.set("uploadProgress", parseInt(data.loaded / data.total * 100, 10));
        });

        $element.on("fileuploadsend", function (e, data) {
          _this5._validUploads++;
          // add upload placeholders (as much placeholders as valid files dropped)
          var placeholder = _.times(_this5._validUploads, function () {
            return uploadPlaceholder;
          }).join("\n");
          _this5.appEvents.trigger('composer:insert-text', placeholder);

          if (data.xhr && data.originalFiles.length === 1) {
            _this5.set("isCancellable", true);
            _this5._xhr = data.xhr();
          }
        });

        $element.on("fileuploadfail", function (e, data) {
          _this5._resetUpload(true);

          var userCancelled = _this5._xhr && _this5._xhr._userCancelled;
          _this5._xhr = null;

          if (!userCancelled) {
            Discourse.Utilities.displayErrorForUpload(data);
          }
        });

        this.messageBus.subscribe("/uploads/composer", function (upload) {
          // replace upload placeholder
          if (upload && upload.url) {
            if (!_this5._xhr || !_this5._xhr._userCancelled) {
              var markdown = Discourse.Utilities.getUploadMarkdown(upload);
              _this5.set('composer.reply', _this5.get('composer.reply').replace(uploadPlaceholder, markdown));
              _this5._resetUpload(false);
            } else {
              _this5._resetUpload(true);
            }
          } else {
            _this5._resetUpload(true);
            Discourse.Utilities.displayErrorForUpload(upload);
          }
        });

        if (this.site.mobileView) {
          this.$(".mobile-file-upload").on("click.uploader", function () {
            // redirect the click on the hidden file input
            $("#mobile-uploader").click();
          });
        }

        this._firefoxPastingHack();
      }
    }, {
      key: '_firefoxPastingHack',

      // Believe it or not pasting an image in Firefox doesn't work without this code
      value: function () {
        var _this6 = this;

        var uaMatch = navigator.userAgent.match(/Firefox\/(\d+)\.\d/);
        if (uaMatch && parseInt(uaMatch[1]) >= 24) {
          this.$().append(Ember.$("<div id='contenteditable' contenteditable='true' style='height: 0; width: 0; overflow: hidden'></div>"));
          this.$("textarea").off('keydown.contenteditable');
          this.$("textarea").on('keydown.contenteditable', function (event) {
            // Catch Ctrl+v / Cmd+v and hijack focus to a contenteditable div. We can't
            // use the onpaste event because for some reason the paste isn't resumed
            // after we switch focus, probably because it is being executed too late.
            if ((event.ctrlKey || event.metaKey) && event.keyCode === 86) {
              (function () {
                // Save the current textarea selection.
                var textarea = _this6.$("textarea")[0];
                var selectionStart = textarea.selectionStart;
                var selectionEnd = textarea.selectionEnd;

                // Focus the contenteditable div.
                var contentEditableDiv = _this6.$('#contenteditable');
                contentEditableDiv.focus();

                // The paste doesn't finish immediately and we don't have any onpaste
                // event, so wait for 100ms which _should_ be enough time.
                setTimeout(function () {
                  var pastedImg = contentEditableDiv.find('img');

                  if (pastedImg.length === 1) {
                    pastedImg.remove();
                  }

                  // For restoring the selection.
                  textarea.focus();
                  var textareaContent = $(textarea).val(),
                      startContent = textareaContent.substring(0, selectionStart),
                      endContent = textareaContent.substring(selectionEnd);

                  var restoreSelection = function (pastedText) {
                    $(textarea).val(startContent + pastedText + endContent);
                    textarea.selectionStart = selectionStart + pastedText.length;
                    textarea.selectionEnd = textarea.selectionStart;
                  };

                  if (contentEditableDiv.html().length > 0) {
                    // If the image wasn't the only pasted content we just give up and
                    // fall back to the original pasted text.
                    contentEditableDiv.find("br").replaceWith("\n");
                    restoreSelection(contentEditableDiv.text());
                  } else {
                    // Depending on how the image is pasted in, we may get either a
                    // normal URL or a data URI. If we get a data URI we can convert it
                    // to a Blob and upload that, but if it is a regular URL that
                    // operation is prevented for security purposes. When we get a regular
                    // URL let's just create an <img> tag for the image.
                    var imageSrc = pastedImg.attr('src');

                    if (imageSrc.match(/^data:image/)) {
                      (function () {
                        // Restore the cursor position, and remove any selected text.
                        restoreSelection("");

                        // Create a Blob to upload.
                        var image = new Image();
                        image.onload = function () {
                          // Create a new canvas.
                          var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                          canvas.height = image.height;
                          canvas.width = image.width;
                          var ctx = canvas.getContext('2d');
                          ctx.drawImage(image, 0, 0);

                          canvas.toBlob(function (blob) {
                            return _this6.$().fileupload('add', { files: blob });
                          });
                        };
                        image.src = imageSrc;
                      })();
                    } else {
                      restoreSelection("<img src='" + imageSrc + "'>");
                    }
                  }

                  contentEditableDiv.html('');
                }, 100);
              })();
            }
          });
        }
      }
    }, {
      key: '_unbindUploadTarget',
      decorators: [on('willDestroyElement')],
      value: function () {
        this._validUploads = 0;
        this.$(".mobile-file-upload").off("click.uploader");
        this.messageBus.unsubscribe("/uploads/composer");
        var $uploadTarget = this.$();
        try {
          $uploadTarget.fileupload("destroy");
        } catch (e) {/* wasn't initialized yet */}
        $uploadTarget.off();
      }
    }, {
      key: '_composerClosed',
      decorators: [on('willDestroyElement')],
      value: function () {
        var _this7 = this;

        Ember.run.next(function () {
          $('#main-outlet').css('padding-bottom', 0);
          // need to wait a bit for the "slide down" transition of the composer
          Ember.run.later(function () {
            return _this7.appEvents.trigger("composer:closed");
          }, 400);
        });
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          importQuote: function (toolbarEvent) {
            this.sendAction('importQuote', toolbarEvent);
          },

          cancelUpload: function () {
            if (this._xhr) {
              this._xhr._userCancelled = true;
              this._xhr.abort();
            }
            this._resetUpload(true);
          },

          showOptions: function () {
            // long term we want some smart positioning algorithm in popup-menu
            // the problem is that positioning in a fixed panel is a nightmare
            // cause offsetParent can end up returning a fixed element and then
            // using offset() is not going to work, so you end up needing special logic
            // especially since we allow for negative .top, provided there is room on screen
            var myPos = this.$().position();
            var buttonPos = this.$('.options').position();

            var popupHeight = $('#reply-control .popup-menu').height();
            var popupWidth = $('#reply-control .popup-menu').width();

            var top = myPos.top + buttonPos.top - 15;
            var left = myPos.left + buttonPos.left - popupWidth / 2;

            var composerPos = $('#reply-control').position();

            if (composerPos.top + top - popupHeight < 0) {
              top = top + popupHeight + this.$('.options').height() + 50;
            }

            var replyWidth = $('#reply-control').width();
            if (left + popupWidth > replyWidth) {
              left = replyWidth - popupWidth - 40;
            }

            this.sendAction('showOptions', { position: "absolute",
              left: left,
              top: top });
          },

          showUploadModal: function (toolbarEvent) {
            this.sendAction('showUploadSelector', toolbarEvent);
          },

          togglePreview: function () {
            this.toggleProperty('showPreview');
            this.keyValueStore.set({ key: 'composer.showPreview', value: this.get('showPreview') });
          },

          extraButtons: function (toolbar) {
            toolbar.addButton({
              id: 'quote',
              group: 'fontStyles',
              icon: 'comment-o',
              sendAction: 'importQuote',
              title: 'composer.quote_post_title',
              unshift: true
            });

            toolbar.addButton({
              id: 'upload',
              group: 'insertions',
              icon: 'upload',
              title: 'upload',
              sendAction: 'showUploadModal'
            });

            if (this.get('canWhisper')) {
              toolbar.addButton({
                id: 'options',
                group: 'extras',
                icon: 'gear',
                title: 'composer.options',
                sendAction: 'showOptions'
              });
            }
          },

          previewUpdated: function ($preview) {
            // Paint mentions
            var unseen = linkSeenMentions($preview, this.siteSettings);
            if (unseen.length) {
              Ember.run.debounce(this, this._renderUnseenMentions, $preview, unseen, 500);
            }

            this._warnMentionedGroups($preview);

            // Paint category hashtags
            var unseenHashtags = linkSeenCategoryHashtags($preview);
            if (unseenHashtags.length) {
              Ember.run.debounce(this, this._renderUnseenCategoryHashtags, $preview, unseenHashtags, 500);
            }

            var post = this.get('composer.post');
            var refresh = false;

            // If we are editing a post, we'll refresh its contents once. This is a feature that
            // allows a user to refresh its contents once.
            if (post && !post.get('refreshedPost')) {
              refresh = true;
              post.set('refreshedPost', true);
            }

            // Paint oneboxes
            $('a.onebox', $preview).each(function (i, e) {
              return Discourse.Onebox.load(e, refresh);
            });
            this.trigger('previewRefreshed', $preview);
          }
        };
      }
    }]));
  });
define("discourse/components/composer-title", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__.default;
    var on = __dependency1__.on;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['title-input'];
      }
    }, {
      key: '_focusOnTitle',
      decorators: [on('didInsertElement')],
      value: function () {
        if (!this.capabilities.isIOS) {
          this.$('input').putCursorAtEnd();
        }
      }
    }, {
      key: 'validation',
      decorators: [computed('composer.titleLength', 'composer.missingTitleCharacters', 'composer.minimumTitleLength', 'lastValidatedAt')],
      value: function (titleLength, missingTitleChars, minimumTitleLength, lastValidatedAt) {

        var reason = undefined;
        if (titleLength < 1) {
          reason = I18n.t('composer.error.title_missing');
        } else if (missingTitleChars > 0) {
          reason = I18n.t('composer.error.title_too_short', { min: minimumTitleLength });
        } else if (titleLength > this.siteSettings.max_topic_title_length) {
          reason = I18n.t('composer.error.title_too_long', { max: this.siteSettings.max_topic_title_length });
        }

        if (reason) {
          return Discourse.InputValidation.create({ failed: true, reason: reason, lastShownAt: lastValidatedAt });
        }
      }
    }]));
  });
define("discourse/components/count-i18n", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend(Discourse.StringBuffer, {
      tagName: 'span',
      rerenderTriggers: ['count', 'suffix'],

      renderString: function (buffer) {
        buffer.push(I18n.t(this.get('key') + (this.get('suffix') || ''), { count: this.get('count') }));
      }
    });
  });
define("discourse/components/create-topics-notice", 
  ["ember-addons/ember-computed-decorators","discourse/models/live-post-counts","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var observes = __dependency1__.observes;
    var LivePostCounts = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNameBindings',
      initializer: function () {
        return ['hidden:hidden', ':create-topics-notice'];
      }
    }, {
      key: 'enabled',
      initializer: function () {
        return false;
      }
    }, {
      key: 'publicTopicCount',
      initializer: function () {
        return null;
      }
    }, {
      key: 'publicPostCount',
      initializer: function () {
        return null;
      }
    }, {
      key: 'requiredTopics',
      initializer: function () {
        return 5;
      }
    }, {
      key: 'requiredPosts',
      initializer: function () {
        return Ember.computed.alias('siteSettings.tl1_requires_read_posts');
      }
    }, {
      key: 'init',
      value: function () {
        this._super();
        if (this.get('shouldSee')) {
          var topicCount = 0,
              postCount = 0;

          // Use data we already have before fetching live stats
          _.each(this.site.get('categories'), function (c) {
            if (!c.get('read_restricted')) {
              topicCount += c.get('topic_count');
              postCount += c.get('post_count');
            }
          });

          if (topicCount < this.get('requiredTopics') || postCount < this.get('requiredPosts')) {
            this.set('enabled', true);
            this.fetchLiveStats();
          }
        }
      }
    }, {
      key: 'shouldSee',
      decorators: [computed()],
      value: function () {
        return Discourse.User.currentProp('admin') && this.siteSettings.show_create_topics_notice;
      }
    }, {
      key: 'hidden',
      decorators: [computed('enabled', 'shouldSee', 'publicTopicCount', 'publicPostCount')],
      value: function () {
        return !this.get('enabled') || !this.get('shouldSee') || this.get('publicTopicCount') == null || this.get('publicPostCount') == null;
      }
    }, {
      key: 'message',
      decorators: [computed('publicTopicCount', 'publicPostCount', 'topicTrackingState.incomingCount')],
      value: function () {
        var msg = null;

        if (this.get('publicTopicCount') < this.get('requiredTopics') && this.get('publicPostCount') < this.get('requiredPosts')) {
          msg = 'too_few_topics_and_posts_notice';
        } else if (this.get('publicTopicCount') < this.get('requiredTopics')) {
          msg = 'too_few_topics_notice';
        } else {
          msg = 'too_few_posts_notice';
        }

        return new Handlebars.SafeString(I18n.t(msg, {
          requiredTopics: this.get('requiredTopics'),
          requiredPosts: this.get('requiredPosts'),
          currentTopics: this.get('publicTopicCount'),
          currentPosts: this.get('publicPostCount')
        }));
      }
    }, {
      key: 'fetchLiveStats',
      decorators: [observes('topicTrackingState.incomingCount')],
      value: function () {
        var _this = this;

        if (!this.get('enabled')) {
          return;
        }

        LivePostCounts.find().then(function (stats) {
          if (stats) {
            _this.set('publicTopicCount', stats.get('public_topic_count'));
            _this.set('publicPostCount', stats.get('public_post_count'));
            if (_this.get('publicTopicCount') >= _this.get('requiredTopics') && _this.get('publicPostCount') >= _this.get('requiredPosts')) {
              _this.set('enabled', false); // No more checks
            }
          }
        });
      }
    }]));
  });
define("discourse/components/d-button", 
  ["discourse/helpers/fa-icon","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var iconHTML = __dependency1__.iconHTML;
    var computed = __dependency2__.default;
    var observes = __dependency2__.observes;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'button';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return [':btn', 'noText'];
      }
    }, {
      key: 'attributeBindings',
      initializer: function () {
        return ['disabled', 'translatedTitle:title'];
      }
    }, {
      key: 'noText',
      initializer: function () {
        return Ember.computed.empty('translatedLabel');
      }
    }, {
      key: 'translatedTitle',
      decorators: [computed("title")],
      value: function (title) {
        if (title) return I18n.t(title);
      }
    }, {
      key: 'translatedLabel',
      decorators: [computed("label")],
      value: function (label) {
        if (label) return I18n.t(label);
      }
    }, {
      key: 'iconChanged',
      decorators: [observes('icon')],
      value: function () {
        this.rerender();
      }
    }, {
      key: 'render',
      value: function (buffer) {
        var label = this.get('translatedLabel'),
            icon = this.get('icon');

        if (label || icon) {
          if (icon) {
            buffer.push(iconHTML(icon) + ' ');
          }
          if (label) {
            buffer.push(label);
          }
        } else {
          // If no label or icon is present, yield
          return this._super(buffer);
        }
      }
    }, {
      key: 'click',
      value: function () {
        this.sendAction("action", this.get("actionParam"));
        return false;
      }
    }]));
  });
define("discourse/components/d-checkbox", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'label';
      }
    }, {
      key: '_watchChanges',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this = this;

        // In Ember 13.3 we can use action on the checkbox `{{input}}` but not in 1.11
        this.$('input').on('click.d-checkbox', function () {
          Ember.run.scheduleOnce('afterRender', function () {
            return _this.sendAction('change');
          });
        });
      }
    }, {
      key: '_stopWatching',
      decorators: [on('willDestroyElement')],
      value: function () {
        this.$('input').off('click.d-checkbox');
      }
    }]));
  });
define("discourse/components/d-editor-modal", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var observes = __dependency1__.observes;
    var on = __dependency1__.on;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNameBindings',
      initializer: function () {
        return [':d-editor-modal', 'hidden'];
      }
    }, {
      key: '_hiddenChanged',
      decorators: [observes('hidden')],
      value: function () {
        var _this = this;

        if (!this.get('hidden')) {
          Ember.run.scheduleOnce('afterRender', function () {
            var $modal = _this.$();
            var $parent = _this.$().closest('.d-editor');
            var w = $parent.width();
            var h = $parent.height();
            var dir = $('html').css('direction') === 'rtl' ? 'right' : 'left';
            var offset = w / 2 - $modal.outerWidth() / 2;
            $modal.css(dir, offset + 'px');
            parent.$('.d-editor-overlay').removeClass('hidden').css({ width: w, height: h });
            _this.$('input:eq(0)').focus();
          });
        } else {
          parent.$('.d-editor-overlay').addClass('hidden');
        }
      }
    }, {
      key: '_listenKeys',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this2 = this;

        this.$().on('keydown.d-modal', function (key) {
          if (_this2.get('hidden')) {
            return;
          }

          if (key.keyCode === 27) {
            _this2.send('cancel');
            return false;
          }
          if (key.keyCode === 13) {
            _this2.send('ok');
            return false;
          }
        });
      }
    }, {
      key: '_stopListening',
      decorators: [on('willDestroyElement')],
      value: function () {
        this.$().off('keydown.d-modal');
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          ok: function () {
            this.set('hidden', true);
            this.sendAction('okAction');
          },

          cancel: function () {
            this.set('hidden', true);
          }
        };
      }
    }]));
  });
define("discourse/components/d-link", 
  ["ember-addons/ember-computed-decorators","discourse/helpers/fa-icon","discourse/lib/intercept-click","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;
    var interceptClick = __dependency3__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'a';
      }
    }, {
      key: 'classNames',
      initializer: function () {
        return ['d-link'];
      }
    }, {
      key: 'attributeBindings',
      initializer: function () {
        return ['translatedTitle:title', 'translatedTitle:aria-title', 'href'];
      }
    }, {
      key: 'href',
      decorators: [computed('path')],
      value: function (path) {
        if (path) {
          return path;
        }

        var route = this.get('route');
        if (route) {
          var router = this.container.lookup('router:main');
          if (router && router.router) {
            var params = [route];
            var model = this.get('model');
            if (model) {
              params.push(model);
            }

            return Discourse.getURL(router.router.generate.apply(router.router, params));
          }
        }

        return '';
      }
    }, {
      key: 'translatedTitle',
      decorators: [computed("title")],
      value: function (title) {
        if (title) return I18n.t(title);
      }
    }, {
      key: 'click',
      value: function (e) {
        var action = this.get('action');
        if (action) {
          this.sendAction('action');
          return false;
        }

        return interceptClick(e);
      }
    }, {
      key: 'render',
      value: function (buffer) {
        if (!!this.get('template')) {
          return this._super(buffer);
        }

        var icon = this.get('icon');
        if (icon) {
          buffer.push(iconHTML(icon));
        }

        var label = this.get('label');
        if (label) {
          if (icon) {
            buffer.push(" ");
          }

          if (this.get('translateLabel') === "false") {
            buffer.push(label);
          } else {
            var count = this.get('count');
            buffer.push(I18n.t(label, { count: count }));
          }
        }
      }
    }]));
  });
define("discourse/components/date-picker-future", 
  ["discourse/components/date-picker","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DatePicker = __dependency1__["default"];

    __exports__["default"] = DatePicker.extend({
      layoutName: "components/date-picker",

      _opts: function () {
        return {
          defaultDate: moment().add(1, "day").toDate(),
          minDate: new Date()
        };
      }
    });
  });
define("discourse/components/date-picker-past", 
  ["discourse/components/date-picker","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DatePicker = __dependency1__["default"];

    __exports__["default"] = DatePicker.extend({
      layoutName: "components/date-picker",

      _opts: function () {
        return {
          defaultDate: new Date(),
          maxDate: new Date()
        };
      }
    });
  });
define("discourse/components/date-picker", 
  ["discourse/lib/load-script","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    /* global Pikaday:true */

    var loadScript = __dependency1__["default"];
    var on = __dependency2__.on;

    __exports__["default"] = Em.Component.extend(_createDecoratedObject([{
      key: "classNames",
      initializer: function () {
        return ["date-picker-wrapper"];
      }
    }, {
      key: "_picker",
      initializer: function () {
        return null;
      }
    }, {
      key: "_loadDatePicker",
      decorators: [on("didInsertElement")],
      value: function () {
        var _this = this;

        var input = this.$(".date-picker")[0];
        var container = $("#" + this.get("containerId"))[0];

        loadScript("/javascripts/pikaday.js").then(function () {
          Ember.run.next(function () {
            var default_opts = {
              field: input,
              container: container || _this.$()[0],
              bound: container === undefined,
              format: "YYYY-MM-DD",
              firstDay: moment.localeData().firstDayOfWeek(),
              i18n: {
                previousMonth: I18n.t('dates.previous_month'),
                nextMonth: I18n.t('dates.next_month'),
                months: moment.months(),
                weekdays: moment.weekdays(),
                weekdaysShort: moment.weekdaysShort()
              },
              onSelect: function (date) {
                return _this.set("value", moment(date).format("YYYY-MM-DD"));
              }
            };

            _this._picker = new Pikaday(_.merge(default_opts, _this._opts()));
          });
        });
      }
    }, {
      key: "_destroy",
      decorators: [on("willDestroyElement")],
      value: function () {
        this._picker = null;
      }
    }, {
      key: "_opts",
      value: function () {
        return null;
      }
    }]));
  });
define("discourse/components/desktop-notification-config", 
  ["ember-addons/ember-computed-decorators","discourse/lib/key-value-store","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var KeyValueStore = __dependency2__["default"];

    var keyValueStore = new KeyValueStore("discourse_desktop_notifications_");

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['controls'];
      }
    }, {
      key: 'notificationsPermission',
      decorators: [computed("isNotSupported")],
      value: function (isNotSupported) {
        return isNotSupported ? "" : Notification.permission;
      }
    }, {
      key: 'notificationsDisabled',
      decorators: [computed],
      initializer: function () {
        return {
          set: function (value) {
            keyValueStore.setItem('notifications-disabled', value);
            return keyValueStore.getItem('notifications-disabled');
          },
          get: function () {
            return keyValueStore.getItem('notifications-disabled');
          }
        };
      }
    }, {
      key: 'isNotSupported',
      decorators: [computed],
      value: function () {
        return typeof window.Notification === "undefined";
      }
    }, {
      key: 'isDefaultPermission',
      decorators: [computed("isNotSupported", "notificationsPermission")],
      value: function (isNotSupported, notificationsPermission) {
        return isNotSupported ? false : notificationsPermission === "default";
      }
    }, {
      key: 'isDeniedPermission',
      decorators: [computed("isNotSupported", "notificationsPermission")],
      value: function (isNotSupported, notificationsPermission) {
        return isNotSupported ? false : notificationsPermission === "denied";
      }
    }, {
      key: 'isGrantedPermission',
      decorators: [computed("isNotSupported", "notificationsPermission")],
      value: function (isNotSupported, notificationsPermission) {
        return isNotSupported ? false : notificationsPermission === "granted";
      }
    }, {
      key: 'isEnabled',
      decorators: [computed("isGrantedPermission", "notificationsDisabled")],
      value: function (isGrantedPermission, notificationsDisabled) {
        return isGrantedPermission ? !notificationsDisabled : false;
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          requestPermission: function () {
            var _this = this;

            Notification.requestPermission(function () {
              return _this.propertyDidChange('notificationsPermission');
            });
          },

          recheckPermission: function () {
            this.propertyDidChange('notificationsPermission');
          },

          turnoff: function () {
            this.set('notificationsDisabled', 'disabled');
            this.propertyDidChange('notificationsPermission');
          },

          turnon: function () {
            this.set('notificationsDisabled', '');
            this.propertyDidChange('notificationsPermission');
          }
        };
      }
    }]));
  });
define("discourse/components/directory-item", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;

    __exports__["default"] = Ember.Component.extend({
      tagName: 'tr',
      classNameBindings: ['me'],
      me: propertyEqual('item.user.id', 'currentUser.id')
    });
  });
define("discourse/components/directory-toggle", 
  ["discourse/mixins/string-buffer","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      tagName: 'th',
      classNames: ['sortable'],
      attributeBindings: ['title'],
      rerenderTriggers: ['order', 'asc'],

      title: (function () {
        var labelKey = 'directory.' + this.get('field');
        return I18n.t(labelKey + '_long', { defaultValue: I18n.t(labelKey) });
      }).property('field'),

      renderString: function (buffer) {

        var icon = this.get('icon');
        if (icon) {
          buffer.push(iconHTML(icon));
        }

        var field = this.get('field');
        buffer.push(I18n.t('directory.' + field));

        if (field === this.get('order')) {
          buffer.push(iconHTML(this.get('asc') ? 'chevron-up' : 'chevron-down'));
        }
      },

      click: function () {
        var currentOrder = this.get('order'),
            field = this.get('field');

        if (currentOrder === field) {
          this.set('asc', this.get('asc') ? null : true);
        } else {
          this.setProperties({ order: field, asc: null });
        }
      }
    });
  });
define("discourse/components/disabled-icon", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'span',
      classNameBindings: [':fa-stack']
    });
  });
define("discourse/components/discourse-banner", 
  ["discourse/components/visible","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var VisibleComponent = __dependency1__["default"];

    __exports__["default"] = VisibleComponent.extend({

      visible: (function () {
        var bannerKey = this.get("banner.key"),
            dismissedBannerKey = this.get("user.dismissed_banner_key") || this.keyValueStore.get("dismissed_banner_key");

        if (bannerKey) {
          bannerKey = parseInt(bannerKey, 10);
        }
        if (dismissedBannerKey) {
          dismissedBannerKey = parseInt(dismissedBannerKey, 10);
        }

        return !this.get("hide") && bannerKey && dismissedBannerKey !== bannerKey;
      }).property("user.dismissed_banner_key", "banner.key", "hide"),

      actions: {
        dismiss: function () {
          if (this.get("user")) {
            this.get("user").dismissBanner(this.get("banner.key"));
          } else {
            this.set("visible", false);
            this.keyValueStore.set({ key: "dismissed_banner_key", value: this.get("banner.key") });
          }
        }
      }

    });
  });
define("discourse/components/discourse-tag-bound", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'a',
      classNameBindings: [':discourse-tag', 'style', 'tagClass'],
      attributeBindings: ['href'],

      tagClass: (function () {
        return "tag-" + this.get('tagRecord.id');
      }).property('tagRecord.id'),

      href: (function () {
        return '/tags/' + this.get('tagRecord.id');
      }).property('tagRecord.id')
    });
  });
define("discourse/components/discovery-categories", 
  ["discourse/mixins/url-refresh","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var UrlRefresh = __dependency1__["default"];
    var on = __dependency2__.on;

    var CATEGORIES_LIST_BODY_CLASS = "categories-list";

    __exports__["default"] = Ember.Component.extend(UrlRefresh, _createDecoratedObject([{
      key: 'classNames',
      initializer: function () {
        return ['contents'];
      }
    }, {
      key: 'addBodyClass',
      decorators: [on("didInsertElement")],
      value: function () {
        $('body').addClass(CATEGORIES_LIST_BODY_CLASS);
      }
    }, {
      key: 'removeBodyClass',
      decorators: [on("willDestroyElement")],
      value: function () {
        $('body').removeClass(CATEGORIES_LIST_BODY_CLASS);
      }
    }]));
  });
define("discourse/components/discovery-topics-list", 
  ["ember-addons/ember-computed-decorators","discourse/mixins/load-more","discourse/mixins/url-refresh","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;
    var observes = __dependency1__.observes;
    var LoadMore = __dependency2__["default"];
    var UrlRefresh = __dependency3__["default"];

    var DiscoveryTopicsListComponent = Ember.Component.extend(UrlRefresh, LoadMore, _createDecoratedObject([{
      key: "classNames",
      initializer: function () {
        return ['contents'];
      }
    }, {
      key: "eyelineSelector",
      initializer: function () {
        return '.topic-list-item';
      }
    }, {
      key: "_readjustScrollPosition",
      decorators: [observes("model"), on("didInsertElement")],
      value: function () {
        var scrollTo = this.session.get('topicListScrollPosition');
        if (scrollTo && scrollTo >= 0) {
          Ember.run.schedule('afterRender', function () {
            return $(window).scrollTop(scrollTo + 1);
          });
        } else {
          Ember.run.scheduleOnce('afterRender', this, this.loadMoreUnlessFull);
        }
      }
    }, {
      key: "_updateTitle",
      decorators: [observes("incomingCount")],
      value: function () {
        Discourse.notifyTitle(this.get('incomingCount'));
      }
    }, {
      key: "saveScrollPosition",
      value: function () {
        this.session.set('topicListScrollPosition', $(window).scrollTop());
      }
    }, {
      key: "scrolled",
      value: function () {
        this._super();
        this.saveScrollPosition();
      }
    }, {
      key: "actions",
      initializer: function () {
        return {
          loadMore: function () {
            var _this = this;

            Discourse.notifyTitle(0);
            this.get('model').loadMore().then(function (hasMoreResults) {
              Ember.run.schedule('afterRender', function () {
                return _this.saveScrollPosition();
              });
              if (!hasMoreResults) {
                _this.get('eyeline').flushRest();
              } else if ($(window).height() >= $(document).height()) {
                _this.send("loadMore");
              }
            });
          }
        };
      }
    }]));

    __exports__["default"] = DiscoveryTopicsListComponent;
  });
define("discourse/components/edit-category-general", 
  ["discourse/lib/url","discourse/components/edit-category-panel","discourse/helpers/category-link","discourse/models/category","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];
    var buildCategoryPanel = __dependency2__.buildCategoryPanel;
    var categoryBadgeHTML = __dependency3__.categoryBadgeHTML;
    var Category = __dependency4__["default"];

    __exports__["default"] = buildCategoryPanel('general', {
      foregroundColors: ['FFFFFF', '000000'],
      canSelectParentCategory: Em.computed.not('category.isUncategorizedCategory'),

      // background colors are available as a pipe-separated string
      backgroundColors: (function () {
        var categories = Discourse.Category.list();
        return this.siteSettings.category_colors.split("|").map(function (i) {
          return i.toUpperCase();
        }).concat(categories.map(function (c) {
          return c.color.toUpperCase();
        })).uniq();
      }).property(),

      usedBackgroundColors: (function () {
        var categories = Discourse.Category.list();
        var category = this.get('category');

        // If editing a category, don't include its color:
        return categories.map(function (c) {
          return category.get('id') && category.get('color').toUpperCase() === c.color.toUpperCase() ? null : c.color.toUpperCase();
        }, this).compact();
      }).property('category.id', 'category.color'),

      parentCategories: (function () {
        return Discourse.Category.list().filter(function (c) {
          return !c.get('parentCategory');
        });
      }).property(),

      categoryBadgePreview: (function () {
        var category = this.get('category');
        var c = Category.create({
          name: category.get('categoryName'),
          color: category.get('color'),
          text_color: category.get('text_color'),
          parent_category_id: parseInt(category.get('parent_category_id'), 10),
          read_restricted: category.get('read_restricted')
        });
        return categoryBadgeHTML(c, { link: false });
      }).property('category.parent_category_id', 'category.categoryName', 'category.color', 'category.text_color'),

      // We can change the parent if there are no children
      subCategories: (function () {
        if (Ember.isEmpty(this.get('category.id'))) {
          return null;
        }
        return Category.list().filterBy('parent_category_id', this.get('category.id'));
      }).property('category.id'),

      showDescription: (function () {
        return !this.get('category.isUncategorizedCategory') && this.get('category.id');
      }).property('category.isUncategorizedCategory', 'category.id'),

      actions: {
        showCategoryTopic: function () {
          DiscourseURL.routeTo(this.get('category.topic_url'));
          return false;
        }
      }
    });
  });
define("discourse/components/edit-category-images", 
  ["discourse/components/edit-category-panel","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildCategoryPanel = __dependency1__.buildCategoryPanel;
    __exports__["default"] = buildCategoryPanel('images');
  });
define("discourse/components/edit-category-security", 
  ["discourse/components/edit-category-panel","discourse/models/permission-type","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var buildCategoryPanel = __dependency1__.buildCategoryPanel;
    var PermissionType = __dependency2__["default"];

    __exports__["default"] = buildCategoryPanel('security', {
      editingPermissions: false,
      selectedGroup: null,
      selectedPermission: null,

      actions: {
        editPermissions: function () {
          if (!this.get('category.is_special')) {
            this.set('editingPermissions', true);
          }
        },

        addPermission: function (group, id) {
          if (!this.get('category.is_special')) {
            this.get('category').addPermission({
              group_name: group + "",
              permission: PermissionType.create({ id: parseInt(id) })
            });
          }
        },

        removePermission: function (permission) {
          if (!this.get('category.is_special')) {
            this.get('category').removePermission(permission);
          }
        }
      }
    });
  });
define("discourse/components/edit-category-settings", 
  ["discourse/lib/computed","discourse/components/edit-category-panel","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var setting = __dependency1__.setting;
    var buildCategoryPanel = __dependency2__.buildCategoryPanel;

    __exports__["default"] = buildCategoryPanel('settings', {
      emailInEnabled: setting('email_in'),
      showPositionInput: setting('fixed_category_positions')
    });
  });
define("discourse/components/edit-category-tab", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;

    __exports__["default"] = Em.Component.extend({
      tagName: 'li',
      classNameBindings: ['active', 'tabClassName'],

      tabClassName: (function () {
        return 'edit-category-' + this.get('tab');
      }).property('tab'),

      active: propertyEqual('selectedTab', 'tab'),

      title: (function () {
        return I18n.t('category.' + this.get('tab').replace('-', '_'));
      }).property('tab'),

      _addToCollection: (function () {
        this.get('panels').addObject(this.get('tabClassName'));
      }).on('didInsertElement'),

      actions: {
        select: function () {
          this.set('selectedTab', this.get('tab'));
        }
      }
    });
  });
define("discourse/components/edit-category-topic-template", 
  ["discourse/components/edit-category-panel","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildCategoryPanel = __dependency1__.buildCategoryPanel;

    __exports__["default"] = buildCategoryPanel('topic-template', {
      _activeTabChanged: (function () {
        var _this = this;

        if (this.get('activeTab')) {
          Ember.run.scheduleOnce('afterRender', function () {
            return _this.$('.d-editor-input').focus();
          });
        }
      }).observes('activeTab')
    });
  });
define("discourse/components/emoji-uploader", 
  ["discourse/mixins/upload","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var UploadMixin = __dependency1__["default"];

    __exports__["default"] = Em.Component.extend(UploadMixin, {
      type: "emoji",
      uploadUrl: "/admin/customize/emojis",

      hasName: Em.computed.notEmpty("name"),
      addDisabled: Em.computed.not("hasName"),

      data: (function () {
        return Ember.isBlank(this.get("name")) ? {} : { name: this.get("name") };
      }).property("name"),

      uploadDone: function (upload) {
        this.set("name", null);
        this.sendAction("done", upload);
      }

    });
  });
define("discourse/components/featured-topic", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      classNameBindings: [':featured-topic'],

      click: function (e) {
        var $target = $(e.target);
        if ($target.closest('.last-posted-at').length) {
          this.sendAction('action', { topic: this.get('topic'), position: $target.offset() });
          return false;
        }
      }
    });
  });
define("discourse/components/flag-action-type", 
  ["discourse/models/post-action-type","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var MAX_MESSAGE_LENGTH = __dependency1__.MAX_MESSAGE_LENGTH;
    var computed = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'customPlaceholder',
      decorators: [computed('flag.name_key')],
      value: function (nameKey) {
        return I18n.t("flagging.custom_placeholder_" + nameKey);
      }
    }, {
      key: 'formattedName',
      decorators: [computed('flag.name', 'flag.name_key', 'flag.is_custom_flag', 'username')],
      value: function (name, nameKey, isCustomFlag, username) {
        if (isCustomFlag) {
          return name.replace("{{username}}", username);
        } else {
          return I18n.t("flagging.formatted_name." + nameKey);
        }
      }
    }, {
      key: 'selected',
      decorators: [computed('flag', 'selectedFlag')],
      value: function (flag, selectedFlag) {
        return flag === selectedFlag;
      }
    }, {
      key: 'showMessageInput',
      initializer: function () {
        return Em.computed.and('flag.is_custom_flag', 'selected');
      }
    }, {
      key: 'showDescription',
      initializer: function () {
        return Em.computed.not('showMessageInput');
      }
    }, {
      key: 'isNotifyUser',
      initializer: function () {
        return Em.computed.equal('flag.name_key', 'notify_user');
      }
    }, {
      key: 'customMessageLengthClasses',
      decorators: [computed('message.length')],
      value: function (messageLength) {
        return messageLength < Discourse.SiteSettings.min_private_message_post_length ? "too-short" : "ok";
      }
    }, {
      key: 'customMessageLength',
      decorators: [computed('message.length')],
      value: function (messageLength) {
        var len = messageLength || 0;
        var minLen = Discourse.SiteSettings.min_private_message_post_length;
        if (len === 0) {
          return I18n.t("flagging.custom_message.at_least", { n: minLen });
        } else if (len < minLen) {
          return I18n.t("flagging.custom_message.more", { n: minLen - len });
        } else {
          return I18n.t("flagging.custom_message.left", {
            n: MAX_MESSAGE_LENGTH - len
          });
        }
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          changePostActionType: function (at) {
            this.sendAction('changePostActionType', at);
          }
        };
      }
    }]));
  });
define("discourse/components/global-notice", 
  ["ember-addons/ember-computed-decorators","discourse/mixins/string-buffer","discourse/helpers/fa-icon","discourse/services/logs-notice","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;
    var StringBuffer = __dependency2__["default"];
    var iconHTML = __dependency3__.iconHTML;
    var LogsNotice = __dependency4__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, _createDecoratedObject([{
      key: 'rerenderTriggers',
      initializer: function () {
        return ['site.isReadOnly'];
      }
    }, {
      key: 'renderString',
      initializer: function () {
        return function (buffer) {
          var notices = [];

          if (this.site.get("isReadOnly")) {
            notices.push([I18n.t("read_only_mode.enabled"), 'alert-read-only']);
          }

          if (this.siteSettings.disable_emails) {
            notices.push([I18n.t("emails_are_disabled"), 'alert-emails-disabled']);
          }

          if (this.currentUser && this.currentUser.get('staff') && this.siteSettings.bootstrap_mode_enabled) {
            if (this.siteSettings.bootstrap_mode_min_users > 0) {
              notices.push([I18n.t("bootstrap_mode_enabled", { min_users: this.siteSettings.bootstrap_mode_min_users }), 'alert-bootstrap-mode']);
            } else {
              notices.push([I18n.t("bootstrap_mode_disabled"), 'alert-bootstrap-mode']);
            }
          }

          if (!_.isEmpty(this.siteSettings.global_notice)) {
            notices.push([this.siteSettings.global_notice, 'alert-global-notice']);
          }

          if (!LogsNotice.currentProp('hidden')) {
            notices.push([LogsNotice.currentProp('message'), 'alert-logs-notice', '<div class=\'close\'>' + iconHTML('times') + '</div>']);
          }

          if (notices.length > 0) {
            buffer.push(_.map(notices, function (n) {
              var html = '<div class=\'row\'><div class=\'alert alert-info ' + n[1] + '\'>';
              if (n[2]) html += n[2];
              html += n[0] + '</div></div>';
              return html;
            }).join(""));
          }
        };
      }
    }, {
      key: '_setupLogsNotice',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this = this;

        LogsNotice.current().addObserver('hidden', function () {
          _this.rerenderString();
        });

        this.$().on('click.global-notice', '.alert-logs-notice .close', function () {
          LogsNotice.currentProp('text', '');
        });
      }
    }, {
      key: '_teardownLogsNotice',
      decorators: [on('willDestroyElement')],
      value: function () {
        this.$().off('click.global-notice');
      }
    }]));
  });
define("discourse/components/group-notifications-button", 
  ["discourse/components/notifications-button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var NotificationsButton = __dependency1__["default"];

    __exports__["default"] = NotificationsButton.extend({
      classNames: ['notification-options', 'group-notification-menu'],
      notificationLevel: Em.computed.alias('group.notification_level'),
      i18nPrefix: 'groups.notifications',

      clicked: function (id) {
        this.get('group').setNotification(id);
      }
    });
  });
define("discourse/components/group-post-stream", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      actions: {
        // TODO: When on Ember 1.13, use a closure action
        loadMore: function () {
          this.sendAction('loadMore');
        }
      }
    });
  });
define("discourse/components/group-selector", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      placeholder: (function () {
        return I18n.t(this.get("placeholderKey"));
      }).property("placeholderKey"),

      _initializeAutocomplete: (function () {
        var self = this;
        var selectedGroups;

        var template = this.container.lookup('template:group-selector-autocomplete.raw');
        self.$('input').autocomplete({
          allowAny: false,
          onChangeItems: function (items) {
            selectedGroups = items;
            self.set("groupNames", items.join(","));
          },
          transformComplete: function (g) {
            return g.name;
          },
          dataSource: function (term) {
            return self.get("groupFinder")(term).then(function (groups) {

              if (!selectedGroups) {
                return groups;
              }

              return groups.filter(function (group) {
                return !selectedGroups.any(function (s) {
                  return s === group.name;
                });
              });
            });
          },
          template: template
        });
      }).on('didInsertElement')
    });
  });
define("discourse/components/header-extra-info", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.needsSecondRowIf = needsSecondRowIf;

    function needsSecondRowIf() {
      Ember.warn("DEPRECATION: `needsSecondRowIf` is deprecated. Use widget hooks on `header-second-row`");
    }
  });
define("discourse/components/highlight-text", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'span',

      _highlightOnInsert: (function () {
        var term = this.get('highlight');
        var self = this;

        if (!_.isEmpty(term)) {
          self.$().highlight(term.split(/\s+/), { className: 'search-highlight' });
        }
      }).observes('highlight').on('didInsertElement')

    });
  });
define("discourse/components/image-uploader", 
  ["ember-addons/ember-computed-decorators","discourse/mixins/upload","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var UploadMixin = __dependency2__["default"];

    __exports__["default"] = Em.Component.extend(UploadMixin, _createDecoratedObject([{
      key: "classNames",
      initializer: function () {
        return ["image-uploader"];
      }
    }, {
      key: "backgroundStyle",
      decorators: [computed('imageUrl')],
      value: function (imageUrl) {
        if (Em.isNone(imageUrl)) {
          return;
        }
        return ("background-image: url(" + imageUrl + ")").htmlSafe();
      }
    }, {
      key: "uploadDone",
      value: function (upload) {
        this.set("imageUrl", upload.url);
      }
    }, {
      key: "actions",
      initializer: function () {
        return {
          trash: function () {
            this.set("imageUrl", null);
          }
        };
      }
    }]));
  });
define("discourse/components/input-tip", 
  ["discourse/mixins/string-buffer","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      classNameBindings: [':tip', 'good', 'bad'],
      rerenderTriggers: ['validation'],

      bad: Em.computed.alias('validation.failed'),
      good: Em.computed.not('bad'),

      renderString: function (buffer) {
        var reason = this.get('validation.reason');
        if (reason) {
          buffer.push(iconHTML(this.get('good') ? 'check' : 'times') + ' ' + reason);
        }
      }
    });
  });
define("discourse/components/json-file-uploader", 
  ["exports"],
  function(__exports__) {
    "use strict";

    __exports__["default"] = Em.Component.extend({
      fileInput: null,
      loading: false,
      expectedRootObjectName: null,
      hover: 0,

      classNames: ['json-uploader'],

      _initialize: (function () {
        var $this = this.$();
        var self = this;

        var $fileInput = $this.find('#js-file-input');
        this.set('fileInput', $fileInput[0]);

        $fileInput.on('change', function () {
          self.fileSelected(this.files);
        });

        $this.on('dragover', function (e) {
          if (e.preventDefault) e.preventDefault();
          return false;
        });
        $this.on('dragenter', function (e) {
          if (e.preventDefault) e.preventDefault();
          self.set('hover', self.get('hover') + 1);
          return false;
        });
        $this.on('dragleave', function (e) {
          if (e.preventDefault) e.preventDefault();
          self.set('hover', self.get('hover') - 1);
          return false;
        });
        $this.on('drop', function (e) {
          if (e.preventDefault) e.preventDefault();

          self.set('hover', 0);
          self.fileSelected(e.dataTransfer.files);
          return false;
        });
      }).on('didInsertElement'),

      accept: (function () {
        return ".json,application/json,application/x-javascript,text/json" + (this.get('extension') ? "," + this.get('extension') : "");
      }).property('extension'),

      setReady: (function () {
        var parsed = undefined;
        try {
          parsed = JSON.parse(this.get('value'));
        } catch (e) {
          this.set('ready', false);
          return;
        }

        var rootObject = parsed[this.get('expectedRootObjectName')];

        if (rootObject !== null && rootObject !== undefined) {
          this.set('ready', true);
        } else {
          this.set('ready', false);
        }
      }).observes('destination', 'expectedRootObjectName'),

      actions: {
        selectFile: function () {
          var $fileInput = $(this.get('fileInput'));
          $fileInput.click();
        }
      },

      fileSelected: function (fileList) {
        var self = this;
        var files = [];
        for (var i = 0; i < fileList.length; i++) {
          files[i] = fileList[i];
        }
        var fileNameRegex = /\.(json|txt)$/;
        files = files.filter(function (file) {
          if (fileNameRegex.test(file.name)) {
            return true;
          }
          if (file.type === "text/plain") {
            return true;
          }
          return false;
        });
        var firstFile = fileList[0];

        this.set('loading', true);

        var reader = new FileReader();
        reader.onload = function (evt) {
          self.set('value', evt.target.result);
          self.set('loading', false);
        };

        reader.readAsText(firstFile);
      }

    });
  });
define("discourse/components/load-more", 
  ["discourse/mixins/load-more","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var LoadMore = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(LoadMore, {
      init: function () {
        this._super();
        this.set('eyelineSelector', this.get('selector'));
      },

      actions: {
        loadMore: function () {
          this.sendAction();
        }
      }
    });
  });
define("discourse/components/login-buttons", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      elementId: 'login-buttons',
      classNameBindings: ['hidden'],

      hidden: Em.computed.equal('buttons.length', 0),

      buttons: (function () {
        return Em.get('Discourse.LoginMethod.all');
      }).property(),

      actions: {
        externalLogin: function (provider) {
          this.sendAction('action', provider);
        }
      }
    });
  });
define("discourse/components/mobile-nav", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;
    var observes = __dependency1__.observes;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: '_init',
      decorators: [on('init')],
      value: function () {
        if (!this.get('site.mobileView')) {
          var classes = this.get('desktopClass');
          if (classes) {
            classes = classes.split(' ');
            this.set('classNames', classes);
          }
        }
      }
    }, {
      key: 'tagName',
      initializer: function () {
        return 'ul';
      }
    }, {
      key: 'classNames',
      initializer: function () {
        return ['mobile-nav'];
      }
    }, {
      key: 'currentPathChanged',
      decorators: [observes('currentPath')],
      value: function () {
        var _this = this;

        this.set('expanded', false);
        Em.run.next(function () {
          return _this._updateSelectedHtml();
        });
      }
    }, {
      key: '_updateSelectedHtml',
      value: function () {
        var active = this.$('.active');
        if (active && active.html) {
          this.set('selectedHtml', active.html());
        }
      }
    }, {
      key: 'didInsertElement',
      value: function () {
        this._updateSelectedHtml();
      }
    }, {
      key: '_bindClick',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this2 = this;

        this.$().on("click.mobile-nav", 'ul li', function () {
          _this2.set('expanded', false);
        });
      }
    }, {
      key: '_unbindClick',
      decorators: [on('willDestroyElement')],
      value: function () {
        this.$().off("click.mobile-nav", 'ul li');
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          toggleExpanded: function () {
            this.toggleProperty('expanded');
          }
        };
      }
    }]));
  });
define("discourse/components/mount-widget", 
  ["discourse/widgets/widget","virtual-dom","discourse/widgets/hooks","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    __exports__.addWidgetCleanCallback = addWidgetCleanCallback;
    var keyDirty = __dependency1__.keyDirty;
    var diff = __dependency2__.diff;
    var patch = __dependency2__.patch;
    var WidgetClickHook = __dependency3__.WidgetClickHook;
    var renderedKey = __dependency1__.renderedKey;
    var queryRegistry = __dependency1__.queryRegistry;

    var _cleanCallbacks = {};

    function addWidgetCleanCallback(widgetName, fn) {
      _cleanCallbacks[widgetName] = _cleanCallbacks[widgetName] || [];
      _cleanCallbacks[widgetName].push(fn);
    }

    __exports__["default"] = Ember.Component.extend({
      _tree: null,
      _rootNode: null,
      _timeout: null,
      _widgetClass: null,
      _renderCallback: null,
      _childEvents: null,

      init: function () {
        this._super();
        var name = this.get('widget');

        this._widgetClass = queryRegistry(name) || this.container.lookupFactory('widget:' + name);

        if (!this._widgetClass) {
          console.error('Error: Could not find widget: ' + name);
        }

        this._childEvents = [];
        this._connected = [];
      },

      didInsertElement: function () {
        WidgetClickHook.setupDocumentCallback();

        this._rootNode = document.createElement('div');
        this.element.appendChild(this._rootNode);
        this._timeout = Ember.run.scheduleOnce('render', this, this.rerenderWidget);
      },

      willClearRender: function () {
        var callbacks = _cleanCallbacks[this.get('widget')];
        if (callbacks) {
          callbacks.forEach(function (cb) {
            return cb();
          });
        }

        this._connected.forEach(function (v) {
          return v.destroy();
        });
        this._connected.length = 0;
      },

      willDestroyElement: function () {
        var _this = this;

        this._childEvents.forEach(function (evt) {
          return _this.appEvents.off(evt);
        });
        Ember.run.cancel(this._timeout);
      },

      afterRender: function () {},

      beforePatch: function () {},

      afterPatch: function () {},

      eventDispatched: function (eventName, key, refreshArg) {
        var onRefresh = Ember.String.camelize(eventName.replace(/:/, '-'));
        keyDirty(key, { onRefresh: onRefresh, refreshArg: refreshArg });
        this.queueRerender();
      },

      dispatch: function (eventName, key) {
        var _this2 = this;

        this._childEvents.push(eventName);
        this.appEvents.on(eventName, function (refreshArg) {
          _this2.eventDispatched(eventName, key, refreshArg);
        });
      },

      queueRerender: function (callback) {
        if (callback && !this._renderCallback) {
          this._renderCallback = callback;
        }

        Ember.run.scheduleOnce('render', this, this.rerenderWidget);
      },

      buildArgs: function () {},

      rerenderWidget: function () {
        Ember.run.cancel(this._timeout);
        if (this._rootNode) {
          if (!this._widgetClass) {
            return;
          }

          var t0 = new Date().getTime();

          var args = this.get('args') || this.buildArgs();
          var opts = { model: this.get('model') };
          var newTree = new this._widgetClass(args, this.container, opts);

          newTree._emberView = this;
          var patches = diff(this._tree || this._rootNode, newTree);

          this.beforePatch();
          this._rootNode = patch(this._rootNode, patches);
          this.afterPatch();

          this._tree = newTree;

          if (this._renderCallback) {
            this._renderCallback();
            this._renderCallback = null;
          }
          this.afterRender();

          renderedKey('*');
          if (this.profileWidget) {
            console.log(new Date().getTime() - t0);
          }
        }
      }

    });
  });
define("discourse/components/nav-item", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    /* You might be looking for navigation-item. */

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'li';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return ['active'];
      }
    }, {
      key: 'router',
      decorators: [computed()],
      value: function () {
        return this.container.lookup('router:main');
      }
    }, {
      key: 'fullPath',
      decorators: [computed("path")],
      value: function (path) {
        return Discourse.getURL(path);
      }
    }, {
      key: 'active',
      decorators: [computed("route", "router.url")],
      value: function (route) {
        if (!route) {
          return;
        }

        var routeParam = this.get('routeParam'),
            router = this.get('router');

        return routeParam ? router.isActive(route, routeParam) : router.isActive(route);
      }
    }]));
  });
define("discourse/components/navigation-bar", 
  ["ember-addons/ember-computed-decorators","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__.default;
    var observes = __dependency1__.observes;
    var DiscourseURL = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'ul';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return [':nav', ':nav-pills'];
      }
    }, {
      key: 'id',
      initializer: function () {
        return 'navigation-bar';
      }
    }, {
      key: 'selectedNavItem',
      decorators: [computed("filterMode", "navItems")],
      value: function (filterMode, navItems) {
        var item = navItems.find(function (i) {
          return i.get('filterMode').indexOf(filterMode) === 0;
        });
        return item || navItems[0];
      }
    }, {
      key: 'closedNav',
      decorators: [observes("expanded")],
      value: function () {
        if (!this.get('expanded')) {
          this.ensureDropClosed();
        }
      }
    }, {
      key: 'ensureDropClosed',
      value: function () {
        if (!this.get('expanded')) {
          this.set('expanded', false);
        }
        $(window).off('click.navigation-bar');
        DiscourseURL.appEvents.off('dom:clean', this, this.ensureDropClosed);
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          toggleDrop: function () {
            var _this = this;

            this.set('expanded', !this.get('expanded'));

            if (this.get('expanded')) {
              DiscourseURL.appEvents.on('dom:clean', this, this.ensureDropClosed);

              Em.run.next(function () {
                if (!_this.get('expanded')) {
                  return;
                }

                _this.$('.drop a').on('click', function () {
                  _this.$('.drop').hide();
                  _this.set('expanded', false);
                  return true;
                });

                $(window).on('click.navigation-bar', function () {
                  _this.set('expanded', false);
                  return true;
                });
              });
            }
          }
        };
      }
    }]));
  });
define("discourse/components/navigation-item", 
  ["ember-addons/ember-computed-decorators","discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var StringBuffer = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, _createDecoratedObject([{
      key: 'tagName',
      initializer: function () {
        return 'li';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return ['active', 'content.hasIcon:has-icon'];
      }
    }, {
      key: 'attributeBindings',
      initializer: function () {
        return ['title'];
      }
    }, {
      key: 'hidden',
      initializer: function () {
        return Em.computed.not('content.visible');
      }
    }, {
      key: 'rerenderTriggers',
      initializer: function () {
        return ['content.count'];
      }
    }, {
      key: 'title',
      decorators: [computed("content.categoryName", "content.name")],
      value: function (categoryName, name) {
        var extra = {};

        if (categoryName) {
          name = "category";
          extra.categoryName = categoryName;
        }

        return I18n.t("filters." + name.replace("/", ".") + ".help", extra);
      }
    }, {
      key: 'active',
      decorators: [computed("content.filterMode", "filterMode")],
      value: function (contentFilterMode, filterMode) {
        return contentFilterMode === filterMode || filterMode.indexOf(contentFilterMode) === 0;
      }
    }, {
      key: 'renderString',
      value: function (buffer) {
        var content = this.get('content');
        buffer.push("<a href='" + content.get('href') + "'>");
        if (content.get('hasIcon')) {
          buffer.push("<span class='" + content.get('name') + "'></span>");
        }
        buffer.push(this.get('content.displayName'));
        buffer.push("</a>");
      }
    }]));
  });
define("discourse/components/number-field", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.TextField.extend(_createDecoratedObject([{
      key: 'classNameBindings',
      initializer: function () {
        return ['invalid'];
      }
    }, {
      key: 'value',
      decorators: [computed('number')],
      initializer: function () {
        return {
          get: function (number) {
            return parseInt(number);
          },
          set: function (value) {
            var num = parseInt(value);
            if (isNaN(num)) {
              this.set('invalid', true);
              return value;
            } else {
              this.set('invalid', false);
              this.set('number', num);
              return num.toString();
            }
          }
        };
      }
    }, {
      key: 'placeholder',
      decorators: [computed("placeholderKey")],
      value: function (key) {
        return key ? I18n.t(key) : "";
      }
    }]));
  });
define("discourse/components/password-field", 
  ["discourse/components/text-field","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var TextField = __dependency1__["default"];

    /**
      Same as text-field, but with special features for a password input.
      Be sure to test on a variety of browsers and operating systems when changing this logic.
    **/
    __exports__["default"] = TextField.extend({
      canToggle: false,

      keyPress: function (e) {
        if (e.which >= 65 && e.which <= 90 && !e.shiftKey || e.which >= 97 && e.which <= 122 && e.shiftKey) {
          this.set('canToggle', true);
          this.set('capsLockOn', true);
        } else if (e.which >= 65 && e.which <= 90 && e.shiftKey || e.which >= 97 && e.which <= 122 && !e.shiftKey) {
          this.set('canToggle', true);
          this.set('capsLockOn', false);
        }
      },

      keyUp: function (e) {
        if (e.which === 20 && this.get('canToggle')) {
          this.toggleProperty('capsLockOn');
        }
      },

      focusOut: function () {
        this.set('capsLockOn', false);
      },

      focusIn: function () {
        this.set('canToggle', false); // can't know the state of caps lock yet. keyPress will figure it out.
      }
    });
  });
define("discourse/components/period-chooser", 
  ["discourse/mixins/cleans-up","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var CleansUp = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(CleansUp, {
      classNames: 'period-chooser',
      showPeriods: false,

      cleanUp: function () {
        this.set('showPeriods', false);
        $('html').off('mousedown.top-period');
      },

      _clickToClose: function () {
        var self = this;
        $('html').off('mousedown.top-period').on('mousedown.top-period', function (e) {
          var $target = $(e.target);
          if ($target.prop('id') === 'topic-entrance' || self.$().has($target).length !== 0) {
            return;
          }
          self.cleanUp();
        });
      },

      click: function (e) {
        if ($(e.target).closest('.period-popup').length) {
          return;
        }

        if (!this.get('showPeriods')) {
          var $chevron = this.$('i.fa-caret-down');
          this.$('#period-popup').css($chevron.position());
          this.set('showPeriods', true);
          this._clickToClose();
        }
      },

      actions: {
        changePeriod: function (p) {
          this.cleanUp();
          this.set('period', p);
          this.sendAction('action', p);
        }
      }

    });
  });
define("discourse/components/pinned-button", 
  ["discourse/components/dropdown-button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DropdownButton = __dependency1__["default"];

    __exports__["default"] = DropdownButton.extend({
      descriptionKey: 'help',
      classNames: ['pinned-options'],
      title: '',
      longDescription: (function () {
        var topic = this.get('topic');
        var globally = topic.get('pinned_globally') ? '_globally' : '';
        var key = 'topic_statuses.' + (topic.get('pinned') ? 'pinned' + globally : 'unpinned') + '.help';
        return I18n.t(key);
      }).property('topic.pinned'),

      target: Em.computed.alias('topic'),

      hidden: (function () {
        var topic = this.get('topic');
        return topic.get('deleted') || !topic.get('pinned') && !topic.get('unpinned');
      }).property('topic.pinned', 'topic.deleted', 'topic.unpinned'),

      activeItem: (function () {
        return this.get('topic.pinned') ? 'pinned' : 'unpinned';
      }).property('topic.pinned'),

      dropDownContent: (function () {
        var globally = this.get('topic.pinned_globally') ? '_globally' : '';
        return [{ id: 'pinned',
          title: I18n.t('topic_statuses.pinned' + globally + '.title'),
          description: I18n.t('topic_statuses.pinned' + globally + '.help'),
          styleClasses: 'fa fa-thumb-tack' }, { id: 'unpinned',
          title: I18n.t('topic_statuses.unpinned.title'),
          description: I18n.t('topic_statuses.unpinned.help'),
          styleClasses: 'fa fa-thumb-tack unpinned' }];
      }).property(),

      text: (function () {
        var globally = this.get('topic.pinned_globally') ? '_globally' : '';
        var state = this.get('topic.pinned') ? 'pinned' + globally : 'unpinned';

        return '<span class="fa fa-thumb-tack' + (state === 'unpinned' ? ' unpinned' : "") + '"></span> ' + I18n.t('topic_statuses.' + state + '.title') + "<span class='caret'></span>";
      }).property('topic.pinned', 'topic.unpinned'),

      clicked: function (id) {
        var topic = this.get('topic');
        if (id === 'unpinned') {
          topic.clearPin();
        } else {
          topic.rePin();
        }
      }

    });
  });
define("discourse/components/popup-input-tip", 
  ["discourse/mixins/string-buffer","discourse/helpers/fa-icon","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var StringBuffer = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;
    var computed = __dependency3__.default;
    var observes = __dependency3__.observes;

    __exports__["default"] = Ember.Component.extend(StringBuffer, _createDecoratedObject([{
      key: 'classNameBindings',
      initializer: function () {
        return [':popup-tip', 'good', 'bad', 'lastShownAt::hide'];
      }
    }, {
      key: 'animateAttribute',
      initializer: function () {
        return null;
      }
    }, {
      key: 'bouncePixels',
      initializer: function () {
        return 6;
      }
    }, {
      key: 'bounceDelay',
      initializer: function () {
        return 100;
      }
    }, {
      key: 'rerenderTriggers',
      initializer: function () {
        return ['validation.reason'];
      }
    }, {
      key: 'click',
      value: function () {
        this.set('shownAt', null);
        this.set('validation.lastShownAt', null);
      }
    }, {
      key: 'bad',
      initializer: function () {
        return Ember.computed.alias("validation.failed");
      }
    }, {
      key: 'good',
      initializer: function () {
        return Ember.computed.not("bad");
      }
    }, {
      key: 'lastShownAt',
      decorators: [computed('shownAt', 'validation.lastShownAt')],
      value: function (shownAt, lastShownAt) {
        return shownAt || lastShownAt;
      }
    }, {
      key: 'bounce',
      decorators: [observes('lastShownAt')],
      value: function () {
        if (this.get("lastShownAt")) {
          var $elem = this.$();
          if (!this.animateAttribute) {
            this.animateAttribute = $elem.css('left') === 'auto' ? 'right' : 'left';
          }
          if (this.animateAttribute === 'left') {
            this.bounceLeft($elem);
          } else {
            this.bounceRight($elem);
          }
        }
      }
    }, {
      key: 'renderString',
      value: function (buffer) {
        var reason = this.get('validation.reason');
        if (!reason) {
          return;
        }

        buffer.push('<span class=\'close\'>' + iconHTML('times-circle') + '</span>' + reason);
      }
    }, {
      key: 'bounceLeft',
      value: function ($elem) {
        for (var i = 0; i < 5; i++) {
          $elem.animate({ left: '+=' + this.bouncePixels }, this.bounceDelay).animate({ left: '-=' + this.bouncePixels }, this.bounceDelay);
        }
      }
    }, {
      key: 'bounceRight',
      value: function ($elem) {
        for (var i = 0; i < 5; i++) {
          $elem.animate({ right: '-=' + this.bouncePixels }, this.bounceDelay).animate({ right: '+=' + this.bouncePixels }, this.bounceDelay);
        }
      }
    }]));
  });
define("discourse/components/popup-menu", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: "classNameBindings",
      initializer: function () {
        return ["visible::hidden", ":popup-menu", "extraClasses"];
      }
    }, {
      key: "_setup",
      decorators: [on('didInsertElement')],
      value: function () {
        var _this = this;

        this.appEvents.on("popup-menu:open", this, "_changeLocation");

        $('html').on("mouseup.popup-menu-" + this.get('elementId'), function (e) {
          var $target = $(e.target);
          if ($target.is("button") || _this.$().has($target).length === 0) {
            _this.sendAction('hide');
          }
        });
      }
    }, {
      key: "_cleanup",
      decorators: [on('willDestroyElement')],
      value: function () {
        $('html').off("mouseup.popup-menu-" + this.get('elementId'));
        this.appEvents.off("popup-menu:open", this, "_changeLocation");
      }
    }, {
      key: "_changeLocation",
      value: function (location) {
        var $this = this.$();
        switch (location.position) {
          case "absolute":
            {
              $this.css({
                position: "absolute",
                top: location.top - $this.innerHeight() + 5,
                left: location.left
              });
              break;
            }
          case "fixed":
            {
              $this.css({
                position: "fixed",
                top: location.top,
                left: location.left - $this.innerWidth()
              });
              break;
            }
        }
      }
    }]));
  });
define("discourse/components/poster-name", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var removed = new Discourse.RemovedObject('discourse/components/poster-name');
    __exports__["default"] = removed;
  });
define("discourse/components/preference-checkbox", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.Component.extend({
      classNames: ['controls'],

      label: (function () {
        return I18n.t(this.get('labelKey'));
      }).property('labelKey'),

      change: function () {
        var warning = this.get('warning');

        if (warning && this.get('checked')) {
          this.sendAction('warning');
          return false;
        }

        return true;
      }
    });
  });
define("discourse/components/queued-post", 
  ["discourse/lib/computed","discourse/mixins/buffered-content","discourse/lib/ajax-error","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;
    var bufferedProperty = __dependency2__.bufferedProperty;
    var popupAjaxError = __dependency3__.popupAjaxError;

    function updateState(state, opts) {
      opts = opts || {};

      return function () {
        var _this = this;

        var post = this.get('post');
        var args = { state: state };

        if (opts.deleteUser) {
          args.delete_user = true;
        }

        post.update(args).then(function () {
          _this.sendAction('removePost', post);
          // this.get('controllers.queued-posts.model').removeObject(post);
        }).catch(popupAjaxError);
      };
    }

    __exports__["default"] = Ember.Component.extend(bufferedProperty('post'), {
      editing: propertyEqual('post', 'currentlyEditing'),
      _confirmDelete: updateState('rejected', { deleteUser: true }),

      actions: {
        approve: updateState('approved'),
        reject: updateState('rejected'),

        deleteUser: function () {
          var _this2 = this;

          bootbox.confirm(I18n.t('queue.delete_prompt', { username: this.get('post.user.username') }), function (confirmed) {
            if (confirmed) {
              _this2._confirmDelete();
            }
          });
        },

        edit: function () {
          var _this3 = this;

          // This is stupid but pagedown cannot be on the screen twice or it will break
          this.set('currentlyEditing', null);
          Ember.run.scheduleOnce('afterRender', function () {
            return _this3.set('currentlyEditing', _this3.get('post'));
          });
        },

        confirmEdit: function () {
          var _this4 = this;

          this.get('post').update({ raw: this.get('buffered.raw') }).then(function () {
            _this4.commitBuffer();
            _this4.set('currentlyEditing', null);
          });
        },

        cancelEdit: function () {
          this.rollbackBuffer();
          this.set('currentlyEditing', null);
        }
      }
    });
  });
define("discourse/components/radio-button", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: "input",
      type: "radio",
      attributeBindings: ["name", "type", "value", "checked:checked"],
      click: function () {
        this.set("selection", this.$().val());
      },
      checked: (function () {
        return this.get("value") === this.get("selection");
      }).property('selection')
    });
  });
define("discourse/components/scrolling-post-stream", 
  ["discourse/lib/url","discourse/widgets/widget","discourse/components/mount-widget","discourse/widgets/post-stream","discourse/lib/safari-hacks","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];
    var keyDirty = __dependency2__.keyDirty;
    var MountWidget = __dependency3__["default"];
    var cloak = __dependency4__.cloak;
    var uncloak = __dependency4__.uncloak;
    var isWorkaroundActive = __dependency5__.isWorkaroundActive;

    function findTopView($posts, viewportTop, min, max) {
      if (max < min) {
        return min;
      }

      while (max > min) {
        var mid = Math.floor((min + max) / 2);
        var $post = $($posts[mid]);
        var viewBottom = $post.position().top + $post.height();

        if (viewBottom > viewportTop) {
          max = mid - 1;
        } else {
          min = mid + 1;
        }
      }

      return min;
    }

    __exports__["default"] = MountWidget.extend({
      widget: 'post-stream',
      _topVisible: null,
      _bottomVisible: null,

      args: Ember.computed(function () {
        return this.getProperties('posts', 'canCreatePost', 'multiSelect', 'gaps', 'selectedQuery', 'selectedPostsCount', 'searchService');
      }).volatile(),

      beforePatch: function () {
        var $body = $(document);
        this.prevHeight = $body.height();
        this.prevScrollTop = $body.scrollTop();
      },

      afterPatch: function () {
        var $body = $(document);
        var height = $body.height();
        var scrollTop = $body.scrollTop();

        // This hack is for when swapping out many cloaked views at once
        // when using keyboard navigation. It could suddenly move the
        // scroll
        if (this.prevHeight === height && scrollTop !== this.prevScrollTop) {
          $body.scrollTop(this.prevScrollTop);
        }
      },

      scrolled: function () {
        var _this = this;

        if (this.isDestroyed || this.isDestroying) {
          return;
        }
        if (isWorkaroundActive()) {
          return;
        }

        var $w = $(window);
        var windowHeight = window.innerHeight ? window.innerHeight : $w.height();
        var slack = Math.round(windowHeight * 5);
        var onscreen = [];
        var nearby = [];

        var windowTop = $w.scrollTop();

        var $posts = this.$('.onscreen-post, .cloaked-post');
        var viewportTop = windowTop - slack;
        var topView = findTopView($posts, viewportTop, 0, $posts.length - 1);

        var windowBottom = windowTop + windowHeight;
        var viewportBottom = windowBottom + slack;

        var bodyHeight = $('body').height();
        if (windowBottom > bodyHeight) {
          windowBottom = bodyHeight;
        }
        if (viewportBottom > bodyHeight) {
          viewportBottom = bodyHeight;
        }

        var bottomView = topView;
        while (bottomView < $posts.length) {
          var post = $posts[bottomView];
          var $post = $(post);

          if (!$post) {
            break;
          }

          var viewTop = $post.offset().top;
          var viewBottom = viewTop + $post.height() + 100;

          if (viewTop > viewportBottom) {
            break;
          }

          if (viewBottom > windowTop && viewTop <= windowBottom) {
            onscreen.push(bottomView);
          }
          nearby.push(bottomView);

          bottomView++;
        }

        var posts = this.posts;
        var refresh = function (cb) {
          return _this.queueRerender(cb);
        };
        if (onscreen.length) {
          var first = posts.objectAt(onscreen[0]);
          if (this._topVisible !== first) {
            (function () {
              _this._topVisible = first;
              var $body = $('body');
              var elem = $posts[onscreen[0]];
              var elemId = elem.id;
              var $elem = $(elem);
              var elemPos = $elem.position();
              var distToElement = elemPos ? $body.scrollTop() - elemPos.top : 0;

              var topRefresh = function () {
                refresh(function () {
                  var $refreshedElem = $('#' + elemId);

                  // Quickly going back might mean the element is destroyed
                  var position = $refreshedElem.position();
                  if (position && position.top) {
                    $('html, body').scrollTop(position.top + distToElement);
                  }
                });
              };
              _this.sendAction('topVisibleChanged', { post: first, refresh: topRefresh });
            })();
          }

          var last = posts.objectAt(onscreen[onscreen.length - 1]);
          if (this._bottomVisible !== last) {
            this._bottomVisible = last;
            this.sendAction('bottomVisibleChanged', { post: last, refresh: refresh });
          }
        } else {
          this._topVisible = null;
          this._bottomVisible = null;
        }

        var onscreenPostNumbers = [];
        var prev = this._previouslyNearby;
        var newPrev = {};
        nearby.forEach(function (idx) {
          var post = posts.objectAt(idx);
          var postNumber = post.post_number;
          delete prev[postNumber];

          if (onscreen.indexOf(idx) !== -1) {
            onscreenPostNumbers.push(postNumber);
          }
          newPrev[postNumber] = post;
          uncloak(post, _this);
        });

        Object.keys(prev).forEach(function (pn) {
          return cloak(prev[pn], _this);
        });

        this._previouslyNearby = newPrev;
        this.screenTrack.setOnscreen(onscreenPostNumbers);
      },

      _scrollTriggered: function () {
        Ember.run.scheduleOnce('afterRender', this, this.scrolled);
      },

      didInsertElement: function () {
        var _this2 = this;

        this._super();
        var debouncedScroll = function () {
          return Ember.run.debounce(_this2, _this2._scrollTriggered, 10);
        };

        this._previouslyNearby = {};

        this.appEvents.on('post-stream:refresh', debouncedScroll);
        $(document).bind('touchmove.post-stream', debouncedScroll);
        $(window).bind('scroll.post-stream', debouncedScroll);
        this._scrollTriggered();

        this.appEvents.on('post-stream:posted', function (staged) {
          var disableJumpReply = _this2.currentUser.get('disable_jump_reply');

          _this2.queueRerender(function () {
            if (staged && !disableJumpReply) {
              var postNumber = staged.get('post_number');
              DiscourseURL.jumpToPost(postNumber, { skipIfOnScreen: true });
            }
          });
        });

        this.$().on('mouseenter.post-stream', 'button.widget-button', function (e) {
          $('button.widget-button').removeClass('d-hover');
          $(e.target).addClass('d-hover');
        });

        this.$().on('mouseleave.post-stream', 'button.widget-button', function () {
          $('button.widget-button').removeClass('d-hover');
        });

        this.appEvents.on('post-stream:refresh', function (args) {
          if (args) {
            if (args.id) {
              keyDirty('post-' + args.id);

              if (args.refreshLikes) {
                keyDirty('post-menu-' + args.id, { onRefresh: 'refreshLikes' });
              }
            } else if (args.force) {
              keyDirty('*');
            }
          }
          _this2.queueRerender();
        });
      },

      willDestroyElement: function () {
        this._super();
        $(document).unbind('touchmove.post-stream');
        $(window).unbind('scroll.post-stream');
        this.appEvents.off('post-stream:refresh');
        this.$().off('mouseenter.post-stream');
        this.$().off('mouseleave.post-stream');
        this.appEvents.off('post-stream:refresh');
        this.appEvents.off('post-stream:posted');
      }

    });
  });
define("discourse/components/search-text-field", 
  ["ember-addons/ember-computed-decorators","discourse/components/text-field","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];
    var on = __dependency1__.on;
    var TextField = __dependency2__["default"];

    __exports__["default"] = TextField.extend(_createDecoratedObject([{
      key: 'placeholder',
      decorators: [computed('searchService.searchContextEnabled')],
      value: function (searchContextEnabled) {
        return searchContextEnabled ? "" : I18n.t('search.title');
      }
    }, {
      key: 'becomeFocused',
      decorators: [on("didInsertElement")],
      value: function () {
        if (!this.get('hasAutofocus')) {
          return;
        }
        // iOS is crazy, without this we will not be
        // at the top of the page
        $(window).scrollTop(0);
        this.$().focus();
      }
    }]));
  });
define("discourse/components/share-source", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      classNameBindings: [':social-link'],

      actions: {
        share: function (source) {
          this.sendAction('action', source);
        }
      }
    });
  });
define("discourse/components/show-popup-button", 
  ["discourse/components/d-button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DButton = __dependency1__["default"];

    __exports__["default"] = DButton.extend({
      click: function () {
        var $target = this.$(),
            position = $target.position(),
            width = $target.innerWidth(),
            loc = {
          position: this.get('position') || "fixed",
          left: position.left + width,
          top: position.top
        };

        this.appEvents.trigger("popup-menu:open", loc);
        this.sendAction("action");
      }
    });
  });
define("discourse/components/signup-cta", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      action: "showCreateAccount",

      actions: {
        neverShow: function () {
          this.keyValueStore.setItem('anon-cta-never', 't');
          this.session.set('showSignupCta', false);
        },
        hideForSession: function () {
          var _this = this;

          this.session.set('hideSignupCta', true);
          this.keyValueStore.setItem('anon-cta-hidden', new Date().getTime());
          Em.run.later(function () {
            return _this.session.set('showSignupCta', false);
          }, 20 * 1000);
        },
        showCreateAccount: function () {
          this.sendAction();
        }
      },

      _turnOffIfHidden: (function () {
        if (this.session.get('hideSignupCta')) {
          this.session.set('showSignupCta', false);
        }
      }).on('willDestroyElement')
    });
  });
define("discourse/components/small-action", 
  ["discourse/lib/formatter","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.actionDescriptionHtml = actionDescriptionHtml;
    __exports__.actionDescription = actionDescription;
    var autoUpdatingRelativeAge = __dependency1__.autoUpdatingRelativeAge;

    function actionDescriptionHtml(actionCode, createdAt, username) {
      var dt = new Date(createdAt);
      var when = autoUpdatingRelativeAge(dt, { format: 'medium-with-ago' });
      var who = username ? '<a class="mention" href="/users/' + username + '">@' + username + '</a>' : "";
      return I18n.t('action_codes.' + actionCode, { who: who, when: when }).htmlSafe();
    }

    function actionDescription(actionCode, createdAt, username) {
      return (function () {
        var ac = this.get(actionCode);
        if (ac) {
          return actionDescriptionHtml(ac, this.get(createdAt), this.get(username));
        }
      }).property(actionCode, createdAt);
    }

    __exports__["default"] = Ember.Component.extend({
      layoutName: 'components/small-action', // needed because `time-gap` inherits from this
      classNames: ['small-action'],

      description: actionDescription('actionCode', 'post.created_at', 'post.action_code_who'),

      actions: {
        edit: function () {
          this.sendAction('editPost', this.get('post'));
        },

        delete: function () {
          this.sendAction('deletePost', this.get('post'));
        }
      }

    });
  });
define("discourse/components/stream-item", 
  ["discourse/lib/computed","discourse/components/small-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var propertyEqual = __dependency1__.propertyEqual;
    var actionDescription = __dependency2__.actionDescription;

    __exports__["default"] = Ember.Component.extend({
      classNameBindings: [":item", "item.hidden", "item.deleted", "moderatorAction"],
      moderatorAction: propertyEqual("item.post_type", "site.post_types.moderator_action"),
      actionDescription: actionDescription("item.action_code", "item.created_at", "item.username"),

      actions: {
        removeBookmark: function (userAction) {
          this.sendAction("removeBookmark", userAction);
        }
      }
    });
  });
define("discourse/components/tag-chooser", 
  ["discourse/lib/render-tag","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var renderTag = __dependency1__["default"];

    function formatTag(t) {
      return renderTag(t.id, { count: t.count });
    }

    __exports__["default"] = Ember.TextField.extend({
      classNameBindings: [':tag-chooser'],
      attributeBindings: ['tabIndex'],

      _setupTags: (function () {
        var tags = this.get('tags') || [];
        this.set('value', tags.join(", "));
      }).on('init'),

      _valueChanged: (function () {
        var tags = this.get('value').split(',').map(function (v) {
          return v.trim();
        }).reject(function (v) {
          return v.length === 0;
        }).uniq();
        this.set('tags', tags);
      }).observes('value'),

      _initializeTags: (function () {
        var site = this.site,
            self = this,
            filterRegexp = new RegExp(this.site.tags_filter_regexp, "g");

        this.$().select2({
          tags: true,
          placeholder: I18n.t('tagging.choose_for_topic'),
          maximumInputLength: this.siteSettings.max_tag_length,
          maximumSelectionSize: this.siteSettings.max_tags_per_topic,
          initSelection: function (element, callback) {
            var data = [];

            function splitVal(string, separator) {
              var val, i, l;
              if (string === null || string.length < 1) return [];
              val = string.split(separator);
              for (i = 0, l = val.length; i < l; i = i + 1) val[i] = $.trim(val[i]);
              return val;
            }

            $(splitVal(element.val(), ",")).each(function () {
              data.push({
                id: this,
                text: this
              });
            });

            callback(data);
          },
          createSearchChoice: function (term, data) {
            term = term.replace(filterRegexp, '').trim();

            // No empty terms, make sure the user has permission to create the tag
            if (!term.length || !site.get('can_create_tag')) {
              return;
            }

            if ($(data).filter(function () {
              return this.text.localeCompare(term) === 0;
            }).length === 0) {
              return { id: term, text: term };
            }
          },
          createSearchChoicePosition: function (list, item) {
            // Search term goes on the bottom
            list.push(item);
          },
          formatSelection: function (data) {
            return data ? renderTag(this.text(data)) : undefined;
          },
          formatSelectionCssClass: function () {
            return "discourse-tag-select2";
          },
          formatResult: formatTag,
          multiple: true,
          ajax: {
            quietMillis: 200,
            cache: true,
            url: Discourse.getURL("/tags/filter/search"),
            dataType: 'json',
            data: function (term) {
              return { q: term, limit: self.siteSettings.max_tag_search_results };
            },
            results: function (data) {
              if (self.siteSettings.tags_sort_alphabetically) {
                data.results = data.results.sort(function (a, b) {
                  return a.id > b.id;
                });
              }
              return data;
            }
          }
        });
      }).on('didInsertElement'),

      _destroyTags: (function () {
        this.$().select2('destroy');
      }).on('willDestroyElement')

    });
  });
define("discourse/components/tag-drop-link", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend({
      tagName: 'a',
      classNameBindings: [':tag-badge-wrapper', ':badge-wrapper', ':bullet', 'tagClass'],
      attributeBindings: ['href'],

      href: (function () {
        var url = '/tags';
        if (this.get('category')) {
          url += this.get('category.url');
        }
        return url + '/' + this.get('tagId');
      }).property('tagId', 'category'),

      tagClass: (function () {
        return "tag-" + this.get('tagId');
      }).property('tagId'),

      render: function (buffer) {
        buffer.push(Handlebars.Utils.escapeExpression(this.get('tagId')));
      },

      click: function (e) {
        e.preventDefault();
        DiscourseURL.routeTo(this.get('href'));
        return true;
      }
    });
  });
define("discourse/components/tag-drop", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var setting = __dependency1__.setting;

    __exports__["default"] = Ember.Component.extend({
      classNameBindings: [':tag-drop', 'tag::no-category', 'tags:has-drop', 'categoryStyle', 'tagClass'],
      categoryStyle: setting('category_style'), // match the category-drop style
      currentCategory: Em.computed.or('secondCategory', 'firstCategory'),
      showFilterByTag: setting('show_filter_by_tag'),
      showTagDropdown: Em.computed.and('showFilterByTag', 'tags'),
      tagId: null,

      tagName: 'li',

      tags: (function () {
        if (this.siteSettings.tags_sort_alphabetically && Discourse.Site.currentProp('top_tags')) {
          return Discourse.Site.currentProp('top_tags').sort();
        } else {
          return Discourse.Site.currentProp('top_tags');
        }
      }).property('site.top_tags'),

      iconClass: (function () {
        if (this.get('expanded')) {
          return "fa fa-caret-down";
        }
        return "fa fa-caret-right";
      }).property('expanded'),

      tagClass: (function () {
        if (this.get('tagId')) {
          return "tag-" + this.get('tagId');
        } else {
          return "tag_all";
        }
      }).property('tagId'),

      allTagsUrl: (function () {
        if (this.get('currentCategory')) {
          return this.get('currentCategory.url') + "?allTags=1";
        } else {
          return "/";
        }
      }).property('firstCategory', 'secondCategory'),

      allTagsLabel: (function () {
        return I18n.t("tagging.selector_all_tags");
      }).property('tag'),

      dropdownButtonClass: (function () {
        var result = 'badge-category category-dropdown-button';
        if (Em.isNone(this.get('tag'))) {
          result += ' home';
        }
        return result;
      }).property('tag'),

      clickEventName: (function () {
        return "click.tag-drop-" + (this.get('tag') || "all");
      }).property('tag'),

      actions: {
        expand: function () {
          var self = this;

          if (!this.get('renderTags')) {
            this.set('renderTags', true);
            Em.run.next(function () {
              self.send('expand');
            });
            return;
          }

          if (this.get('expanded')) {
            this.close();
            return;
          }

          if (this.get('tags')) {
            this.set('expanded', true);
          }
          var $dropdown = this.$()[0];

          this.$('a[data-drop-close]').on('click.tag-drop', function () {
            self.close();
          });

          Em.run.next(function () {
            self.$('.cat a').add('html').on(self.get('clickEventName'), function (e) {
              var $target = $(e.target),
                  closest = $target.closest($dropdown);

              if ($(e.currentTarget).hasClass('badge-wrapper')) {
                self.close();
              }

              return $(e.currentTarget).hasClass('badge-category') || closest.length && closest[0] === $dropdown ? true : self.close();
            });
          });
        }
      },

      removeEvents: function () {
        $('html').off(this.get('clickEventName'));
        this.$('a[data-drop-close]').off('click.tag-drop');
      },

      close: function () {
        this.removeEvents();
        this.set('expanded', false);
      },

      willDestroyElement: function () {
        this.removeEvents();
      }

    });
  });
define("discourse/components/tag-notifications-button", 
  ["discourse/components/notifications-button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var NotificationsButton = __dependency1__["default"];

    __exports__["default"] = NotificationsButton.extend({
      classNames: ['notification-options', 'tag-notification-menu'],
      buttonIncludesText: false,
      i18nPrefix: 'tagging.notifications',

      clicked: function (id) {
        this.sendAction('action', id);
      }
    });
  });
define("discourse/components/text-overflow", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      _parse: (function () {
        var _this = this;

        Ember.run.next(null, function () {
          _this.$().find('hr').remove();
          _this.$().ellipsis();
        });
      }).on('didInsertElement'),

      render: function (buffer) {
        buffer.push(this.get('text'));
      }
    });
  });
define("discourse/components/toggle-deleted", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      layoutName: 'components/toggle-deleted',
      tagName: 'section',
      classNames: ['information'],
      postStream: Em.computed.alias('topic.postStream'),

      actions: {
        toggleDeleted: function () {
          this.get('postStream').toggleDeleted();
        }
      }
    });
  });
define("discourse/components/top-period-buttons", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      classNames: ['top-title-buttons'],

      periods: (function () {
        var period = this.get('period');
        return this.site.get('periods').filter(function (p) {
          return p !== period;
        });
      }).property('period'),

      actions: {
        changePeriod: function (p) {
          this.sendAction('action', p);
        }
      }
    });
  });
define("discourse/components/topic-closing", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      elementId: 'topic-closing-info',
      delayedRerender: null,

      rerenderTriggers: ['topic.closed', 'topic.details.auto_close_at', 'topic.details.auto_close_based_on_last_post', 'topic.details.auto_close_hours'],

      renderString: function (buffer) {
        if (!!Ember.isEmpty(this.get('topic.details.auto_close_at'))) return;
        if (this.get("topic.closed")) return;

        var autoCloseAt = moment(this.get('topic.details.auto_close_at'));
        if (autoCloseAt < new Date()) return;

        var duration = moment.duration(autoCloseAt - moment());
        var minutesLeft = duration.asMinutes();
        var timeLeftString = duration.humanize(true);
        var rerenderDelay = 1000;

        if (minutesLeft > 2160) {
          rerenderDelay = 12 * 60 * 60000;
        } else if (minutesLeft > 1410) {
          rerenderDelay = 60 * 60000;
        } else if (minutesLeft > 90) {
          rerenderDelay = 30 * 60000;
        } else if (minutesLeft > 2) {
          rerenderDelay = 60000;
        }

        var basedOnLastPost = this.get("topic.details.auto_close_based_on_last_post");
        var key = basedOnLastPost ? 'topic.auto_close_notice_based_on_last_post' : 'topic.auto_close_notice';
        var autoCloseHours = this.get("topic.details.auto_close_hours") || 0;

        buffer.push('<h3><i class="fa fa-clock-o"></i> ');
        buffer.push(I18n.t(key, { timeLeft: timeLeftString, duration: moment.duration(autoCloseHours, "hours").humanize() }));
        buffer.push('</h3>');

        // TODO Sam: concerned this can cause a heavy rerender loop
        this.set('delayedRerender', Em.run.later(this, this.rerender, rerenderDelay));
      },

      willDestroyElement: function () {
        if (this.delayedRerender) {
          Em.run.cancel(this.get('delayedRerender'));
        }
      }
    });
  });
define("discourse/components/topic-footer-buttons", 
  ["discourse/views/container","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ContainerView = __dependency1__["default"];
    var on = __dependency2__.on;

    __exports__["default"] = ContainerView.extend(_createDecoratedObject([{
      key: 'elementId',
      initializer: function () {
        return 'topic-footer-buttons';
      }
    }, {
      key: 'createButtons',
      decorators: [on('init')],
      value: function () {
        var topic = this.get('topic');
        var currentUser = this.get('controller.currentUser');

        if (currentUser) {
          var viewArgs = { topic: topic, currentUser: currentUser };
          this.attachViewWithArgs(viewArgs, 'topic-footer-main-buttons');
          this.attachViewWithArgs(viewArgs, 'pinned-button');
          this.attachViewWithArgs(viewArgs, 'topic-notifications-button');

          this.trigger('additionalButtons', this);
        } else {
          // If not logged in give them a login control
          this.attachViewClass('login-reply-button');
        }
      }
    }]));
  });
define("discourse/components/topic-footer-mobile-dropdown", 
  ["discourse/helpers/fa-icon","discourse/components/combo-box","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var iconHTML = __dependency1__.iconHTML;
    var Combobox = __dependency2__["default"];
    var on = __dependency3__.on;
    var observes = __dependency3__.observes;

    __exports__["default"] = Combobox.extend(_createDecoratedObject([{
      key: 'none',
      initializer: function () {
        return "topic.controls";
      }
    }, {
      key: '_createContent',
      decorators: [on('init')],
      value: function () {
        var content = [];
        var topic = this.get('topic');
        var details = topic.get('details');

        if (details.get('can_invite_to')) {
          content.push({ id: 'invite', icon: 'users', name: I18n.t('topic.invite_reply.title') });
        }

        if (topic.get('bookmarked')) {
          content.push({ id: 'bookmark', icon: 'bookmark', name: I18n.t('bookmarked.clear_bookmarks') });
        } else {
          content.push({ id: 'bookmark', icon: 'bookmark', name: I18n.t('bookmarked.title') });
        }
        content.push({ id: 'share', icon: 'link', name: I18n.t('topic.share.title') });

        if (details.get('can_flag_topic')) {
          content.push({ id: 'flag', icon: 'flag', name: I18n.t('topic.flag_topic.title') });
        }

        this.comboTemplate = function (item) {
          var contentItem = content.findProperty('id', item.id);
          if (!contentItem) {
            return item.text;
          }
          return iconHTML(contentItem.icon) + '&nbsp; ' + item.text;
        };

        this.set('content', content);
      }
    }, {
      key: '_valueChanged',
      decorators: [observes('value')],
      value: function () {
        var _this = this;

        var value = this.get('value');
        var controller = this.get('parentView.controller');
        var topic = this.get('topic');

        var refresh = function () {
          _this._createContent();
          _this.set('value', null);
        };

        switch (value) {
          case 'invite':
            controller.send('showInvite');
            refresh();
            break;
          case 'bookmark':
            topic.toggleBookmark().then(function () {
              return refresh();
            });
            break;
          case 'share':
            this.appEvents.trigger('share:url', topic.get('shareUrl'), $('#topic-footer-buttons'));
            refresh();
            break;
          case 'flag':
            controller.send('showFlagTopic', topic);
            refresh();
            break;
        }
      }
    }]));
  });
define("discourse/components/topic-list-item", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      rerenderTriggers: ['bulkSelectEnabled', 'topic.pinned'],
      tagName: 'tr',
      rawTemplate: 'list/topic-list-item.raw',
      classNameBindings: [':topic-list-item', 'unboundClassNames'],
      attributeBindings: ['data-topic-id'],
      'data-topic-id': Em.computed.alias('topic.id'),

      actions: {
        toggleBookmark: function () {
          var _this = this;

          this.get('topic').toggleBookmark().finally(function () {
            return _this.rerender();
          });
        }
      },

      unboundClassNames: (function () {
        var classes = [];
        var topic = this.get('topic');

        if (topic.get('category')) {
          classes.push("category-" + topic.get('category.fullSlug'));
        }

        if (topic.get('hasExcerpt')) {
          classes.push('has-excerpt');
        }

        _.each(['liked', 'archived', 'bookmarked'], function (name) {
          if (topic.get(name)) {
            classes.push(name);
          }
        });

        return classes.join(' ');
      }).property(),

      titleColSpan: (function () {
        return !this.get('hideCategory') && this.get('topic.isPinnedUncategorized') ? 2 : 1;
      }).property("topic.isPinnedUncategorized"),

      hasLikes: function () {
        return this.get('topic.like_count') > 0;
      },

      hasOpLikes: function () {
        return this.get('topic.op_like_count') > 0;
      },

      expandPinned: (function () {
        var pinned = this.get('topic.pinned');
        if (!pinned) {
          return false;
        }

        if (this.get('expandGloballyPinned') && this.get('topic.pinned_globally')) {
          return true;
        }

        if (this.get('expandAllPinned')) {
          return true;
        }

        return false;
      }).property(),

      click: function (e) {
        var target = $(e.target);

        if (target.hasClass('posts-map') || target.parents('.posts-map').length > 0) {
          if (target.prop('tagName') !== 'A') {
            target = target.find('a');
            if (target.length === 0) {
              target = target.end();
            }
          }
          this.container.lookup('controller:application').send("showTopicEntrance", { topic: this.get('topic'), position: target.offset() });
          return false;
        }

        if (target.hasClass('bulk-select')) {
          var selected = this.get('selected');
          var topic = this.get('topic');

          if (target.is(':checked')) {
            selected.addObject(topic);
          } else {
            selected.removeObject(topic);
          }
        }

        if (target.closest('a.topic-status').length === 1) {
          this.get('topic').togglePinnedForUser();
          return false;
        }
      },

      highlight: function () {
        var $topic = this.$();
        var originalCol = $topic.css('backgroundColor');
        $topic.addClass('highlighted').stop().animate({ backgroundColor: originalCol }, 2500, 'swing', function () {
          $topic.removeClass('highlighted');
        });
      },

      _highlightIfNeeded: (function () {
        // highlight the last topic viewed
        if (this.session.get('lastTopicIdViewed') === this.get('topic.id')) {
          this.session.set('lastTopicIdViewed', null);
          this.highlight();
        } else if (this.get('topic.highlight')) {
          // highlight new topics that have been loaded from the server or the one we just created
          this.set('topic.highlight', false);
          this.highlight();
        }
      }).on('didInsertElement')

    });
  });
define("discourse/components/topic-list", 
  ["exports"],
  function(__exports__) {
    "use strict";

    __exports__["default"] = Ember.Component.extend({
      tagName: 'table',
      classNames: ['topic-list'],
      showTopicPostBadges: true,

      _observeHideCategory: (function () {
        this.addObserver('hideCategory', this.rerender);
        this.addObserver('order', this.rerender);
        this.addObserver('ascending', this.rerender);
      }).on('init'),

      toggleInTitle: (function () {
        return !this.get('bulkSelectEnabled') && this.get('canBulkSelect');
      }).property('bulkSelectEnabled'),

      sortable: (function () {
        return !!this.get('changeSort');
      }).property(),

      skipHeader: (function () {
        return this.site.mobileView;
      }).property(),

      showLikes: (function () {
        return this.get('order') === "likes";
      }).property('order'),

      showOpLikes: (function () {
        return this.get('order') === "op_likes";
      }).property('order'),

      click: function (e) {
        var self = this;
        var on = function (sel, callback) {
          var target = $(e.target).closest(sel);

          if (target.length === 1) {
            callback.apply(self, [target]);
          }
        };

        on('button.bulk-select', function () {
          this.sendAction('toggleBulkSelect');
          this.rerender();
        });

        on('th.sortable', function (e2) {
          this.sendAction('changeSort', e2.data('sort-order'));
          this.rerender();
        });
      }
    });
  });
define("discourse/components/topic-post-badges", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    // Creates a link
    function link(buffer, prop, url, cssClass, i18nKey, text) {
      if (!prop) {
        return;
      }

      var title = I18n.t("topic." + i18nKey, { count: prop });
      buffer.push("<a href='" + url + "' class='badge " + cssClass + " badge-notification' title='" + title + "'>" + (text || prop) + "</a>\n");
    }

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      tagName: 'span',
      classNameBindings: [':topic-post-badges'],
      rerenderTriggers: ['url', 'unread', 'newPosts', 'unseen'],

      renderString: function (buffer) {
        var url = this.get('url');

        link(buffer, this.get('unread'), url, 'unread', 'unread_posts');
        link(buffer, this.get('newPosts'), url, 'new-posts', 'new_posts');
        link(buffer, this.get('unseen'), url, 'new-topic', 'new', I18n.t('filters.new.lower_title'));
      }
    });
  });
define("discourse/components/topic-status", 
  ["discourse/helpers/fa-icon","discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var iconHTML = __dependency1__.iconHTML;
    var StringBuffer = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(StringBuffer, {
      classNames: ['topic-statuses'],

      rerenderTriggers: ['topic.archived', 'topic.closed', 'topic.pinned', 'topic.visible', 'topic.unpinned', 'topic.is_warning'],

      click: function (e) {
        if ($(e.target).hasClass('fa-thumb-tack')) {
          var topic = this.get('topic');

          // only pin unpin for now
          if (topic.get('pinned')) {
            topic.clearPin();
          } else {
            topic.rePin();
          }
        }

        return false;
      },

      canAct: (function () {
        return Discourse.User.current() && !this.get('disableActions');
      }).property('disableActions'),

      renderString: function (buffer) {
        var self = this;

        var renderIcon = function (name, key, actionable) {
          var title = Discourse.Utilities.escapeExpression(I18n.t('topic_statuses.' + key + '.help')),
              startTag = actionable ? "a href" : "span",
              endTag = actionable ? "a" : "span",
              iconArgs = key === 'unpinned' ? { 'class': 'unpinned' } : null,
              icon = iconHTML(name, iconArgs);

          buffer.push('<' + startTag + ' title=\'' + title + '\' class=\'topic-status\'>' + icon + '</' + endTag + '>');
        };

        var renderIconIf = function (conditionProp, name, key, actionable) {
          if (!self.get(conditionProp)) {
            return;
          }
          renderIcon(name, key, actionable);
        };

        renderIconIf('topic.is_warning', 'envelope', 'warning');

        if (this.get('topic.closed') && this.get('topic.archived')) {
          renderIcon('lock', 'locked_and_archived');
        } else {
          renderIconIf('topic.closed', 'lock', 'locked');
          renderIconIf('topic.archived', 'lock', 'archived');
        }

        renderIconIf('topic.pinned', 'thumb-tack', 'pinned', this.get("canAct"));
        renderIconIf('topic.unpinned', 'thumb-tack', 'unpinned', this.get("canAct"));
        renderIconIf('topic.invisible', 'eye-slash', 'invisible');
      }
    });
  });
define("discourse/components/track-selected", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: "span",
      selectionChanged: (function () {
        var selected = this.get('selected');
        var list = this.get('selectedList');
        var id = this.get('selectedId');

        if (selected) {
          list.addObject(id);
        } else {
          list.removeObject(id);
        }
      }).observes('selected')
    });
  });
define("discourse/components/user-badge", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'span',

      showGrantCount: (function () {
        return this.get('count') && this.get('count') > 1;
      }).property('count'),

      badgeUrl: (function () {
        // NOTE: I tried using a link-to helper here but the queryParams mean it fails
        var username = this.get('user.username_lower') || '';
        username = username !== '' ? "?username=" + username : '';
        return this.get('badge.url') + username;
      }).property("badge", "user")

    });
  });
define("discourse/components/user-field", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var fmt = __dependency1__.fmt;

    __exports__["default"] = Ember.Component.extend({
      classNameBindings: [':user-field', 'field.field_type'],
      layoutName: fmt('field.field_type', 'components/user-fields/%@'),

      noneLabel: (function () {
        return 'user_fields.none';
      }).property()
    });
  });
define("discourse/components/user-info", 
  ["discourse/lib/computed","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var url = __dependency1__.url;
    var computed = __dependency2__["default"];

    function normalize(name) {
      return name.replace(/[\-\_ \.]/g, '').toLowerCase();
    }

    __exports__["default"] = Ember.Component.extend(_createDecoratedObject([{
      key: 'classNameBindings',
      initializer: function () {
        return [':user-info', 'size'];
      }
    }, {
      key: 'size',
      initializer: function () {
        return 'small';
      }
    }, {
      key: 'userPath',
      initializer: function () {
        return url('user.username', '/users/%@');
      }
    }, {
      key: 'hasBlock',

      // TODO: In later ember releases `hasBlock` works without this
      initializer: function () {
        return Ember.computed.alias('template');
      }
    }, {
      key: 'name',
      decorators: [computed('user.name', 'user.username')],
      value: function (name, username) {
        if (name && normalize(username) !== normalize(name)) {
          return name;
        }
      }
    }]));
  });
define("discourse/components/user-link", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'a',
      attributeBindings: ['href', 'data-user-card'],
      href: Ember.computed.alias('user.path'),
      'data-user-card': Ember.computed.alias('user.username')
    });
  });
define("discourse/components/user-notifications-large", 
  ["discourse/components/mount-widget","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var MountWidget = __dependency1__["default"];
    var observes = __dependency2__.observes;

    __exports__["default"] = MountWidget.extend(_createDecoratedObject([{
      key: 'widget',
      initializer: function () {
        return 'user-notifications-large';
      }
    }, {
      key: 'init',
      value: function () {
        this._super();
        this.args = { notifications: this.get('notifications') };
      }
    }, {
      key: '_triggerRefresh',
      decorators: [observes('notifications.length', 'notifications.@each.read')],
      value: function () {
        this.queueRerender();
      }
    }]));
  });
define("discourse/components/user-selector", 
  ["discourse/components/text-field","discourse/lib/user-search","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var TextField = __dependency1__["default"];
    var userSearch = __dependency2__["default"];

    __exports__["default"] = TextField.extend({

      _initializeAutocomplete: (function () {
        var self = this,
            selected = [],
            groups = [],
            currentUser = this.currentUser,
            includeMentionableGroups = this.get('includeMentionableGroups') === 'true',
            includeGroups = this.get('includeGroups') === 'true',
            allowedUsers = this.get('allowedUsers') === 'true';

        function excludedUsernames() {
          if (currentUser && self.get('excludeCurrentUser')) {
            return selected.concat([currentUser.get('username')]);
          }
          return selected;
        }

        this.$().val(this.get('usernames')).autocomplete({
          template: this.container.lookup('template:user-selector-autocomplete.raw'),
          disabled: this.get('disabled'),
          single: this.get('single'),
          allowAny: this.get('allowAny'),

          dataSource: function (term) {
            var results = userSearch({
              term: term.replace(/[^a-zA-Z0-9_\-\.]/, ''),
              topicId: self.get('topicId'),
              exclude: excludedUsernames(),
              includeGroups: includeGroups,
              allowedUsers: allowedUsers,
              includeMentionableGroups: includeMentionableGroups
            });

            return results;
          },

          transformComplete: function (v) {
            if (v.username || v.name) {
              if (!v.username) {
                groups.push(v.name);
              }
              return v.username || v.name;
            } else {
              var excludes = excludedUsernames();
              return v.usernames.filter(function (item) {
                return excludes.indexOf(item) === -1;
              });
            }
          },

          onChangeItems: function (items) {
            var hasGroups = false;
            items = items.map(function (i) {
              if (groups.indexOf(i) > -1) {
                hasGroups = true;
              }
              return i.username ? i.username : i;
            });
            self.set('usernames', items.join(","));
            self.set('hasGroups', hasGroups);

            selected = items;
          },

          reverseTransform: function (i) {
            return { username: i };
          }

        });
      }).on('didInsertElement'),

      _removeAutocomplete: (function () {
        this.$().autocomplete('destroy');
      }).on('willDestroyElement'),

      // THIS IS A HUGE HACK TO SUPPORT CLEARING THE INPUT
      _clearInput: (function () {
        if (arguments.length > 1) {
          if (Em.isEmpty(this.get("usernames"))) {
            this.$().parent().find("a").click();
          }
        }
      }).observes("usernames")

    });
  });
define("discourse/components/user-stat", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      classNames: ['user-stat']
    });
  });
define("discourse/components/user-stream", 
  ["discourse/mixins/load-more","discourse/lib/click-track","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var LoadMore = __dependency1__["default"];
    var ClickTrack = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend(LoadMore, {
      loading: false,
      eyelineSelector: '.user-stream .item',
      classNames: ['user-stream'],

      _scrollTopOnModelChange: (function () {
        Em.run.schedule('afterRender', function () {
          return $(document).scrollTop(0);
        });
      }).observes('stream.user.id'),

      _inserted: (function () {
        var _this = this;

        this.bindScrolling({ name: 'user-stream-view' });

        $(window).on('resize.discourse-on-scroll', function () {
          return _this.scrolled();
        });

        this.$().on('mouseup.discourse-redirect', '.excerpt a', function (e) {
          // bypass if we are selecting stuff
          var selection = window.getSelection && window.getSelection();
          if (selection.type === "Range" || selection.rangeCount > 0) {
            if (Discourse.Utilities.selectedText() !== "") {
              return true;
            }
          }

          var $target = $(e.target);
          if ($target.hasClass('mention') || $target.parents('.expanded-embed').length) {
            return false;
          }

          return ClickTrack.trackClick(e);
        });
      }).on('didInsertElement'),

      // This view is being removed. Shut down operations
      _destroyed: (function () {
        this.unbindScrolling('user-stream-view');
        $(window).unbind('resize.discourse-on-scroll');

        // Unbind link tracking
        this.$().off('mouseup.discourse-redirect', '.excerpt a');
      }).on('willDestroyElement'),

      actions: {
        loadMore: function () {
          var _this2 = this;

          if (this.get('loading')) {
            return;
          }

          this.set('loading', true);
          var stream = this.get('stream');
          stream.findItems().then(function () {
            _this2.set('loading', false);
            _this2.get('eyeline').flushRest();
          });
        }
      }
    });
  });
define("discourse/views/application", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      _appendCategoryClass: (function (obj, key) {
        var newClass = Em.get(obj, key);
        if (newClass) {
          $('body').addClass('category-' + newClass);
        }
      }).observes('controller.styleCategory.id'),

      _removeOldClass: (function (obj, key) {
        var oldClass = Em.get(obj, key);
        if (oldClass) {
          $('body').removeClass('category-' + oldClass);
        }
      }).observesBefore('controller.styleCategory.id')
    });
  });
define("discourse/views/archive-button", 
  ["discourse/mixins/string-buffer","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var StringBuffer = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(StringBuffer, {
      tagName: 'button',
      classNames: ['btn', 'standard'],
      attributeBindings: ['title'],
      archived: Em.computed.alias('controller.model.message_archived'),
      archiving: Em.computed.alias('controller.model.archiving'),
      rerenderTriggers: ['archived', 'archiving'],

      title: (function () {
        var key = this.get('archived') ? 'topic.move_to_inbox.help' : 'topic.archive_message.help';
        return I18n.t(key);
      }).property('archived'),

      renderString: function (buffer) {
        if (this.get('archived')) {
          buffer.push(I18n.t('topic.move_to_inbox.title'));
        } else {
          buffer.push("<i class='fa fa-folder'></i>");
          buffer.push(I18n.t('topic.archive_message.title'));
        }
      },

      click: function () {
        if (!this.get('archiving')) {
          if (this.get('archived')) {
            this.get('controller').send('moveToInbox');
          } else {
            this.get('controller').send('archiveMessage');
          }
        }
      }
    });
  });
define("discourse/views/avatar-selector", 
  ["ember-addons/ember-computed-decorators","discourse/views/modal-body","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;
    var observes = __dependency1__.observes;
    var ModalBodyView = __dependency2__["default"];

    __exports__["default"] = ModalBodyView.extend(_createDecoratedObject([{
      key: "templateName",
      initializer: function () {
        return 'modal/avatar_selector';
      }
    }, {
      key: "classNames",
      initializer: function () {
        return ['avatar-selector'];
      }
    }, {
      key: "title",
      initializer: function () {
        return I18n.t('user.change_avatar.title');
      }
    }, {
      key: "selectedChanged",
      decorators: [observes("controller.selected"), on("didInsertElement")],
      value: function () {
        var _this = this;

        Em.run.next(function () {
          return $('input:radio[name="avatar"]').val([_this.get('controller.selected')]);
        });
      }
    }, {
      key: "_focusSelectedButton",
      decorators: [on("didInsertElement")],
      value: function () {
        var _this2 = this;

        Em.run.next(function () {
          return $('input:radio[value="' + _this2.get('controller.selected') + '"]').focus();
        });
      }
    }]));

    // *HACK* used to select the proper radio button, because {{action}} stops the default behavior
  });
define("discourse/views/badges-index", 
  ["discourse/mixins/scroll-top","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ScrollTop = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(ScrollTop);
  });
define("discourse/views/bookmark-button", 
  ["discourse/views/button","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ButtonView = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    __exports__["default"] = ButtonView.extend({
      classNames: ['bookmark'],
      attributeBindings: ['disabled'],

      bookmarked: Ember.computed.alias('controller.model.bookmarked'),

      textKey: (function () {
        return this.get('bookmarked') ? 'bookmarked.clear_bookmarks' : 'bookmarked.title';
      }).property('bookmarked'),

      rerenderTriggers: ['bookmarked'],

      helpKey: (function () {
        return this.get("bookmarked") ? "bookmarked.help.unbookmark" : "bookmarked.help.bookmark";
      }).property("bookmarked"),

      click: function () {
        this.get('controller').send('toggleBookmark');
      },

      renderIcon: function (buffer) {
        var className = this.get("bookmarked") ? "bookmarked" : "";
        buffer.push(iconHTML('bookmark', { class: className }));
      }
    });
  });
define("discourse/views/composer-messages", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.CollectionView.extend({
      classNameBindings: [':composer-popup-container', 'hidden'],
      content: Em.computed.alias('controller.content'),

      hidden: Em.computed.not('controller.controllers.composer.model.viewOpen'),

      itemViewClass: Ember.View.extend({
        classNames: ['composer-popup', 'hidden'],
        templateName: Em.computed.alias('content.templateName'),

        _setup: (function () {
          this._super();
          this.set('context', this.get('content'));

          if (this.get('content.extraClass')) {
            this.get('classNames').pushObject(this.get('content.extraClass'));
          }
        }).on('init'),

        _initCss: (function () {
          this.$().show();
        }).on('didInsertElement')
      })
    });
  });
define("discourse/views/create-account", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/create-account',
      title: I18n.t('create_account.title'),
      classNames: ['create-account'],

      _setup: (function () {
        // Allows submitting the form when pressing 'ENTER' on *any* text input field
        // but only when the submit button is enabled.
        var createAccountController = this.get('controller');

        if ($.cookie('email')) {
          createAccountController.set('accountEmail', $.cookie('email'));
        }

        Em.run.schedule('afterRender', function () {
          $("input[type='text'], input[type='password']").keydown(function (e) {
            if (createAccountController.get('submitDisabled') === false && e.keyCode === 13) {
              createAccountController.send('createAccount');
            }
          });
        });
      }).on('didInsertElement')
    });
  });
define("discourse/views/edit-topic-auto-close", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: "modal/edit-topic-auto-close",
      title: I18n.t("topic.auto_close_title"),
      focusInput: false
    });
  });
define("discourse/views/flag-topic-button", 
  ["discourse/views/button","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ButtonView = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    __exports__["default"] = ButtonView.extend({
      classNames: ['flag-topic'],
      textKey: 'topic.flag_topic.title',
      helpKey: 'topic.flag_topic.help',

      click: function () {
        this.get('controller').send('showFlagTopic', this.get('controller.content'));
      },

      renderIcon: function (buffer) {
        buffer.push(iconHTML('flag'));
      }
    });
  });
define("discourse/views/full-page-search", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend();
  });
define("discourse/views/hide-modal", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.View.extend({
      // No rendering!
      render: Em.K,

      _hideModal: (function () {
        $('#discourse-modal').modal('hide');
      }).on('didInsertElement')
    });
  });
define("discourse/views/history", 
  ["discourse/views/modal-body","discourse/lib/click-track","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];
    var ClickTrack = __dependency2__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/history',
      title: I18n.t('history'),

      resizeModal: (function () {
        var viewPortHeight = $(window).height();
        this.$(".modal-body").css("max-height", Math.floor(0.8 * viewPortHeight) + "px");
      }).on("didInsertElement"),

      _inserted: (function () {
        this.$().on('mouseup.discourse-redirect', '#revisions a', function (e) {
          // bypass if we are selecting stuff
          var selection = window.getSelection && window.getSelection();
          if (selection.type === "Range" || selection.rangeCount > 0) {
            if (Discourse.Utilities.selectedText() !== "") {
              return true;
            }
          }

          var $target = $(e.target);
          if ($target.hasClass('mention') || $target.parents('.expanded-embed').length) {
            return false;
          }

          return ClickTrack.trackClick(e);
        });
      }).on('didInsertElement'),

      // This view is being removed. Shut down operations
      _destroyed: (function () {
        this.$().off('mouseup.discourse-redirect', '#revisions a');
      }).on('willDestroyElement')
    });
  });
define("discourse/views/invite-reply-button", 
  ["discourse/views/button","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ButtonView = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    __exports__["default"] = ButtonView.extend({
      textKey: 'topic.invite_reply.title',
      helpKey: 'topic.invite_reply.help',
      attributeBindings: ['disabled'],
      disabled: Em.computed.or('controller.model.archived', 'controller.model.closed', 'controller.model.deleted'),

      renderIcon: function (buffer) {
        buffer.push(iconHTML('users'));
      },

      click: function () {
        this.get('controller').send('showInvite');
      }
    });
  });
define("discourse/views/invite", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/invite',

      title: (function () {
        if (this.get('controller.isMessage')) {
          return I18n.t('topic.invite_private.title');
        } else if (this.get('controller.invitingToTopic')) {
          return I18n.t('topic.invite_reply.title');
        } else {
          return I18n.t('user.invited.create');
        }
      }).property('controller.{invitingToTopic,isMessage}'),

      inviteLinkChanged: (function () {
        if (!Ember.isEmpty(this.get('controller.model.inviteLink'))) {
          Em.run.next(function () {
            $('.invite-link-input').select().focus();
          });
        }
      }).observes('controller.model.inviteLink')

    });
  });
define("discourse/views/list/post-count-or-badges", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Object.extend({
      postCountsPresent: Ember.computed.or('topic.unread', 'topic.displayNewPosts'),
      showBadges: Ember.computed.and('postBadgesEnabled', 'postCountsPresent')
    });
  });
define("discourse/views/list/posts-count-column", 
  ["discourse/lib/computed","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var fmt = __dependency1__.fmt;

    __exports__["default"] = Ember.Object.extend({
      tagName: "td",
      ratio: (function () {
        var likes = parseFloat(this.get('topic.like_count')),
            posts = parseFloat(this.get('topic.posts_count'));

        if (posts < 10) {
          return 0;
        }

        return (likes || 0) / posts;
      }).property(),

      title: (function () {
        return I18n.messageFormat('posts_likes_MF', {
          count: this.get('topic.replyCount'),
          ratio: this.get('ratioText')
        }).trim();
      }).property(),

      ratioText: (function () {
        var ratio = this.get('ratio');

        var settings = Discourse.SiteSettings;
        if (ratio > settings.topic_post_like_heat_high) {
          return 'high';
        }
        if (ratio > settings.topic_post_like_heat_medium) {
          return 'med';
        }
        if (ratio > settings.topic_post_like_heat_low) {
          return 'low';
        }
        return '';
      }).property(),

      likesHeat: fmt('ratioText', 'heatmap-%@')
    });
  });
define("discourse/views/loading", 
  ["discourse/helpers/loading-spinner","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var spinnerHTML = __dependency1__.spinnerHTML;

    __exports__["default"] = Ember.View.extend({
      render: function (buffer) {
        buffer.push(spinnerHTML);
      }
    });
  });
define("discourse/views/login-reply-button", 
  ["discourse/views/button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ButtonView = __dependency1__["default"];

    __exports__["default"] = ButtonView.extend({
      textKey: 'topic.reply.title',
      classNames: ['btn', 'btn-primary', 'create'],
      click: function () {
        this.get('controller').send('showLogin');
      },
      renderIcon: function (buffer) {
        buffer.push("<i class='fa fa-reply'></i>");
      }
    });
  });
define("discourse/views/login", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/login',
      title: I18n.t('login.title'),
      classNames: ['login-modal'],

      mouseMove: function (e) {
        this.set('controller.lastX', e.screenX);
        this.set('controller.lastY', e.screenY);
      },

      _setup: (function () {
        var loginController = this.get('controller');

        // Get username and password from the browser's password manager,
        // if it filled the hidden static login form:
        var prefillUsername = $('#hidden-login-form input[name=username]').val();
        if (prefillUsername) {
          loginController.set('loginName', prefillUsername);
          loginController.set('loginPassword', $('#hidden-login-form input[name=password]').val());
        } else if ($.cookie('email')) {
          loginController.set('loginName', $.cookie('email'));
        }

        Em.run.schedule('afterRender', function () {
          $('#login-account-password, #login-account-name').keydown(function (e) {
            if (e.keyCode === 13 && !loginController.get('loginDisabled')) {
              loginController.send('login');
            }
          });
        });
      }).on('didInsertElement')
    });
  });
define("discourse/views/modal", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;

    __exports__["default"] = Ember.View.extend(_createDecoratedObject([{
      key: 'elementId',
      initializer: function () {
        return 'discourse-modal';
      }
    }, {
      key: 'templateName',
      initializer: function () {
        return 'modal/modal';
      }
    }, {
      key: 'classNameBindings',
      initializer: function () {
        return [':modal', ':hidden', 'controller.modalClass'];
      }
    }, {
      key: 'attributeBindings',
      initializer: function () {
        return ['data-keyboard'];
      }
    }, {
      key: 'data-keyboard',

      // We handle ESC ourselves
      initializer: function () {
        return 'false';
      }
    }, {
      key: 'setUp',
      decorators: [on("didInsertElement")],
      value: function () {
        $('html').on('keydown.discourse-modal', function (e) {
          if (e.which === 27) {
            Em.run.next(function () {
              return $('.modal-header a.close').click();
            });
          }
        });
      }
    }, {
      key: 'cleanUp',
      decorators: [on("willDestroyElement")],
      value: function () {
        $('html').off('keydown.discourse-modal');
      }
    }, {
      key: 'click',
      value: function (e) {
        var $target = $(e.target);
        if ($target.hasClass("modal-middle-container") || $target.hasClass("modal-outer-container")) {
          // Delegate click to modal close if clicked outside.
          // We do this because some CSS of ours seems to cover
          // the backdrop and makes it unclickable.
          $('.modal-header a.close').click();
        }
      }
    }]));
  });
define("discourse/views/navigation-categories", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;

    var CATEGORIES_BODY_CLASS = "navigation-categories";

    __exports__["default"] = Ember.View.extend(_createDecoratedObject([{
      key: "addBodyClass",
      decorators: [on("didInsertElement")],
      value: function () {
        $('body').addClass(CATEGORIES_BODY_CLASS);
      }
    }, {
      key: "removeBodyClass",
      decorators: [on("willDestroyElement")],
      value: function () {
        $('body').removeClass(CATEGORIES_BODY_CLASS);
      }
    }]));
  });
define("discourse/views/navigation-category", 
  ["discourse/mixins/add-category-class","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var AddCategoryClass = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(AddCategoryClass, {
      categoryFullSlug: Ember.computed.alias('controller.category.fullSlug')
    });
  });
define("discourse/views/preferences-about", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      templateName: 'user/about',
      classNames: ['user-preferences'],

      _focusAbout: (function () {
        var self = this;
        Ember.run.schedule('afterRender', function () {
          self.$('textarea').focus();
        });
      }).on('didInsertElement')
    });
  });
define("discourse/views/preferences-email", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.View.extend({
      templateName: 'user/email',
      classNames: ['user-preferences'],
      _focusField: (function () {
        Em.run.schedule('afterRender', function () {
          $('#change_email').focus();
        });
      }).on('didInsertElement')
    });
  });
define("discourse/views/preferences-username", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      templateName: 'user/username',
      classNames: ['user-preferences'],

      _focusUsername: (function () {
        Em.run.schedule('afterRender', function () {
          $('#change_username').focus();
        });
      }).on('didInsertElement'),

      keyDown: function (e) {
        if (e.keyCode === 13) {
          if (!this.get('controller').get('saveDisabled')) {
            return this.get('controller').send('changeUsername');
          } else {
            e.preventDefault();
            return false;
          }
        }
      }
    });
  });
define("discourse/views/preferences", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      templateName: 'user/preferences',
      classNames: ['user-preferences']
    });
  });
define("discourse/views/quote-button", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // we don't want to deselect when we click on buttons that use it
    function ignoreElements(e) {
      var $target = $(e.target);
      return $target.hasClass('quote-button') || $target.closest('.create').length || $target.closest('.reply-new').length;
    }

    __exports__["default"] = Ember.View.extend({
      classNames: ['quote-button'],
      classNameBindings: ['visible'],
      isMouseDown: false,
      isTouchInProgress: false,

      /**
        The button is visible whenever there is something in the buffer
        (ie. something has been selected)
      **/
      visible: Em.computed.notEmpty('controller.buffer'),

      render: function (buffer) {
        buffer.push(I18n.t("post.quote_reply"));
      },

      /**
        Binds to the following global events:
          - `mousedown` to clear the quote button if they click elsewhere.
          - `mouseup` to trigger the display of the quote button.
          - `selectionchange` to make the selection work under iOS
         @method didInsertElement
      **/
      didInsertElement: function () {
        var controller = this.get('controller'),
            view = this;

        var onSelectionChanged = function () {
          view.selectText(window.getSelection().anchorNode, controller);
        };

        // Windows Phone hack, it is not firing the touch events
        // best we can do is debounce this so we dont keep locking up
        // the selection when we add the caret to measure where we place
        // the quote reply widget
        //
        // Same hack applied to Android cause it has unreliable touchend
        var isAndroid = this.capabilities.isAndroid;
        if (this.capabilities.isWinphone || isAndroid) {
          onSelectionChanged = _.debounce(onSelectionChanged, 500);
        }

        $(document).on("mousedown.quote-button", function (e) {
          view.set('isMouseDown', true);

          if (ignoreElements(e)) {
            return;
          }

          // deselects only when the user left click
          // (allows anyone to `extend` their selection using shift+click)
          if (!window.getSelection().isCollapsed && e.which === 1 && !e.shiftKey) controller.deselectText();
        }).on('mouseup.quote-button', function (e) {
          if (ignoreElements(e)) {
            return;
          }

          view.selectText(e.target, controller);
          view.set('isMouseDown', false);
        }).on('selectionchange', function () {
          // there is no need to handle this event when the mouse is down
          // or if there a touch in progress
          if (view.get('isMouseDown') || view.get('isTouchInProgress')) return;
          // `selection.anchorNode` is used as a target
          onSelectionChanged();
        });

        // Android is dodgy, touchend often will not fire
        // https://code.google.com/p/android/issues/detail?id=19827
        if (!isAndroid) {
          $(document).on('touchstart.quote-button', function () {
            view.set('isTouchInProgress', true);
          }).on('touchend.quote-button', function () {
            view.set('isTouchInProgress', false);
          });
        }
      },

      selectText: function (target, controller) {
        var $target = $(target);
        // breaks if quoting has been disabled by the user
        if (!Discourse.User.currentProp('enable_quoting')) return;
        // retrieve the post id from the DOM
        var postId = $target.closest('.boxed, .reply').data('post-id');
        // select the text
        if (postId) controller.selectText(postId);
      },

      willDestroyElement: function () {
        $(document).off("mousedown.quote-button").off("mouseup.quote-button").off("touchstart.quote-button").off("touchend.quote-button").off("selectionchange");
      },

      click: function (e) {
        e.stopPropagation();
        return this.get('controller').quoteText(e);
      }

    });
  });
define("discourse/views/raw-email", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/raw_email',
      title: I18n.t('raw_email.title'),

      resizeModal: (function () {
        var viewPortHeight = $(window).height();
        this.$(".modal-body").css("max-height", Math.floor(0.8 * viewPortHeight) + "px");
      }).on("didInsertElement")
    });
  });
define("discourse/views/rename-tag", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      title: I18n.t("tagging.rename_tag")
    });
  });
define("discourse/views/reorder-categories", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      title: I18n.t('categories.reorder.title'),
      templateName: 'modal/reorder-categories',

      _setup: (function () {
        this.get('controller').on('scrollIntoView', this, this.scrollIntoView);
      }).on('didInsertElement'),
      _teardown: (function () {
        this.get('controller').off('scrollIntoView', this, this.scrollIntoView);
        this.set('prevScrollElem', null);
      }).on('willClearRender'),

      scrollIntoView: function () {
        var elem = this.$('tr[data-category-id="' + this.get('controller.scrollIntoViewId') + '"]');
        var scrollParent = this.$('.modal-body');
        var eoff = elem.position();
        var poff = $(document.getElementById('rc-scroll-anchor')).position();
        var currHeight = scrollParent.height();

        elem[0].className = "highlighted";

        var goal = eoff.top - poff.top - currHeight / 2,
            current = scrollParent.scrollTop();
        scrollParent.scrollTop(9999999);
        var max = scrollParent.scrollTop();
        scrollParent.scrollTop(current);

        var doneTimeout = setTimeout(function () {
          elem[0].className = "highlighted done";
          setTimeout(function () {
            elem[0].className = "";
          }, 2000);
        }, 0);

        if (goal > current - currHeight / 4 && goal < current + currHeight / 4) {
          // Too close to goal
          return;
        }
        if (max - current < 10 && goal > current) {
          // Too close to bottom
          return;
        }
        if (current < 10 && goal < current) {
          // Too close to top
          return;
        }

        if (!window.requestAnimationFrame) {
          scrollParent.scrollTop(goal);
        } else {
          (function () {
            clearTimeout(doneTimeout);
            var startTime = performance.now();
            var duration = 100;

            function doScroll(timestamp) {
              var progress = (timestamp - startTime) / duration;
              if (progress > 1) {
                progress = 1;
                setTimeout(function () {
                  elem[0].className = "highlighted done";
                  setTimeout(function () {
                    elem[0].className = "";
                  }, 2000);
                }, 0);
              } else if (progress < 0) {
                progress = 0;
              }
              if (progress < 1) {
                window.requestAnimationFrame(doScroll);
              }

              var iprogress = 1 - progress;
              scrollParent.scrollTop(goal * progress + current * iprogress);
            }
            window.requestAnimationFrame(doScroll);
          })();
        }
      }
    });
  });
define("discourse/views/reply-button", 
  ["discourse/views/button","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ButtonView = __dependency1__["default"];

    __exports__["default"] = ButtonView.extend({
      classNames: ['btn', 'btn-primary', 'create'],
      helpKey: 'topic.reply.help',

      text: (function () {
        var archetypeCapitalized = this.get('controller.content.archetype').capitalize();
        var customTitle = this.get("parentView.replyButtonText" + archetypeCapitalized);
        if (customTitle) {
          return customTitle;
        }

        return I18n.t("topic.reply.title");
      }).property(),

      renderIcon: function (buffer) {
        buffer.push("<i class='fa fa-reply'></i>");
      },

      click: function () {
        this.get('controller').send('replyToPost');
      }
    });
  });
define("discourse/views/search-help", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/search_help',
      title: I18n.t('search_help.title'),
      focusInput: false
    });
  });
define("discourse/views/share-button", 
  ["discourse/views/button","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ButtonView = __dependency1__["default"];
    var iconHTML = __dependency2__.iconHTML;

    __exports__["default"] = ButtonView.extend({
      classNames: ['share'],
      textKey: 'topic.share.title',
      helpKey: 'topic.share.help',
      'data-share-url': Em.computed.alias('topic.shareUrl'),
      topic: Em.computed.alias('controller.model'),

      renderIcon: function (buffer) {
        buffer.push(iconHTML("link"));
      }
    });
  });
define("discourse/views/share", 
  ["discourse/lib/intercept-click","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var wantsNewWindow = __dependency1__.wantsNewWindow;

    __exports__["default"] = Ember.View.extend({
      templateName: 'share',
      elementId: 'share-link',
      classNameBindings: ['hasLink'],

      hasLink: (function () {
        if (!Ember.isEmpty(this.get('controller.link'))) return 'visible';
        return null;
      }).property('controller.link'),

      linkChanged: (function () {
        var self = this;
        if (!Ember.isEmpty(this.get('controller.link'))) {
          Em.run.next(function () {
            if (!self.capabilities.touch) {
              var $linkInput = $('#share-link input');
              $linkInput.val(self.get('controller.link'));

              // Wait for the fade-in transition to finish before selecting the link:
              window.setTimeout(function () {
                $linkInput.select().focus();
              }, 160);
            } else {
              var $linkForTouch = $('#share-link .share-for-touch a');
              $linkForTouch.attr('href', self.get('controller.link'));
              $linkForTouch.html(self.get('controller.link'));
              var range = window.document.createRange();
              range.selectNode($linkForTouch[0]);
              window.getSelection().addRange(range);
            }
          });
        }
      }).observes('controller.link'),

      didInsertElement: function () {
        var self = this,
            $html = $('html');

        $html.on('mousedown.outside-share-link', function (e) {
          // Use mousedown instead of click so this event is handled before routing occurs when a
          // link is clicked (which is a click event) while the share dialog is showing.
          if (self.$().has(e.target).length !== 0) {
            return;
          }

          self.get('controller').send('close');
          return true;
        });

        function showPanel($target, url, postNumber, date) {
          var $currentTargetOffset = $target.offset();
          var $shareLink = $('#share-link');

          // Relative urls
          if (url.indexOf("/") === 0) {
            url = window.location.protocol + "//" + window.location.host + url;
          }

          var shareLinkWidth = $shareLink.width();
          var x = $currentTargetOffset.left - shareLinkWidth / 2;
          if (x < 25) {
            x = 25;
          }
          if (x + shareLinkWidth > $(window).width()) {
            x -= shareLinkWidth / 2;
          }

          var header = $('.d-header');
          var y = $currentTargetOffset.top - ($shareLink.height() + 20);
          if (y < header.offset().top + header.height()) {
            y = $currentTargetOffset.top + 10;
          }

          $shareLink.css({ top: "" + y + "px" });

          if (!self.site.mobileView) {
            $shareLink.css({ left: "" + x + "px" });
          }

          self.set('controller.link', url);
          self.set('controller.postNumber', postNumber);
          self.set('controller.date', date);
        }

        this.appEvents.on('share:url', function (url, $target) {
          return showPanel($target, url);
        });

        $html.on('click.discoure-share-link', '[data-share-url]', function (e) {
          // if they want to open in a new tab, let it so
          if (wantsNewWindow(e)) {
            return true;
          }

          e.preventDefault();

          var $currentTarget = $(e.currentTarget),
              url = $currentTarget.data('share-url'),
              postNumber = $currentTarget.data('post-number'),
              date = $currentTarget.children().data('time');
          showPanel($currentTarget, url, postNumber, date);
          return false;
        });

        $html.on('keydown.share-view', function (e) {
          if (e.keyCode === 27) {
            self.get('controller').send('close');
          }
        });
      },

      willDestroyElement: function () {
        this.get('controller').send('close');

        $('html').off('click.discoure-share-link').off('mousedown.outside-share-link').off('keydown.share-view');
      }

    });
  });
define("discourse/views/split-topic", 
  ["discourse/mixins/selected-posts-count","discourse/views/modal-body","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var SelectedPostsCount = __dependency1__["default"];
    var ModalBodyView = __dependency2__["default"];

    __exports__["default"] = ModalBodyView.extend(SelectedPostsCount, {
      templateName: 'modal/split-topic',
      title: I18n.t('topic.split_topic.title')
    });
  });
define("discourse/views/static", 
  ["discourse/lib/is-element-in-viewport","discourse/mixins/scroll-top","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var isElementInViewport = __dependency1__["default"];
    var ScrollTop = __dependency2__["default"];
    var on = __dependency3__.on;

    __exports__["default"] = Ember.View.extend(ScrollTop, _createDecoratedObject([{
      key: '_addBodyClass',
      decorators: [on('didInsertElement')],
      value: function () {
        var path = this.get('controller.model.path');
        $('body').addClass('static-' + path);
      }
    }, {
      key: '_removeBodyClass',
      decorators: [on('willDestroyElement')],
      value: function () {
        var path = this.get('controller.model.path');
        $('body').removeClass('static-' + path);
      }
    }, {
      key: '_checkRead',
      decorators: [on('didInsertElement')],
      value: function () {
        var _this = this;

        var currentUser = this.get('controller.currentUser');
        if (currentUser) {
          var path = this.get('controller.model.path');
          if (path === "faq" || path === "guidelines") {
            (function () {
              var controller = _this.get('controller');
              $(window).on('load.faq resize.faq scroll.faq', function () {
                var faqUnread = !currentUser.get('read_faq');
                if (faqUnread && isElementInViewport($(".contents p").last())) {
                  controller.send('markFaqRead');
                }
              });
            })();
          }
        }
      }
    }, {
      key: '_stopChecking',
      decorators: [on('willDestroyElement')],
      value: function () {
        $(window).off('load.faq resize.faq scroll.faq');
      }
    }]));
  });
define("discourse/views/topic-entrance", 
  ["discourse/mixins/cleans-up","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var CleansUp = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(CleansUp, {
      elementId: 'topic-entrance',
      classNameBindings: ['visible::hidden'],
      visible: Em.computed.notEmpty('controller.model'),

      _positionChanged: (function () {
        var _this = this;

        var pos = this.get('controller.position');
        if (!pos) {
          return;
        }

        var $self = this.$();

        // Move after we render so the height is correct
        Em.run.schedule('afterRender', function () {
          var width = $self.width(),
              height = $self.height();
          pos.left = parseInt(pos.left) - width / 2;
          pos.top = parseInt(pos.top) - height / 2;

          var windowWidth = $(window).width();
          if (pos.left + width > windowWidth) {
            pos.left = windowWidth - width - 15;
          }
          $self.css(pos);
        });

        $('html').off('mousedown.topic-entrance').on('mousedown.topic-entrance', function (e) {
          var $target = $(e.target);
          if ($target.prop('id') === 'topic-entrance' || $self.has($target).length !== 0) {
            return;
          }
          _this.cleanUp();
        });
      }).observes('controller.position'),

      _removed: (function () {
        $('html').off('mousedown.topic-entrance');
      }).on('willDestroyElement'),

      cleanUp: function () {
        this.set('controller.model', null);
        $('html').off('mousedown.topic-entrance');
      },

      keyDown: function (e) {
        if (e.which === 27) {
          this.cleanUp();
        }
      }

    });
  });
define("discourse/views/topic-footer-main-buttons", 
  ["discourse/views/container","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ContainerView = __dependency1__["default"];
    var on = __dependency2__.on;

    __exports__["default"] = ContainerView.extend(_createDecoratedObject([{
      key: 'elementId',
      initializer: function () {
        return 'topic-footer-main-buttons';
      }
    }, {
      key: 'createButtons',
      decorators: [on('init')],
      value: function () {
        var mobileView = this.site.mobileView;

        if (!mobileView && this.currentUser.get('staff')) {
          var viewArgs = { action: 'showTopicAdminMenu', title: 'topic_admin_menu', icon: 'wrench', position: 'absolute' };
          this.attachViewWithArgs(viewArgs, 'show-popup-button');
        }

        var topic = this.get('topic');
        if (!topic.get('isPrivateMessage')) {
          if (mobileView) {
            this.attachViewWithArgs({ topic: topic }, 'topic-footer-mobile-dropdown');
          } else {
            // We hide some controls from private messages
            this.attachViewClass('bookmark-button');
            this.attachViewClass('share-button');
            if (this.get('topic.details.can_flag_topic')) {
              this.attachViewClass('flag-topic-button');
            }
          }
        }

        if (!mobileView && this.get('topic.details.can_invite_to')) {
          this.attachViewClass('invite-reply-button');
        }

        if (topic.get('isPrivateMessage')) {
          this.attachViewClass('archive-button');
        }

        if (this.get('topic.details.can_create_post')) {
          this.attachViewClass('reply-button');
        }

        this.trigger('additionalButtons', this);
      }
    }]));
  });
define("discourse/views/topic-list-header-column", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Object.extend({

      localizedName: (function () {
        if (this.forceName) {
          return this.forceName;
        }

        return I18n.t(this.name);
      }).property(),

      sortClass: (function () {
        return "fa fa-chevron-" + (this.parent.ascending ? "up" : "down");
      }).property(),

      isSorting: (function () {
        return this.sortable && this.parent.order === this.order;
      }).property(),

      className: (function () {
        var name = [];
        if (this.order) {
          name.push(this.order);
        }
        if (this.sortable) {
          name.push("sortable");

          if (this.get("isSorting")) {
            name.push("sorting");
          }
        }

        if (this.number) {
          name.push("num");
        }

        return name.join(' ');
      }).property()
    });
  });
define("discourse/views/topic-list-poster", 
  ["discourse/helpers/user-avatar","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var renderAvatar = __dependency1__.renderAvatar;

    __exports__["default"] = Ember.View.extend({
      tagName: 'a',
      attributeBindings: ['href', 'data-user-card'],
      classNameBindings: ['content.extras'],

      user: Em.computed.alias('content.user'),
      href: Em.computed.alias('user.path'),

      'data-user-card': Em.computed.alias('user.username'),

      render: function (buffer) {
        var av = renderAvatar(this.get('content'), { usernamePath: 'user.username', imageSize: 'small' });
        buffer.push(av);
      }
    });
  });
define("discourse/views/topic-progress", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      elementId: 'topic-progress-wrapper',
      docked: false,
      classNameBindings: ['docked'],

      _inserted: (function () {
        this.appEvents.on("composer:opened", this, '_dock').on("composer:resized", this, '_dock').on("composer:closed", this, '_dock').on("topic:scrolled", this, '_dock');

        // Reflows are expensive. Cache the jQuery selector
        // and the width when inserted into the DOM
        this._$topicProgress = this.$('#topic-progress');
      }).on('didInsertElement'),

      _unbindEvents: (function () {
        this.appEvents.off("composer:opened", this, '_dock').off("composer:resized", this, '_dock').off("composer:closed", this, '_dock').off('topic:scrolled', this, '_dock');
      }).on('willDestroyElement'),

      _updateBar: (function () {
        Em.run.scheduleOnce('afterRender', this, '_updateProgressBar');
      }).observes('controller.streamPercentage', 'controller.model.postStream.stream.[]').on('init'),

      _updateProgressBar: function () {
        // speeds up stuff, bypass jquery slowness and extra checks
        if (!this._totalWidth) {
          this._totalWidth = this._$topicProgress[0].offsetWidth;
        }
        var totalWidth = this._totalWidth;
        var progressWidth = this.get('controller.streamPercentage') * totalWidth;

        this._$topicProgress.find('.bg').css("border-right-width", progressWidth === totalWidth ? "0px" : "1px").width(progressWidth);
      },

      _dock: function () {
        var maximumOffset = $('#topic-footer-buttons').offset(),
            composerHeight = $('#reply-control').height() || 0,
            $topicProgressWrapper = this.$(),
            style = $topicProgressWrapper.attr('style') || '',
            offset = window.pageYOffset || $('html').scrollTop();

        var isDocked = false;
        if (maximumOffset) {
          var threshold = maximumOffset.top,
              windowHeight = $(window).height(),
              topicProgressHeight = $('#topic-progress').height();

          isDocked = offset >= threshold - windowHeight + topicProgressHeight + composerHeight;
        }

        if (composerHeight > 0) {
          if (isDocked) {
            if (style.indexOf('bottom') >= 0) {
              $topicProgressWrapper.css('bottom', '');
            }
          } else {
            var height = composerHeight + "px";
            if ($topicProgressWrapper.css('bottom') !== height) {
              $topicProgressWrapper.css('bottom', height);
            }
          }
        } else {
          if (style.indexOf('bottom') >= 0) {
            $topicProgressWrapper.css('bottom', '');
          }
        }
        this.set('docked', isDocked);
      },

      _focusWhenOpened: (function () {
        var _this = this;

        // Don't focus on mobile or touch
        if (this.site.mobileView || this.capabilities.isIOS) {
          return;
        }

        if (this.get('controller.expanded')) {
          (function () {
            var self = _this;
            Em.run.schedule('afterRender', function () {
              self.$('input').focus();
            });
          })();
        }
      }).observes('controller.expanded'),

      click: function (e) {
        if ($(e.target).parents('#topic-progress').length) {
          this.get('controller').send('toggleExpansion');
        }
      },

      keyDown: function (e) {
        var controller = this.get('controller');
        if (controller.get('expanded')) {
          if (e.keyCode === 13) {
            this.$('input').blur();
            controller.send('jumpPost');
          } else if (e.keyCode === 27) {
            controller.send('toggleExpansion');
          }
        }
      }

    });
  });
define("discourse/views/topic-status", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Object.extend({
      renderDiv: (function () {
        return this.get('statuses').length > 0 && !this.noDiv;
      }).property(),
      statuses: (function () {
        var topic = this.get("topic");
        var results = [];
        var self = this;

        // TODO, custom statuses? via override?

        if (topic.get('is_warning')) {
          results.push({ icon: 'envelope', key: 'warning' });
        }

        if (topic.get('bookmarked')) {
          var url = topic.get('url');
          var postNumbers = topic.get('bookmarked_post_numbers');
          var extraClasses = "";
          if (postNumbers && postNumbers[0] > 1) {
            url += '/' + postNumbers[0];
          } else {
            extraClasses = "op-bookmark";
          }

          results.push({ extraClasses: extraClasses, icon: 'bookmark', key: 'bookmarked', href: url });
        }

        if (topic.get('closed') && topic.get('archived')) {
          results.push({ icon: 'lock', key: 'locked_and_archived' });
        } else if (topic.get('closed')) {
          results.push({ icon: 'lock', key: 'locked' });
        } else if (topic.get('archived')) {
          results.push({ icon: 'lock', key: 'archived' });
        }

        if (topic.get('pinned')) {
          results.push({ icon: 'thumb-tack', key: 'pinned' });
        }

        if (topic.get('unpinned')) {
          results.push({ icon: 'thumb-tack unpinned', key: 'unpinned' });
        }

        if (topic.get('invisible')) {
          results.push({ icon: 'eye-slash', key: 'invisible' });
        }

        _.each(results, function (result) {
          result.title = I18n.t("topic_statuses." + result.key + ".help");
          if (!self.disableActions && (result.key === "pinned" || result.key === "unpinned")) {
            result.openTag = 'a href';
            result.closeTag = 'a';
          } else {
            result.openTag = 'span';
            result.closeTag = 'span';
          }
        });

        return results;
      }).property()
    });
  });
define("discourse/views/topic-unsubscribe", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.View.extend({
      classNames: ["topic-unsubscribe"]
    });
  });
define("discourse/views/topic", 
  ["discourse/mixins/add-category-class","discourse/mixins/add-archetype-class","discourse/lib/click-track","discourse/mixins/scrolling","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var AddCategoryClass = __dependency1__["default"];
    var AddArchetypeClass = __dependency2__["default"];
    var ClickTrack = __dependency3__["default"];
    var Scrolling = __dependency4__["default"];

    var TopicView = Ember.View.extend(AddCategoryClass, AddArchetypeClass, Scrolling, {
      templateName: 'topic',
      topic: Ember.computed.alias('controller.model'),

      userFilters: Ember.computed.alias('topic.userFilters'),
      classNameBindings: ['controller.multiSelect:multi-select', 'topic.archetype', 'topic.is_warning', 'topic.category.read_restricted:read_restricted', 'topic.deleted:deleted-topic', 'topic.categoryClass'],
      menuVisible: true,
      SHORT_POST: 1200,

      categoryFullSlug: Em.computed.alias('topic.category.fullSlug'),
      postStream: Em.computed.alias('topic.postStream'),
      archetype: Em.computed.alias('topic.archetype'),

      _lastShowTopic: null,

      _composeChanged: (function () {
        var composerController = Discourse.get('router.composerController');
        composerController.clearState();
        composerController.set('topic', this.get('topic'));
      }).observes('composer'),

      _enteredTopic: (function () {
        // Ember is supposed to only call observers when values change but something
        // in our view set up is firing this observer with the same value. This check
        // prevents scrolled from being called twice.
        var enteredAt = this.get('controller.enteredAt');
        if (enteredAt && this.get('lastEnteredAt') !== enteredAt) {
          this._lastShowTopic = null;
          this.scrolled();
          this.set('lastEnteredAt', enteredAt);
        }
      }).observes('controller.enteredAt'),

      _inserted: (function () {
        var _this = this;

        this.bindScrolling({ name: 'topic-view' });

        $(window).on('resize.discourse-on-scroll', function () {
          return _this.scrolled();
        });

        this.$().on('mouseup.discourse-redirect', '.cooked a, a.track-link', function (e) {
          // bypass if we are selecting stuff
          var selection = window.getSelection && window.getSelection();
          if (selection.type === "Range" || selection.rangeCount > 0) {
            if (Discourse.Utilities.selectedText() !== "") {
              return true;
            }
          }

          var $target = $(e.target);
          if ($target.hasClass('mention') || $target.parents('.expanded-embed').length) {
            return false;
          }

          return ClickTrack.trackClick(e);
        });

        this.appEvents.on('post:highlight', function (postNumber) {
          Ember.run.scheduleOnce('afterRender', null, highlight, postNumber);
        });
      }).on('didInsertElement'),

      // This view is being removed. Shut down operations
      _destroyed: (function () {
        this.unbindScrolling('topic-view');
        $(window).unbind('resize.discourse-on-scroll');

        // Unbind link tracking
        this.$().off('mouseup.discourse-redirect', '.cooked a, a.track-link');

        this.resetExamineDockCache();

        // this happens after route exit, stuff could have trickled in
        this.appEvents.trigger('header:hide-topic');
        this.appEvents.off('post:highlight');
      }).on('willDestroyElement'),

      gotFocus: (function () {
        if (Discourse.get('hasFocus')) {
          this.scrolled();
        }
      }).observes("Discourse.hasFocus"),

      resetExamineDockCache: function () {
        this.set('docAt', false);
      },

      offset: 0,
      hasScrolled: Em.computed.gt("offset", 0),

      showTopicInHeader: function (topic, offset) {
        if (this.get('docAt')) {
          return offset >= this.get('docAt') || topic.get('postStream.firstPostNotLoaded');
        } else {
          return topic.get('postStream.firstPostNotLoaded');
        }
      },

      // The user has scrolled the window, or it is finished rendering and ready for processing.
      scrolled: function () {
        if (this.isDestroyed || this.isDestroying || this._state !== 'inDOM') {
          return;
        }

        var offset = window.pageYOffset || $('html').scrollTop();
        if (!this.get('docAt')) {
          var title = $('#topic-title');
          if (title && title.length === 1) {
            this.set('docAt', title.offset().top);
          }
        }

        this.set("offset", offset);

        var topic = this.get('topic');
        var showTopic = this.showTopicInHeader(topic, offset);
        if (showTopic !== this._lastShowTopic) {
          this._lastShowTopic = showTopic;

          if (showTopic) {
            this.appEvents.trigger('header:show-topic', topic);
          } else {
            this.appEvents.trigger('header:hide-topic');
          }
        }

        // Trigger a scrolled event
        this.appEvents.trigger('topic:scrolled', offset);
      }
    });

    function highlight(postNumber) {
      var $contents = $('#post_' + postNumber + ' .topic-body'),
          origColor = $contents.data('orig-color') || $contents.css('backgroundColor');

      $contents.data("orig-color", origColor).addClass('highlighted').stop().animate({ backgroundColor: origColor }, 2500, 'swing', function () {
        $contents.removeClass('highlighted');
        $contents.css({ 'background-color': '' });
      });
    }

    __exports__["default"] = TopicView;
  });
define("discourse/views/unknown", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.View.extend({
      classNameBindings: [':container'],

      render: function (buffer) {
        buffer.push(this.get('controller.model'));
      }
    });
  });
define("discourse/views/upload-customization", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/upload-customization',
      title: I18n.t('admin.customize.import_title')
    });
  });
define("discourse/views/upload-selector", 
  ["discourse/views/modal-body","ember-addons/ember-computed-decorators","discourse/controllers/upload-selector","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var ModalBodyView = __dependency1__["default"];
    var computed = __dependency2__.default;
    var on = __dependency2__.on;
    var observes = __dependency2__.observes;
    var uploadTranslate = __dependency3__.uploadTranslate;

    __exports__["default"] = ModalBodyView.extend(_createDecoratedObject([{
      key: 'templateName',
      initializer: function () {
        return 'modal/upload-selector';
      }
    }, {
      key: 'classNames',
      initializer: function () {
        return ['upload-selector'];
      }
    }, {
      key: 'title',
      decorators: [computed()],
      value: function () {
        return uploadTranslate("title");
      }
    }, {
      key: 'touchStart',
      value: function (evt) {
        // HACK: workaround Safari iOS being really weird and not shipping click events
        if (this.capabilities.isSafari && evt.target.id === "filename-input") {
          this.$('#filename-input').click();
        }
      }
    }, {
      key: 'selectedChanged',
      decorators: [observes('controller.local'), on('didInsertElement')],
      value: function () {
        var _this = this;

        Ember.run.next(function () {
          // *HACK* to select the proper radio button
          var value = _this.get('controller.local') ? 'local' : 'remote';
          $('input:radio[name="upload"]').val([value]);
          $('.inputs input:first').focus();
        });
      }
    }]));
  });
define("discourse/views/user-badges", 
  ["discourse/mixins/scroll-top","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ScrollTop = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(ScrollTop);
  });
define("discourse/views/user-card", 
  ["discourse/lib/intercept-click","discourse/lib/computed","discourse/mixins/cleans-up","discourse/lib/after-transition","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var wantsNewWindow = __dependency1__.wantsNewWindow;
    var setting = __dependency2__.setting;
    var CleansUp = __dependency3__["default"];
    var afterTransition = __dependency4__["default"];

    var clickOutsideEventName = "mousedown.outside-user-card",
        clickDataExpand = "click.discourse-user-card",
        clickMention = "click.discourse-user-mention";

    __exports__["default"] = Ember.View.extend(CleansUp, {
      elementId: 'user-card',
      classNameBindings: ['controller.visible:show', 'controller.showBadges', 'controller.hasCardBadgeImage'],
      allowBackgrounds: setting('allow_profile_backgrounds'),

      addBackground: (function () {
        var url = this.get('controller.user.card_background');

        if (!this.get('allowBackgrounds')) {
          return;
        }

        var $this = this.$();
        if (!$this) {
          return;
        }

        if (Ember.isEmpty(url)) {
          $this.css('background-image', '').addClass('no-bg');
        } else {
          $this.css('background-image', "url(" + Discourse.getURLWithCDN(url) + ")").removeClass('no-bg');
        }
      }).observes('controller.user.card_background'),

      _setup: (function () {
        var _this = this;

        afterTransition(this.$(), this._hide.bind(this));

        $('html').off(clickOutsideEventName).on(clickOutsideEventName, function (e) {
          if (_this.get('controller.visible')) {
            var $target = $(e.target);
            if ($target.closest('[data-user-card]').data('userCard') || $target.closest('a.mention').length > 0 || $target.closest('#user-card').length > 0) {
              return;
            }

            _this.get('controller').close();
          }

          return true;
        });

        var expand = function (username, $target) {
          var postId = $target.parents('article').data('post-id'),
              user = _this.get('controller').show(username, postId, $target[0]);
          if (user !== undefined) {
            user.then(function () {
              return _this._willShow($target);
            }).catch(function () {
              return _this._hide();
            });
          } else {
            _this._hide();
          }
          return false;
        };

        $('#main-outlet').on(clickDataExpand, '[data-user-card]', function (e) {
          if (wantsNewWindow(e)) {
            return;
          }

          var $target = $(e.currentTarget),
              username = $target.data('user-card');
          return expand(username, $target);
        });

        $('#main-outlet').on(clickMention, 'a.mention', function (e) {
          if (wantsNewWindow(e)) {
            return;
          }

          var $target = $(e.target),
              username = $target.text().replace(/^@/, '');
          return expand(username, $target);
        });
        this.appEvents.on('usercard:shown', this, '_shown');
      }).on('didInsertElement'),

      _shown: function () {
        var _this2 = this;

        // After the card is shown, focus on the first link
        //
        // note: we DO NOT use afterRender here cause _willShow may
        //  run after _shown, if we allowed this to happen the usercard
        //  may be offscreen and we may scroll all the way to it on focus
        Ember.run.next(null, function () {
          return _this2.$('a:first').focus();
        });
      },

      _willShow: function (target) {
        var _this3 = this;

        var rtl = $('html').css('direction') === 'rtl';
        if (!target) {
          return;
        }
        var width = this.$().width();

        Ember.run.schedule('afterRender', function () {
          if (target) {
            var position = target.offset();
            if (position) {

              if (rtl) {
                // The site direction is rtl
                position.right = $(window).width() - position.left + 10;
                position.left = 'auto';
                var overage = $(window).width() - 50 - (position.right + width);
                if (overage < 0) {
                  position.right += overage;
                  position.top += target.height() + 48;
                }
              } else {
                // The site direction is ltr
                position.left += target.width() + 10;

                var overage = $(window).width() - 50 - (position.left + width);
                if (overage < 0) {
                  position.left += overage;
                  position.top += target.height() + 48;
                }
              }

              position.top -= $('#main-outlet').offset().top;
              _this3.$().css(position);
            }
            _this3.appEvents.trigger('usercard:shown');
          }
        });
      },

      _hide: function () {
        if (!this.get('controller.visible')) {
          this.$().css({ left: -9999, top: -9999 });
        }
      },

      cleanUp: function () {
        this.get('controller').close();
      },

      keyUp: function (e) {
        if (e.keyCode === 27) {
          // ESC
          var target = this.get('controller.cardTarget');
          this.cleanUp();
          target.focus();
        }
      },

      _removeEvents: (function () {
        $('html').off(clickOutsideEventName);

        $('#main').off(clickDataExpand).off(clickMention);

        this.appEvents.off('usercard:shown', this, '_shown');
      }).on('willDestroyElement')

    });
  });
define("discourse/views/user", 
  ["discourse/mixins/scroll-top","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ScrollTop = __dependency1__["default"];

    __exports__["default"] = Ember.View.extend(ScrollTop, {
      templateName: 'user/user'
    });
  });
define("discourse/helpers/application", 
  ["discourse/lib/helpers","discourse/lib/formatter"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var registerUnbound = __dependency1__.registerUnbound;
    var longDate = __dependency2__.longDate;
    var autoUpdatingRelativeAge = __dependency2__.autoUpdatingRelativeAge;
    var number = __dependency2__.number;

    var safe = Handlebars.SafeString;

    registerUnbound('raw-date', function (dt) {
      return longDate(new Date(dt));
    });

    registerUnbound('age-with-tooltip', function (dt) {
      return new safe(autoUpdatingRelativeAge(new Date(dt), { title: true }));
    });

    registerUnbound('number', function (orig, params) {
      orig = parseInt(orig, 10);
      if (isNaN(orig)) {
        orig = 0;
      }

      var title = orig;
      if (params.numberKey) {
        title = I18n.t(params.numberKey, { number: orig });
      }

      var classNames = 'number';
      if (params['class']) {
        classNames += ' ' + params['class'];
      }
      var result = "<span class='" + classNames + "'";

      // Round off the thousands to one decimal place
      var n = number(orig);
      if (n !== title) {
        result += " title='" + Handlebars.Utils.escapeExpression(title) + "'";
      }
      result += ">" + n + "</span>";

      return new safe(result);
    });
  });
define("discourse/helpers/as-hash", 
  ["exports"],
  function(__exports__) {
    "use strict";

    __exports__["default"] = hashHelper;
    // Note: Later versions of ember include `hash`

    function hashHelper(params) {
      var hash = {};
      Object.keys(params.hash).forEach(function (k) {
        hash[k] = params.data.view.getStream(params.hash[k]).value();
      });
      return hash;
    }
  });
define("discourse/helpers/border-color", 
  ["discourse/lib/helpers","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var htmlHelper = __dependency1__.htmlHelper;

    __exports__["default"] = htmlHelper(function (color) {
      return 'border-color: #' + color;
    });
  });
define("discourse/helpers/bound-avatar-template", 
  ["discourse/lib/helpers","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var htmlHelper = __dependency1__.htmlHelper;

    __exports__["default"] = htmlHelper(function (avatarTemplate, size) {
      return Discourse.Utilities.avatarImg({ size: size, avatarTemplate: avatarTemplate });
    });
  });
define("discourse/helpers/bound-avatar", 
  ["discourse/lib/helpers","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var htmlHelper = __dependency1__.htmlHelper;

    __exports__["default"] = htmlHelper(function (user, size) {
      if (Ember.isEmpty(user)) {
        return "<div class='avatar-placeholder'></div>";
      }

      var avatarTemplate = Em.get(user, 'avatar_template');
      return Discourse.Utilities.avatarImg({ size: size, avatarTemplate: avatarTemplate });
    });
  });
define("discourse/helpers/bound-category-link", 
  ["discourse/lib/helpers","discourse/helpers/category-link","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var htmlHelper = __dependency1__.htmlHelper;
    var categoryLinkHTML = __dependency2__.categoryLinkHTML;

    __exports__["default"] = htmlHelper(categoryLinkHTML);
  });
define("discourse/helpers/bound-date", 
  ["discourse/lib/formatter","discourse/lib/helpers","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var autoUpdatingRelativeAge = __dependency1__.autoUpdatingRelativeAge;
    var htmlHelper = __dependency2__.htmlHelper;

    __exports__["default"] = htmlHelper(function (dt) {
      return autoUpdatingRelativeAge(new Date(dt), { format: 'medium', title: true });
    });
  });
define("discourse/helpers/capitalize-string", 
  ["discourse/lib/helpers","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var htmlHelper = __dependency1__.htmlHelper;

    __exports__["default"] = htmlHelper(function (str) {
      return str[0].toUpperCase() + str.slice(1);
    });
  });
define("discourse/helpers/category-badge", 
  ["discourse/helpers/category-link","discourse/lib/helpers"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var categoryLinkHTML = __dependency1__.categoryLinkHTML;
    var registerUnbound = __dependency2__.registerUnbound;

    registerUnbound('category-badge', function (cat, options) {
      options.link = false;
      return categoryLinkHTML(cat, options);
    });
  });
define("discourse/helpers/cook-text", 
  ["discourse/lib/helpers"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__.registerUnbound;

    registerUnbound('cook-text', function (text) {
      return new Handlebars.SafeString(Discourse.Markdown.cook(text, { sanitize: true }));
    });
  });
define("discourse/helpers/custom-html", 
  ["discourse/lib/helpers","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.getCustomHTML = getCustomHTML;
    __exports__.setCustomHTML = setCustomHTML;
    var registerHelper = __dependency1__.registerHelper;

    var _customizations = {};

    function getCustomHTML(key) {
      var c = _customizations[key];
      if (c) {
        return new Handlebars.SafeString(c);
      }

      var html = PreloadStore.get("customHTML");
      if (html && html[key] && html[key].length) {
        return new Handlebars.SafeString(html[key]);
      }
    }

    // Set a fragment of HTML by key. It can then be looked up with `getCustomHTML(key)`.

    function setCustomHTML(key, html) {
      _customizations[key] = html;
    }

    registerHelper('custom-html', function (params, hash, options, env) {
      var name = params[0];
      var html = getCustomHTML(name);
      if (html) {
        return html;
      }

      var contextString = params[1];
      var target = env || contextString;
      var container = target.container || target.data.view.container;
      if (container.lookup('template:' + name)) {
        return env.helpers.partial.helperFunction.apply(this, arguments);
      }
    });
  });
define("discourse/helpers/dash-if-empty", 
  ["discourse/lib/helpers","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var htmlHelper = __dependency1__.htmlHelper;

    __exports__["default"] = htmlHelper(function (str) {
      return Ember.isEmpty(str) ? '&mdash;' : str;
    });
  });
define("discourse/helpers/discouse-tag", 
  ["discourse/lib/helpers","discourse/lib/render-tag","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var registerUnbound = __dependency1__.registerUnbound;
    var renderTag = __dependency2__["default"];

    __exports__["default"] = registerUnbound('discourse-tag', function (name, params) {
      return new Handlebars.SafeString(renderTag(name, params));
    });
  });
define("discourse/helpers/format-age", 
  ["discourse/lib/formatter","discourse/lib/helpers"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var autoUpdatingRelativeAge = __dependency1__.autoUpdatingRelativeAge;
    var registerUnbound = __dependency2__.registerUnbound;

    registerUnbound('format-age', function (dt) {
      dt = new Date(dt);
      return new Handlebars.SafeString(autoUpdatingRelativeAge(dt));
    });
  });
define("discourse/helpers/format-date", 
  ["discourse/lib/helpers","discourse/lib/formatter"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var registerUnbound = __dependency1__.registerUnbound;
    var autoUpdatingRelativeAge = __dependency2__.autoUpdatingRelativeAge;

    /**
      Display logic for dates. It is unbound in Ember but will use jQuery to
      update the dates on a regular interval.
    **/
    registerUnbound('format-date', function (val, params) {
      var leaveAgo,
          format = 'medium',
          title = true;

      if (params.leaveAgo) {
        leaveAgo = params.leaveAgo === "true";
      }
      if (params.format) {
        format = params.format;
      }
      if (params.noTitle) {
        title = false;
      }

      if (val) {
        var date = new Date(val);
        return new Handlebars.SafeString(autoUpdatingRelativeAge(date, { format: format, title: title, leaveAgo: leaveAgo }));
      }
    });
  });
define("discourse/helpers/icon-or-image", 
  ["discourse/lib/helpers","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var htmlHelper = __dependency1__.htmlHelper;

    __exports__["default"] = htmlHelper(function (str) {
      if (Ember.isEmpty(str)) {
        return "";
      }
      return str.indexOf('fa-') === 0 ? '<i class=\'fa ' + str + '\'></i>' : '<img src=\'' + str + '\'>';
    });
  });
define("discourse/helpers/inline-date", 
  ["discourse/lib/formatter","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var relativeAge = __dependency1__.relativeAge;

    __exports__["default"] = function (dt, params) {
      dt = params.data.view.getStream(dt).value();
      return relativeAge(new Date(dt));
    }
  });
define("discourse/helpers/max-usernames", 
  ["discourse/lib/helpers"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__.registerUnbound;

    registerUnbound('max-usernames', function (usernames, params) {
      var maxLength = parseInt(params.max) || 3;
      if (usernames.length > maxLength) {
        return usernames.slice(0, maxLength).join(", ") + ", +" + (usernames.length - maxLength);
      } else {
        return usernames.join(", ");
      }
    });
  });
define("discourse/helpers/node", 
  ["virtual-dom","discourse/lib/formatter","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    __exports__.dateNode = dateNode;
    __exports__.numberNode = numberNode;
    var h = __dependency1__.h;
    var relativeAge = __dependency2__.relativeAge;
    var longDate = __dependency2__.longDate;
    var number = __dependency2__.number;

    function dateNode(dt) {
      if (typeof dt === "string") {
        dt = new Date(dt);
      }
      if (dt) {
        var attributes = {
          title: longDate(dt),
          'data-time': dt.getTime(),
          'data-format': 'tiny'
        };

        return h('span.relative-date', { attributes: attributes }, relativeAge(dt));
      }
    }

    function numberNode(num, opts) {
      opts = opts || {};
      num = parseInt(num, 10);
      if (isNaN(num)) {
        num = 0;
      }

      var numString = num.toString();
      var attributes = {};
      var formatted = number(num);
      if (formatted !== numString) {
        attributes.title = numString;
      }

      return h('span.number', { className: opts.className, attributes: attributes }, formatted);
    }
  });
define("discourse/helpers/period-title", 
  ["discourse/lib/helpers","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var htmlHelper = __dependency1__.htmlHelper;

    var TITLE_SUBS = {
      all: 'all_time',
      yearly: 'this_year',
      quarterly: 'this_quarter',
      monthly: 'this_month',
      daily: 'today'
    };

    __exports__["default"] = htmlHelper(function (period, options) {
      var title = I18n.t('filters.top.' + (TITLE_SUBS[period] || 'this_week'));
      if (options.hash.showDateRange) {
        var dateString = "";
        switch (period) {
          case 'yearly':
            dateString = moment().subtract(1, 'year').format(I18n.t('dates.long_with_year_no_time')) + " - " + moment().format(I18n.t('dates.long_with_year_no_time'));
            break;
          case 'quarterly':
            dateString = moment().subtract(3, 'month').format(I18n.t('dates.long_no_year_no_time')) + " - " + moment().format(I18n.t('dates.long_no_year_no_time'));
            break;
          case 'weekly':
            dateString = moment().subtract(1, 'week').format(I18n.t('dates.long_no_year_no_time')) + " - " + moment().format(I18n.t('dates.long_no_year_no_time'));
            break;
          case 'monthly':
            dateString = moment().subtract(1, 'month').format(I18n.t('dates.long_no_year_no_time')) + " - " + moment().format(I18n.t('dates.long_no_year_no_time'));
            break;
          case 'daily':
            dateString = moment().format(I18n.t('dates.full_no_year_no_time'));
            break;
        }

        return title + ' <span class=\'top-date-string\'>' + dateString + '</span>';
      } else {
        return title;
      }
    });
  });
define("discourse/helpers/plugin-outlet", 
  ["discourse/lib/helpers","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    __exports__.rewire = rewire;
    /**
       A plugin outlet is an extension point for templates where other templates can
       be inserted by plugins.

       ## Usage

       If your handlebars template has:

       ```handlebars
         {{plugin-outlet "evil-trout"}}
       ```

       Then any handlebars files you create in the `connectors/evil-trout` directory
       will automatically be appended. For example:

       plugins/hello/assets/javascripts/discourse/templates/connectors/evil-trout/hello.hbs

       With the contents:

       ```handlebars
         <b>Hello World</b>
       ```

       Will insert <b>Hello World</b> at that point in the template.

       Optionally you can also define a view class for the outlet as:

       plugins/hello/assets/javascripts/discourse/views/connectors/evil-trout/hello.js.es6

       And it will be wired up automatically.

       ## The block form

       If you use the block form of the outlet, its contents will be displayed
       if no connectors are found. Example:

       ```handlebars
         {{#plugin-outlet "hello-world"}}
           Nobody says hello :'(
         {{/plugin-outlet}}
       ```

       ## Disabling

       If a plugin returns a disabled status, the outlets will not be wired up for it.
       The list of disabled plugins is returned via the `Site` singleton.

    **/

    var registerHelper = __dependency1__.registerHelper;

    var _connectorCache = undefined,
        _rawCache = undefined;

    function findOutlets(collection, callback) {

      var disabledPlugins = Discourse.Site.currentProp('disabled_plugins') || [];

      Object.keys(collection).forEach(function (res) {
        if (res.indexOf("/connectors/") !== -1) {
          // Skip any disabled plugins
          for (var i = 0; i < disabledPlugins.length; i++) {
            if (res.indexOf("/" + disabledPlugins[i] + "/") !== -1) {
              return;
            }
          }

          var segments = res.split("/");
          var outletName = segments[segments.length - 2];
          var uniqueName = segments[segments.length - 1];

          callback(outletName, res, uniqueName);
        }
      });
    }

    function buildConnectorCache() {
      _connectorCache = {};
      _rawCache = {};

      var uniqueViews = {};
      findOutlets(requirejs._eak_seen, function (outletName, resource, uniqueName) {
        _connectorCache[outletName] = _connectorCache[outletName] || [];

        var viewClass = require(resource, null, null, true).default;
        uniqueViews[uniqueName] = viewClass;
        _connectorCache[outletName].pushObject(viewClass);
      });

      findOutlets(Ember.TEMPLATES, function (outletName, resource, uniqueName) {
        _connectorCache[outletName] = _connectorCache[outletName] || [];

        var mixin = { templateName: resource.replace('javascripts/', '') };
        var viewClass = uniqueViews[uniqueName];

        if (viewClass) {
          // We are going to add it back with the proper template
          _connectorCache[outletName].removeObject(viewClass);
        } else {
          if (!/\.raw$/.test(uniqueName)) {
            viewClass = Ember.View.extend({ classNames: [outletName + '-outlet', uniqueName] });
          }
        }

        if (viewClass) {
          _connectorCache[outletName].pushObject(viewClass.extend(mixin));
        } else {
          // we have a raw template
          if (!_rawCache[outletName]) {
            _rawCache[outletName] = [];
          }

          _rawCache[outletName].push(Ember.TEMPLATES[resource]);
        }
      });
    }

    var _viewInjections;
    function viewInjections(container) {
      if (_viewInjections) {
        return _viewInjections;
      }

      var injections = container._registry.getTypeInjections('view');

      _viewInjections = {};
      injections.forEach(function (i) {
        _viewInjections[i.property] = container.lookup(i.fullName);
      });

      return _viewInjections;
    }

    // unbound version of outlets, only has a template
    Handlebars.registerHelper('plugin-outlet', function (name) {
      if (!_rawCache) {
        buildConnectorCache();
      }

      var functions = _rawCache[name];
      if (functions) {
        var output = [];

        for (var i = 0; i < functions.length; i++) {
          output.push(functions[i]({ context: this }));
        }

        return new Handlebars.SafeString(output.join(""));
      }
    });

    registerHelper('plugin-outlet', function (params, hash, options, env) {
      var connectionName = params[0];

      if (!_connectorCache) {
        buildConnectorCache();
      }

      if (_connectorCache[connectionName]) {
        var childViews = _connectorCache[connectionName];

        // If there is more than one view, create a container. Otherwise
        // just shove it in.
        var viewClass = childViews.length > 1 ? Ember.ContainerView : childViews[0];

        var newHash = $.extend({}, viewInjections(env.data.view.container));
        if (hash.tagName) {
          newHash.tagName = hash.tagName;
        }

        delete options.fn; // we don't need the default template since we have a connector
        env.helpers.view.helperFunction.call(this, [viewClass], newHash, options, env);

        var cvs = env.data.view._childViews;
        if (childViews.length > 1 && cvs && cvs.length) {
          (function () {
            var inserted = cvs[cvs.length - 1];
            if (inserted) {
              childViews.forEach(function (cv) {
                inserted.pushObject(cv.create());
              });
            }
          })();
        }
      }
    });

    // No longer used

    function rewire() {}
  });
define("discourse/helpers/raw", 
  ["discourse/lib/helpers"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__.registerUnbound;

    // see: https://github.com/emberjs/ember.js/issues/12634
    var missingViews = {};

    function renderRaw(ctx, template, templateName, params) {
      params.parent = params.parent || ctx;

      if (!params.view && !missingViews[templateName]) {
        var viewClass = Discourse.__container__.lookupFactory('view:' + templateName);
        if (viewClass) {
          params.view = viewClass.create(params);
        } else {
          missingViews[templateName] = true;
        }
      }

      return new Handlebars.SafeString(template(params));
    }

    registerUnbound('raw', function (templateName, params) {
      var template = Discourse.__container__.lookup('template:' + templateName + '.raw');
      if (!template) {
        Ember.warn('Could not find raw template: ' + templateName);
        return;
      }
      return renderRaw(this, template, templateName, params);
    });
  });
define("discourse/helpers/shorten-url", 
  ["discourse/lib/helpers"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__.registerUnbound;

    registerUnbound('shorten-url', function (url) {
      var matches = url.match(/\//g);

      if (matches && matches.length === 3) {
        url = url.replace(/\/$/, '');
      }
      url = url.replace(/^https?:\/\//, '');
      url = url.replace(/^www\./, '');
      return url.substring(0, 80);
    });
  });
define("discourse/helpers/topic-link", 
  ["discourse/lib/helpers"],
  function(__dependency1__) {
    "use strict";
    var registerUnbound = __dependency1__.registerUnbound;

    registerUnbound('topic-link', function (topic) {
      var title = topic.get('fancyTitle');
      var url = topic.linked_post_number ? topic.urlForPostNumber(topic.linked_post_number) : topic.get('lastUnreadUrl');

      var extraClass = topic.get('last_read_post_number') === topic.get('highest_post_number') ? " visited" : "";
      var string = "<a href='" + url + "' class='title" + extraClass + "'>" + title + "</a>";

      return new Handlebars.SafeString(string);
    });
  });
define("discourse/helpers/user-status", 
  ["discourse/helpers/fa-icon","discourse/lib/helpers","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var iconHTML = __dependency1__.iconHTML;
    var htmlHelper = __dependency2__.htmlHelper;

    __exports__["default"] = htmlHelper(function (user, args) {
      if (!user) {
        return;
      }

      var name = Discourse.Utilities.escapeExpression(user.get('name'));
      var currentUser = args.hash.currentUser;

      if (currentUser && user.get('admin') && currentUser.get('staff')) {
        return iconHTML('shield', { label: I18n.t('user.admin', { user: name }) });
      }
      if (user.get('moderator')) {
        return iconHTML('shield', { label: I18n.t('user.moderator', { user: name }) });
      }
    });
  });
Ember.TEMPLATES["about"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["about.simple_title"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["guidelines"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["faq"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","nav-item-guidelines");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","nav-item-faq");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
        block(env, morph0, context, "link-to", ["guidelines"], {}, child0, null);
        block(env, morph1, context, "link-to", ["faq"], {}, child1, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["faq"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","nav-item-faq");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        block(env, morph0, context, "link-to", ["faq"], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["terms_of_service"], {});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["privacy"], {});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "a", blockArguments[0]);
          inline(env, morph0, context, "user-info", [], {"user": get(env, context, "a")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","about admins");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h3");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","clearfix");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element2, [1]),0,0);
        var morph1 = dom.createMorphAt(element2,3,3);
        inline(env, morph0, context, "i18n", ["about.our_admins"], {});
        block(env, morph1, context, "each", [get(env, context, "model.admins")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "m", blockArguments[0]);
          inline(env, morph0, context, "user-info", [], {"user": get(env, context, "m")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","about moderators");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h3");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","users");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","clearfix");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
        inline(env, morph0, context, "i18n", ["about.our_moderators"], {});
        block(env, morph1, context, "each", [get(env, context, "model.moderators")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child7 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","about contact");
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h3");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("p");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
        var morph1 = dom.createUnsafeMorphAt(dom.childAt(element0, [3]),0,0);
        inline(env, morph0, context, "i18n", ["about.contact"], {});
        content(env, morph1, context, "contactInfo");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","contents clearfix body-page");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("ul");
      dom.setAttribute(el3,"class","nav-pills");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("li");
      dom.setAttribute(el4,"class","nav-item-about");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("li");
      dom.setAttribute(el4,"class","nav-item-tos");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("li");
      dom.setAttribute(el4,"class","nav-item-privacy");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","about");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h2");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("p");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","about stats");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h3");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("table");
      dom.setAttribute(el4,"class","table");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("tr");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("th");
      var el7 = dom.createTextNode(" ");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("th");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("th");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("th");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("tr");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      dom.setAttribute(el6,"class","title");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("tr");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("tr");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("tr");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createTextNode("—");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("tr");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("td");
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, block = hooks.block, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [0, 1]);
      var element4 = dom.childAt(element3, [1]);
      var element5 = dom.childAt(element3, [3]);
      var element6 = dom.childAt(element3, [9]);
      var element7 = dom.childAt(element6, [3]);
      var element8 = dom.childAt(element7, [1]);
      var element9 = dom.childAt(element7, [3]);
      var element10 = dom.childAt(element7, [5]);
      var element11 = dom.childAt(element7, [7]);
      var element12 = dom.childAt(element7, [9]);
      var element13 = dom.childAt(element7, [11]);
      var morph0 = dom.createMorphAt(dom.childAt(element4, [1]),0,0);
      var morph1 = dom.createMorphAt(element4,3,3);
      var morph2 = dom.createMorphAt(dom.childAt(element4, [5]),0,0);
      var morph3 = dom.createMorphAt(dom.childAt(element4, [7]),0,0);
      var morph4 = dom.createMorphAt(dom.childAt(element5, [1]),0,0);
      var morph5 = dom.createMorphAt(dom.childAt(element5, [3]),0,0);
      var morph6 = dom.createMorphAt(element3,5,5);
      var morph7 = dom.createMorphAt(element3,7,7);
      var morph8 = dom.createMorphAt(dom.childAt(element6, [1]),0,0);
      var morph9 = dom.createMorphAt(dom.childAt(element8, [3]),0,0);
      var morph10 = dom.createMorphAt(dom.childAt(element8, [5]),0,0);
      var morph11 = dom.createMorphAt(dom.childAt(element8, [7]),0,0);
      var morph12 = dom.createMorphAt(dom.childAt(element9, [1]),0,0);
      var morph13 = dom.createMorphAt(dom.childAt(element9, [3]),0,0);
      var morph14 = dom.createMorphAt(dom.childAt(element9, [5]),0,0);
      var morph15 = dom.createMorphAt(dom.childAt(element9, [7]),0,0);
      var morph16 = dom.createMorphAt(dom.childAt(element10, [1]),0,0);
      var morph17 = dom.createMorphAt(dom.childAt(element10, [3]),0,0);
      var morph18 = dom.createMorphAt(dom.childAt(element10, [5]),0,0);
      var morph19 = dom.createMorphAt(dom.childAt(element10, [7]),0,0);
      var morph20 = dom.createMorphAt(dom.childAt(element11, [1]),0,0);
      var morph21 = dom.createMorphAt(dom.childAt(element11, [3]),0,0);
      var morph22 = dom.createMorphAt(dom.childAt(element11, [5]),0,0);
      var morph23 = dom.createMorphAt(dom.childAt(element11, [7]),0,0);
      var morph24 = dom.createMorphAt(dom.childAt(element12, [1]),0,0);
      var morph25 = dom.createMorphAt(dom.childAt(element12, [5]),0,0);
      var morph26 = dom.createMorphAt(dom.childAt(element12, [7]),0,0);
      var morph27 = dom.createMorphAt(dom.childAt(element13, [1]),0,0);
      var morph28 = dom.createMorphAt(dom.childAt(element13, [3]),0,0);
      var morph29 = dom.createMorphAt(dom.childAt(element13, [5]),0,0);
      var morph30 = dom.createMorphAt(dom.childAt(element13, [7]),0,0);
      var morph31 = dom.createMorphAt(element3,11,11);
      block(env, morph0, context, "link-to", ["about"], {"class": "active"}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "faqOverriden")], {}, child1, child2);
      block(env, morph2, context, "link-to", ["tos"], {}, child3, null);
      block(env, morph3, context, "link-to", ["privacy"], {}, child4, null);
      inline(env, morph4, context, "i18n", ["about.title"], {"title": get(env, context, "model.title")});
      content(env, morph5, context, "model.description");
      block(env, morph6, context, "if", [get(env, context, "model.admins")], {}, child5, null);
      block(env, morph7, context, "if", [get(env, context, "model.moderators")], {}, child6, null);
      inline(env, morph8, context, "i18n", ["about.stats"], {});
      inline(env, morph9, context, "i18n", ["about.stat.all_time"], {});
      inline(env, morph10, context, "i18n", ["about.stat.last_7_days"], {});
      inline(env, morph11, context, "i18n", ["about.stat.last_30_days"], {});
      inline(env, morph12, context, "i18n", ["about.topic_count"], {});
      inline(env, morph13, context, "number", [get(env, context, "model.stats.topic_count")], {});
      inline(env, morph14, context, "number", [get(env, context, "model.stats.topics_7_days")], {});
      inline(env, morph15, context, "number", [get(env, context, "model.stats.topics_30_days")], {});
      inline(env, morph16, context, "i18n", ["about.post_count"], {});
      inline(env, morph17, context, "number", [get(env, context, "model.stats.post_count")], {});
      inline(env, morph18, context, "number", [get(env, context, "model.stats.posts_7_days")], {});
      inline(env, morph19, context, "number", [get(env, context, "model.stats.posts_30_days")], {});
      inline(env, morph20, context, "i18n", ["about.user_count"], {});
      inline(env, morph21, context, "number", [get(env, context, "model.stats.user_count")], {});
      inline(env, morph22, context, "number", [get(env, context, "model.stats.users_7_days")], {});
      inline(env, morph23, context, "number", [get(env, context, "model.stats.users_30_days")], {});
      inline(env, morph24, context, "i18n", ["about.active_user_count"], {});
      inline(env, morph25, context, "number", [get(env, context, "model.stats.active_users_7_days")], {});
      inline(env, morph26, context, "number", [get(env, context, "model.stats.active_users_30_days")], {});
      inline(env, morph27, context, "i18n", ["about.like_count"], {});
      inline(env, morph28, context, "number", [get(env, context, "model.stats.like_count")], {});
      inline(env, morph29, context, "number", [get(env, context, "model.stats.likes_7_days")], {});
      inline(env, morph30, context, "number", [get(env, context, "model.stats.likes_30_days")], {});
      block(env, morph31, context, "if", [get(env, context, "contactInfo")], {}, child7, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["additional-composer-buttons"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["application"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "custom-html", ["top"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "custom-html", ["footer"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"id","main-outlet");
      dom.setAttribute(el1,"class","wrap");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","container");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [2]);
      var element1 = dom.childAt(element0, [1]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(element1,1,1);
      var morph2 = dom.createMorphAt(element1,3,3);
      var morph3 = dom.createMorphAt(element1,5,5);
      var morph4 = dom.createMorphAt(element0,3,3);
      var morph5 = dom.createMorphAt(element0,5,5);
      var morph6 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph7 = dom.createMorphAt(fragment,6,6,contextualElement);
      var morph8 = dom.createMorphAt(fragment,7,7,contextualElement);
      var morph9 = dom.createMorphAt(fragment,9,9,contextualElement);
      var morph10 = dom.createMorphAt(fragment,11,11,contextualElement);
      var morph11 = dom.createMorphAt(fragment,13,13,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "site-header", [], {"canSignUp": get(env, context, "canSignUp"), "showCreateAccount": "showCreateAccount", "showLogin": "showLogin", "showKeyboard": "showKeyboardShortcutsHelp", "toggleMobileView": "toggleMobileView", "toggleAnonymous": "toggleAnonymous", "logout": "logout", "showSearchHelp": "showSearchHelp"});
      block(env, morph1, context, "if", [get(env, context, "showTop")], {}, child0, null);
      content(env, morph2, context, "global-notice");
      content(env, morph3, context, "create-topics-notice");
      content(env, morph4, context, "outlet");
      inline(env, morph5, context, "render", ["user-card"], {});
      inline(env, morph6, context, "plugin-outlet", ["above-footer"], {});
      block(env, morph7, context, "if", [get(env, context, "showFooter")], {}, child1, null);
      inline(env, morph8, context, "plugin-outlet", ["below-footer"], {});
      inline(env, morph9, context, "render", ["modal"], {});
      inline(env, morph10, context, "render", ["topic-entrance"], {});
      inline(env, morph11, context, "render", ["composer"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["badges/index"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "b", blockArguments[0]);
          inline(env, morph0, context, "badge-card", [], {"badge": get(env, context, "b"), "navigateOnClick": "true"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","badge-grouping");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","title");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("h3");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, content = hooks.content, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [1, 1]),0,0);
        var morph1 = dom.createMorphAt(element0,3,3);
        set(env, context, "bg", blockArguments[0]);
        content(env, morph0, context, "bg.badgeGrouping.displayName");
        block(env, morph1, context, "each", [get(env, context, "bg.badges")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container badges");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("h1");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","badge-groups");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
      inline(env, morph0, context, "i18n", ["badges.title"], {});
      block(env, morph1, context, "each", [get(env, context, "badgeGroups")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["badges/show"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["badges.title"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("              ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("a");
                dom.setAttribute(el1,"class","post-link");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element1 = dom.childAt(fragment, [1]);
                var morph0 = dom.createUnsafeMorphAt(element1,0,0);
                var attrMorph0 = dom.createAttrMorph(element1, 'href');
                attribute(env, attrMorph0, element1, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "ub.topic.url")], {}), "/", subexpr(env, context, "unbound", [get(env, context, "ub.post_number")], {})]));
                content(env, morph0, context, "ub.topic.fancyTitle");
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","granted-on");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, inline = hooks.inline, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
              dom.insertBoundary(fragment, null);
              inline(env, morph0, context, "i18n", ["badges.granted_on"], {"date": subexpr(env, context, "inline-date", [get(env, context, "ub.granted_at")], {})});
              block(env, morph1, context, "if", [get(env, context, "ub.post_number")], {}, child0, null);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            set(env, context, "ub", blockArguments[0]);
            block(env, morph0, context, "user-info", [], {"user": get(env, context, "ub.user"), "size": "medium", "class": "badge-info", "date": get(env, context, "ub.granted_at")}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "each", [get(env, context, "userBadges")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","clearfix");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("a");
            dom.setAttribute(el2,"class","btn");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1, 1]);
            var morph0 = dom.createMorphAt(element0,0,0);
            var attrMorph0 = dom.createAttrMorph(element0, 'href');
            attribute(env, attrMorph0, element0, "href", concat(env, [get(env, context, "model.url")]));
            inline(env, morph0, context, "i18n", ["badges.others_count"], {"count": get(env, context, "model.grant_count")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "canShowOthers")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","user-badges");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element2,1,1);
        var morph1 = dom.createMorphAt(element2,3,3);
        var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
        block(env, morph0, context, "load-more", [], {"selector": ".badge-info", "action": "loadMore"}, child0, null);
        block(env, morph1, context, "unless", [get(env, context, "canLoadMore")], {}, child1, null);
        inline(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "canLoadMore")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container show-badge");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("h1");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n     /\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","show-badge-details");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","badge-grant-info");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("div");
      dom.setAttribute(el5,"class","grant-info-item");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(" ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("div");
      dom.setAttribute(el5,"class","grant-info-item");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(" ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, block = hooks.block, content = hooks.content, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [0]);
      var element4 = dom.childAt(element3, [1]);
      var element5 = dom.childAt(element3, [3]);
      var element6 = dom.childAt(element5, [3, 1]);
      var element7 = dom.childAt(element6, [1]);
      var element8 = dom.childAt(element6, [3]);
      var morph0 = dom.createMorphAt(element4,1,1);
      var morph1 = dom.createMorphAt(element4,3,3);
      var morph2 = dom.createMorphAt(element5,1,1);
      var morph3 = dom.createMorphAt(element7,1,1);
      var morph4 = dom.createMorphAt(element7,3,3);
      var morph5 = dom.createMorphAt(element8,1,1);
      var morph6 = dom.createMorphAt(element8,3,3);
      var morph7 = dom.createMorphAt(element3,5,5);
      block(env, morph0, context, "link-to", ["badges.index"], {}, child0, null);
      content(env, morph1, context, "model.name");
      inline(env, morph2, context, "badge-card", [], {"badge": get(env, context, "model"), "size": "large", "count": get(env, context, "userBadges.grant_count")});
      inline(env, morph3, context, "check-mark", [], {"checked": get(env, context, "model.allow_title")});
      inline(env, morph4, context, "i18n", ["badges.allow_title"], {});
      inline(env, morph5, context, "check-mark", [], {"checked": get(env, context, "model.multiple_grant")});
      inline(env, morph6, context, "i18n", ["badges.multiple_grant"], {});
      block(env, morph7, context, "if", [get(env, context, "userBadges")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["bulk-tag"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("p");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("p");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      inline(env, morph0, context, "i18n", ["topics.bulk.choose_new_tags"], {});
      inline(env, morph1, context, "tag-chooser", [], {"tags": get(env, context, "tags")});
      inline(env, morph2, context, "d-button", [], {"action": "changeTags", "disabled": get(env, context, "emptyTags"), "label": "topics.bulk.change_tags"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["category-group-autocomplete.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "      <li><a href>"
    + container.escapeExpression((helpers["category-link"] || (depth0 && depth0["category-link"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"option",{"name":"category-link","hash":{"link":"false","allowUncategorized":"true"},"hashTypes":{"link":"StringLiteral","allowUncategorized":"StringLiteral"},"hashContexts":{"link":depth0,"allowUncategorized":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a></li>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<div class='autocomplete'>\n  <ul>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"option","in","options",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + "  </ul>\n</div>\n";
},"useData":true});
Ember.TEMPLATES["category-tag-autocomplete.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "      <li>\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"option.model",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "      </li>\n";
},"2":function(container,depth0,helpers,partials,data) {
    return "          <a href>"
    + container.escapeExpression((helpers["category-link"] || (depth0 && depth0["category-link"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"option.model",{"name":"category-link","hash":{"link":"false","allowUncategorized":"true"},"hashTypes":{"link":"StringLiteral","allowUncategorized":"StringLiteral"},"hashContexts":{"link":depth0,"allowUncategorized":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"4":function(container,depth0,helpers,partials,data) {
    return "          <a href>"
    + container.escapeExpression((helpers["fa-icon"] || (depth0 && depth0["fa-icon"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"tag",{"name":"fa-icon","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"option.text",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + " x "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"option.count",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<div class='autocomplete'>\n  <ul>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"option","in","options",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + "  </ul>\n</div>\n";
},"useData":true});
Ember.TEMPLATES["components/admin-group-selector"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("input");
      dom.setAttribute(el1,"type","text");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/auto-close-form"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","auto-close-fields");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","examples");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [1, 1]);
      var element2 = dom.childAt(element0, [5, 1]);
      var morph0 = dom.createMorphAt(element1,1,1);
      var morph1 = dom.createMorphAt(element1,3,3);
      var morph2 = dom.createMorphAt(element1,5,5);
      var morph3 = dom.createMorphAt(element1,7,7);
      var morph4 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
      var morph5 = dom.createMorphAt(element2,1,1);
      var morph6 = dom.createMorphAt(element2,3,3);
      inline(env, morph0, context, "fa-icon", ["clock-o"], {});
      inline(env, morph1, context, "i18n", ["composer.auto_close.label"], {});
      inline(env, morph2, context, "text-field", [], {"value": get(env, context, "autoCloseTime")});
      content(env, morph3, context, "autoCloseUnits");
      content(env, morph4, context, "autoCloseExamples");
      inline(env, morph5, context, "input", [], {"type": "checkbox", "checked": get(env, context, "autoCloseBasedOnLastPost")});
      inline(env, morph6, context, "i18n", ["composer.auto_close.based_on_last_post"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/avatar-uploader"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("span");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("%");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        var morph1 = dom.createMorphAt(element0,2,2);
        inline(env, morph0, context, "i18n", ["upload_selector.uploading"], {});
        content(env, morph1, context, "uploadProgress");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","warning");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["user.change_avatar.image_is_not_a_square"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      dom.setAttribute(el1,"class","btn");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode(" ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("input");
      dom.setAttribute(el2,"type","file");
      dom.setAttribute(el2,"accept","image/*");
      dom.setAttribute(el2,"style","visibility: hidden; position: absolute;");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, concat = hooks.concat, inline = hooks.inline, content = hooks.content, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var element2 = dom.childAt(element1, [5]);
      var morph0 = dom.createMorphAt(element1,1,1);
      var morph1 = dom.createMorphAt(element1,3,3);
      var attrMorph0 = dom.createAttrMorph(element1, 'disabled');
      var attrMorph1 = dom.createAttrMorph(element1, 'title');
      var attrMorph2 = dom.createAttrMorph(element2, 'disabled');
      var morph2 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph3 = dom.createMorphAt(fragment,3,3,contextualElement);
      dom.insertBoundary(fragment, null);
      attribute(env, attrMorph0, element1, "disabled", get(env, context, "uploading"));
      attribute(env, attrMorph1, element1, "title", concat(env, [subexpr(env, context, "i18n", ["user.change_avatar.upload_title"], {})]));
      inline(env, morph0, context, "fa-icon", ["picture-o"], {});
      content(env, morph1, context, "uploadButtonText");
      attribute(env, attrMorph2, element2, "disabled", get(env, context, "uploading"));
      block(env, morph2, context, "if", [get(env, context, "uploading")], {}, child0, null);
      block(env, morph3, context, "if", [get(env, context, "imageIsNotASquare")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/badge-button"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("span");
      dom.setAttribute(el1,"class","badge-display-name");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "icon-or-image", [get(env, context, "badge.icon")], {});
      content(env, morph1, context, "badge.name");
      content(env, morph2, context, "yield");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/badge-card"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","grant-count");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, attribute = hooks.attribute, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        var attrMorph0 = dom.createAttrMorph(element0, 'title');
        attribute(env, attrMorph0, element0, "title", subexpr(env, context, "i18n", ["badges.granted"], {"count": get(env, context, "displayCount")}));
        content(env, morph0, context, "displayCount");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","check-display status-checked");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "fa-icon", ["check"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","badge-contents");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","badge-info");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","badge-info-item");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h3");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","badge-summary");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [2]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element1, [3, 1]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
      var morph2 = dom.createMorphAt(element2,1,1);
      var attrMorph0 = dom.createAttrMorph(element2, 'class');
      var morph3 = dom.createMorphAt(dom.childAt(element3, [1]),0,0);
      var morph4 = dom.createUnsafeMorphAt(dom.childAt(element3, [3]),0,0);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "displayCount")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "badge.has_badge")], {}, child1, null);
      attribute(env, attrMorph0, element2, "class", concat(env, ["badge-icon ", get(env, context, "badge.badgeTypeClassName")]));
      inline(env, morph2, context, "icon-or-image", [get(env, context, "badge.icon")], {});
      content(env, morph3, context, "badge.name");
      content(env, morph4, context, "summary");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/basic-topic-list"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "topic-list", [], {"showParticipants": get(env, context, "showParticipants"), "showPosters": get(env, context, "showPosters"), "hideCategory": get(env, context, "hideCategory"), "topics": get(env, context, "topics"), "expandExcerpts": get(env, context, "expandExcerpts"), "bulkSelectEnabled": get(env, context, "bulkSelectEnabled"), "canBulkSelect": get(env, context, "canBulkSelect"), "selected": get(env, context, "selected")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("    ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","alert alert-info");
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n    ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            inline(env, morph0, context, "i18n", ["choose_topic.none_found"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "unless", [get(env, context, "loadingMore")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "topics")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/bread-crumbs"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "category-drop", [], {"category": get(env, context, "secondCategory"), "parentCategory": get(env, context, "firstCategory"), "categories": get(env, context, "childCategories"), "subCategory": "true", "noSubcategories": get(env, context, "noSubcategories")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "tag-drop", [], {"firstCategory": get(env, context, "firstCategory"), "secondCategory": get(env, context, "secondCategory"), "tagId": get(env, context, "tagId")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","clear");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "category-drop", [], {"category": get(env, context, "firstCategory"), "categories": get(env, context, "parentCategories")});
      block(env, morph1, context, "if", [get(env, context, "childCategories")], {}, child0, null);
      block(env, morph2, context, "if", [get(env, context, "siteSettings.tagging_enabled")], {}, child1, null);
      inline(env, morph3, context, "plugin-outlet", ["bread-crumbs-right"], {"tagName": "li"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/bulk-select-button"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"id","bulk-select");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        inline(env, morph0, context, "d-button", [], {"action": "showBulkActions", "icon": "wrench"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "selected")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/category-drop"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "fa-icon", ["lock"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"href","");
        dom.setAttribute(el1,"class","badge-category");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","badge-category-bg");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, element = hooks.element, block = hooks.block, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element7 = dom.childAt(fragment, [1]);
        var element8 = dom.childAt(element7, [1]);
        var attrMorph0 = dom.createAttrMorph(element7, 'style');
        var attrMorph1 = dom.createAttrMorph(element7, 'aria-label');
        var attrMorph2 = dom.createAttrMorph(element7, 'aria-expanded');
        var attrMorph3 = dom.createAttrMorph(element8, 'style');
        var morph0 = dom.createMorphAt(element7,3,3);
        var morph1 = dom.createMorphAt(element7,5,5);
        attribute(env, attrMorph0, element7, "style", get(env, context, "badgeStyle"));
        attribute(env, attrMorph1, element7, "aria-label", subexpr(env, context, "i18n", ["categories.category_list"], {}));
        attribute(env, attrMorph2, element7, "aria-expanded", get(env, context, "expanded"));
        element(env, element7, context, "action", ["expand"], {});
        attribute(env, attrMorph3, element8, "style", get(env, context, "categoryColor"));
        block(env, morph0, context, "if", [get(env, context, "category.read_restricted")], {}, child0, null);
        content(env, morph1, context, "category.name");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          dom.setAttribute(el1,"class","badge-category home");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element6 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element6,0,0);
          var attrMorph0 = dom.createAttrMorph(element6, 'style');
          var attrMorph1 = dom.createAttrMorph(element6, 'aria-label');
          var attrMorph2 = dom.createAttrMorph(element6, 'aria-expanded');
          attribute(env, attrMorph0, element6, "style", get(env, context, "badgeStyle"));
          attribute(env, attrMorph1, element6, "aria-label", subexpr(env, context, "i18n", ["categories.category_list"], {}));
          attribute(env, attrMorph2, element6, "aria-expanded", get(env, context, "expanded"));
          element(env, element6, context, "action", ["expand"], {});
          inline(env, morph0, context, "i18n", ["categories.no_subcategory"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          dom.setAttribute(el1,"class","badge-category home");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, element = hooks.element, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element5 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element5,0,0);
          var attrMorph0 = dom.createAttrMorph(element5, 'style');
          var attrMorph1 = dom.createAttrMorph(element5, 'aria-label');
          var attrMorph2 = dom.createAttrMorph(element5, 'aria-expanded');
          attribute(env, attrMorph0, element5, "style", get(env, context, "badgeStyle"));
          attribute(env, attrMorph1, element5, "aria-label", subexpr(env, context, "i18n", ["categories.category_list"], {}));
          attribute(env, attrMorph2, element5, "aria-expanded", get(env, context, "expanded"));
          element(env, element5, context, "action", ["expand"], {});
          content(env, morph0, context, "allCategoriesLabel");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "noSubcategories")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","cat");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"data-drop-close","true");
          dom.setAttribute(el2,"class","badge-category home");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element0,0,0);
          var attrMorph0 = dom.createAttrMorph(element0, 'href');
          attribute(env, attrMorph0, element0, "href", get(env, context, "noCategoriesUrl"));
          inline(env, morph0, context, "i18n", ["categories.no_subcategory"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","cat");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
            set(env, context, "c", blockArguments[0]);
            inline(env, morph0, context, "category-link", [get(env, context, "c")], {"allowUncategorized": true, "hideParent": get(env, context, "subCategory")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          block(env, morph0, context, "each", [get(env, context, "categories")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"href","");
        var el2 = dom.createElement("i");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","cat");
        var el3 = dom.createElement("a");
        dom.setAttribute(el3,"data-drop-close","true");
        dom.setAttribute(el3,"class","badge-category home");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, subexpr = hooks.subexpr, concat = hooks.concat, content = hooks.content, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var element2 = dom.childAt(element1, [0]);
        var element3 = dom.childAt(fragment, [3]);
        var element4 = dom.childAt(element3, [1, 0]);
        var attrMorph0 = dom.createAttrMorph(element1, 'class');
        var attrMorph1 = dom.createAttrMorph(element1, 'style');
        var attrMorph2 = dom.createAttrMorph(element2, 'class');
        var attrMorph3 = dom.createAttrMorph(element3, 'class');
        var morph0 = dom.createMorphAt(element4,0,0);
        var attrMorph4 = dom.createAttrMorph(element4, 'href');
        var morph1 = dom.createMorphAt(element3,3,3);
        var morph2 = dom.createMorphAt(element3,4,4);
        attribute(env, attrMorph0, element1, "class", get(env, context, "dropdownButtonClass"));
        attribute(env, attrMorph1, element1, "style", get(env, context, "badgeStyle"));
        element(env, element1, context, "action", ["expand"], {});
        attribute(env, attrMorph2, element2, "class", get(env, context, "iconClass"));
        attribute(env, attrMorph3, element3, "class", concat(env, [subexpr(env, context, "unless", [get(env, context, "expanded"), "hidden"], {}), " category-dropdown-menu chooser}}"]));
        attribute(env, attrMorph4, element4, "href", get(env, context, "allCategoriesUrl"));
        content(env, morph0, context, "allCategoriesLabel");
        block(env, morph1, context, "if", [get(env, context, "subCategory")], {}, child0, null);
        block(env, morph2, context, "if", [get(env, context, "renderCategories")], {}, child1, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "category")], {}, child0, child1);
      block(env, morph1, context, "if", [get(env, context, "categories")], {}, child2, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/category-group"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("input");
      dom.setAttribute(el1,"class","category-group");
      dom.setAttribute(el1,"type","text");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/category-unread"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"class","badge new-posts badge-notification");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element1,0,0);
        var attrMorph0 = dom.createAttrMorph(element1, 'href');
        var attrMorph1 = dom.createAttrMorph(element1, 'title');
        attribute(env, attrMorph0, element1, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "category.unreadUrl")], {})]));
        attribute(env, attrMorph1, element1, "title", concat(env, [subexpr(env, context, "i18n", ["topic.unread_topics"], {"count": get(env, context, "category.unreadTopics")})]));
        inline(env, morph0, context, "i18n", ["filters.unread.lower_title_with_count"], {"count": get(env, context, "category.unreadTopics")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"class","badge new-posts badge-notification");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        var attrMorph0 = dom.createAttrMorph(element0, 'href');
        var attrMorph1 = dom.createAttrMorph(element0, 'title');
        attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "category.newUrl")], {})]));
        attribute(env, attrMorph1, element0, "title", concat(env, [subexpr(env, context, "i18n", ["topic.new_topics"], {"count": get(env, context, "category.newTopics")})]));
        inline(env, morph0, context, "i18n", ["filters.new.lower_title_with_count"], {"count": get(env, context, "category.newTopics")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "category.unreadTopics")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "category.newTopics")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/choose-topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["loading"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          inline(env, morph0, context, "i18n", ["choose_topic.none_found"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "bound-category-link", [get(env, context, "t.category.parentCategory")], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","controls");
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("label");
            dom.setAttribute(el2,"class","radio");
            var el3 = dom.createTextNode("\n        ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("input");
            dom.setAttribute(el3,"type","radio");
            dom.setAttribute(el3,"name","choose_topic_id");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("        ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n        ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1, 1]);
            var element1 = dom.childAt(element0, [1]);
            var attrMorph0 = dom.createAttrMorph(element1, 'id');
            var morph0 = dom.createMorphAt(element0,2,2);
            var morph1 = dom.createMorphAt(element0,4,4);
            var morph2 = dom.createMorphAt(element0,6,6);
            set(env, context, "t", blockArguments[0]);
            attribute(env, attrMorph0, element1, "id", concat(env, ["choose-topic-", subexpr(env, context, "unbound", [get(env, context, "t.id")], {})]));
            element(env, element1, context, "action", ["chooseTopic", get(env, context, "t")], {});
            content(env, morph0, context, "t.title");
            block(env, morph1, context, "if", [get(env, context, "t.category.parentCategory")], {}, child0, null);
            inline(env, morph2, context, "bound-category-link", [get(env, context, "t.category")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "each", [get(env, context, "topics")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "noResults")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      dom.setAttribute(el1,"for","choose-topic-title");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, null);
      inline(env, morph0, context, "i18n", ["choose_topic.title.search"], {});
      inline(env, morph1, context, "text-field", [], {"value": get(env, context, "topicTitle"), "placeholderKey": "choose_topic.title.placeholder", "id": "choose-topic-title"});
      block(env, morph2, context, "if", [get(env, context, "loading")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/color-input"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "text-field", [], {"class": "hex-input", "value": get(env, context, "hexValue"), "maxlength": "6"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/composer-editor"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("input");
        dom.setAttribute(el1,"type","file");
        dom.setAttribute(el1,"id","mobile-uploader");
        dom.setAttribute(el1,"multiple","");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element3 = dom.childAt(fragment, [3]);
        var morph0 = dom.createMorphAt(element3,0,0);
        var attrMorph0 = dom.createAttrMorph(element3, 'class');
        attribute(env, attrMorph0, element3, "class", concat(env, ["mobile-file-upload ", subexpr(env, context, "if", [get(env, context, "isUploading"), "hidden"], {})]));
        inline(env, morph0, context, "i18n", ["upload"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"href","");
        dom.setAttribute(el1,"class","toggle-preview");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var morph0 = dom.createUnsafeMorphAt(element2,0,0);
        element(env, element2, context, "action", ["togglePreview"], {});
        content(env, morph0, context, "toggleText");
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          dom.setAttribute(el1,"id","cancel-file-upload");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,0,0);
          element(env, element0, context, "action", ["cancelUpload"], {});
          inline(env, morph0, context, "fa-icon", ["times"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"id","file-uploading");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("%\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element1,1,1);
        var morph1 = dom.createMorphAt(element1,3,3);
        var morph2 = dom.createMorphAt(element1,5,5);
        var morph3 = dom.createMorphAt(element1,7,7);
        inline(env, morph0, context, "loading-spinner", [], {"size": "small"});
        inline(env, morph1, context, "i18n", ["upload_selector.uploading"], {});
        content(env, morph2, context, "uploadProgress");
        block(env, morph3, context, "if", [get(env, context, "isCancellable")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","composer-bottom-right");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","draft-status");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element4 = dom.childAt(fragment, [2]);
      var element5 = dom.childAt(element4, [4]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(element4,1,1);
      var morph2 = dom.createMorphAt(element4,2,2);
      var morph3 = dom.createMorphAt(element5,1,1);
      var attrMorph0 = dom.createAttrMorph(element5, 'class');
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "d-editor", [], {"tabindex": "4", "value": get(env, context, "composer.reply"), "placeholder": "composer.reply_placeholder", "previewUpdated": "previewUpdated", "markdownOptions": get(env, context, "markdownOptions"), "extraButtons": "extraButtons", "importQuote": "importQuote", "showOptions": "showOptions", "showUploadModal": "showUploadModal", "validation": get(env, context, "validation"), "loading": get(env, context, "composer.loading")});
      block(env, morph1, context, "if", [get(env, context, "site.mobileView")], {}, child0, child1);
      block(env, morph2, context, "if", [get(env, context, "isUploading")], {}, child2, null);
      attribute(env, attrMorph0, element5, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "isUploading"), "hidden"], {})]));
      content(env, morph3, context, "draftStatus");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/composer-title"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "text-field", [], {"value": get(env, context, "composer.title"), "tabindex": "2", "id": "reply-title", "maxLength": get(env, context, "siteSettings.max_topic_title_length"), "placeholderKey": "composer.title_placeholder", "disabled": get(env, context, "composer.loading")});
      inline(env, morph1, context, "popup-input-tip", [], {"validation": get(env, context, "validation")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/create-topics-notice"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","row");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","alert alert-info alert-too-few-topics");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1]),1,1);
        content(env, morph0, context, "message");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "unless", [get(env, context, "hidden")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/d-checkbox"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "checked")});
      inline(env, morph1, context, "i18n", [get(env, context, "label")], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/d-editor-modal"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","controls");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [3]);
      var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
      var morph1 = dom.createMorphAt(element0,1,1);
      var morph2 = dom.createMorphAt(element0,3,3);
      content(env, morph0, context, "yield");
      inline(env, morph1, context, "d-button", [], {"class": "btn-primary", "label": "composer.modal_ok", "action": "ok"});
      inline(env, morph2, context, "d-button", [], {"class": "btn-danger", "label": "composer.modal_cancel", "action": "cancel"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/d-editor"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("h3");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
        inline(env, morph0, context, "i18n", ["composer.link_dialog_title"], {});
        inline(env, morph1, context, "text-field", [], {"value": get(env, context, "linkUrl"), "placeholderKey": "composer.link_url_placeholder", "class": "link-url"});
        inline(env, morph2, context, "text-field", [], {"value": get(env, context, "linkText"), "placeholderKey": "composer.link_optional_text", "class": "link-text"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "b", blockArguments[0]);
          inline(env, morph0, context, "d-button", [], {"action": get(env, context, "b.action"), "actionParam": get(env, context, "b"), "translatedTitle": get(env, context, "b.title"), "icon": get(env, context, "b.icon"), "class": get(env, context, "b.className")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","d-editor-spacer");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        set(env, context, "group", blockArguments[0]);
        block(env, morph0, context, "each", [get(env, context, "group.buttons")], {}, child0, null);
        block(env, morph1, context, "unless", [get(env, context, "group.lastGroup")], {}, child1, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "hidePreview", "class": "hide-preview", "label": "composer.hide_preview"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","d-editor-overlay hidden");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","d-editor-modals");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","d-editor-container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","d-editor-button-bar");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","d-editor-preview-header");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","d-editor-textarea-wrapper");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","d-editor-preview");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [4]);
      var element1 = dom.childAt(element0, [5]);
      var element2 = dom.childAt(element0, [7]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
      var morph2 = dom.createMorphAt(element1,1,1);
      var morph3 = dom.createMorphAt(element1,3,3);
      var morph4 = dom.createMorphAt(element1,5,5);
      var attrMorph0 = dom.createAttrMorph(element2, 'class');
      var morph5 = dom.createUnsafeMorphAt(dom.childAt(element2, [1]),1,1);
      var morph6 = dom.createMorphAt(element2,3,3);
      block(env, morph0, context, "d-editor-modal", [], {"class": "insert-link", "hidden": get(env, context, "insertLinkHidden"), "okAction": "insertLink"}, child0, null);
      block(env, morph1, context, "each", [get(env, context, "toolbar.groups")], {}, child1, null);
      inline(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")});
      inline(env, morph3, context, "textarea", [], {"tabindex": get(env, context, "tabindex"), "value": get(env, context, "value"), "class": "d-editor-input", "placeholder": get(env, context, "placeholderTranslated")});
      inline(env, morph4, context, "popup-input-tip", [], {"validation": get(env, context, "validation")});
      attribute(env, attrMorph0, element2, "class", concat(env, ["d-editor-preview-wrapper ", subexpr(env, context, "if", [get(env, context, "forcePreview"), "force-preview"], {})]));
      content(env, morph5, context, "preview");
      block(env, morph6, context, "if", [get(env, context, "site.mobileView")], {}, child2, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/date-picker"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("input");
      dom.setAttribute(el1,"type","text");
      dom.setAttribute(el1,"class","date-picker");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/desktop-notification-config"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"icon": "bell-slash", "label": "user.desktop_notifications.not_supported", "disabled": "true"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"icon": "bell-slash", "label": "user.desktop_notifications.perm_default", "action": "requestPermission"});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "d-button", [], {"icon": "bell-slash", "label": "user.desktop_notifications.perm_denied_btn", "action": "recheckPermission", "disabled": "true"});
        inline(env, morph1, context, "i18n", ["user.desktop_notifications.perm_denied_expl"], {});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "d-button", [], {"icon": "bell-slash-o", "label": "user.desktop_notifications.disable", "action": "turnoff"});
          inline(env, morph1, context, "i18n", ["user.desktop_notifications.currently_enabled"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "d-button", [], {"icon": "bell-o", "label": "user.desktop_notifications.enable", "action": "turnon"});
          inline(env, morph1, context, "i18n", ["user.desktop_notifications.currently_disabled"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "isEnabled")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
      var morph3 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, null);
      block(env, morph0, context, "if", [get(env, context, "isNotSupported")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "isDefaultPermission")], {}, child1, null);
      block(env, morph2, context, "if", [get(env, context, "isDeniedPermission")], {}, child2, null);
      block(env, morph3, context, "if", [get(env, context, "isGrantedPermission")], {}, child3, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/directory-item"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("td");
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","time-read");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 0]),0,0);
        inline(env, morph0, context, "unbound", [get(env, context, "item.time_read")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("td");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("td");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("td");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("td");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("td");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("td");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("td");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("td");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [4]),0,0);
      var morph3 = dom.createMorphAt(dom.childAt(fragment, [6]),0,0);
      var morph4 = dom.createMorphAt(dom.childAt(fragment, [8]),0,0);
      var morph5 = dom.createMorphAt(dom.childAt(fragment, [10]),0,0);
      var morph6 = dom.createMorphAt(dom.childAt(fragment, [12]),0,0);
      var morph7 = dom.createMorphAt(dom.childAt(fragment, [14]),0,0);
      var morph8 = dom.createMorphAt(fragment,16,16,contextualElement);
      dom.insertBoundary(fragment, null);
      inline(env, morph0, context, "user-info", [], {"user": get(env, context, "item.user")});
      inline(env, morph1, context, "number", [get(env, context, "item.likes_received")], {});
      inline(env, morph2, context, "number", [get(env, context, "item.likes_given")], {});
      inline(env, morph3, context, "number", [get(env, context, "item.topic_count")], {});
      inline(env, morph4, context, "number", [get(env, context, "item.post_count")], {});
      inline(env, morph5, context, "number", [get(env, context, "item.topics_entered")], {});
      inline(env, morph6, context, "number", [get(env, context, "item.posts_read")], {});
      inline(env, morph7, context, "number", [get(env, context, "item.days_visited")], {});
      block(env, morph8, context, "if", [get(env, context, "showTimeRead")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/disabled-icon"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "fa-icon", ["ban"], {"modifier": "stack-2x"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "fa-icon", [get(env, context, "icon")], {"modifier": "stack-2x"});
      block(env, morph1, context, "if", [get(env, context, "disabled")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/discourse-banner"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createElement("a");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 0]);
        var morph0 = dom.createUnsafeMorphAt(element0,0,0);
        var attrMorph0 = dom.createAttrMorph(element0, 'href');
        attribute(env, attrMorph0, element0, "href", concat(env, [get(env, context, "banner.url")]));
        inline(env, morph0, context, "i18n", ["banner.edit"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","row");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","banner");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"id","banner-content");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","close");
      var el5 = dom.createElement("i");
      dom.setAttribute(el5,"class","fa fa-times");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, subexpr = hooks.subexpr, concat = hooks.concat, content = hooks.content, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0, 1]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(element3, [0]);
      var attrMorph0 = dom.createAttrMorph(element1, 'class');
      var attrMorph1 = dom.createAttrMorph(element4, 'title');
      var morph0 = dom.createUnsafeMorphAt(element2,3,3);
      var morph1 = dom.createMorphAt(element2,5,5);
      attribute(env, attrMorph0, element1, "class", get(env, context, "overlay"));
      element(env, element3, context, "action", ["dismiss"], {});
      attribute(env, attrMorph1, element4, "title", concat(env, [subexpr(env, context, "i18n", ["banner.close"], {})]));
      content(env, morph0, context, "banner.html");
      block(env, morph1, context, "if", [get(env, context, "currentUser.staff")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/discourse-tag-bound"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      content(env, morph0, context, "tagRecord.id");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-general"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            set(env, context, "s", blockArguments[0]);
            inline(env, morph0, context, "category-badge", [get(env, context, "s")], {"hideParent": "true"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("label");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          dom.insertBoundary(fragment, null);
          inline(env, morph0, context, "i18n", ["categories.subcategories"], {});
          block(env, morph1, context, "each", [get(env, context, "subCategories")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("label");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "i18n", ["category.parent"], {});
          inline(env, morph1, context, "category-chooser", [], {"valueAttribute": "id", "value": get(env, context, "category.parent_category_id"), "categories": get(env, context, "parentCategories"), "rootNone": true});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "if", [get(env, context, "subCategories")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
          content(env, morph0, context, "category.description");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["category.no_description"], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("br");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "d-button", [], {"class": "btn-small", "action": "showCategoryTopic", "icon": "pencil", "label": "category.change_in_category_topic"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
        var morph1 = dom.createMorphAt(element0,3,3);
        var morph2 = dom.createMorphAt(element0,4,4);
        inline(env, morph0, context, "i18n", ["category.description"], {});
        block(env, morph1, context, "if", [get(env, context, "category.description")], {}, child0, child1);
        block(env, morph2, context, "if", [get(env, context, "category.topic_url")], {}, child2, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("section");
      dom.setAttribute(el2,"class","field");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","field-item");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","field-item");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("section");
      dom.setAttribute(el2,"class","field");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","category-color-editor");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","input-prepend input-append");
      dom.setAttribute(el4,"style","margin-top: 10px;");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("span");
      dom.setAttribute(el5,"class","color-title");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(":");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("span");
      dom.setAttribute(el5,"class","add-on");
      var el6 = dom.createTextNode("#");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","input-prepend input-append");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("span");
      dom.setAttribute(el5,"class","color-title");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(":");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("span");
      dom.setAttribute(el5,"class","add-on");
      var el6 = dom.createTextNode("#");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(element2, [3]);
      var element5 = dom.childAt(element1, [7]);
      var element6 = dom.childAt(element5, [3]);
      var element7 = dom.childAt(element6, [3]);
      var element8 = dom.childAt(element6, [5]);
      var morph0 = dom.createMorphAt(dom.childAt(element3, [1]),0,0);
      var morph1 = dom.createMorphAt(element3,3,3);
      var morph2 = dom.createMorphAt(dom.childAt(element4, [1]),0,0);
      var morph3 = dom.createMorphAt(element4,3,3);
      var morph4 = dom.createMorphAt(element1,3,3);
      var morph5 = dom.createMorphAt(element1,5,5);
      var morph6 = dom.createMorphAt(dom.childAt(element5, [1]),0,0);
      var morph7 = dom.createUnsafeMorphAt(element6,1,1);
      var morph8 = dom.createMorphAt(dom.childAt(element7, [1]),0,0);
      var morph9 = dom.createMorphAt(element7,4,4);
      var morph10 = dom.createMorphAt(element7,6,6);
      var morph11 = dom.createMorphAt(dom.childAt(element8, [1]),0,0);
      var morph12 = dom.createMorphAt(element8,4,4);
      var morph13 = dom.createMorphAt(element8,6,6);
      inline(env, morph0, context, "i18n", ["category.name"], {});
      inline(env, morph1, context, "text-field", [], {"value": get(env, context, "category.name"), "placeholderKey": "category.name_placeholder", "maxlength": "50"});
      inline(env, morph2, context, "i18n", ["category.slug"], {});
      inline(env, morph3, context, "text-field", [], {"value": get(env, context, "category.slug"), "placeholderKey": "category.slug_placeholder", "maxlength": "255"});
      block(env, morph4, context, "if", [get(env, context, "canSelectParentCategory")], {}, child0, null);
      block(env, morph5, context, "if", [get(env, context, "showDescription")], {}, child1, null);
      inline(env, morph6, context, "i18n", ["category.badge_colors"], {});
      content(env, morph7, context, "categoryBadgePreview");
      inline(env, morph8, context, "i18n", ["category.background_color"], {});
      inline(env, morph9, context, "text-field", [], {"value": get(env, context, "category.color"), "placeholderKey": "category.color_placeholder", "maxlength": "6"});
      inline(env, morph10, context, "color-picker", [], {"colors": get(env, context, "backgroundColors"), "usedColors": get(env, context, "usedBackgroundColors"), "value": get(env, context, "category.color")});
      inline(env, morph11, context, "i18n", ["category.foreground_color"], {});
      inline(env, morph12, context, "text-field", [], {"value": get(env, context, "category.text_color"), "placeholderKey": "category.color_placeholder", "maxlength": "6"});
      inline(env, morph13, context, "color-picker", [], {"colors": get(env, context, "foregroundColors"), "value": get(env, context, "category.text_color"), "id": "edit-text-color"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-images"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","field");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","field");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
      var morph1 = dom.createMorphAt(element0,3,3);
      var morph2 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph3 = dom.createMorphAt(element1,3,3);
      inline(env, morph0, context, "i18n", ["category.logo"], {});
      inline(env, morph1, context, "image-uploader", [], {"imageUrl": get(env, context, "category.logo_url"), "type": "category_logo", "class": "no-repeat"});
      inline(env, morph2, context, "i18n", ["category.background_image"], {});
      inline(env, morph3, context, "image-uploader", [], {"imageUrl": get(env, context, "category.background_url"), "type": "category_background"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-panel"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "component", [get(env, context, "customComponent")], {"tab": get(env, context, "tab"), "selectedTab": get(env, context, "selectedTab"), "category": get(env, context, "category")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-security"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","warning");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["category.special_warning"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element2 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element2,0,0);
          element(env, element2, context, "action", ["removePermission", get(env, context, "p")], {});
          inline(env, morph0, context, "fa-icon", ["times-circle"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","name");
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","badge-group");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","permission");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, content = hooks.content, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element3 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element3, [1, 0]),0,0);
        var morph1 = dom.createUnsafeMorphAt(element3,3,3);
        var morph2 = dom.createMorphAt(dom.childAt(element3, [5]),0,0);
        var morph3 = dom.createMorphAt(element3,7,7);
        set(env, context, "p", blockArguments[0]);
        content(env, morph0, context, "p.group_name");
        inline(env, morph1, context, "i18n", ["category.can"], {});
        content(env, morph2, context, "p.permission.description");
        block(env, morph3, context, "if", [get(env, context, "editingPermissions")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-small");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [5]);
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph2 = dom.createMorphAt(element1,0,0);
        inline(env, morph0, context, "combo-box", [], {"content": get(env, context, "category.availableGroups"), "value": get(env, context, "selectedGroup")});
        inline(env, morph1, context, "combo-box", [], {"class": "permission-selector", "nameProperty": "description", "content": get(env, context, "category.availablePermissions"), "value": get(env, context, "selectedPermission")});
        element(env, element1, context, "action", ["addPermission", get(env, context, "selectedGroup"), get(env, context, "selectedPermission")], {});
        inline(env, morph2, context, "i18n", ["category.add_permission"], {});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"class","btn btn-small");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,0,0);
          element(env, element0, context, "action", ["editPermissions"], {});
          inline(env, morph0, context, "i18n", ["category.edit_permissions"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "unless", [get(env, context, "category.is_special")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","field");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("ul");
      dom.setAttribute(el2,"class","permission-list");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element4 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element4,1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element4, [3]),1,1);
      var morph2 = dom.createMorphAt(element4,5,5);
      block(env, morph0, context, "if", [get(env, context, "category.is_special")], {}, child0, null);
      block(env, morph1, context, "each", [get(env, context, "category.permissions")], {}, child1, null);
      block(env, morph2, context, "if", [get(env, context, "editingPermissions")], {}, child2, child3);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-settings"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element3 = dom.childAt(fragment, [1, 1]);
        var element4 = dom.childAt(fragment, [3, 1]);
        var morph0 = dom.createMorphAt(element3,1,1);
        var morph1 = dom.createMorphAt(element3,3,3);
        var morph2 = dom.createMorphAt(element4,1,1);
        var morph3 = dom.createMorphAt(element4,3,3);
        var morph4 = dom.createMorphAt(element4,5,5);
        inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "category.email_in_allow_strangers")});
        inline(env, morph1, context, "i18n", ["category.email_in_allow_strangers"], {});
        inline(env, morph2, context, "fa-icon", ["envelope-o"], {});
        inline(env, morph3, context, "i18n", ["category.email_in"], {});
        inline(env, morph4, context, "text-field", [], {"value": get(env, context, "category.email_in")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element2,1,1);
        var morph1 = dom.createMorphAt(element2,3,3);
        inline(env, morph0, context, "i18n", ["category.position"], {});
        inline(env, morph1, context, "text-field", [], {"value": get(env, context, "category.position"), "class": "position-input"});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","/admin/site_settings/category/email");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element1,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
        inline(env, morph0, context, "i18n", ["category.email_in_disabled"], {});
        inline(env, morph1, context, "i18n", ["category.email_in_disabled_click"], {});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","/admin/site_settings/category/basic");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
        inline(env, morph0, context, "i18n", ["category.position_disabled"], {});
        inline(env, morph1, context, "i18n", ["category.position_disabled_click"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","field");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","field");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","field");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element5 = dom.childAt(fragment, [2, 1]);
      var element6 = dom.childAt(fragment, [4, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      var morph1 = dom.createMorphAt(element5,1,1);
      var morph2 = dom.createMorphAt(element5,3,3);
      var morph3 = dom.createMorphAt(element6,1,1);
      var morph4 = dom.createMorphAt(element6,3,3);
      var morph5 = dom.createMorphAt(fragment,6,6,contextualElement);
      var morph6 = dom.createMorphAt(fragment,8,8,contextualElement);
      var morph7 = dom.createMorphAt(fragment,10,10,contextualElement);
      var morph8 = dom.createMorphAt(fragment,12,12,contextualElement);
      var morph9 = dom.createMorphAt(fragment,14,14,contextualElement);
      inline(env, morph0, context, "auto-close-form", [], {"autoCloseTime": get(env, context, "category.auto_close_hours"), "autoCloseBasedOnLastPost": get(env, context, "category.auto_close_based_on_last_post"), "autoCloseExamples": "", "limited": "true"});
      inline(env, morph1, context, "input", [], {"type": "checkbox", "checked": get(env, context, "category.allow_badges")});
      inline(env, morph2, context, "i18n", ["category.allow_badges_label"], {});
      inline(env, morph3, context, "input", [], {"type": "checkbox", "checked": get(env, context, "category.suppress_from_homepage")});
      inline(env, morph4, context, "i18n", ["category.suppress_from_homepage"], {});
      block(env, morph5, context, "if", [get(env, context, "emailInEnabled")], {}, child0, null);
      block(env, morph6, context, "if", [get(env, context, "showPositionInput")], {}, child1, null);
      block(env, morph7, context, "unless", [get(env, context, "emailInEnabled")], {}, child2, null);
      block(env, morph8, context, "unless", [get(env, context, "showPositionInput")], {}, child3, null);
      inline(env, morph9, context, "plugin-outlet", ["category-custom-settings"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-tab"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"href","");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,0,0);
      element(env, element0, context, "action", ["select"], {});
      content(env, morph0, context, "title");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/edit-category-topic-template"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      inline(env, morph0, context, "i18n", ["category.topic_template"], {});
      inline(env, morph1, context, "d-editor", [], {"value": get(env, context, "category.topic_template")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/emoji-uploader"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("label");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("input");
      dom.setAttribute(el2,"type","file");
      dom.setAttribute(el2,"accept",".png,.gif");
      dom.setAttribute(el2,"style","visibility: hidden; position: absolute;");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [2]);
      var element1 = dom.childAt(element0, [5]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(element0,1,1);
      var morph2 = dom.createMorphAt(element0,3,3);
      var attrMorph0 = dom.createAttrMorph(element0, 'class');
      var attrMorph1 = dom.createAttrMorph(element1, 'disabled');
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "text-field", [], {"name": "name", "placeholderKey": "admin.emoji.name", "value": get(env, context, "name")});
      attribute(env, attrMorph0, element0, "class", concat(env, ["btn btn-primary ", subexpr(env, context, "if", [get(env, context, "addDisabled"), "disabled"], {})]));
      inline(env, morph1, context, "fa-icon", ["plus"], {});
      inline(env, morph2, context, "i18n", ["admin.emoji.add"], {});
      attribute(env, attrMorph1, element1, "disabled", get(env, context, "addDisabled"));
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/featured-topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","last-user-info");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var element1 = dom.childAt(element0, [3]);
        var element2 = dom.childAt(element0, [5]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(element1,0,0);
        var attrMorph0 = dom.createAttrMorph(element1, 'href');
        var morph2 = dom.createMorphAt(element2,0,0);
        var attrMorph1 = dom.createAttrMorph(element2, 'href');
        inline(env, morph0, context, "i18n", ["categories.latest_by"], {});
        attribute(env, attrMorph0, element1, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "topic.lastPosterUrl")], {})]));
        inline(env, morph1, context, "unbound", [get(env, context, "topic.last_poster.username")], {});
        attribute(env, attrMorph1, element2, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "topic.lastPostUrl")], {})]));
        inline(env, morph2, context, "format-age", [get(env, context, "topic.last_posted_at")], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("   \n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"href","");
        dom.setAttribute(el1,"class","last-posted-at");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "format-age", [get(env, context, "topic.last_posted_at")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"class","title");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createUnsafeMorphAt(element3,0,0);
      var attrMorph0 = dom.createAttrMorph(element3, 'href');
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "topic-status", [], {"topic": get(env, context, "topic")});
      attribute(env, attrMorph0, element3, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "topic.lastUnreadUrl")], {})]));
      inline(env, morph1, context, "unbound", [get(env, context, "topic.fancyTitle")], {});
      inline(env, morph2, context, "topic-post-badges", [], {"newPosts": get(env, context, "topic.totalUnread"), "unseen": get(env, context, "topic.unseen"), "url": get(env, context, "topic.lastUnreadUrl")});
      block(env, morph3, context, "if", [get(env, context, "latestTopicOnly")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/flag-action-type"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [3]);
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(element4,0,0);
          var attrMorph0 = dom.createAttrMorph(element4, 'class');
          inline(env, morph0, context, "textarea", [], {"name": "message", "class": "flag-message", "placeholder": get(env, context, "customPlaceholder"), "value": get(env, context, "message")});
          attribute(env, attrMorph0, element4, "class", concat(env, ["custom-message-length ", get(env, context, "customMessageLengthClasses")]));
          content(env, morph1, context, "customMessageLength");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("hr");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h3");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
          inline(env, morph0, context, "i18n", ["flagging.notify_staff"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("h3");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","controls");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","radio");
        var el3 = dom.createElement("input");
        dom.setAttribute(el3,"type","radio");
        dom.setAttribute(el3,"name","post_action_type_index");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode(" ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","description");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element5 = dom.childAt(fragment, [3]);
        var element6 = dom.childAt(element5, [1]);
        var element7 = dom.childAt(element6, [0]);
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var attrMorph0 = dom.createAttrMorph(element7, 'id');
        var morph1 = dom.createUnsafeMorphAt(dom.childAt(element6, [2]),0,0);
        var morph2 = dom.createMorphAt(element5,3,3);
        var morph3 = dom.createMorphAt(fragment,5,5,contextualElement);
        dom.insertBoundary(fragment, null);
        content(env, morph0, context, "formattedName");
        attribute(env, attrMorph0, element7, "id", concat(env, ["radio_", subexpr(env, context, "unbound", [get(env, context, "flag.name_key")], {})]));
        element(env, element7, context, "action", ["changePostActionType", get(env, context, "flag")], {});
        content(env, morph1, context, "flag.description");
        block(env, morph2, context, "if", [get(env, context, "showMessageInput")], {}, child0, null);
        block(env, morph3, context, "if", [get(env, context, "staffFlagsAvailable")], {}, child1, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","description");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "flag.description");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [3]);
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(element0,0,0);
          var attrMorph0 = dom.createAttrMorph(element0, 'class');
          inline(env, morph0, context, "textarea", [], {"name": "message", "class": "flag-message", "placeholder": get(env, context, "customPlaceholder"), "value": get(env, context, "message")});
          attribute(env, attrMorph0, element0, "class", concat(env, ["custom-message-length ", get(env, context, "customMessageLengthClasses")]));
          content(env, morph1, context, "customMessageLength");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","controls");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","radio");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("input");
        dom.setAttribute(el3,"type","radio");
        dom.setAttribute(el3,"name","post_action_type_index");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode(" ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("strong");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var element2 = dom.childAt(element1, [1]);
        var element3 = dom.childAt(element2, [1]);
        var attrMorph0 = dom.createAttrMorph(element3, 'id');
        var morph0 = dom.createMorphAt(dom.childAt(element2, [3]),0,0);
        var morph1 = dom.createMorphAt(element2,5,5);
        var morph2 = dom.createMorphAt(element1,3,3);
        attribute(env, attrMorph0, element3, "id", concat(env, ["radio_", subexpr(env, context, "unbound", [get(env, context, "flag.name_key")], {})]));
        element(env, element3, context, "action", ["changePostActionType", get(env, context, "flag")], {});
        content(env, morph0, context, "formattedName");
        block(env, morph1, context, "if", [get(env, context, "showDescription")], {}, child0, null);
        block(env, morph2, context, "if", [get(env, context, "showMessageInput")], {}, child1, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "isNotifyUser")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/group-post-stream"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "post", blockArguments[0]);
          inline(env, morph0, context, "group-post", [], {"post": get(env, context, "post")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          inline(env, morph0, context, "i18n", [get(env, context, "emptyText")], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","user-stream");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "each", [get(env, context, "posts")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "load-more", [], {"selector": ".user-stream .item", "action": "loadMore"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/group-post"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","title");
          var el2 = dom.createTextNode(", ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
          content(env, morph0, context, "post.user_title");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","name");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
        content(env, morph0, context, "post.user_long_name");
        block(env, morph1, context, "if", [get(env, context, "post.user_title")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","item");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","clearfix info");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("a");
      dom.setAttribute(el3,"class","avatar-link");
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","avatar-wrapper");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","time");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","title");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("a");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","category");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","group-member-info");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      dom.setAttribute(el2,"class","excerpt");
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, content = hooks.content, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [1]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element1, [5, 1]);
      var attrMorph0 = dom.createAttrMorph(element2, 'href');
      var attrMorph1 = dom.createAttrMorph(element2, 'data-user-card');
      var morph0 = dom.createMorphAt(dom.childAt(element2, [0]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
      var morph2 = dom.createUnsafeMorphAt(element3,0,0);
      var attrMorph2 = dom.createAttrMorph(element3, 'href');
      var morph3 = dom.createMorphAt(dom.childAt(element1, [7]),0,0);
      var morph4 = dom.createMorphAt(dom.childAt(element1, [9]),1,1);
      var morph5 = dom.createUnsafeMorphAt(dom.childAt(element0, [3]),1,1);
      attribute(env, attrMorph0, element2, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "post.user.userUrl")], {})]));
      attribute(env, attrMorph1, element2, "data-user-card", concat(env, [subexpr(env, context, "unbound", [get(env, context, "post.user.username")], {})]));
      inline(env, morph0, context, "avatar", [get(env, context, "post.user")], {"imageSize": "large", "extraClasses": "actor", "ignoreTitle": "true"});
      inline(env, morph1, context, "format-date", [get(env, context, "post.created_at")], {"leaveAgo": "true"});
      attribute(env, attrMorph2, element3, "href", get(env, context, "post.url"));
      content(env, morph2, context, "post.topic.fancyTitle");
      inline(env, morph3, context, "category-link", [get(env, context, "post.category")], {});
      block(env, morph4, context, "if", [get(env, context, "post.user_long_name")], {}, child0, null);
      inline(env, morph5, context, "unbound", [get(env, context, "post.cooked")], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/group-selector"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("input");
      dom.setAttribute(el1,"class","ember-text-field group-names");
      dom.setAttribute(el1,"type","text");
      dom.setAttribute(el1,"name","groups");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var attrMorph0 = dom.createAttrMorph(element0, 'placeholder');
      attribute(env, attrMorph0, element0, "placeholder", get(env, context, "placeholder"));
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/image-uploader"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-danger pad-left no-text");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        element(env, element0, context, "action", ["trash"], {});
        inline(env, morph0, context, "fa-icon", ["trash-o"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","uploaded-image-preview input-xxlarge");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","image-upload-controls");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("input");
      dom.setAttribute(el4,"type","file");
      dom.setAttribute(el4,"accept","image/*");
      dom.setAttribute(el4,"style","visibility: hidden; position: absolute;");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode(" ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("%");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, concat = hooks.concat, inline = hooks.inline, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(element3, [3]);
      var element5 = dom.childAt(element2, [5]);
      var attrMorph0 = dom.createAttrMorph(element1, 'style');
      var morph0 = dom.createMorphAt(element3,1,1);
      var attrMorph1 = dom.createAttrMorph(element3, 'class');
      var attrMorph2 = dom.createAttrMorph(element4, 'disabled');
      var morph1 = dom.createMorphAt(element2,3,3);
      var morph2 = dom.createMorphAt(element5,0,0);
      var morph3 = dom.createMorphAt(element5,2,2);
      var attrMorph3 = dom.createAttrMorph(element5, 'class');
      attribute(env, attrMorph0, element1, "style", get(env, context, "backgroundStyle"));
      attribute(env, attrMorph1, element3, "class", concat(env, ["btn pad-left no-text ", subexpr(env, context, "if", [get(env, context, "uploading"), "disabled"], {})]));
      inline(env, morph0, context, "fa-icon", ["picture-o"], {});
      attribute(env, attrMorph2, element4, "disabled", get(env, context, "uploading"));
      block(env, morph1, context, "if", [get(env, context, "backgroundStyle")], {}, child0, null);
      attribute(env, attrMorph3, element5, "class", concat(env, ["btn ", subexpr(env, context, "unless", [get(env, context, "uploading"), "hidden"], {})]));
      inline(env, morph2, context, "i18n", ["upload_selector.uploading"], {});
      content(env, morph3, context, "uploadProgress");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/ip-lookup"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element9 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element9,1,1);
        var morph1 = dom.createMorphAt(element9,2,2);
        element(env, element9, context, "action", ["lookup"], {});
        inline(env, morph0, context, "fa-icon", ["globe"], {});
        inline(env, morph1, context, "i18n", ["admin.user.ip_lookup"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dt");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dd");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "i18n", ["ip_lookup.hostname"], {});
            content(env, morph1, context, "location.hostname");
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"target","_blank");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("br");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element4 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element4,0,0);
            var attrMorph0 = dom.createAttrMorph(element4, 'href');
            var morph1 = dom.createMorphAt(fragment,4,4,contextualElement);
            attribute(env, attrMorph0, element4, "href", concat(env, ["https://maps.google.com/maps?q=", subexpr(env, context, "unbound", [get(env, context, "location.loc")], {})]));
            content(env, morph0, context, "location.loc");
            content(env, morph1, context, "city");
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "i18n", ["ip_lookup.location_not_found"], {});
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dt");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dd");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "i18n", ["ip_lookup.organisation"], {});
            content(env, morph1, context, "location.org");
            return fragment;
          }
        };
      }());
      var child4 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dt");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dd");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "i18n", ["ip_lookup.phone"], {});
            content(env, morph1, context, "location.phone");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dt");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dd");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
          var morph2 = dom.createMorphAt(dom.childAt(fragment, [4]),1,1);
          var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
          var morph4 = dom.createMorphAt(fragment,8,8,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "location.hostname")], {}, child0, null);
          inline(env, morph1, context, "i18n", ["ip_lookup.location"], {});
          block(env, morph2, context, "if", [get(env, context, "location.loc")], {}, child1, child2);
          block(env, morph3, context, "if", [get(env, context, "location.org")], {}, child3, null);
          block(env, morph4, context, "if", [get(env, context, "location.phone")], {}, child4, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "loading-spinner", [], {"size": "small"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"class","btn btn-danger pull-right");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline, get = hooks.get;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element3 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element3,1,1);
          var morph1 = dom.createMorphAt(element3,2,2);
          element(env, element3, context, "action", ["deleteOtherAccounts"], {});
          inline(env, morph0, context, "fa-icon", ["warning"], {});
          inline(env, morph1, context, "i18n", ["ip_lookup.delete_other_accounts"], {"count": get(env, context, "otherAccountsToDelete")});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode(" ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
                var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
                dom.insertBoundary(fragment, null);
                dom.insertBoundary(fragment, 0);
                inline(env, morph0, context, "avatar", [get(env, context, "a")], {"usernamePath": "user.username", "imageSize": "small"});
                content(env, morph1, context, "a.username");
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("tr");
              var el2 = dom.createTextNode("\n                    ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("td");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                    ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("td");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                    ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("td");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                    ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("td");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                    ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("td");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element0 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
              var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
              var morph2 = dom.createMorphAt(dom.childAt(element0, [5]),0,0);
              var morph3 = dom.createMorphAt(dom.childAt(element0, [7]),0,0);
              var morph4 = dom.createMorphAt(dom.childAt(element0, [9]),0,0);
              set(env, context, "a", blockArguments[0]);
              block(env, morph0, context, "link-to", ["adminUser", get(env, context, "a")], {}, child0, null);
              content(env, morph1, context, "a.trustLevel.id");
              content(env, morph2, context, "a.time_read");
              content(env, morph3, context, "a.topics_entered");
              content(env, morph4, context, "a.post_count");
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("dd");
            dom.setAttribute(el1,"class","other-accounts");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("table");
            dom.setAttribute(el2,"class","table table-condensed table-hover");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("thead");
            var el4 = dom.createTextNode("\n                ");
            dom.appendChild(el3, el4);
            var el4 = dom.createElement("tr");
            var el5 = dom.createTextNode("\n                  ");
            dom.appendChild(el4, el5);
            var el5 = dom.createElement("th");
            var el6 = dom.createComment("");
            dom.appendChild(el5, el6);
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                  ");
            dom.appendChild(el4, el5);
            var el5 = dom.createElement("th");
            var el6 = dom.createComment("");
            dom.appendChild(el5, el6);
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                  ");
            dom.appendChild(el4, el5);
            var el5 = dom.createElement("th");
            var el6 = dom.createComment("");
            dom.appendChild(el5, el6);
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                  ");
            dom.appendChild(el4, el5);
            var el5 = dom.createElement("th");
            var el6 = dom.createComment("");
            dom.appendChild(el5, el6);
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                  ");
            dom.appendChild(el4, el5);
            var el5 = dom.createElement("th");
            var el6 = dom.createComment("");
            dom.appendChild(el5, el6);
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                ");
            dom.appendChild(el4, el5);
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("tbody");
            var el4 = dom.createTextNode("\n");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("              ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1, 1]);
            var element2 = dom.childAt(element1, [1, 1]);
            var morph0 = dom.createMorphAt(dom.childAt(element2, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(element2, [3]),0,0);
            var morph2 = dom.createMorphAt(dom.childAt(element2, [5]),0,0);
            var morph3 = dom.createMorphAt(dom.childAt(element2, [7]),0,0);
            var morph4 = dom.createMorphAt(dom.childAt(element2, [9]),0,0);
            var morph5 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
            inline(env, morph0, context, "i18n", ["ip_lookup.username"], {});
            inline(env, morph1, context, "i18n", ["ip_lookup.trust_level"], {});
            inline(env, morph2, context, "i18n", ["ip_lookup.read_time"], {});
            inline(env, morph3, context, "i18n", ["ip_lookup.topics_entered"], {});
            inline(env, morph4, context, "i18n", ["ip_lookup.post_count"], {});
            block(env, morph5, context, "each", [get(env, context, "other_accounts")], {}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "other_accounts.length")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","location-box");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"class","close pull-right");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h4");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("dl");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("dt");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("strong");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element5 = dom.childAt(fragment, [1]);
        var element6 = dom.childAt(element5, [1]);
        var element7 = dom.childAt(element5, [5]);
        var element8 = dom.childAt(element7, [3]);
        var morph0 = dom.createMorphAt(element6,0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element5, [3]),0,0);
        var morph2 = dom.createMorphAt(element7,1,1);
        var morph3 = dom.createMorphAt(element8,1,1);
        var morph4 = dom.createMorphAt(dom.childAt(element8, [3]),0,0);
        var morph5 = dom.createMorphAt(element8,5,5);
        var morph6 = dom.createMorphAt(element7,5,5);
        element(env, element6, context, "action", ["hide"], {});
        inline(env, morph0, context, "fa-icon", ["times"], {});
        inline(env, morph1, context, "i18n", ["ip_lookup.title"], {});
        block(env, morph2, context, "if", [get(env, context, "location")], {}, child0, child1);
        inline(env, morph3, context, "i18n", ["ip_lookup.other_accounts"], {});
        content(env, morph4, context, "totalOthersWithSameIP");
        block(env, morph5, context, "if", [get(env, context, "other_accounts.length")], {}, child2, null);
        block(env, morph6, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "otherAccountsLoading")}, child3, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "ip")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "show")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/json-file-uploader"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","jsfu-shade-container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","jsfu-file");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("input");
      dom.setAttribute(el3,"id","js-file-input");
      dom.setAttribute(el3,"type","file");
      dom.setAttribute(el3,"style","display:none;");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","jsfu-separator");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","jsfu-paste");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","text");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [1]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element0, [7]);
      var attrMorph0 = dom.createAttrMorph(element2, 'accept');
      var morph0 = dom.createMorphAt(element1,3,3);
      var morph1 = dom.createMorphAt(element1,5,5);
      var morph2 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
      var morph3 = dom.createMorphAt(dom.childAt(element0, [5]),1,1);
      var attrMorph1 = dom.createAttrMorph(element3, 'class');
      var morph4 = dom.createMorphAt(dom.childAt(element3, [0]),0,0);
      attribute(env, attrMorph0, element2, "accept", get(env, context, "accept"));
      inline(env, morph0, context, "d-button", [], {"class": "fileSelect", "action": "selectFile", "class": "", "icon": "upload", "label": "upload_selector.select_file"});
      inline(env, morph1, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading"), "size": "small"});
      inline(env, morph2, context, "i18n", ["alternation"], {});
      inline(env, morph3, context, "textarea", [], {"value": get(env, context, "value")});
      attribute(env, attrMorph1, element3, "class", concat(env, ["jsfu-shade ", subexpr(env, context, "if", [get(env, context, "hover"), "", "hidden"], {})]));
      inline(env, morph4, context, "fa-icon", ["upload"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/list-setting"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","input-setting-list");
      var el2 = dom.createTextNode("\n    ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("input");
      dom.setAttribute(el2,"type","text");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var attrMorph0 = dom.createAttrMorph(element0, 'value');
      attribute(env, attrMorph0, element0, "value", concat(env, [subexpr(env, context, "unbound", [get(env, context, "settingValue")], {})]));
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/login-buttons"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        var attrMorph0 = dom.createAttrMorph(element0, 'class');
        set(env, context, "b", blockArguments[0]);
        attribute(env, attrMorph0, element0, "class", concat(env, ["btn btn-social ", get(env, context, "b.name")]));
        element(env, element0, context, "action", ["externalLogin", get(env, context, "b")], {});
        content(env, morph0, context, "b.title");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "buttons")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/mobile-nav"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, 0);
      content(env, morph0, context, "yield");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/nav-item"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            content(env, morph0, context, "i18nLabel");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          block(env, morph0, context, "link-to", [get(env, context, "route"), get(env, context, "routeParam")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "i18n", [get(env, context, "label")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          block(env, morph0, context, "link-to", [get(env, context, "route"), get(env, context, "routeParam")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "i18nLabel")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "i18n", [get(env, context, "label")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          block(env, morph0, context, "link-to", [get(env, context, "route")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"data-auto-route","true");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element1,0,0);
            var attrMorph0 = dom.createAttrMorph(element1, 'href');
            attribute(env, attrMorph0, element1, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "fullPath")], {})]));
            inline(env, morph0, context, "i18n", [get(env, context, "label")], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"data-auto-route","true");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element0,0,0);
            var attrMorph0 = dom.createAttrMorph(element0, 'href');
            attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "href")], {})]));
            inline(env, morph0, context, "i18n", [get(env, context, "label")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "path")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "route")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "routeParam")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/navigation-bar"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "navItem", blockArguments[0]);
        inline(env, morph0, context, "navigation-item", [], {"content": get(env, context, "navItem"), "filterMode": get(env, context, "filterMode")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "navItems")], {}, child0, null);
      inline(env, morph1, context, "custom-html", ["extraNavItem"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/period-chooser"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 0]);
        var morph0 = dom.createMorphAt(element0,0,0);
        set(env, context, "p", blockArguments[0]);
        element(env, element0, context, "action", ["changePeriod", get(env, context, "p")], {});
        inline(env, morph0, context, "period-title", [get(env, context, "p")], {"showDateRange": true});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("h2");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("button");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"id","period-popup");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("ul");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","clearfix");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [4]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      var attrMorph0 = dom.createAttrMorph(element1, 'class');
      var morph2 = dom.createMorphAt(dom.childAt(element1, [1]),1,1);
      inline(env, morph0, context, "period-title", [get(env, context, "period")], {"showDateRange": true});
      inline(env, morph1, context, "fa-icon", ["caret-down"], {});
      attribute(env, attrMorph0, element1, "class", concat(env, [subexpr(env, context, "unless", [get(env, context, "showPeriods"), "hidden"], {}), " period-popup"]));
      block(env, morph2, context, "each", [get(env, context, "site.periods")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/popup-menu"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("h3");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("ul");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      inline(env, morph0, context, "i18n", [get(env, context, "title")], {});
      content(env, morph1, context, "yield");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/preference-checkbox"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      dom.setAttribute(el1,"class","checkbox-label");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,3,3);
      inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "checked")});
      content(env, morph1, context, "label");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/queued-post"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "avatar", [get(env, context, "post.user")], {"imageSize": "large"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "post.user.username");
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("i");
        dom.setAttribute(el1,"class","fa fa-ban");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var attrMorph0 = dom.createAttrMorph(element0, 'title');
        attribute(env, attrMorph0, element0, "title", concat(env, [subexpr(env, context, "i18n", ["user.blocked_tooltip"], {})]));
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "topic-link", [get(env, context, "post.topic")], {});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "post.post_options.title");
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-editor", [], {"value": get(env, context, "buffered.raw")});
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "cook-text", [get(env, context, "post.raw")], {});
        return fragment;
      }
    };
  }());
  var child7 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "confirmEdit", "label": "queue.confirm", "disabled": get(env, context, "post.isSaving"), "class": "btn-primary confirm"});
        inline(env, morph1, context, "d-button", [], {"action": "cancelEdit", "label": "queue.cancel", "icon": "times", "disabled": get(env, context, "post.isSaving"), "class": "btn-danger cancel"});
        return fragment;
      }
    };
  }());
  var child8 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"action": "deleteUser", "disabled": get(env, context, "post.isSaving"), "label": "queue.delete_user", "icon": "trash", "class": "btn-danger delete-user"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
        var morph3 = dom.createMorphAt(fragment,7,7,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "approve", "disabled": get(env, context, "post.isSaving"), "label": "queue.approve", "icon": "check", "class": "btn-primary approve"});
        inline(env, morph1, context, "d-button", [], {"action": "reject", "disabled": get(env, context, "post.isSaving"), "label": "queue.reject", "icon": "times", "class": "btn-danger reject"});
        block(env, morph2, context, "if", [get(env, context, "post.can_delete_user")], {}, child0, null);
        inline(env, morph3, context, "d-button", [], {"action": "edit", "disabled": get(env, context, "post.isSaving"), "label": "queue.edit", "icon": "pencil", "class": "edit"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","queued-post");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","poster");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","cooked");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","names");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("span");
      dom.setAttribute(el4,"class","username");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","post-info");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("span");
      dom.setAttribute(el4,"class","post-date");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","clearfix");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","post-title");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","body");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","queue-controls");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","clearfix");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var element2 = dom.childAt(element1, [3]);
      var element3 = dom.childAt(element2, [1, 1]);
      var element4 = dom.childAt(element2, [7]);
      var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),1,1);
      var morph1 = dom.createMorphAt(element3,1,1);
      var morph2 = dom.createMorphAt(element3,2,2);
      var morph3 = dom.createMorphAt(dom.childAt(element2, [3, 1]),0,0);
      var morph4 = dom.createMorphAt(element4,1,1);
      var morph5 = dom.createMorphAt(element4,3,3);
      var morph6 = dom.createMorphAt(element4,5,5);
      var morph7 = dom.createMorphAt(dom.childAt(element2, [9]),1,1);
      var morph8 = dom.createMorphAt(dom.childAt(element2, [11]),1,1);
      block(env, morph0, context, "user-link", [], {"user": get(env, context, "post.user")}, child0, null);
      block(env, morph1, context, "user-link", [], {"user": get(env, context, "post.user")}, child1, null);
      block(env, morph2, context, "if", [get(env, context, "post.user.blocked")], {}, child2, null);
      inline(env, morph3, context, "age-with-tooltip", [get(env, context, "post.created_at")], {});
      inline(env, morph4, context, "i18n", ["queue.topic"], {});
      block(env, morph5, context, "if", [get(env, context, "post.topic")], {}, child3, child4);
      inline(env, morph6, context, "category-badge", [get(env, context, "post.category")], {});
      block(env, morph7, context, "if", [get(env, context, "editing")], {}, child5, child6);
      block(env, morph8, context, "if", [get(env, context, "editing")], {}, child7, child8);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/share-source"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("i");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var attrMorph0 = dom.createAttrMorph(element0, 'class');
        attribute(env, attrMorph0, element0, "class", concat(env, ["fa ", get(env, context, "source.faIcon")]));
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "source.htmlIcon");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"href","");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element1,1,1);
      var attrMorph0 = dom.createAttrMorph(element1, 'title');
      var attrMorph1 = dom.createAttrMorph(element1, 'aria-label');
      attribute(env, attrMorph0, element1, "title", concat(env, [subexpr(env, context, "unbound", [get(env, context, "source.title")], {})]));
      attribute(env, attrMorph1, element1, "aria-label", concat(env, [subexpr(env, context, "unbound", [get(env, context, "source.title")], {})]));
      element(env, element1, context, "action", ["share", get(env, context, "source")], {});
      block(env, morph0, context, "if", [get(env, context, "source.faIcon")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/signup-cta"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var element3 = dom.childAt(element2, [3]);
        var morph0 = dom.createMorphAt(element2,1,1);
        var morph1 = dom.createMorphAt(element3,0,0);
        inline(env, morph0, context, "i18n", ["signup_cta.hidden_for_session"], {});
        element(env, element3, context, "action", ["neverShow"], {});
        inline(env, morph1, context, "i18n", ["signup_cta.hide_forever"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","buttons");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, subexpr = hooks.subexpr, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [5]);
        var element1 = dom.childAt(element0, [5]);
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
        var morph2 = dom.createMorphAt(element0,1,1);
        var morph3 = dom.createMorphAt(element0,3,3);
        var morph4 = dom.createMorphAt(element1,0,0);
        inline(env, morph0, context, "replace-emoji", [subexpr(env, context, "i18n", ["signup_cta.intro"], {})], {});
        inline(env, morph1, context, "replace-emoji", [subexpr(env, context, "i18n", ["signup_cta.value_prop"], {})], {});
        inline(env, morph2, context, "d-button", [], {"action": "showCreateAccount", "label": "signup_cta.sign_up", "icon": "check", "class": "btn-primary"});
        inline(env, morph3, context, "d-button", [], {"action": "hideForSession", "label": "signup_cta.hide_session", "class": "no-icon"});
        element(env, element1, context, "action", ["neverShow"], {});
        inline(env, morph4, context, "i18n", ["signup_cta.hide_forever"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","signup-cta alert alert-info");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","clearfix");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      block(env, morph0, context, "if", [get(env, context, "session.hideSignupCta")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/small-action"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element1,0,0);
          var attrMorph0 = dom.createAttrMorph(element1, 'title');
          attribute(env, attrMorph0, element1, "title", subexpr(env, context, "i18n", ["post.controls.delete"], {}));
          element(env, element1, context, "action", ["delete"], {});
          inline(env, morph0, context, "fa-icon", ["times"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,0,0);
          var attrMorph0 = dom.createAttrMorph(element0, 'title');
          attribute(env, attrMorph0, element0, "title", subexpr(env, context, "i18n", ["post.controls.edit"], {}));
          element(env, element0, context, "action", ["edit"], {});
          inline(env, morph0, context, "fa-icon", ["pencil"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [3]);
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph2 = dom.createMorphAt(element2,1,1);
        var attrMorph0 = dom.createAttrMorph(element2, 'href');
        var attrMorph1 = dom.createAttrMorph(element2, 'data-user-card');
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "post.can_delete")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "post.can_edit")], {}, child1, null);
        attribute(env, attrMorph0, element2, "href", get(env, context, "post.usernameUrl"));
        attribute(env, attrMorph1, element2, "data-user-card", get(env, context, "post.username"));
        inline(env, morph2, context, "avatar", [get(env, context, "post")], {"imageSize": "small"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","small-action-desc");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      block(env, morph0, context, "if", [get(env, context, "post")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/stream-item"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","excerpt");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        content(env, morph0, context, "actionDescription");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("button");
            dom.setAttribute(el1,"class","btn btn-default remove-bookmark");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element1,1,1);
            var morph1 = dom.createMorphAt(element1,3,3);
            element(env, element1, context, "action", ["removeBookmark", get(env, context, "grandChild")], {});
            inline(env, morph0, context, "fa-icon", ["times"], {});
            inline(env, morph1, context, "i18n", ["bookmarks.remove"], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode(" — ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("span");
              dom.setAttribute(el1,"class","edit-reason");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              content(env, morph0, context, "grandChild.edit_reason");
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"class","avatar-link");
            var el2 = dom.createElement("div");
            dom.setAttribute(el2,"class","avatar-wrapper");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var attrMorph0 = dom.createAttrMorph(element0, 'href');
            var attrMorph1 = dom.createAttrMorph(element0, 'data-user-card');
            var morph0 = dom.createMorphAt(dom.childAt(element0, [0]),0,0);
            var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
            attribute(env, attrMorph0, element0, "href", get(env, context, "grandChild.userUrl"));
            attribute(env, attrMorph1, element0, "data-user-card", get(env, context, "grandChild.username"));
            inline(env, morph0, context, "avatar", [get(env, context, "grandChild")], {"imageSize": "tiny", "extraClasses": "actor", "ignoreTitle": "true", "avatarTemplatePath": "acting_avatar_template"});
            block(env, morph1, context, "if", [get(env, context, "grandChild.edit_reason")], {}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          set(env, context, "grandChild", blockArguments[0]);
          block(env, morph0, context, "if", [get(env, context, "grandChild.removableBookmark")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","child-actions");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("i");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var element3 = dom.childAt(element2, [1]);
        var attrMorph0 = dom.createAttrMorph(element3, 'class');
        var morph0 = dom.createMorphAt(element2,3,3);
        set(env, context, "child", blockArguments[0]);
        attribute(env, attrMorph0, element3, "class", concat(env, ["icon ", get(env, context, "child.icon")]));
        block(env, morph0, context, "each", [get(env, context, "child.items")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","clearfix info");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      dom.setAttribute(el2,"class","avatar-link");
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","avatar-wrapper");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("span");
      dom.setAttribute(el2,"class","time");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("span");
      dom.setAttribute(el2,"class","title");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("a");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","category");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("p");
      dom.setAttribute(el1,"class","excerpt");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, inline = hooks.inline, content = hooks.content, block = hooks.block, concat = hooks.concat;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element4 = dom.childAt(fragment, [0]);
      var element5 = dom.childAt(element4, [1]);
      var element6 = dom.childAt(element4, [7, 1]);
      var element7 = dom.childAt(fragment, [4]);
      var attrMorph0 = dom.createAttrMorph(element5, 'href');
      var attrMorph1 = dom.createAttrMorph(element5, 'data-user-card');
      var morph0 = dom.createMorphAt(dom.childAt(element5, [0]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element4, [3]),0,0);
      var morph2 = dom.createMorphAt(element4,5,5);
      var morph3 = dom.createUnsafeMorphAt(element6,0,0);
      var attrMorph2 = dom.createAttrMorph(element6, 'href');
      var morph4 = dom.createMorphAt(dom.childAt(element4, [9]),0,0);
      var morph5 = dom.createMorphAt(element4,11,11);
      var morph6 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph7 = dom.createUnsafeMorphAt(element7,0,0);
      var attrMorph3 = dom.createAttrMorph(element7, 'data-topic-id');
      var attrMorph4 = dom.createAttrMorph(element7, 'data-post-id');
      var attrMorph5 = dom.createAttrMorph(element7, 'data-user-id');
      var morph8 = dom.createMorphAt(fragment,6,6,contextualElement);
      dom.insertBoundary(fragment, null);
      attribute(env, attrMorph0, element5, "href", get(env, context, "item.userUrl"));
      attribute(env, attrMorph1, element5, "data-user-card", get(env, context, "item.username"));
      inline(env, morph0, context, "avatar", [get(env, context, "item")], {"imageSize": "large", "extraClasses": "actor", "ignoreTitle": "true"});
      inline(env, morph1, context, "format-date", [get(env, context, "item.created_at")], {});
      inline(env, morph2, context, "topic-status", [], {"topic": get(env, context, "item"), "disableActions": true});
      attribute(env, attrMorph2, element6, "href", get(env, context, "item.postUrl"));
      content(env, morph3, context, "item.title");
      inline(env, morph4, context, "category-link", [get(env, context, "item.category")], {});
      inline(env, morph5, context, "plugin-outlet", ["user-stream-item-header"], {});
      block(env, morph6, context, "if", [get(env, context, "actionDescription")], {}, child0, null);
      attribute(env, attrMorph3, element7, "data-topic-id", concat(env, [get(env, context, "item.topic_id")]));
      attribute(env, attrMorph4, element7, "data-post-id", concat(env, [get(env, context, "item.post_id")]));
      attribute(env, attrMorph5, element7, "data-user-id", concat(env, [get(env, context, "item.user_id")]));
      content(env, morph7, context, "item.excerpt");
      block(env, morph8, context, "each", [get(env, context, "item.children")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/tag-drop"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element5 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element5,0,0);
          var attrMorph0 = dom.createAttrMorph(element5, 'class');
          attribute(env, attrMorph0, element5, "class", concat(env, ["badge-category ", get(env, context, "tagClass")]));
          element(env, element5, context, "action", ["expand"], {});
          content(env, morph0, context, "tagId");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element4,0,0);
          var attrMorph0 = dom.createAttrMorph(element4, 'class');
          attribute(env, attrMorph0, element4, "class", concat(env, ["badge-category ", get(env, context, "tagClass"), " home"]));
          element(env, element4, context, "action", ["expand"], {});
          content(env, morph0, context, "allTagsLabel");
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","cat");
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n          ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              set(env, context, "t", blockArguments[0]);
              inline(env, morph0, context, "tag-drop-link", [], {"tagId": get(env, context, "t"), "category": get(env, context, "currentCategory")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "each", [get(env, context, "tags")], {}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          var el2 = dom.createElement("i");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("section");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","cat");
          var el3 = dom.createElement("a");
          dom.setAttribute(el3,"data-drop-close","true");
          dom.setAttribute(el3,"class","badge-category home");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, subexpr = hooks.subexpr, concat = hooks.concat, content = hooks.content, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var element1 = dom.childAt(element0, [0]);
          var element2 = dom.childAt(fragment, [3]);
          var element3 = dom.childAt(element2, [1, 0]);
          var attrMorph0 = dom.createAttrMorph(element0, 'class');
          var attrMorph1 = dom.createAttrMorph(element1, 'class');
          var attrMorph2 = dom.createAttrMorph(element2, 'class');
          var morph0 = dom.createMorphAt(element3,0,0);
          var attrMorph3 = dom.createAttrMorph(element3, 'href');
          var morph1 = dom.createMorphAt(element2,3,3);
          attribute(env, attrMorph0, element0, "class", get(env, context, "dropdownButtonClass"));
          element(env, element0, context, "action", ["expand"], {});
          attribute(env, attrMorph1, element1, "class", get(env, context, "iconClass"));
          attribute(env, attrMorph2, element2, "class", concat(env, [subexpr(env, context, "unless", [get(env, context, "expanded"), "hidden"], {}), " category-dropdown-menu chooser"]));
          attribute(env, attrMorph3, element3, "href", get(env, context, "allTagsUrl"));
          content(env, morph0, context, "allTagsLabel");
          block(env, morph1, context, "if", [get(env, context, "renderTags")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "tagId")], {}, child0, child1);
        block(env, morph1, context, "if", [get(env, context, "tags")], {}, child2, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "showTagDropdown")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/toggle-deleted"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-danger");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [3]);
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(element1,0,0);
        inline(env, morph0, context, "i18n", ["deleted_filter.disabled_description"], {});
        element(env, element1, context, "action", ["toggleDeleted"], {});
        inline(env, morph1, context, "i18n", ["deleted_filter.enable"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-danger");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [3]);
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(element0,0,0);
        inline(env, morph0, context, "i18n", ["deleted_filter.enabled_description"], {});
        element(env, element0, context, "action", ["toggleDeleted"], {});
        inline(env, morph1, context, "i18n", ["deleted_filter.disable"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "postStream.show_deleted")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/top-period-buttons"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "period-title", [get(env, context, "p")], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        set(env, context, "p", blockArguments[0]);
        block(env, morph0, context, "d-button", [], {"action": "changePeriod", "actionParam": get(env, context, "p")}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "periods")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/topic-category"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "bound-category-link", [get(env, context, "topic.category.parentCategory")], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "t", blockArguments[0]);
          inline(env, morph0, context, "discourse-tag", [get(env, context, "t")], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","list-tags");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "each", [get(env, context, "topic.tags")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
      var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
      var morph3 = dom.createMorphAt(fragment,5,5,contextualElement);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "topic.category.parentCategory")], {}, child0, null);
      inline(env, morph1, context, "bound-category-link", [get(env, context, "topic.category")], {"hideParent": true});
      block(env, morph2, context, "if", [get(env, context, "siteSettings.tagging_enabled")], {}, child1, null);
      inline(env, morph3, context, "plugin-outlet", ["topic-category"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/topic-list"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("thead");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        inline(env, morph0, context, "raw", ["topic-list-header"], {"currentUser": get(env, context, "currentUser"), "canBulkSelect": get(env, context, "canBulkSelect"), "toggleInTitle": get(env, context, "toggleInTitle"), "hideCategory": get(env, context, "hideCategory"), "showPosters": get(env, context, "showPosters"), "showLikes": get(env, context, "showLikes"), "showOpLikes": get(env, context, "showOpLikes"), "showParticipants": get(env, context, "showParticipants"), "order": get(env, context, "order"), "ascending": get(env, context, "ascending"), "sortable": get(env, context, "sortable"), "bulkSelectEnabled": get(env, context, "bulkSelectEnabled")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "topic", blockArguments[0]);
        inline(env, morph0, context, "topic-list-item", [], {"topic": get(env, context, "topic"), "bulkSelectEnabled": get(env, context, "bulkSelectEnabled"), "showTopicPostBadges": get(env, context, "showTopicPostBadges"), "hideCategory": get(env, context, "hideCategory"), "showPosters": get(env, context, "showPosters"), "showParticipants": get(env, context, "showParticipants"), "showLikes": get(env, context, "showLikes"), "showOpLikes": get(env, context, "showOpLikes"), "expandGloballyPinned": get(env, context, "expandGloballyPinned"), "expandAllPinned": get(env, context, "expandAllPinned"), "selected": get(env, context, "selected")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("tbody");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "unless", [get(env, context, "skipHeader")], {}, child0, null);
      block(env, morph1, context, "each", [get(env, context, "topics")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/track-selected"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "selected")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-badge"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","count");
          var el2 = dom.createTextNode("(× ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(")");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          content(env, morph0, context, "count");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "showGrantCount")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var attrMorph0 = dom.createAttrMorph(element0, 'href');
      attribute(env, attrMorph0, element0, "href", concat(env, [get(env, context, "badgeUrl")]));
      block(env, morph0, context, "badge-button", [], {"badge": get(env, context, "badge")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-fields/confirm"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","controls");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode(" ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var morph0 = dom.createMorphAt(element0,0,0);
      var morph1 = dom.createUnsafeMorphAt(element0,2,2);
      inline(env, morph0, context, "input", [], {"checked": get(env, context, "value"), "type": "checkbox"});
      content(env, morph1, context, "field.description");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-fields/dropdown"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","required");
        var el2 = dom.createTextNode("*");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","controls");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [2]);
      var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(element0,1,1);
      var morph2 = dom.createMorphAt(element0,3,3);
      var morph3 = dom.createUnsafeMorphAt(dom.childAt(element0, [5]),0,0);
      content(env, morph0, context, "field.name");
      inline(env, morph1, context, "combo-box", [], {"content": get(env, context, "field.options"), "value": get(env, context, "value"), "none": get(env, context, "noneLabel")});
      block(env, morph2, context, "if", [get(env, context, "field.required")], {}, child0, null);
      content(env, morph3, context, "field.description");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-fields/text"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","required");
        var el2 = dom.createTextNode("*");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","controls");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [2]);
      var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(element0,1,1);
      var morph2 = dom.createMorphAt(element0,3,3);
      var morph3 = dom.createUnsafeMorphAt(dom.childAt(element0, [5]),0,0);
      content(env, morph0, context, "field.name");
      inline(env, morph1, context, "input", [], {"value": get(env, context, "value"), "maxlength": get(env, context, "site.user_field_max_length")});
      block(env, morph2, context, "if", [get(env, context, "field.required")], {}, child0, null);
      content(env, morph3, context, "field.description");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-info"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","details");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        content(env, morph0, context, "yield");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","user-image");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","user-detail");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","name-line");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","username");
      var el4 = dom.createElement("a");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","name");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","title");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var element1 = dom.childAt(fragment, [2]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element2, [1, 0]);
      var morph0 = dom.createMorphAt(element0,0,0);
      var attrMorph0 = dom.createAttrMorph(element0, 'href');
      var attrMorph1 = dom.createAttrMorph(element0, 'data-user-card');
      var morph1 = dom.createMorphAt(element3,0,0);
      var attrMorph2 = dom.createAttrMorph(element3, 'href');
      var attrMorph3 = dom.createAttrMorph(element3, 'data-user-card');
      var morph2 = dom.createMorphAt(dom.childAt(element2, [3]),0,0);
      var morph3 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
      var morph4 = dom.createMorphAt(element1,5,5);
      attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "userPath")], {})]));
      attribute(env, attrMorph1, element0, "data-user-card", concat(env, [subexpr(env, context, "unbound", [get(env, context, "user.username")], {})]));
      inline(env, morph0, context, "avatar", [get(env, context, "user")], {"imageSize": "large"});
      attribute(env, attrMorph2, element3, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "userPath")], {})]));
      attribute(env, attrMorph3, element3, "data-user-card", concat(env, [subexpr(env, context, "unbound", [get(env, context, "user.username")], {})]));
      inline(env, morph1, context, "unbound", [get(env, context, "user.username")], {});
      inline(env, morph2, context, "unbound", [get(env, context, "name")], {});
      inline(env, morph3, context, "unbound", [get(env, context, "user.title")], {});
      block(env, morph4, context, "if", [get(env, context, "hasBlock")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["components/user-stat"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "fa-icon", [get(env, context, "icon")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("span");
      dom.setAttribute(el1,"class","value");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("span");
      dom.setAttribute(el1,"class","label");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,3,3);
      var morph2 = dom.createUnsafeMorphAt(dom.childAt(fragment, [2]),0,0);
      block(env, morph0, context, "if", [get(env, context, "icon")], {}, child0, null);
      inline(env, morph1, context, "number", [get(env, context, "value")], {});
      inline(env, morph2, context, "i18n", [get(env, context, "label")], {"count": get(env, context, "value")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["composer"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            inline(env, morph0, context, "d-button", [], {"action": "toggleWhisper", "icon": "eye-slash", "label": "composer.toggle_whisper"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "popup-menu", [], {"visible": get(env, context, "optionsVisible"), "hide": "hideOptions", "title": "composer.options"}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          dom.setAttribute(el1,"class","toggle-toolbar");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element13 = dom.childAt(fragment, [1]);
          element(env, element13, context, "action", ["toggleToolbar"], {"bubbles": false});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("span");
              dom.setAttribute(el1,"class","whisper");
              var el2 = dom.createTextNode("(");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode(")");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              inline(env, morph0, context, "i18n", ["composer.whisper"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "model.whisper")], {}, child0, null);
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","edit-reason-input");
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              inline(env, morph0, context, "text-field", [], {"value": get(env, context, "editReason"), "tabindex": "7", "id": "edit-reason", "maxlength": "255", "placeholderKey": "composer.edit_reason_placeholder"});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("a");
              dom.setAttribute(el1,"class","display-edit-reason");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element9 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(element9,0,0);
              element(env, element9, context, "action", ["displayEditReason"], {});
              inline(env, morph0, context, "i18n", ["composer.show_edit_reason"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "showEditReason")], {}, child0, child1);
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                  ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("div");
                dom.setAttribute(el1,"class","add-warning");
                var el2 = dom.createTextNode("\n                    ");
                dom.appendChild(el1, el2);
                var el2 = dom.createElement("label");
                var el3 = dom.createTextNode("\n                      ");
                dom.appendChild(el2, el3);
                var el3 = dom.createComment("");
                dom.appendChild(el2, el3);
                var el3 = dom.createTextNode("\n                      ");
                dom.appendChild(el2, el3);
                var el3 = dom.createComment("");
                dom.appendChild(el2, el3);
                var el3 = dom.createTextNode("\n                    ");
                dom.appendChild(el2, el3);
                dom.appendChild(el1, el2);
                var el2 = dom.createTextNode("\n                  ");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element7 = dom.childAt(fragment, [1, 1]);
                var morph0 = dom.createMorphAt(element7,1,1);
                var morph1 = dom.createMorphAt(element7,3,3);
                inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "model.isWarning"), "tabindex": "3"});
                inline(env, morph1, context, "i18n", ["composer.add_warning"], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
              dom.insertBoundary(fragment, null);
              inline(env, morph0, context, "user-selector", [], {"topicId": get(env, context, "topicModel.id"), "excludeCurrentUser": "true", "id": "private-message-users", "includeMentionableGroups": "true", "class": "span8", "placeholderKey": "composer.users_placeholder", "tabindex": "1", "usernames": get(env, context, "model.targetUsernames"), "hasGroups": get(env, context, "model.hasTargetGroups")});
              block(env, morph1, context, "if", [get(env, context, "showWarning")], {}, child0, null);
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                  ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("button");
                dom.setAttribute(el1,"class","btn");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element5 = dom.childAt(fragment, [1]);
                var morph0 = dom.createMorphAt(element5,0,0);
                element(env, element5, context, "action", ["showOptions"], {});
                inline(env, morph0, context, "i18n", ["topic.options"], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","category-input");
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element6 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(element6,1,1);
              var morph1 = dom.createMorphAt(element6,3,3);
              var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
              var morph3 = dom.createMorphAt(fragment,5,5,contextualElement);
              inline(env, morph0, context, "category-chooser", [], {"valueAttribute": "id", "value": get(env, context, "model.categoryId"), "scopedCategoryId": get(env, context, "scopedCategoryId"), "tabindex": "3"});
              inline(env, morph1, context, "popup-input-tip", [], {"validation": get(env, context, "categoryValidation")});
              block(env, morph2, context, "if", [get(env, context, "model.archetype.hasOptions")], {}, child0, null);
              inline(env, morph3, context, "render", ["additional-composer-buttons", get(env, context, "model")], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","form-element clearfix");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n              ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("            ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element8 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element8,1,1);
            var morph1 = dom.createMorphAt(element8,3,3);
            var morph2 = dom.createMorphAt(element8,5,5);
            block(env, morph0, context, "if", [get(env, context, "model.creatingPrivateMessage")], {}, child0, null);
            inline(env, morph1, context, "composer-title", [], {"composer": get(env, context, "model"), "lastValidatedAt": get(env, context, "lastValidatedAt")});
            block(env, morph2, context, "if", [get(env, context, "model.showCategoryChooser")], {}, child1, null);
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "tag-chooser", [], {"tags": get(env, context, "model.tags"), "tabIndex": "4"});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("            ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("span");
                dom.setAttribute(el1,"class","whisper");
                var el2 = dom.createElement("i");
                dom.setAttribute(el2,"class","fa fa-eye-slash");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              block(env, morph0, context, "if", [get(env, context, "model.whisper")], {}, child0, null);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","submit-panel");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("button");
            dom.setAttribute(el2,"tabindex","5");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("a");
            dom.setAttribute(el2,"href","");
            dom.setAttribute(el2,"class","cancel");
            dom.setAttribute(el2,"tabindex","6");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element2 = dom.childAt(fragment, [1]);
            var element3 = dom.childAt(element2, [5]);
            var element4 = dom.childAt(element2, [7]);
            var morph0 = dom.createMorphAt(element2,1,1);
            var morph1 = dom.createMorphAt(element2,3,3);
            var morph2 = dom.createUnsafeMorphAt(element3,0,0);
            var morph3 = dom.createMorphAt(element3,1,1);
            var attrMorph0 = dom.createAttrMorph(element3, 'class');
            var attrMorph1 = dom.createAttrMorph(element3, 'title');
            var morph4 = dom.createMorphAt(element4,0,0);
            var morph5 = dom.createMorphAt(element2,9,9);
            inline(env, morph0, context, "plugin-outlet", ["composer-fields-below"], {});
            block(env, morph1, context, "if", [get(env, context, "canEditTags")], {}, child0, null);
            attribute(env, attrMorph0, element3, "class", concat(env, ["btn btn-primary create ", subexpr(env, context, "if", [get(env, context, "disableSubmit"), "disabled"], {})]));
            attribute(env, attrMorph1, element3, "title", concat(env, [subexpr(env, context, "i18n", ["composer.title"], {})]));
            element(env, element3, context, "action", ["save"], {});
            content(env, morph2, context, "model.saveIcon");
            content(env, morph3, context, "model.saveText");
            element(env, element4, context, "action", ["cancel"], {});
            inline(env, morph4, context, "i18n", ["cancel"], {});
            block(env, morph5, context, "if", [get(env, context, "site.mobileView")], {}, child1, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","control-row reply-area");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","composer-fields");
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","reply-to");
          var el4 = dom.createTextNode("\n            ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, content = hooks.content, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element10 = dom.childAt(fragment, [1]);
          var element11 = dom.childAt(element10, [1]);
          var element12 = dom.childAt(element11, [3]);
          var morph0 = dom.createMorphAt(element11,1,1);
          var morph1 = dom.createUnsafeMorphAt(element12,1,1);
          var morph2 = dom.createMorphAt(element12,3,3);
          var morph3 = dom.createMorphAt(element12,5,5);
          var morph4 = dom.createMorphAt(element11,5,5);
          var morph5 = dom.createMorphAt(element11,7,7);
          var morph6 = dom.createMorphAt(element10,3,3);
          var morph7 = dom.createMorphAt(element10,5,5);
          inline(env, morph0, context, "plugin-outlet", ["composer-open"], {});
          content(env, morph1, context, "model.actionTitle");
          block(env, morph2, context, "unless", [get(env, context, "site.mobileView")], {}, child0, null);
          block(env, morph3, context, "if", [get(env, context, "canEdit")], {}, child1, null);
          block(env, morph4, context, "if", [get(env, context, "model.canEditTitle")], {}, child2, null);
          inline(env, morph5, context, "plugin-outlet", ["composer-fields"], {});
          inline(env, morph6, context, "composer-editor", [], {"topic": get(env, context, "topic"), "composer": get(env, context, "model"), "lastValidatedAt": get(env, context, "lastValidatedAt"), "canWhisper": get(env, context, "canWhisper"), "draftStatus": get(env, context, "model.draftStatus"), "isUploading": get(env, context, "isUploading"), "groupsMentioned": "groupsMentioned", "importQuote": "importQuote", "showOptions": "showOptions", "showToolbar": get(env, context, "showToolbar"), "showUploadSelector": "showUploadSelector"});
          block(env, morph7, context, "if", [get(env, context, "currentUser")], {}, child3, null);
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode(" ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"class","permalink");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [3]);
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(element0,0,0);
            var attrMorph0 = dom.createAttrMorph(element0, 'href');
            inline(env, morph0, context, "i18n", ["composer.saved"], {});
            attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "createdPost.url")], {})]));
            element(env, element0, context, "action", ["viewNewReply"], {});
            inline(env, morph1, context, "i18n", ["composer.view_new_post"], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode(" ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
            inline(env, morph0, context, "i18n", ["composer.saving"], {});
            inline(env, morph1, context, "loading-spinner", [], {"size": "small"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","row");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","span24");
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","saving-text");
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","draft-text");
          var el4 = dom.createTextNode("\n            ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1, 1]);
          var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),1,1);
          var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
          block(env, morph0, context, "if", [get(env, context, "model.createdPost")], {}, child0, child1);
          inline(env, morph1, context, "i18n", ["composer.saved_draft"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","contents");
        var el2 = dom.createTextNode("\n\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","control");
        var el3 = dom.createTextNode("\n\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("    ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("a");
        dom.setAttribute(el3,"href","");
        dom.setAttribute(el3,"class","toggler");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n  ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, subexpr = hooks.subexpr, attribute = hooks.attribute, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element14 = dom.childAt(fragment, [0]);
        var element15 = dom.childAt(element14, [5]);
        var element16 = dom.childAt(element15, [3]);
        var morph0 = dom.createMorphAt(element14,1,1);
        var morph1 = dom.createMorphAt(element14,3,3);
        var morph2 = dom.createMorphAt(element15,1,1);
        var attrMorph0 = dom.createAttrMorph(element16, 'title');
        var morph3 = dom.createMorphAt(element15,5,5);
        block(env, morph0, context, "if", [get(env, context, "currentUser.staff")], {}, child0, null);
        inline(env, morph1, context, "render", ["composer-messages"], {});
        block(env, morph2, context, "if", [get(env, context, "site.mobileView")], {}, child1, null);
        attribute(env, attrMorph0, element16, "title", subexpr(env, context, "i18n", ["composer.toggler"], {}));
        element(env, element16, context, "action", ["toggle"], {"bubbles": false});
        block(env, morph3, context, "if", [get(env, context, "model.viewOpen")], {}, child2, child3);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "visible")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["composer/education"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"href","");
      dom.setAttribute(el1,"class","close");
      var el2 = dom.createElement("i");
      dom.setAttribute(el2,"class","fa fa-times-circle");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, element = hooks.element, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createUnsafeMorphAt(fragment,2,2,contextualElement);
      element(env, element0, context, "action", ["closeMessage", get(env, context, "this")], {});
      content(env, morph0, context, "body");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["composer/group-mentioned"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"href","");
      dom.setAttribute(el1,"class","close");
      var el2 = dom.createElement("i");
      dom.setAttribute(el2,"class","fa fa-times-circle");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, element = hooks.element, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createUnsafeMorphAt(fragment,2,2,contextualElement);
      element(env, element0, context, "action", ["closeMessage", get(env, context, "this")], {});
      content(env, morph0, context, "body");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["composer/similar-topics"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("a");
      dom.setAttribute(el1,"href","");
      dom.setAttribute(el1,"class","close");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("h3");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("ul");
      dom.setAttribute(el1,"class","topics");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline, subexpr = hooks.subexpr;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,0,0);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [4]),1,1);
      element(env, element0, context, "action", ["closeMessage", get(env, context, "this")], {});
      inline(env, morph0, context, "fa-icon", ["times-circle"], {});
      inline(env, morph1, context, "i18n", ["composer.similar_topics"], {});
      inline(env, morph2, context, "mount-widget", [], {"widget": "search-result-topic", "args": subexpr(env, context, "as-hash", [], {"results": get(env, context, "similarTopics")})});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["discovery"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","list-controls");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","container");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","row");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","full-width");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"id","header-list-area");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","row");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","full-width");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"id","list-area");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [6]);
      var element1 = dom.childAt(element0, [3, 1, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2, 1]),1,1);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var attrMorph0 = dom.createAttrMorph(element0, 'class');
      var morph3 = dom.createMorphAt(dom.childAt(element0, [1, 1, 1]),1,1);
      var morph4 = dom.createMorphAt(element1,1,1);
      var morph5 = dom.createMorphAt(element1,3,3);
      var morph6 = dom.createMorphAt(fragment,8,8,contextualElement);
      inline(env, morph0, context, "discourse-banner", [], {"user": get(env, context, "currentUser"), "banner": get(env, context, "site.banner")});
      inline(env, morph1, context, "outlet", ["navigation-bar"], {});
      inline(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")});
      attribute(env, attrMorph0, element0, "class", concat(env, ["container list-container ", subexpr(env, context, "if", [get(env, context, "loading"), "hidden"], {})]));
      inline(env, morph3, context, "outlet", ["header-list-container"], {});
      inline(env, morph4, context, "plugin-outlet", ["discovery-list-container-top"], {});
      inline(env, morph5, context, "outlet", ["list-container"], {});
      inline(env, morph6, context, "plugin-outlet", ["discovery-below"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["discovery/categories"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "category-logo-link", [], {"category": get(env, context, "c")});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 1,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                    ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                    ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement, blockArguments) {
                var dom = env.dom;
                var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
                set(env, context, "s", blockArguments[0]);
                inline(env, morph0, context, "category-link", [get(env, context, "s")], {"hideParent": "true"});
                inline(env, morph1, context, "category-unread", [], {"category": get(env, context, "s")});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","subcategories");
              var el2 = dom.createTextNode("\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              block(env, morph0, context, "each", [get(env, context, "c.subcategories")], {}, child0, null);
              return fragment;
            }
          };
        }());
        var child2 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              set(env, context, "f", blockArguments[0]);
              inline(env, morph0, context, "featured-topic", [], {"topic": get(env, context, "f"), "latestTopicOnly": get(env, context, "latestTopicOnly"), "action": "showTopicEntrance"});
              return fragment;
            }
          };
        }());
        var child3 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("tr");
              var el2 = dom.createTextNode("\n                    ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("td");
              dom.setAttribute(el2,"class","value");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                    ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("td");
              dom.setAttribute(el2,"class","unit");
              var el3 = dom.createTextNode(" / ");
              dom.appendChild(el2, el3);
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element0 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
              var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
              set(env, context, "s", blockArguments[0]);
              content(env, morph0, context, "s.value");
              content(env, morph1, context, "s.unit");
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"class","category");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            var el4 = dom.createTextNode("\n                ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n                ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n                ");
            dom.appendChild(el3, el4);
            var el4 = dom.createElement("div");
            dom.setAttribute(el4,"class","category-description");
            var el5 = dom.createTextNode("\n                  ");
            dom.appendChild(el4, el5);
            var el5 = dom.createComment("");
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                ");
            dom.appendChild(el4, el5);
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n                ");
            dom.appendChild(el3, el4);
            var el4 = dom.createElement("div");
            dom.setAttribute(el4,"class","clearfix");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"class","stats");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("table");
            dom.setAttribute(el3,"class","categoryStats");
            var el4 = dom.createTextNode("\n                ");
            dom.appendChild(el3, el4);
            var el4 = dom.createElement("tbody");
            var el5 = dom.createTextNode("\n");
            dom.appendChild(el4, el5);
            var el5 = dom.createComment("");
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("                ");
            dom.appendChild(el4, el5);
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var element2 = dom.childAt(element1, [1]);
            var element3 = dom.childAt(element2, [1]);
            var element4 = dom.childAt(element1, [3]);
            var element5 = dom.childAt(element1, [5]);
            var attrMorph0 = dom.createAttrMorph(element1, 'data-category_id');
            var attrMorph1 = dom.createAttrMorph(element1, 'class');
            var attrMorph2 = dom.createAttrMorph(element2, 'style');
            var morph0 = dom.createMorphAt(element3,1,1);
            var morph1 = dom.createMorphAt(element3,3,3);
            var morph2 = dom.createMorphAt(element3,5,5);
            var morph3 = dom.createUnsafeMorphAt(dom.childAt(element3, [7]),1,1);
            var morph4 = dom.createMorphAt(element2,3,3);
            var morph5 = dom.createMorphAt(element4,1,1);
            var attrMorph3 = dom.createAttrMorph(element4, 'class');
            var attrMorph4 = dom.createAttrMorph(element5, 'title');
            var morph6 = dom.createMorphAt(dom.childAt(element5, [1, 1]),1,1);
            set(env, context, "c", blockArguments[0]);
            attribute(env, attrMorph0, element1, "data-category_id", concat(env, [subexpr(env, context, "unbound", [get(env, context, "c.id")], {})]));
            attribute(env, attrMorph1, element1, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "c.description_excerpt"), "has-description", "no-description"], {}), " ", subexpr(env, context, "if", [get(env, context, "c.logo_url"), "has-logo", "no-logo"], {})]));
            attribute(env, attrMorph2, element2, "style", subexpr(env, context, "border-color", [get(env, context, "c.color")], {}));
            inline(env, morph0, context, "category-title-link", [], {"category": get(env, context, "c")});
            inline(env, morph1, context, "category-unread", [], {"category": get(env, context, "c")});
            block(env, morph2, context, "if", [get(env, context, "c.logo_url")], {}, child0, null);
            content(env, morph3, context, "c.description_excerpt");
            block(env, morph4, context, "if", [get(env, context, "c.subcategories")], {}, child1, null);
            attribute(env, attrMorph3, element4, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "c.archived"), "archived"], {}), " latest"]));
            block(env, morph5, context, "each", [get(env, context, "c.featuredTopics")], {}, child2, null);
            attribute(env, attrMorph4, element5, "title", get(env, context, "c.topicStatsTitle"));
            block(env, morph6, context, "each", [get(env, context, "c.topicCountStats")], {}, child3, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("table");
          dom.setAttribute(el1,"class","topic-list categories");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("thead");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("tr");
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("th");
          dom.setAttribute(el4,"class","category");
          var el5 = dom.createComment("");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("th");
          dom.setAttribute(el4,"class","latest");
          var el5 = dom.createComment("");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("th");
          dom.setAttribute(el4,"class","stats topics");
          var el5 = dom.createComment("");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("tbody");
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element6 = dom.childAt(fragment, [1]);
          var element7 = dom.childAt(element6, [1, 1]);
          var morph0 = dom.createMorphAt(dom.childAt(element7, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(element7, [3]),0,0);
          var morph2 = dom.createMorphAt(dom.childAt(element7, [5]),0,0);
          var morph3 = dom.createMorphAt(dom.childAt(element6, [3]),1,1);
          inline(env, morph0, context, "i18n", ["categories.category"], {});
          inline(env, morph1, context, "i18n", ["categories.latest"], {});
          inline(env, morph2, context, "i18n", ["categories.topics"], {});
          block(env, morph3, context, "each", [get(env, context, "model.categories")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("footer");
        dom.setAttribute(el1,"class","topic-list-bottom");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "discovery-categories", [], {"refresh": "refresh"}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "model.categories")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["discovery/topics"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","alert alert-info");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        content(env, morph0, context, "redirectedReason");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","dismiss-topics-top");
          dom.setAttribute(el1,"class","btn dismiss-read");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element9 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element9,0,0);
          var attrMorph0 = dom.createAttrMorph(element9, 'title');
          attribute(env, attrMorph0, element9, "title", concat(env, [subexpr(env, context, "i18n", ["topics.bulk.dismiss_tooltip"], {})]));
          element(env, element9, context, "action", ["dismissReadPosts"], {});
          inline(env, morph0, context, "i18n", ["topics.bulk.dismiss_button"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","dismiss-new-top");
          dom.setAttribute(el1,"class","btn dismiss-read");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element8 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element8,0,0);
          element(env, element8, context, "action", ["resetNew"], {});
          inline(env, morph0, context, "i18n", ["topics.bulk.dismiss_new"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","row");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element10 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element10,1,1);
        var morph1 = dom.createMorphAt(element10,2,2);
        block(env, morph0, context, "if", [get(env, context, "showDismissRead")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "showResetNew")], {}, child1, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","top-lists");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "period-chooser", [], {"period": get(env, context, "period"), "action": "changePeriod"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("div");
            dom.setAttribute(el2,"class","alert alert-info clickable");
            var el3 = dom.createTextNode("\n          ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n          ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n        ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element6 = dom.childAt(fragment, [1]);
            var element7 = dom.childAt(element6, [1]);
            var attrMorph0 = dom.createAttrMorph(element6, 'class');
            var morph0 = dom.createMorphAt(element7,1,1);
            var morph1 = dom.createMorphAt(element7,3,3);
            attribute(env, attrMorph0, element6, "class", concat(env, ["show-more ", subexpr(env, context, "if", [get(env, context, "hasTopics"), "has-topics"], {})]));
            element(env, element7, context, "action", ["showInserted"], {});
            inline(env, morph0, context, "count-i18n", [], {"key": "topic_count_", "suffix": get(env, context, "topicTrackingState.filter"), "count": get(env, context, "topicTrackingState.incomingCount")});
            inline(env, morph1, context, "i18n", ["click_to_show"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "topicTrackingState.hasIncoming")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "topic-list", [], {"showTopicPostBadges": get(env, context, "showTopicPostBadges"), "showPosters": true, "currentUser": get(env, context, "currentUser"), "canBulkSelect": get(env, context, "canBulkSelect"), "changeSort": "changeSort", "toggleBulkSelect": "toggleBulkSelect", "hideCategory": get(env, context, "model.hideCategory"), "order": get(env, context, "order"), "ascending": get(env, context, "ascending"), "bulkSelectEnabled": get(env, context, "bulkSelectEnabled"), "selected": get(env, context, "selected"), "expandGloballyPinned": get(env, context, "expandGloballyPinned"), "expandAllPinned": get(env, context, "expandAllPinned"), "topics": get(env, context, "model.topics")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "top")], {}, child0, child1);
        block(env, morph1, context, "if", [get(env, context, "hasTopics")], {}, child2, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","dismiss-topics");
          dom.setAttribute(el1,"class","btn dismiss-read");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element5 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element5,0,0);
          var attrMorph0 = dom.createAttrMorph(element5, 'title');
          attribute(env, attrMorph0, element5, "title", concat(env, [subexpr(env, context, "i18n", ["topics.bulk.dismiss_tooltip"], {})]));
          element(env, element5, context, "action", ["dismissReadPosts"], {});
          inline(env, morph0, context, "i18n", ["topics.bulk.dismiss_button"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","dismiss-new");
          dom.setAttribute(el1,"class","btn dismiss-read");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element4,0,0);
          element(env, element4, context, "action", ["resetNew"], {});
          inline(env, morph0, context, "i18n", ["topics.bulk.dismiss_new"], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"href","");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element2 = dom.childAt(fragment, [0]);
            var morph0 = dom.createMorphAt(element2,0,0);
            element(env, element2, context, "action", ["createTopic"], {});
            inline(env, morph0, context, "i18n", ["topic.suggest_create_topic"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","education");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h3");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element3 = dom.childAt(fragment, [3]);
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),1,1);
          var morph1 = dom.createMorphAt(element3,1,1);
          var morph2 = dom.createMorphAt(element3,3,3);
          content(env, morph0, context, "footerEducation");
          content(env, morph1, context, "footerMessage");
          block(env, morph2, context, "if", [get(env, context, "canCreateTopicOnCategory")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "i18n", ["topic.browse_all_categories"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "i18n", ["topic.view_latest_topics"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h3");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(", ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, block = hooks.block, inline = hooks.inline, get = hooks.get;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element1,1,1);
            var morph1 = dom.createMorphAt(element1,3,3);
            var morph2 = dom.createMorphAt(element1,5,5);
            var morph3 = dom.createMorphAt(element1,7,7);
            var morph4 = dom.createMorphAt(element1,9,9);
            block(env, morph0, context, "link-to", ["discovery.categories"], {}, child0, null);
            block(env, morph1, context, "link-to", ["discovery.latest"], {}, child1, null);
            inline(env, morph2, context, "i18n", ["or"], {});
            inline(env, morph3, context, "i18n", ["filters.top.other_periods"], {});
            inline(env, morph4, context, "top-period-buttons", [], {"period": get(env, context, "period"), "action": "changePeriod"});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode(" ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              dom.insertBoundary(fragment, null);
              inline(env, morph0, context, "i18n", ["topic.browse_all_categories"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "i18n", ["topic.view_latest_topics"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","education");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h3");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [3]);
            var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),1,1);
            var morph1 = dom.createMorphAt(element0,1,1);
            var morph2 = dom.createMorphAt(element0,2,2);
            var morph3 = dom.createMorphAt(element0,4,4);
            var morph4 = dom.createMorphAt(element0,6,6);
            content(env, morph0, context, "footerEducation");
            content(env, morph1, context, "footerMessage");
            block(env, morph2, context, "link-to", ["discovery.categories"], {}, child0, null);
            inline(env, morph3, context, "i18n", ["or"], {});
            block(env, morph4, context, "link-to", ["discovery.latest"], {}, child1, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "top")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "showDismissRead")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "showResetNew")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "latest")], {}, child2, child3);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("footer");
      dom.setAttribute(el1,"class","topic-list-bottom");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element11 = dom.childAt(fragment, [8]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      var morph4 = dom.createMorphAt(element11,1,1);
      var morph5 = dom.createMorphAt(element11,3,3);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "redirectedReason")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "showDismissAtTop")], {}, child1, null);
      inline(env, morph2, context, "bulk-select-button", [], {"selected": get(env, context, "selected"), "action": "refresh"});
      block(env, morph3, context, "discovery-topics-list", [], {"model": get(env, context, "model"), "refresh": "refresh", "incomingCount": get(env, context, "topicTrackingState.incomingCount")}, child2, null);
      inline(env, morph4, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.loadingMore")});
      block(env, morph5, context, "if", [get(env, context, "allLoaded")], {}, child3, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["emoji-selector-autocomplete.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "      <li>\n        <a href>\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"option.src",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(2, data, 0),"inverse":container.program(4, data, 0),"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "        </a>\n      </li>\n";
},"2":function(container,depth0,helpers,partials,data) {
    return "            <img src="
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"option.src",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + " class='emoji'>\n            <span class='emoji-shortname'>"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"option.code",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</span>\n";
},"4":function(container,depth0,helpers,partials,data) {
    return "            "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"option.label",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<div class='autocomplete'>\n  <ul>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"option","in","options",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + "  </ul>\n</div>\n";
},"useData":true});
Ember.TEMPLATES["emoji-toolbar.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<li><a title='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"item.title",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "' "
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"item.selected",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(2, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + " data-group-id='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"item.groupId",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'><img src='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"item.src",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "' class='emoji'></a></li>";
},"2":function(container,depth0,helpers,partials,data) {
    return "class='selected'";
},"4":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "      <tr>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"item","in","row",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(5, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + "      </tr>\n";
},"5":function(container,depth0,helpers,partials,data) {
    return "          <td><a title='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"item.title",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'><img src='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"item.src",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "' class='emoji'></a></td>\n";
},"7":function(container,depth0,helpers,partials,data) {
    return "        "
    + container.escapeExpression((helpers["fa-icon"] || (depth0 && depth0["fa-icon"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"fast-backward",{"name":"fa-icon","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"9":function(container,depth0,helpers,partials,data) {
    return "        <a>"
    + container.escapeExpression((helpers["fa-icon"] || (depth0 && depth0["fa-icon"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"fast-backward",{"name":"fa-icon","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"11":function(container,depth0,helpers,partials,data) {
    return "        "
    + container.escapeExpression((helpers["fa-icon"] || (depth0 && depth0["fa-icon"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"fast-forward",{"name":"fa-icon","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"13":function(container,depth0,helpers,partials,data) {
    return "        <a>"
    + container.escapeExpression((helpers["fa-icon"] || (depth0 && depth0["fa-icon"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"fast-forward",{"name":"fa-icon","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<div class='emoji-modal'>\n  <ul class='toolbar'>\n    "
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"item","in","toolbarItems",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + "\n  </ul>\n  <div class='emoji-table-wrapper'>\n  <table class='emoji-page'>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"row","in","rows",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(4, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + "  </table>\n  </div>\n\n  <div class='info'></div>\n  <div class='nav'>\n    <span class='prev'>\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"prevDisabled",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(7, data, 0),"inverse":container.program(9, data, 0),"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "    </span>\n    <span class='next'>\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"nextDisabled",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(11, data, 0),"inverse":container.program(13, data, 0),"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "    </span>\n  </div>\n  <div class='clearfix'></div>\n</div>\n";
},"useData":true});
Ember.TEMPLATES["exception"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("i");
        dom.setAttribute(el1,"class","fa fa-check-circle");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "buttonData", blockArguments[0]);
        inline(env, morph0, context, "d-button", [], {"icon": get(env, context, "buttonData.icon"), "action": get(env, context, "buttonData.action"), "label": get(env, context, "buttonData.key"), "class": get(env, context, "buttonData.classes")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","error-page");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","face");
      var el4 = dom.createTextNode(":(");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","reason");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","url");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode(" ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("a");
      dom.setAttribute(el4,"data-auto-route","true");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","desc");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","buttons");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, inline = hooks.inline, get = hooks.get, attribute = hooks.attribute, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var element1 = dom.childAt(element0, [5]);
      var element2 = dom.childAt(element1, [3]);
      var element3 = dom.childAt(element0, [7]);
      var element4 = dom.childAt(element0, [9]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
      var morph1 = dom.createMorphAt(element1,1,1);
      var morph2 = dom.createMorphAt(element2,0,0);
      var attrMorph0 = dom.createAttrMorph(element2, 'href');
      var morph3 = dom.createMorphAt(element3,1,1);
      var morph4 = dom.createMorphAt(element3,3,3);
      var morph5 = dom.createMorphAt(element4,1,1);
      var morph6 = dom.createMorphAt(element4,3,3);
      content(env, morph0, context, "reason");
      inline(env, morph1, context, "i18n", ["errors.prev_page"], {});
      attribute(env, attrMorph0, element2, "href", get(env, context, "requestUrl"));
      content(env, morph2, context, "requestUrl");
      block(env, morph3, context, "if", [get(env, context, "networkFixed")], {}, child0, null);
      content(env, morph4, context, "desc");
      block(env, morph5, context, "each", [get(env, context, "enabledButtons")], {}, child1, null);
      inline(env, morph6, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["full-page-search"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","new-topic-btn");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          inline(env, morph0, context, "d-button", [], {"id": "create-topic", "class": "btn-default", "action": "createTopic", "actionParam": get(env, context, "searchTerm"), "icon": "plus", "label": "topic.create"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "unless", [get(env, context, "site.mobileView")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "d-button", [], {"icon": "list", "class": "bulk-select", "title": "topics.bulk.toggle", "action": "toggleBulkSelect"});
          inline(env, morph1, context, "bulk-select-button", [], {"selected": get(env, context, "selected"), "action": "refresh"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "model.posts")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("  ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","fps-select");
          var el2 = dom.createTextNode("\n  ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"href","");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n  ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"href","");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n  ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element13 = dom.childAt(fragment, [1]);
          var element14 = dom.childAt(element13, [1]);
          var element15 = dom.childAt(element13, [3]);
          var morph0 = dom.createMorphAt(element14,0,0);
          var morph1 = dom.createMorphAt(element15,0,0);
          element(env, element14, context, "action", ["selectAll"], {});
          inline(env, morph0, context, "i18n", ["search.select_all"], {});
          element(env, element15, context, "action", ["clearAll"], {});
          inline(env, morph1, context, "i18n", ["search.clear_all"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "bulkSelectEnabled")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","fps-search-context");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        var el3 = dom.createTextNode("\n  ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode(" ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element12 = dom.childAt(fragment, [0, 1]);
        var morph0 = dom.createMorphAt(element12,1,1);
        var morph1 = dom.createMorphAt(element12,3,3);
        inline(env, morph0, context, "input", [], {"type": "checkbox", "name": "searchContext", "checked": get(env, context, "searchContextEnabled")});
        content(env, morph1, context, "searchContextDescription");
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "i18n", ["search.no_results"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h3");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"href","");
          dom.setAttribute(el2,"class","show-help");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element10 = dom.childAt(fragment, [1]);
          var element11 = dom.childAt(element10, [3]);
          var morph0 = dom.createMorphAt(element10,1,1);
          var morph1 = dom.createMorphAt(element11,0,0);
          block(env, morph0, context, "if", [get(env, context, "searchActive")], {}, child0, null);
          element(env, element11, context, "action", ["showSearchHelp"], {"bubbles": false});
          inline(env, morph1, context, "i18n", ["search.search_help"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("  ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","search-title clearfix");
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","result-count");
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("span");
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n      ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n    ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","sort-by");
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("span");
          dom.setAttribute(el3,"class","desc");
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n      ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n    ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n  ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element8 = dom.childAt(fragment, [1]);
          var element9 = dom.childAt(element8, [3]);
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(element8, [1, 1]),1,1);
          var morph1 = dom.createMorphAt(dom.childAt(element9, [1]),1,1);
          var morph2 = dom.createMorphAt(element9,3,3);
          inline(env, morph0, context, "i18n", ["search.result_count"], {"count": get(env, context, "resultCount"), "term": get(env, context, "noSortQ")});
          inline(env, morph1, context, "i18n", ["search.sort_by"], {});
          inline(env, morph2, context, "combo-box", [], {"value": get(env, context, "sortOrder"), "content": get(env, context, "sortOrders"), "castInteger": "true"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "track-selected", [], {"selectedList": get(env, context, "selected"), "selectedId": get(env, context, "result.topic")});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createUnsafeMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "unbound", [get(env, context, "result.topic.fancyTitle")], {});
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            set(env, context, "tag", blockArguments[0]);
            inline(env, morph0, context, "discourse-tag", [get(env, context, "tag")], {});
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          -\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            return fragment;
          }
        };
      }());
      var child4 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "unbound", [get(env, context, "result.blurb")], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "highlight-text", [], {"highlight": get(env, context, "q")}, child0, null);
            return fragment;
          }
        };
      }());
      var child5 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("        ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("span");
              dom.setAttribute(el1,"class","like-count");
              var el2 = dom.createTextNode("\n          ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode(" ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("i");
              dom.setAttribute(el2,"class","icon fa fa-heart");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n        ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              content(env, morph0, context, "result.like_count");
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "result.like_count")], {}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","fps-result");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","topic");
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("a");
          dom.setAttribute(el3,"class","search-link");
          var el4 = dom.createTextNode("\n            ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("span");
          dom.setAttribute(el4,"class","topic-title");
          var el5 = dom.createComment("");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","search-category");
          var el4 = dom.createTextNode("\n            ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("            ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","blurb container");
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("span");
          dom.setAttribute(el3,"class","date");
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("          ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element2 = dom.childAt(fragment, [1]);
          var element3 = dom.childAt(element2, [1]);
          var element4 = dom.childAt(element3, [5]);
          var element5 = dom.childAt(element3, [7]);
          var element6 = dom.childAt(element2, [3]);
          var element7 = dom.childAt(element6, [1]);
          var morph0 = dom.createMorphAt(element3,1,1);
          var morph1 = dom.createMorphAt(element3,3,3);
          var morph2 = dom.createMorphAt(element4,1,1);
          var attrMorph0 = dom.createAttrMorph(element4, 'href');
          var morph3 = dom.createMorphAt(dom.childAt(element4, [2]),0,0);
          var morph4 = dom.createMorphAt(element5,1,1);
          var morph5 = dom.createMorphAt(element5,3,3);
          var morph6 = dom.createMorphAt(element5,5,5);
          var morph7 = dom.createMorphAt(element7,1,1);
          var morph8 = dom.createMorphAt(element7,3,3);
          var morph9 = dom.createMorphAt(element6,3,3);
          var morph10 = dom.createMorphAt(element2,5,5);
          set(env, context, "result", blockArguments[0]);
          block(env, morph0, context, "if", [get(env, context, "bulkSelectEnabled")], {}, child0, null);
          inline(env, morph1, context, "avatar", [get(env, context, "result")], {"imageSize": "tiny"});
          attribute(env, attrMorph0, element4, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "result.url")], {})]));
          inline(env, morph2, context, "topic-status", [], {"topic": get(env, context, "result.topic"), "disableActions": true});
          block(env, morph3, context, "highlight-text", [], {"highlight": get(env, context, "q")}, child1, null);
          inline(env, morph4, context, "category-link", [get(env, context, "result.topic.category")], {});
          block(env, morph5, context, "each", [get(env, context, "result.topic.tags")], {}, child2, null);
          inline(env, morph6, context, "plugin-outlet", ["full-page-search-category"], {});
          inline(env, morph7, context, "format-age", [get(env, context, "result.created_at")], {});
          block(env, morph8, context, "if", [get(env, context, "result.blurb")], {}, child3, null);
          block(env, morph9, context, "if", [get(env, context, "result.blurb")], {}, child4, null);
          block(env, morph10, context, "if", [get(env, context, "showLikeCount")], {}, child5, null);
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("  ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h3");
          dom.setAttribute(el1,"class","search-footer");
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"href","");
          dom.setAttribute(el2,"class","show-help");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n  ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, element = hooks.element;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var element1 = dom.childAt(element0, [3]);
          var morph0 = dom.createMorphAt(element0,1,1);
          var morph1 = dom.createMorphAt(element1,0,0);
          inline(env, morph0, context, "i18n", ["search.no_more_results"], {});
          element(env, element1, context, "action", ["showSearchHelp"], {"bubbles": false});
          inline(env, morph1, context, "i18n", ["search.search_help"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
        var morph3 = dom.createMorphAt(fragment,7,7,contextualElement);
        block(env, morph0, context, "unless", [get(env, context, "model.posts")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "model.posts")], {}, child1, null);
        block(env, morph2, context, "each", [get(env, context, "model.posts")], {}, child2, null);
        block(env, morph3, context, "if", [get(env, context, "model.posts")], {}, child3, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","search row clearfix");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element16 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element16,1,1);
      var morph1 = dom.createMorphAt(element16,3,3);
      var morph2 = dom.createMorphAt(element16,5,5);
      var morph3 = dom.createMorphAt(element16,6,6);
      var morph4 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph5 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph6 = dom.createMorphAt(fragment,6,6,contextualElement);
      dom.insertBoundary(fragment, null);
      inline(env, morph0, context, "search-text-field", [], {"value": get(env, context, "searchTerm"), "class": "full-page-search input-xxlarge search no-blur", "action": "search", "hasAutofocus": get(env, context, "hasAutofocus")});
      inline(env, morph1, context, "d-button", [], {"action": "search", "icon": "search", "class": "btn-primary", "disabled": get(env, context, "searchButtonDisabled")});
      block(env, morph2, context, "if", [get(env, context, "currentUser")], {}, child0, null);
      block(env, morph3, context, "if", [get(env, context, "canBulkSelect")], {}, child1, null);
      block(env, morph4, context, "if", [get(env, context, "model.posts")], {}, child2, null);
      block(env, morph5, context, "if", [get(env, context, "context")], {}, child3, null);
      block(env, morph6, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")}, child4, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["group-index"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "group-post-stream", [], {"posts": get(env, context, "model"), "emptyText": get(env, context, "emptyText"), "loadMore": "loadMore"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["group-members"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","clearfix");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("form");
          dom.setAttribute(el2,"id","add-user-to-group");
          dom.setAttribute(el2,"autocomplete","off");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element5 = dom.childAt(fragment, [1, 1]);
          var morph0 = dom.createMorphAt(element5,1,1);
          var morph1 = dom.createMorphAt(element5,3,3);
          inline(env, morph0, context, "user-selector", [], {"usernames": get(env, context, "usernames"), "placeholderKey": "groups.selector_placeholder", "id": "user-search-selector", "name": "usernames"});
          inline(env, morph1, context, "d-button", [], {"action": "addMembers", "class": "add", "icon": "plus", "label": "groups.add"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("th");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createElement("span");
              dom.setAttribute(el1,"class","is-owner");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
              inline(env, morph0, context, "i18n", ["groups.owner"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("a");
                dom.setAttribute(el1,"class","remove-link");
                var el2 = dom.createElement("i");
                dom.setAttribute(el2,"class","fa fa-times");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, element = hooks.element;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element0 = dom.childAt(fragment, [1]);
                element(env, element0, context, "action", ["removeMember", get(env, context, "m")], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("td");
              dom.setAttribute(el1,"class","remove-user");
              var el2 = dom.createTextNode("\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("            ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              block(env, morph0, context, "unless", [get(env, context, "m.owner")], {}, child0, null);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"class","avatar");
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n          ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("span");
            dom.setAttribute(el3,"class","text");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n          ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("span");
            dom.setAttribute(el3,"class","text");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n          ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var element2 = dom.childAt(element1, [1]);
            var morph0 = dom.createMorphAt(element2,1,1);
            var morph1 = dom.createMorphAt(element2,3,3);
            var morph2 = dom.createMorphAt(dom.childAt(element1, [3, 1]),0,0);
            var morph3 = dom.createMorphAt(dom.childAt(element1, [5, 1]),0,0);
            var morph4 = dom.createMorphAt(element1,7,7);
            set(env, context, "m", blockArguments[0]);
            inline(env, morph0, context, "user-info", [], {"user": get(env, context, "m")});
            block(env, morph1, context, "if", [get(env, context, "m.owner")], {}, child0, null);
            inline(env, morph2, context, "bound-date", [get(env, context, "m.last_posted_at")], {});
            inline(env, morph3, context, "bound-date", [get(env, context, "m.last_seen_at")], {});
            block(env, morph4, context, "if", [get(env, context, "isOwner")], {}, child1, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("table");
          dom.setAttribute(el1,"class","group-members");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("tr");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("th");
          dom.setAttribute(el3,"colspan","2");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("th");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element3 = dom.childAt(fragment, [1]);
          var element4 = dom.childAt(element3, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(element4, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(element4, [3]),0,0);
          var morph2 = dom.createMorphAt(element4,5,5);
          var morph3 = dom.createMorphAt(element3,3,3);
          inline(env, morph0, context, "i18n", ["last_post"], {});
          inline(env, morph1, context, "i18n", ["last_seen"], {});
          block(env, morph2, context, "if", [get(env, context, "isOwner")], {}, child0, null);
          block(env, morph3, context, "each", [get(env, context, "model.members")], {}, child1, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "isOwner")], {}, child0, null);
        block(env, morph1, context, "load-more", [], {"selector": ".group-members tr", "action": "loadMore"}, child1, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["groups.empty.users"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "model")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["group-selector-autocomplete.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "      <li><a href>"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"option.name",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a></li>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<div class='autocomplete'>\n  <ul>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"option","in","options",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + "  </ul>\n</div>\n";
},"useData":true});
Ember.TEMPLATES["group"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","count");
            var el2 = dom.createTextNode("(");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(")");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
            content(env, morph0, context, "tab.count");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          content(env, morph0, context, "tab.message");
          block(env, morph1, context, "if", [get(env, context, "tab.count")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var attrMorph0 = dom.createAttrMorph(element0, 'class');
        set(env, context, "tab", blockArguments[0]);
        attribute(env, attrMorph0, element0, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "tab.active"), "active"], {})]));
        block(env, morph0, context, "link-to", [get(env, context, "tab.location"), get(env, context, "model")], {"title": get(env, context, "tab.message")}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container user-table");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","wrapper");
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","user-navigation");
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("ul");
      dom.setAttribute(el4,"class","action-list nav-stacked");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("    ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n  ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n  ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      dom.setAttribute(el3,"class","user-main");
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("section");
      dom.setAttribute(el4,"class","user-right groups");
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("section");
      dom.setAttribute(el5,"class","about group");
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("div");
      dom.setAttribute(el6,"class","details");
      var el7 = dom.createTextNode("\n          ");
      dom.appendChild(el6, el7);
      var el7 = dom.createElement("h1");
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n        ");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n      ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n    ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n  ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0, 1]);
      var element2 = dom.childAt(element1, [3, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(element1, [1, 1]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element2, [1, 1, 1]),0,0);
      var morph2 = dom.createMorphAt(element2,3,3);
      block(env, morph0, context, "each", [get(env, context, "tabs")], {}, child0, null);
      content(env, morph1, context, "model.name");
      content(env, morph2, context, "outlet");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["list/action-list.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<div class='post-actions "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"className",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'>\n  <i class='fa fa-"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"icon",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'></i>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"postNumber","in","postNumbers",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(2, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + "</div>\n";
},"2":function(container,depth0,helpers,partials,data) {
    return "    <a href='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"topic.url",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "/"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"postNumber",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'>#"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"postNumber",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"postNumbers",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"useData":true});
Ember.TEMPLATES["list/activity-column.raw"] = Discourse.EmberCompatHandlebars.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"this.tagName",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + " class=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"class",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + " "
    + container.escapeExpression((helpers["cold-age-class"] || (depth0 && depth0["cold-age-class"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic.createdAt",{"name":"cold-age-class","hash":{"class":"","startDate":"topic.bumpedAt"},"hashTypes":{"class":"StringLiteral","startDate":"PathExpression"},"hashContexts":{"class":depth0,"startDate":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + " activity\" title=\""
    + ((stack1 = helpers.get.call(depth0 != null ? depth0 : {},"topic.bumpedAtTitle",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "\"><a href=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"topic.lastPostUrl",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">"
    + container.escapeExpression((helpers["format-date"] || (depth0 && depth0["format-date"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic.bumpedAt",{"name":"format-date","hash":{"noTitle":"true","format":"tiny"},"hashTypes":{"noTitle":"StringLiteral","format":"StringLiteral"},"hashContexts":{"noTitle":depth0,"format":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a></"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"this.tagName",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + ">\n";
},"useData":true});
Ember.TEMPLATES["list/category-column.raw"] = Discourse.EmberCompatHandlebars.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<td class='category'>"
    + container.escapeExpression((helpers["category-link"] || (depth0 && depth0["category-link"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"category",{"name":"category-link","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</td>\n";
},"useData":true});
Ember.TEMPLATES["list/post-count-or-badges.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-post-badges",{"name":"raw","hash":{"url":"topic.lastUnreadUrl","unseen":"topic.unseen","newPosts":"topic.displayNewPosts","unread":"topic.unread"},"hashTypes":{"url":"PathExpression","unseen":"PathExpression","newPosts":"PathExpression","unread":"PathExpression"},"hashContexts":{"url":depth0,"unseen":depth0,"newPosts":depth0,"unread":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"3":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"list.posts-count-column",{"name":"raw","hash":{"tagName":"div","topic":"topic"},"hashTypes":{"tagName":"StringLiteral","topic":"PathExpression"},"hashContexts":{"tagName":depth0,"topic":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"view.showBadges",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"useData":true});
Ember.TEMPLATES["list/posters-column.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "<a href=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"poster.user.path",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\" data-user-card=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"poster.user.username",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\" class=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"poster.extras",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">"
    + container.escapeExpression((helpers.avatar || (depth0 && depth0.avatar) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"poster",{"name":"avatar","hash":{"imageSize":"small","usernamePath":"user.username","avatarTemplatePath":"user.avatar_template"},"hashTypes":{"imageSize":"StringLiteral","usernamePath":"StringLiteral","avatarTemplatePath":"StringLiteral"},"hashContexts":{"imageSize":depth0,"usernamePath":depth0,"avatarTemplatePath":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<td class='posters'>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"poster","in","posters",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + "</td>\n";
},"useData":true});
Ember.TEMPLATES["list/posts-count-column.raw"] = Discourse.EmberCompatHandlebars.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"view.tagName",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + " class='num posts-map posts "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"view.likesHeat",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "' title='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"view.title",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'>\n  <a href class='posts-map badge-posts "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"view.likesHeat",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'>"
    + container.escapeExpression((helpers.number || (depth0 && depth0.number) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic.replyCount",{"name":"number","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n</"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"view.tagName",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + ">\n";
},"useData":true});
Ember.TEMPLATES["list/topic-excerpt.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "  <div class=\"topic-excerpt\">\n    "
    + ((stack1 = helpers.get.call(depth0 != null ? depth0 : {},"topic.excerpt",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"topic.excerptTruncated",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(2, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "  </div>\n";
},"2":function(container,depth0,helpers,partials,data) {
    return "      <a href=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"topic.url",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">"
    + container.escapeExpression((helpers.i18n || (depth0 && depth0.i18n) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"read_more",{"name":"i18n","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"topic.hasExcerpt",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"useData":true});
Ember.TEMPLATES["list/topic-list-item.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "  <td class='star'>\n    <input type=\"checkbox\" class=\"bulk-select\">\n  </td>\n";
},"3":function(container,depth0,helpers,partials,data) {
    return "    "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-post-badges",{"name":"raw","hash":{"url":"topic.lastUnreadUrl","unseen":"topic.unseen","newPosts":"topic.displayNewPosts","unread":"topic.unread"},"hashTypes":{"url":"PathExpression","unseen":"PathExpression","newPosts":"PathExpression","unread":"PathExpression"},"hashContexts":{"url":depth0,"unseen":depth0,"newPosts":depth0,"unread":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"5":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "    <div class='discourse-tags'>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"tag","in","topic.visibleListTags",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(6, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + "    </div>\n";
},"6":function(container,depth0,helpers,partials,data) {
    return "      "
    + container.escapeExpression((helpers["discourse-tag"] || (depth0 && depth0["discourse-tag"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"tag",{"name":"discourse-tag","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n";
},"8":function(container,depth0,helpers,partials,data) {
    return "    "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"list.topic-excerpt",{"name":"raw","hash":{"topic":"topic"},"hashTypes":{"topic":"PathExpression"},"hashContexts":{"topic":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"10":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.unless.call(depth0 != null ? depth0 : {},"topic.isPinnedUncategorized",{"name":"unless","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(11, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"11":function(container,depth0,helpers,partials,data) {
    return "    "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"list.category-column",{"name":"raw","hash":{"category":"topic.category"},"hashTypes":{"category":"PathExpression"},"hashContexts":{"category":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"13":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"list.posters-column",{"name":"raw","hash":{"posters":"topic.posters"},"hashTypes":{"posters":"PathExpression"},"hashContexts":{"posters":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"15":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"list.posters-column",{"name":"raw","hash":{"posters":"topic.participants"},"hashTypes":{"posters":"PathExpression"},"hashContexts":{"posters":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"17":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<td class=\"num likes\">\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"hasLikes",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(18, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"18":function(container,depth0,helpers,partials,data) {
    return "    <a href='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"topic.summaryUrl",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'>\n      "
    + container.escapeExpression((helpers.number || (depth0 && depth0.number) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic.like_count",{"name":"number","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + " <i class='fa fa-heart'></i></td>\n    </a>\n";
},"20":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<td class=\"num likes\">\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"hasOpLikes",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(21, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"21":function(container,depth0,helpers,partials,data) {
    return "    <a href='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"topic.summaryUrl",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'>\n      "
    + container.escapeExpression((helpers.number || (depth0 && depth0.number) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic.op_like_count",{"name":"number","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + " <i class='fa fa-heart'></i></td>\n    </a>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"bulkSelectEnabled",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "\n<td class='main-link clearfix' colspan=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"titleColSpan",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">\n  "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-status",{"name":"raw","hash":{"topic":"topic"},"hashTypes":{"topic":"PathExpression"},"hashContexts":{"topic":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n  "
    + container.escapeExpression((helpers["topic-link"] || (depth0 && depth0["topic-link"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic",{"name":"topic-link","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n  "
    + container.escapeExpression((helpers["plugin-outlet"] || (depth0 && depth0["plugin-outlet"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-list-after-title",{"name":"plugin-outlet","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"showTopicPostBadges",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(3, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"topic.tags",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(5, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "  "
    + container.escapeExpression((helpers["plugin-outlet"] || (depth0 && depth0["plugin-outlet"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-list-tags",{"name":"plugin-outlet","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"expandPinned",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(8, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "  "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"list.action-list",{"name":"raw","hash":{"icon":"heart","className":"likes","postNumbers":"topic.liked_post_numbers","topic":"topic"},"hashTypes":{"icon":"StringLiteral","className":"StringLiteral","postNumbers":"PathExpression","topic":"PathExpression"},"hashContexts":{"icon":depth0,"className":depth0,"postNumbers":depth0,"topic":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n</td>\n\n"
    + ((stack1 = helpers.unless.call(depth0 != null ? depth0 : {},"hideCategory",{"name":"unless","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(10, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"showPosters",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(13, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "\n"
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"list.posts-count-column",{"name":"raw","hash":{"topic":"topic"},"hashTypes":{"topic":"PathExpression"},"hashContexts":{"topic":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"showParticipants",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(15, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"showLikes",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(17, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"showOpLikes",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(20, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "\n<td class=\"num views "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"topic.viewsHeat",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">"
    + container.escapeExpression((helpers.number || (depth0 && depth0.number) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic.views",{"name":"number","hash":{"numberKey":"views_long"},"hashTypes":{"numberKey":"StringLiteral"},"hashContexts":{"numberKey":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</td>\n\n"
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"list.activity-column",{"name":"raw","hash":{"tagName":"td","class":"num","topic":"topic"},"hashTypes":{"tagName":"StringLiteral","class":"StringLiteral","topic":"PathExpression"},"hashContexts":{"tagName":depth0,"class":depth0,"topic":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"useData":true});
Ember.TEMPLATES["login-preferences"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "showForgotPassword", "label": "login.forgot"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("h2");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      dom.setAttribute(el2,"style","margin-top: 1em");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
      var morph2 = dom.createMorphAt(element0,5,5);
      var morph3 = dom.createMorphAt(element0,7,7);
      inline(env, morph0, context, "i18n", ["login.to_continue"], {});
      inline(env, morph1, context, "i18n", ["login.preferences"], {});
      inline(env, morph2, context, "d-button", [], {"class": "btn-primary", "action": "showLogin", "label": "log_in"});
      block(env, morph3, context, "unless", [get(env, context, "siteSettings.enable_sso")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/components/basic-topic-list"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("span");
              dom.setAttribute(el1,"class","badge-notification new-topic");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          var child0 = (function() {
            var child0 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.2",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createElement("a");
                  var el2 = dom.createComment("");
                  dom.appendChild(el1, el2);
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var element2 = dom.childAt(fragment, [0]);
                  var morph0 = dom.createMorphAt(element2,0,0);
                  var attrMorph0 = dom.createAttrMorph(element2, 'href');
                  attribute(env, attrMorph0, element2, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "t.url")], {})]));
                  inline(env, morph0, context, "i18n", ["read_more"], {});
                  return fragment;
                }
              };
            }());
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                    ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, block = hooks.block;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                block(env, morph0, context, "unless", [get(env, context, "t.canClearPin")], {}, child0, null);
                return fragment;
              }
            };
          }());
          var child1 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                    ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("a");
                dom.setAttribute(el1,"href","");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, get = hooks.get, element = hooks.element, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element1 = dom.childAt(fragment, [1]);
                var morph0 = dom.createMorphAt(element1,0,0);
                var attrMorph0 = dom.createAttrMorph(element1, 'title');
                attribute(env, attrMorph0, element1, "title", concat(env, [subexpr(env, context, "i18n", ["topic.clear_pin.help"], {})]));
                element(env, element1, context, "action", ["clearPin", get(env, context, "t")], {});
                inline(env, morph0, context, "i18n", ["topic.clear_pin.title"], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","topic-excerpt");
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element3 = dom.childAt(fragment, [1]);
              var morph0 = dom.createUnsafeMorphAt(element3,1,1);
              var morph1 = dom.createMorphAt(element3,3,3);
              var morph2 = dom.createMorphAt(element3,4,4);
              content(env, morph0, context, "t.excerpt");
              block(env, morph1, context, "if", [get(env, context, "t.excerptTruncated")], {}, child0, null);
              block(env, morph2, context, "if", [get(env, context, "t.canClearPin")], {}, child1, null);
              return fragment;
            }
          };
        }());
        var child2 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","category");
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              inline(env, morph0, context, "category-link", [get(env, context, "t.category")], {});
              return fragment;
            }
          };
        }());
        var child3 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 1,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                    ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("a");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement, blockArguments) {
                var dom = env.dom;
                var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element0 = dom.childAt(fragment, [1]);
                var morph0 = dom.createMorphAt(element0,0,0);
                var attrMorph0 = dom.createAttrMorph(element0, 'href');
                var attrMorph1 = dom.createAttrMorph(element0, 'class');
                set(env, context, "p", blockArguments[0]);
                attribute(env, attrMorph0, element0, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "p.user.path")], {})]));
                attribute(env, attrMorph1, element0, "class", concat(env, [subexpr(env, context, "unbound", [get(env, context, "p.extras")], {})]));
                inline(env, morph0, context, "avatar", [get(env, context, "p")], {"usernamePath": "user.username", "imageSize": "small"});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","participants");
              var el2 = dom.createTextNode("\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              block(env, morph0, context, "each", [get(env, context, "participants")], {}, child0, null);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            dom.setAttribute(el3,"class","main-link");
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("            ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            dom.setAttribute(el3,"class","pull-right");
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n            ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            dom.setAttribute(el3,"class","clearfix");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            dom.setAttribute(el3,"class","topic-item-stats clearfix");
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createElement("div");
            dom.setAttribute(el4,"class","pull-right");
            var el5 = dom.createTextNode("\n                ");
            dom.appendChild(el4, el5);
            var el5 = dom.createComment("");
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n                ");
            dom.appendChild(el4, el5);
            var el5 = dom.createElement("a");
            var el6 = dom.createComment("");
            dom.appendChild(el5, el6);
            dom.appendChild(el4, el5);
            var el5 = dom.createTextNode("\n              ");
            dom.appendChild(el4, el5);
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createElement("div");
            dom.setAttribute(el4,"class","clearfix");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n            ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n          ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element4 = dom.childAt(fragment, [1]);
            var element5 = dom.childAt(element4, [1]);
            var element6 = dom.childAt(element5, [1]);
            var element7 = dom.childAt(element5, [7]);
            var element8 = dom.childAt(element7, [1]);
            var element9 = dom.childAt(element8, [3]);
            var attrMorph0 = dom.createAttrMorph(element4, 'class');
            var attrMorph1 = dom.createAttrMorph(element4, 'data-topic-id');
            var morph0 = dom.createMorphAt(element6,1,1);
            var morph1 = dom.createMorphAt(element6,3,3);
            var morph2 = dom.createMorphAt(element6,5,5);
            var morph3 = dom.createMorphAt(element6,6,6);
            var morph4 = dom.createMorphAt(dom.childAt(element5, [3]),1,1);
            var morph5 = dom.createMorphAt(element8,1,1);
            var morph6 = dom.createMorphAt(element9,0,0);
            var attrMorph2 = dom.createAttrMorph(element9, 'href');
            var attrMorph3 = dom.createAttrMorph(element9, 'title');
            var morph7 = dom.createMorphAt(element7,3,3);
            var morph8 = dom.createMorphAt(element7,4,4);
            set(env, context, "t", blockArguments[0]);
            attribute(env, attrMorph0, element4, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "t.archived"), "archived"], {})]));
            attribute(env, attrMorph1, element4, "data-topic-id", get(env, context, "t.id"));
            inline(env, morph0, context, "topic-status", [], {"topic": get(env, context, "t")});
            inline(env, morph1, context, "topic-link", [get(env, context, "t")], {});
            block(env, morph2, context, "if", [get(env, context, "t.unseen")], {}, child0, null);
            block(env, morph3, context, "if", [get(env, context, "t.hasExcerpt")], {}, child1, null);
            inline(env, morph4, context, "raw", ["list/post-count-or-badges"], {"topic": get(env, context, "t"), "postBadgesEnabled": "true"});
            inline(env, morph5, context, "raw", ["list/activity-column"], {"topic": get(env, context, "t"), "tagName": "div", "class": "num activity last"});
            attribute(env, attrMorph2, element9, "href", concat(env, [get(env, context, "t.lastPostUrl")]));
            attribute(env, attrMorph3, element9, "title", concat(env, [subexpr(env, context, "i18n", ["last_post"], {}), ": ", subexpr(env, context, "raw-date", [get(env, context, "t.bumped_at")], {})]));
            content(env, morph6, context, "t.last_poster_username");
            block(env, morph7, context, "unless", [get(env, context, "hideCategory")], {}, child2, null);
            block(env, morph8, context, "if", [get(env, context, "showParticipants")], {}, child3, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("table");
          dom.setAttribute(el1,"class","topic-list");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("tbody");
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1]),1,1);
          block(env, morph0, context, "each", [get(env, context, "topics")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","alert alert-info");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "i18n", ["choose_topic.none_found"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "topics")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/components/directory-item"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","time-read");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "unbound", [get(env, context, "item.time_read")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      var morph4 = dom.createMorphAt(fragment,8,8,contextualElement);
      var morph5 = dom.createMorphAt(fragment,10,10,contextualElement);
      var morph6 = dom.createMorphAt(fragment,12,12,contextualElement);
      var morph7 = dom.createMorphAt(fragment,14,14,contextualElement);
      var morph8 = dom.createMorphAt(fragment,16,16,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "user-info", [], {"user": get(env, context, "item.user")});
      inline(env, morph1, context, "user-stat", [], {"value": get(env, context, "item.likes_received"), "label": "directory.likes_received", "icon": "heart"});
      inline(env, morph2, context, "user-stat", [], {"value": get(env, context, "item.likes_given"), "label": "directory.likes_given", "icon": "heart"});
      inline(env, morph3, context, "user-stat", [], {"value": get(env, context, "item.topic_count"), "label": "directory.topic_count"});
      inline(env, morph4, context, "user-stat", [], {"value": get(env, context, "item.post_count"), "label": "directory.post_count"});
      inline(env, morph5, context, "user-stat", [], {"value": get(env, context, "item.topics_entered"), "label": "directory.topics_entered"});
      inline(env, morph6, context, "user-stat", [], {"value": get(env, context, "item.posts_read"), "label": "directory.posts_read"});
      inline(env, morph7, context, "user-stat", [], {"value": get(env, context, "item.days_visited"), "label": "directory.days_visited"});
      block(env, morph8, context, "if", [get(env, context, "showTimeRead")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/components/mobile-nav"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("li");
      var el2 = dom.createElement("a");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode(" ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("i");
      dom.setAttribute(el3,"class","fa fa-caret-down");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("ul");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, content = hooks.content, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 0]);
      var element1 = dom.childAt(fragment, [2]);
      var morph0 = dom.createUnsafeMorphAt(element0,0,0);
      var morph1 = dom.createMorphAt(element1,1,1);
      var attrMorph0 = dom.createAttrMorph(element1, 'class');
      element(env, element0, context, "action", ["toggleExpanded"], {});
      content(env, morph0, context, "selectedHtml");
      attribute(env, attrMorph0, element1, "class", concat(env, ["drop ", subexpr(env, context, "if", [get(env, context, "expanded"), "expanded"], {})]));
      content(env, morph1, context, "yield");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/components/navigation-bar"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "navItem", blockArguments[0]);
          inline(env, morph0, context, "navigation-item", [], {"content": get(env, context, "navItem"), "filterMode": get(env, context, "filterMode")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("ul");
        dom.setAttribute(el1,"class","drop");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
        block(env, morph0, context, "each", [get(env, context, "navItems")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("li");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("i");
      dom.setAttribute(el3,"class","fa fa-caret-down");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, content = hooks.content, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, null);
      element(env, element0, context, "action", ["toggleDrop"], {});
      content(env, morph0, context, "selectedNavItem.displayName");
      block(env, morph1, context, "if", [get(env, context, "expanded")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/discovery/categories"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("tr");
          dom.setAttribute(el1,"class","category-description");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"colspan","3");
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1, 1]),1,1);
          content(env, morph0, context, "c.description_excerpt");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","badge-notification new-topic");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createElement("a");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element2 = dom.childAt(fragment, [0]);
                var morph0 = dom.createMorphAt(element2,0,0);
                var attrMorph0 = dom.createAttrMorph(element2, 'href');
                attribute(env, attrMorph0, element2, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "t.url")], {})]));
                inline(env, morph0, context, "i18n", ["read_more"], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                    ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              block(env, morph0, context, "unless", [get(env, context, "t.canClearPin")], {}, child0, null);
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                    ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("a");
              dom.setAttribute(el1,"href","");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element1 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(element1,0,0);
              var attrMorph0 = dom.createAttrMorph(element1, 'title');
              attribute(env, attrMorph0, element1, "title", concat(env, [subexpr(env, context, "unbound", [get(env, context, "i18n"), get(env, context, "topic.clear_pin.help")], {})]));
              element(env, element1, context, "action", ["clearPin", get(env, context, "t")], {});
              inline(env, morph0, context, "i18n", ["topic.clear_pin.title"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","topic-excerpt");
            var el2 = dom.createTextNode("\n                  ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("                ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element3 = dom.childAt(fragment, [1]);
            var morph0 = dom.createUnsafeMorphAt(element3,1,1);
            var morph1 = dom.createMorphAt(element3,3,3);
            var morph2 = dom.createMorphAt(element3,4,4);
            content(env, morph0, context, "t.excerpt");
            block(env, morph1, context, "if", [get(env, context, "t.excerptTruncated")], {}, child0, null);
            block(env, morph2, context, "if", [get(env, context, "t.canClearPin")], {}, child1, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("tr");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"class","main-link");
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","topic-inset");
          var el4 = dom.createTextNode("\n              ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n              ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("              ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("span");
          var el5 = dom.createComment("");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("            ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          dom.setAttribute(el2,"class","num posts");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [1]);
          var element5 = dom.childAt(element4, [1, 1]);
          var element6 = dom.childAt(element5, [7]);
          var attrMorph0 = dom.createAttrMorph(element4, 'class');
          var morph0 = dom.createMorphAt(element5,1,1);
          var morph1 = dom.createMorphAt(element5,3,3);
          var morph2 = dom.createMorphAt(element5,5,5);
          var morph3 = dom.createUnsafeMorphAt(element6,0,0);
          var attrMorph1 = dom.createAttrMorph(element6, 'class');
          var attrMorph2 = dom.createAttrMorph(element6, 'title');
          var morph4 = dom.createMorphAt(element5,9,9);
          var morph5 = dom.createMorphAt(dom.childAt(element4, [3]),0,0);
          set(env, context, "t", blockArguments[0]);
          attribute(env, attrMorph0, element4, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "t.archived"), "archived"], {}), " category-topic-link"]));
          inline(env, morph0, context, "topic-status", [], {"topic": get(env, context, "t")});
          inline(env, morph1, context, "topic-link", [get(env, context, "t")], {});
          block(env, morph2, context, "if", [get(env, context, "t.unseen")], {}, child0, null);
          attribute(env, attrMorph1, element6, "class", concat(env, [subexpr(env, context, "cold-age-class", [get(env, context, "t.last_posted_at")], {})]));
          attribute(env, attrMorph2, element6, "title", concat(env, [subexpr(env, context, "raw-date", [get(env, context, "t.last_posted_at")], {})]));
          inline(env, morph3, context, "format-age", [get(env, context, "t.last_posted_at")], {});
          block(env, morph4, context, "if", [get(env, context, "t.hasExcerpt")], {}, child1, null);
          inline(env, morph5, context, "raw", ["list/post-count-or-badges"], {"topic": get(env, context, "t"), "postBadgesEnabled": "true"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            set(env, context, "subcategory", blockArguments[0]);
            inline(env, morph0, context, "category-link", [get(env, context, "subcategory")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("tr");
          dom.setAttribute(el1,"class","subcategories-list");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("td");
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","subcategories");
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("            ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1, 1]),1,1);
          block(env, morph0, context, "each", [get(env, context, "c.subcategories")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"href","");
          dom.setAttribute(el1,"class","btn btn-small");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,0,0);
          element(env, element0, context, "action", ["editCategory", get(env, context, "c")], {});
          inline(env, morph0, context, "i18n", ["category.edit"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","category-list-item category");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("table");
        dom.setAttribute(el2,"class","topic-list");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("tr");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("th");
        dom.setAttribute(el4,"class","main-link");
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n        ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("footer");
        dom.setAttribute(el2,"class","clearfix");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("figure");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode(" ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("figcaption");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("figure");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode(" ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("figcaption");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("figure");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode(" ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("figcaption");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element7 = dom.childAt(fragment, [1]);
        var element8 = dom.childAt(element7, [1]);
        var element9 = dom.childAt(element7, [3]);
        var element10 = dom.childAt(element9, [1]);
        var element11 = dom.childAt(element9, [3]);
        var element12 = dom.childAt(element9, [5]);
        var attrMorph0 = dom.createAttrMorph(element7, 'style');
        var morph0 = dom.createMorphAt(dom.childAt(element8, [1, 1]),1,1);
        var morph1 = dom.createMorphAt(element8,3,3);
        var morph2 = dom.createMorphAt(element8,5,5);
        var morph3 = dom.createMorphAt(element8,6,6);
        var morph4 = dom.createMorphAt(element10,0,0);
        var attrMorph1 = dom.createAttrMorph(element10, 'title');
        var morph5 = dom.createMorphAt(dom.childAt(element10, [2]),0,0);
        var morph6 = dom.createMorphAt(element11,0,0);
        var attrMorph2 = dom.createAttrMorph(element11, 'title');
        var morph7 = dom.createMorphAt(dom.childAt(element11, [2]),0,0);
        var morph8 = dom.createMorphAt(element12,0,0);
        var attrMorph3 = dom.createAttrMorph(element12, 'title');
        var morph9 = dom.createMorphAt(dom.childAt(element12, [2]),0,0);
        var morph10 = dom.createMorphAt(element9,7,7);
        set(env, context, "c", blockArguments[0]);
        attribute(env, attrMorph0, element7, "style", concat(env, ["border-color: #", subexpr(env, context, "unbound", [get(env, context, "c.color")], {})]));
        inline(env, morph0, context, "category-title-link", [], {"category": get(env, context, "c")});
        block(env, morph1, context, "if", [get(env, context, "c.description_excerpt")], {}, child0, null);
        block(env, morph2, context, "each", [get(env, context, "c.topics")], {}, child1, null);
        block(env, morph3, context, "if", [get(env, context, "c.subcategories")], {}, child2, null);
        attribute(env, attrMorph1, element10, "title", concat(env, [subexpr(env, context, "i18n", ["year_desc"], {})]));
        inline(env, morph4, context, "number", [get(env, context, "c.topics_year")], {});
        inline(env, morph5, context, "i18n", ["category.this_year"], {});
        attribute(env, attrMorph2, element11, "title", concat(env, [subexpr(env, context, "i18n", ["month_desc"], {})]));
        inline(env, morph6, context, "number", [get(env, context, "c.topics_month")], {});
        inline(env, morph7, context, "i18n", ["month"], {});
        attribute(env, attrMorph3, element12, "title", concat(env, [subexpr(env, context, "i18n", ["week_desc"], {})]));
        inline(env, morph8, context, "number", [get(env, context, "c.topics_week")], {});
        inline(env, morph9, context, "i18n", ["week"], {});
        block(env, morph10, context, "if", [get(env, context, "c.can_edit")], {}, child3, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "model.categories")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/discovery/topics"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","top-lists");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "period-chooser", [], {"period": get(env, context, "period"), "action": "changePeriod"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","alert alert-info");
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, element = hooks.element, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element6 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element6,1,1);
            var morph1 = dom.createMorphAt(element6,3,3);
            element(env, element6, context, "action", ["showInserted"], {});
            inline(env, morph0, context, "count-i18n", [], {"key": "topic_count_", "suffix": get(env, context, "topicTrackingState.filter"), "count": get(env, context, "topicTrackingState.incomingCount")});
            inline(env, morph1, context, "i18n", ["click_to_show"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "topicTrackingState.hasIncoming")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "topic-list", [], {"showPosters": true, "currentUser": get(env, context, "currentUser"), "hideCategory": get(env, context, "model.hideCategory"), "topics": get(env, context, "model.topics")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "top")], {}, child0, child1);
        block(env, morph1, context, "if", [get(env, context, "hasTopics")], {}, child2, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","dismiss-topics");
          dom.setAttribute(el1,"class","btn dismiss-read");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element5 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element5,0,0);
          var attrMorph0 = dom.createAttrMorph(element5, 'title');
          attribute(env, attrMorph0, element5, "title", concat(env, [subexpr(env, context, "i18n", ["topics.bulk.dismiss_tooltip"], {})]));
          element(env, element5, context, "action", ["dismissReadPosts"], {});
          inline(env, morph0, context, "i18n", ["topics.bulk.dismiss_button"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","dismiss-new");
          dom.setAttribute(el1,"class","btn dismiss-read");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element4,0,0);
          element(env, element4, context, "action", ["resetNew"], {});
          inline(env, morph0, context, "i18n", ["topics.bulk.dismiss_new"], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("a");
            dom.setAttribute(el1,"href","");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element2 = dom.childAt(fragment, [0]);
            var morph0 = dom.createMorphAt(element2,0,0);
            element(env, element2, context, "action", ["createTopic"], {});
            inline(env, morph0, context, "i18n", ["topic.suggest_create_topic"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","education");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h3");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element3 = dom.childAt(fragment, [3]);
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),1,1);
          var morph1 = dom.createMorphAt(element3,1,1);
          var morph2 = dom.createMorphAt(element3,3,3);
          content(env, morph0, context, "footerEducation");
          content(env, morph1, context, "footerMessage");
          block(env, morph2, context, "if", [get(env, context, "model.can_create_topic")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "i18n", ["topic.browse_all_categories"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "i18n", ["topic.view_latest_topics"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h3");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(", ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("br");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, block = hooks.block, inline = hooks.inline, get = hooks.get;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element1 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element1,1,1);
            var morph1 = dom.createMorphAt(element1,3,3);
            var morph2 = dom.createMorphAt(element1,5,5);
            var morph3 = dom.createMorphAt(element1,7,7);
            var morph4 = dom.createMorphAt(element1,11,11);
            block(env, morph0, context, "link-to", ["discovery.categories"], {}, child0, null);
            block(env, morph1, context, "link-to", ["discovery.latest"], {}, child1, null);
            inline(env, morph2, context, "i18n", ["or"], {});
            inline(env, morph3, context, "i18n", ["filters.top.other_periods"], {});
            inline(env, morph4, context, "top-period-buttons", [], {"period": get(env, context, "period"), "action": "changePeriod"});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode(" ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              dom.insertBoundary(fragment, null);
              inline(env, morph0, context, "i18n", ["topic.browse_all_categories"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "i18n", ["topic.view_latest_topics"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","education");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h3");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [3]);
            var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),1,1);
            var morph1 = dom.createMorphAt(element0,1,1);
            var morph2 = dom.createMorphAt(element0,2,2);
            var morph3 = dom.createMorphAt(element0,4,4);
            var morph4 = dom.createMorphAt(element0,6,6);
            content(env, morph0, context, "footerEducation");
            content(env, morph1, context, "footerMessage");
            block(env, morph2, context, "link-to", ["discovery.categories"], {}, child0, null);
            inline(env, morph3, context, "i18n", ["or"], {});
            block(env, morph4, context, "link-to", ["discovery.latest"], {}, child1, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "top")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "showDismissRead")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "showResetNew")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "latest")], {}, child2, child3);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("footer");
      dom.setAttribute(el1,"class","topic-list-bottom");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element7 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(element7,1,1);
      var morph2 = dom.createMorphAt(element7,3,3);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "discovery-topics-list", [], {"model": get(env, context, "model"), "refresh": "refresh", "incomingCount": get(env, context, "topicTrackingState.incomingCount")}, child0, null);
      inline(env, morph1, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.loadingMore")});
      block(env, morph2, context, "if", [get(env, context, "allLoaded")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/list/topic_list_item.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "  <div class='pull-left'>\n    <a href=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"topic.lastPostUrl",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">"
    + container.escapeExpression((helpers.avatar || (depth0 && depth0.avatar) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic.lastPoster",{"name":"avatar","hash":{"imageSize":"large"},"hashTypes":{"imageSize":"StringLiteral"},"hashContexts":{"imageSize":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n  </div>\n  <div class='right'>\n";
},"3":function(container,depth0,helpers,partials,data) {
    return "  <div>\n";
},"5":function(container,depth0,helpers,partials,data) {
    return "        <span class=\"badge-notification new-topic\"></span>\n";
},"7":function(container,depth0,helpers,partials,data) {
    return "        <div class='category'>\n          "
    + container.escapeExpression((helpers["category-link"] || (depth0 && depth0["category-link"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic.category",{"name":"category-link","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n        </div>\n";
},"9":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "        <div class='discourse-tags'>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"tag","in","context.topic.visibleListTags",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(10, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + "        </div>\n";
},"10":function(container,depth0,helpers,partials,data) {
    return "          "
    + container.escapeExpression((helpers["discourse-tag"] || (depth0 && depth0["discourse-tag"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"tag",{"name":"discourse-tag","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<td>"
    + ((stack1 = helpers.unless.call(depth0 != null ? depth0 : {},"topic.hasExcerpt",{"name":"unless","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "<div class='main-link'>\n      "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-status",{"name":"raw","hash":{"topic":"topic"},"hashTypes":{"topic":"PathExpression"},"hashContexts":{"topic":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n      "
    + container.escapeExpression((helpers["topic-link"] || (depth0 && depth0["topic-link"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic",{"name":"topic-link","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"topic.unseen",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(5, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "      "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"list.topic-excerpt",{"name":"raw","hash":{"topic":"topic"},"hashTypes":{"topic":"PathExpression"},"hashContexts":{"topic":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n    </div>\n\n    <div class='pull-right'>\n      "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"list.post-count-or-badges",{"name":"raw","hash":{"postBadgesEnabled":"showTopicPostBadges","topic":"topic"},"hashTypes":{"postBadgesEnabled":"PathExpression","topic":"PathExpression"},"hashContexts":{"postBadgesEnabled":depth0,"topic":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n    </div>\n\n    <div class=\"topic-item-stats clearfix\">\n"
    + ((stack1 = helpers.unless.call(depth0 != null ? depth0 : {},"hideCategory",{"name":"unless","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(7, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"context.topic.tags",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(9, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "\n      "
    + container.escapeExpression((helpers["plugin-outlet"] || (depth0 && depth0["plugin-outlet"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-list-tags",{"name":"plugin-outlet","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n\n      <div class=\"pull-right\">\n        <div class='num activity last'>\n          <span class=\"age activity\" title=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"topic.bumpedAtTitle",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\"><a href=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"topic.lastPostUrl",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">"
    + container.escapeExpression((helpers["format-date"] || (depth0 && depth0["format-date"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic.bumpedAt",{"name":"format-date","hash":{"noTitle":"true","format":"tiny"},"hashTypes":{"noTitle":"StringLiteral","format":"StringLiteral"},"hashContexts":{"noTitle":depth0,"format":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a></span>\n        </div>\n      </div>\n\n      <div class=\"clearfix\"></div>\n    </div>\n  </div>\n</td>\n";
},"useData":true});
Ember.TEMPLATES["mobile/modal/login"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("form");
        dom.setAttribute(el1,"id","login-form");
        dom.setAttribute(el1,"method","post");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("table");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n              ");
        dom.appendChild(el5, el6);
        var el6 = dom.createElement("label");
        dom.setAttribute(el6,"for","login-account-name");
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        var el7 = dom.createTextNode(" ");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n              ");
        dom.appendChild(el5, el6);
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n                ");
        dom.appendChild(el5, el6);
        var el6 = dom.createElement("label");
        dom.setAttribute(el6,"for","login-account-password");
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        var el7 = dom.createTextNode(" ");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n                ");
        dom.appendChild(el5, el6);
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("  \n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n              ");
        dom.appendChild(el5, el6);
        var el6 = dom.createElement("a");
        dom.setAttribute(el6,"id","forgot-password-link");
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1, 1, 1]);
        var element3 = dom.childAt(element2, [1]);
        var element4 = dom.childAt(element2, [3]);
        var element5 = dom.childAt(element2, [5, 3, 1]);
        var morph0 = dom.createMorphAt(dom.childAt(element3, [1, 1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element3, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(element4, [1, 1]),0,0);
        var morph3 = dom.createMorphAt(dom.childAt(element4, [3]),1,1);
        var morph4 = dom.createMorphAt(element5,0,0);
        inline(env, morph0, context, "i18n", ["login.username"], {});
        inline(env, morph1, context, "text-field", [], {"value": get(env, context, "loginName"), "type": "email", "placeholderKey": "login.email_placeholder", "id": "login-account-name", "autocorrect": "off", "autocapitalize": "off"});
        inline(env, morph2, context, "i18n", ["login.password"], {});
        inline(env, morph3, context, "text-field", [], {"value": get(env, context, "loginPassword"), "type": "password", "id": "login-account-password", "maxlength": "200"});
        element(env, element5, context, "action", ["showForgotPassword"], {});
        inline(env, morph4, context, "i18n", ["forgot_password.action"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["login.authenticating"], {});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"class","btn btn-large");
          dom.setAttribute(el1,"id","new-account-link");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,1,1);
          element(env, element0, context, "action", ["showCreateAccount"], {});
          inline(env, morph0, context, "i18n", ["create_account.title"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-large btn-primary");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-unlock");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, content = hooks.content, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var attrMorph0 = dom.createAttrMorph(element1, 'disabled');
        var morph0 = dom.createMorphAt(element1,3,3);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        attribute(env, attrMorph0, element1, "disabled", get(env, context, "loginDisabled"));
        element(env, element1, context, "action", ["login"], {});
        content(env, morph0, context, "loginButtonText");
        block(env, morph1, context, "if", [get(env, context, "showSignupLink")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","login-alert");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element6 = dom.childAt(fragment, [0]);
      var element7 = dom.childAt(element6, [7]);
      var element8 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(element6,1,1);
      var morph1 = dom.createMorphAt(element6,3,3);
      var morph2 = dom.createMorphAt(element6,5,5);
      var morph3 = dom.createMorphAt(element7,0,0);
      var attrMorph0 = dom.createAttrMorph(element7, 'class');
      var morph4 = dom.createMorphAt(element8,1,1);
      var morph5 = dom.createMorphAt(element8,2,2);
      inline(env, morph0, context, "login-buttons", [], {"action": "externalLogin"});
      block(env, morph1, context, "if", [get(env, context, "canLoginLocal")], {}, child0, null);
      content(env, morph2, context, "authMessage");
      attribute(env, attrMorph0, element7, "class", get(env, context, "alertClass"));
      content(env, morph3, context, "alert");
      block(env, morph4, context, "if", [get(env, context, "authenticate")], {}, child1, null);
      block(env, morph5, context, "if", [get(env, context, "canLoginLocal")], {}, child2, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["mobile/users"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            set(env, context, "item", blockArguments[0]);
            inline(env, morph0, context, "directory-item", [], {"tagName": "div", "class": "user", "item": get(env, context, "item"), "showTimeRead": get(env, context, "showTimeRead")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","total-rows");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
          inline(env, morph0, context, "i18n", ["directory.total_rows"], {"count": get(env, context, "model.totalRows")});
          block(env, morph1, context, "each", [get(env, context, "model")], {}, child0, null);
          inline(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.loadingMore")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","clearfix");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
          inline(env, morph0, context, "i18n", ["directory.no_results"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "model.length")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","directory");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","clearfix user-controls");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var element1 = dom.childAt(element0, [1]);
      var morph0 = dom.createMorphAt(element1,1,1);
      var morph1 = dom.createMorphAt(element1,3,3);
      var morph2 = dom.createMorphAt(element0,3,3);
      inline(env, morph0, context, "period-chooser", [], {"period": get(env, context, "period")});
      inline(env, morph1, context, "text-field", [], {"value": get(env, context, "nameInput"), "placeholderKey": "directory.filter_name", "class": "filter-name"});
      block(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.loading")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/avatar_selector"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "bound-avatar-template", [get(env, context, "custom_avatar_template"), "large"], {});
          inline(env, morph1, context, "i18n", ["user.change_avatar.uploaded_avatar"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.change_avatar.uploaded_avatar_empty"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("input");
        dom.setAttribute(el2,"type","radio");
        dom.setAttribute(el2,"id","uploaded_avatar");
        dom.setAttribute(el2,"name","avatar");
        dom.setAttribute(el2,"value","uploaded");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","radio");
        dom.setAttribute(el2,"for","uploaded_avatar");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, get = hooks.get, block = hooks.block, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var element1 = dom.childAt(element0, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
        var morph1 = dom.createMorphAt(element0,5,5);
        element(env, element1, context, "action", ["useUploadedAvatar"], {});
        block(env, morph0, context, "if", [get(env, context, "custom_avatar_template")], {}, child0, child1);
        inline(env, morph1, context, "avatar-uploader", [], {"user_id": get(env, context, "id"), "uploadedAvatarTemplate": get(env, context, "custom_avatar_template"), "uploadedAvatarId": get(env, context, "custom_avatar_upload_id"), "uploading": get(env, context, "uploading"), "done": "useUploadedAvatar"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("input");
      dom.setAttribute(el4,"type","radio");
      dom.setAttribute(el4,"id","system-avatar");
      dom.setAttribute(el4,"name","avatar");
      dom.setAttribute(el4,"value","system");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","radio");
      dom.setAttribute(el4,"for","system-avatar");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode(" ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("input");
      dom.setAttribute(el4,"type","radio");
      dom.setAttribute(el4,"id","gravatar");
      dom.setAttribute(el4,"name","avatar");
      dom.setAttribute(el4,"value","gravatar");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","radio");
      dom.setAttribute(el4,"for","gravatar");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode(" ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode(" ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, get = hooks.get, inline = hooks.inline, content = hooks.content, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [0, 1]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(element3, [1]);
      var element5 = dom.childAt(element3, [3]);
      var element6 = dom.childAt(element2, [3]);
      var element7 = dom.childAt(element6, [1]);
      var element8 = dom.childAt(element6, [3]);
      var element9 = dom.childAt(fragment, [2]);
      var element10 = dom.childAt(element9, [3]);
      var morph0 = dom.createMorphAt(element5,0,0);
      var morph1 = dom.createUnsafeMorphAt(element5,2,2);
      var morph2 = dom.createMorphAt(element8,0,0);
      var morph3 = dom.createUnsafeMorphAt(element8,2,2);
      var morph4 = dom.createMorphAt(element8,4,4);
      var morph5 = dom.createMorphAt(element6,5,5);
      var morph6 = dom.createMorphAt(element2,5,5);
      var morph7 = dom.createMorphAt(element9,1,1);
      var morph8 = dom.createMorphAt(element10,0,0);
      element(env, element4, context, "action", ["useSystem"], {});
      inline(env, morph0, context, "bound-avatar-template", [get(env, context, "system_avatar_template"), "large"], {});
      inline(env, morph1, context, "i18n", ["user.change_avatar.letter_based"], {});
      element(env, element7, context, "action", ["useGravatar"], {});
      inline(env, morph2, context, "bound-avatar-template", [get(env, context, "gravatar_avatar_template"), "large"], {});
      inline(env, morph3, context, "i18n", ["user.change_avatar.gravatar"], {});
      content(env, morph4, context, "email");
      inline(env, morph5, context, "d-button", [], {"action": "refreshGravatar", "title": "user.change_avatar.refresh_gravatar_title", "disabled": get(env, context, "gravatarRefreshDisabled"), "icon": "refresh"});
      block(env, morph6, context, "if", [get(env, context, "allowAvatarUpload")], {}, child0, null);
      inline(env, morph7, context, "d-button", [], {"action": "saveAvatarSelection", "class": "btn-primary", "disabled": get(env, context, "uploading"), "label": "save"});
      element(env, element10, context, "action", ["closeModal"], {});
      inline(env, morph8, context, "i18n", ["cancel"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/bulk_actions_buttons"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "button", blockArguments[0]);
          inline(env, morph0, context, "d-button", [], {"action": get(env, context, "button.action"), "label": get(env, context, "button.label")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        set(env, context, "row", blockArguments[0]);
        block(env, morph0, context, "each", [get(env, context, "row")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "buttonRows")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/bulk_change_category"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "changeCategory", "label": "topics.bulk.change_category"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("p");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("p");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, null);
      inline(env, morph0, context, "i18n", ["topics.bulk.choose_new_category"], {});
      inline(env, morph1, context, "category-chooser", [], {"value": get(env, context, "newCategoryId")});
      block(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/bulk_notification_level"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","controls");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","radio");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode(" ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("strong");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","description");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
        var morph2 = dom.createUnsafeMorphAt(dom.childAt(element0, [5]),0,0);
        set(env, context, "level", blockArguments[0]);
        inline(env, morph0, context, "radio-button", [], {"value": get(env, context, "level.id"), "name": "notification_level", "selection": get(env, context, "notificationLevelId")});
        inline(env, morph1, context, "unbound", [get(env, context, "level.name")], {});
        inline(env, morph2, context, "unbound", [get(env, context, "level.description")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("button");
      dom.setAttribute(el1,"class","btn");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(element1,0,0);
      var attrMorph0 = dom.createAttrMorph(element1, 'disabled');
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "notificationLevels")], {}, child0, null);
      attribute(env, attrMorph0, element1, "disabled", get(env, context, "disabled"));
      element(env, element1, context, "action", ["changeNotificationLevel"], {});
      inline(env, morph1, context, "i18n", ["topics.bulk.notification_level"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/change-owner"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createTextNode("\n      ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      var el3 = dom.createTextNode("\n      ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"class","btn btn-primary");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [5]);
      var element2 = dom.childAt(fragment, [2, 1]);
      var morph0 = dom.createUnsafeMorphAt(element0,1,1);
      var morph1 = dom.createUnsafeMorphAt(dom.childAt(element0, [3]),1,1);
      var morph2 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph3 = dom.createMorphAt(element1,3,3);
      var morph4 = dom.createMorphAt(element2,0,0);
      var attrMorph0 = dom.createAttrMorph(element2, 'disabled');
      inline(env, morph0, context, "i18n", ["topic.change_owner.instructions"], {"count": get(env, context, "selectedPostsCount"), "old_user": get(env, context, "selectedPostsUsername")});
      inline(env, morph1, context, "i18n", ["topic.change_owner.instructions_warn"], {});
      inline(env, morph2, context, "i18n", ["topic.change_owner.label"], {});
      inline(env, morph3, context, "user-selector", [], {"single": "true", "usernames": get(env, context, "new_user"), "placeholderKey": "topic.change_owner.placeholder"});
      attribute(env, attrMorph0, element2, "disabled", get(env, context, "buttonDisabled"));
      element(env, element2, context, "action", ["changeOwnershipOfPosts"], {});
      content(env, morph4, context, "buttonTitle");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/change-timestamp"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body change-timestamp");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","date-container");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"class","btn btn-primary");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [3]);
      var element2 = dom.childAt(element0, [5]);
      var element3 = dom.childAt(fragment, [2, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
      var morph1 = dom.createMorphAt(element1,1,1);
      var attrMorph0 = dom.createAttrMorph(element1, 'class');
      var morph2 = dom.createMorphAt(element2,1,1);
      var morph3 = dom.createMorphAt(element2,3,3);
      var morph4 = dom.createMorphAt(element3,0,0);
      var attrMorph1 = dom.createAttrMorph(element3, 'disabled');
      inline(env, morph0, context, "i18n", ["topic.change_timestamp.instructions"], {});
      attribute(env, attrMorph0, element1, "class", concat(env, ["alert alert-error ", subexpr(env, context, "unless", [get(env, context, "validTimestamp"), "hidden"], {})]));
      inline(env, morph1, context, "i18n", ["topic.change_timestamp.invalid_timestamp"], {});
      inline(env, morph2, context, "date-picker-past", [], {"value": get(env, context, "date"), "containerId": "date-container"});
      inline(env, morph3, context, "input", [], {"type": "time", "value": get(env, context, "time")});
      attribute(env, attrMorph1, element3, "disabled", get(env, context, "buttonDisabled"));
      element(env, element3, context, "action", ["changeTimestamp"], {});
      content(env, morph4, context, "buttonTitle");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/create-account"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "login-buttons", [], {"action": "externalLogin"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            dom.setAttribute(el1,"class","input");
            var el2 = dom.createTextNode("\n                ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"class","label");
            var el3 = dom.createElement("label");
            dom.setAttribute(el3,"for","new-account-username");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n                ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n                ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n                 ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n                ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            dom.setAttribute(el1,"class","instructions");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createElement("label");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element9 = dom.childAt(fragment, [1]);
            var element10 = dom.childAt(element9, [3]);
            var morph0 = dom.createMorphAt(dom.childAt(element9, [1, 0]),0,0);
            var morph1 = dom.createMorphAt(element10,1,1);
            var morph2 = dom.createMorphAt(element10,3,3);
            var morph3 = dom.createMorphAt(dom.childAt(fragment, [3, 3, 0]),0,0);
            inline(env, morph0, context, "i18n", ["user.username.title"], {});
            inline(env, morph1, context, "input", [], {"value": get(env, context, "accountUsername"), "id": "new-account-username", "name": "username", "maxlength": get(env, context, "maxUsernameLength")});
            inline(env, morph2, context, "input-tip", [], {"validation": get(env, context, "usernameValidation"), "id": "username-validation"});
            inline(env, morph3, context, "i18n", ["user.username.instructions"], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            dom.setAttribute(el1,"class","input");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"style","width:80px");
            dom.setAttribute(el2,"class","label");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("label");
            dom.setAttribute(el3,"for","new-account-name");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"style","width:496px");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode(" ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            dom.setAttribute(el1,"class","instructions");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createElement("label");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element7 = dom.childAt(fragment, [1]);
            var element8 = dom.childAt(element7, [3]);
            var morph0 = dom.createMorphAt(dom.childAt(element7, [1, 1]),0,0);
            var morph1 = dom.createMorphAt(element8,1,1);
            var morph2 = dom.createMorphAt(element8,3,3);
            var morph3 = dom.createMorphAt(dom.childAt(fragment, [3, 3, 0]),0,0);
            inline(env, morph0, context, "i18n", ["user.name.title"], {});
            inline(env, morph1, context, "text-field", [], {"value": get(env, context, "accountName"), "id": "new-account-name"});
            inline(env, morph2, context, "input-tip", [], {"validation": get(env, context, "nameValidation")});
            content(env, morph3, context, "nameInstructions");
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            dom.setAttribute(el1,"class","input");
            var el2 = dom.createTextNode("\n              ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"class","label");
            var el3 = dom.createElement("label");
            dom.setAttribute(el3,"for","new-account-password");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n              ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n               ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            dom.setAttribute(el1,"class","instructions");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("label");
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            var el4 = dom.createElement("i");
            dom.setAttribute(el4,"class","fa fa-exclamation-triangle");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode(" ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element3 = dom.childAt(fragment, [1]);
            var element4 = dom.childAt(element3, [3]);
            var element5 = dom.childAt(fragment, [3, 3]);
            var element6 = dom.childAt(element5, [3]);
            var morph0 = dom.createMorphAt(dom.childAt(element3, [1, 0]),0,0);
            var morph1 = dom.createMorphAt(element4,1,1);
            var morph2 = dom.createMorphAt(element4,3,3);
            var morph3 = dom.createMorphAt(dom.childAt(element5, [1]),0,0);
            var attrMorph0 = dom.createAttrMorph(element6, 'class');
            var morph4 = dom.createMorphAt(element6,2,2);
            inline(env, morph0, context, "i18n", ["user.password.title"], {});
            inline(env, morph1, context, "password-field", [], {"value": get(env, context, "accountPassword"), "type": "password", "id": "new-account-password", "capsLockOn": get(env, context, "capsLockOn")});
            inline(env, morph2, context, "input-tip", [], {"validation": get(env, context, "passwordValidation")});
            content(env, morph3, context, "passwordInstructions");
            attribute(env, attrMorph0, element6, "class", concat(env, ["caps-lock-warning ", subexpr(env, context, "unless", [get(env, context, "capsLockOn"), "invisible"], {})]));
            inline(env, morph4, context, "i18n", ["login.caps_lock_warning"], {});
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              set(env, context, "f", blockArguments[0]);
              inline(env, morph0, context, "user-field", [], {"field": get(env, context, "f.field"), "value": get(env, context, "f.value")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","user-fields");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            block(env, morph0, context, "each", [get(env, context, "userFields")], {}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("form");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("table");
          var el4 = dom.createTextNode("\n\n        ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("tr");
          dom.setAttribute(el4,"class","input");
          var el5 = dom.createTextNode("\n              ");
          dom.appendChild(el4, el5);
          var el5 = dom.createElement("td");
          dom.setAttribute(el5,"class","label");
          var el6 = dom.createElement("label");
          dom.setAttribute(el6,"for","new-account-email");
          var el7 = dom.createComment("");
          dom.appendChild(el6, el7);
          dom.appendChild(el5, el6);
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n              ");
          dom.appendChild(el4, el5);
          var el5 = dom.createElement("td");
          var el6 = dom.createTextNode("\n              ");
          dom.appendChild(el5, el6);
          var el6 = dom.createComment("");
          dom.appendChild(el5, el6);
          var el6 = dom.createTextNode("\n               ");
          dom.appendChild(el5, el6);
          var el6 = dom.createComment("");
          dom.appendChild(el5, el6);
          var el6 = dom.createTextNode("\n              ");
          dom.appendChild(el5, el6);
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n        ");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("tr");
          dom.setAttribute(el4,"class","instructions");
          var el5 = dom.createTextNode("\n          ");
          dom.appendChild(el4, el5);
          var el5 = dom.createElement("td");
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n          ");
          dom.appendChild(el4, el5);
          var el5 = dom.createElement("td");
          var el6 = dom.createElement("label");
          var el7 = dom.createComment("");
          dom.appendChild(el6, el7);
          dom.appendChild(el5, el6);
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n        ");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("tr");
          dom.setAttribute(el4,"class","password-confirmation");
          var el5 = dom.createTextNode("\n          ");
          dom.appendChild(el4, el5);
          var el5 = dom.createElement("td");
          var el6 = dom.createElement("label");
          dom.setAttribute(el6,"for","new-account-password-confirmation");
          var el7 = dom.createComment("");
          dom.appendChild(el6, el7);
          dom.appendChild(el5, el6);
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n          ");
          dom.appendChild(el4, el5);
          var el5 = dom.createElement("td");
          var el6 = dom.createTextNode("\n            ");
          dom.appendChild(el5, el6);
          var el6 = dom.createComment("");
          dom.appendChild(el5, el6);
          var el6 = dom.createTextNode("\n            ");
          dom.appendChild(el5, el6);
          var el6 = dom.createComment("");
          dom.appendChild(el5, el6);
          var el6 = dom.createTextNode("\n          ");
          dom.appendChild(el5, el6);
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n        ");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n\n        ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element11 = dom.childAt(fragment, [1, 1]);
          var element12 = dom.childAt(element11, [1]);
          var element13 = dom.childAt(element12, [1]);
          var element14 = dom.childAt(element13, [3]);
          var element15 = dom.childAt(element12, [13]);
          var element16 = dom.childAt(element15, [3]);
          var morph0 = dom.createMorphAt(dom.childAt(element13, [1, 0]),0,0);
          var morph1 = dom.createMorphAt(element14,1,1);
          var morph2 = dom.createMorphAt(element14,3,3);
          var morph3 = dom.createMorphAt(dom.childAt(element12, [3, 3, 0]),0,0);
          var morph4 = dom.createMorphAt(element12,5,5);
          var morph5 = dom.createMorphAt(element12,7,7);
          var morph6 = dom.createMorphAt(element12,9,9);
          var morph7 = dom.createMorphAt(element12,11,11);
          var morph8 = dom.createMorphAt(dom.childAt(element15, [1, 0]),0,0);
          var morph9 = dom.createMorphAt(element16,1,1);
          var morph10 = dom.createMorphAt(element16,3,3);
          var morph11 = dom.createMorphAt(element11,3,3);
          inline(env, morph0, context, "i18n", ["user.email.title"], {});
          inline(env, morph1, context, "input", [], {"type": "email", "value": get(env, context, "accountEmail"), "id": "new-account-email", "disabled": get(env, context, "emailValidated"), "name": "email", "autofocus": "autofocus"});
          inline(env, morph2, context, "input-tip", [], {"validation": get(env, context, "emailValidation")});
          inline(env, morph3, context, "i18n", ["user.email.instructions"], {});
          block(env, morph4, context, "if", [get(env, context, "usernameRequired")], {}, child0, null);
          block(env, morph5, context, "if", [get(env, context, "siteSettings.enable_names")], {}, child1, null);
          inline(env, morph6, context, "plugin-outlet", ["create-account-before-password"], {});
          block(env, morph7, context, "if", [get(env, context, "passwordRequired")], {}, child2, null);
          inline(env, morph8, context, "i18n", ["user.password_confirmation.title"], {});
          inline(env, morph9, context, "input", [], {"type": "password", "value": get(env, context, "accountPasswordConfirm"), "id": "new-account-confirmation"});
          inline(env, morph10, context, "input", [], {"value": get(env, context, "accountChallenge"), "id": "new-account-challenge"});
          block(env, morph11, context, "if", [get(env, context, "userFields")], {}, child3, null);
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("button");
            dom.setAttribute(el1,"class","btn btn-large");
            dom.setAttribute(el1,"id","login-link");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element0,1,1);
            element(env, element0, context, "action", ["showLogin"], {});
            inline(env, morph0, context, "i18n", ["log_in"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","modal-footer");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("button");
          dom.setAttribute(el2,"class","btn btn-large btn-primary");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1]);
          var element2 = dom.childAt(element1, [1]);
          var morph0 = dom.createMorphAt(element2,0,0);
          var attrMorph0 = dom.createAttrMorph(element2, 'disabled');
          var morph1 = dom.createMorphAt(element1,3,3);
          attribute(env, attrMorph0, element2, "disabled", get(env, context, "submitDisabled"));
          element(env, element2, context, "action", ["createAccount"], {});
          inline(env, morph0, context, "i18n", ["create_account.title"], {});
          block(env, morph1, context, "conditional-loading-spinner", [], {"condition": get(env, context, "formSubmitted"), "size": "small"}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","modal-body");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element17 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element17,1,1);
        var morph1 = dom.createMorphAt(element17,3,3);
        var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        block(env, morph0, context, "unless", [get(env, context, "hasAuthOptions")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "showCreateForm")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "showCreateForm")], {}, child2, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "unless", [get(env, context, "complete")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/dismiss-read"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"class","btn btn-primary");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [2, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0, 1]),1,1);
      var morph1 = dom.createMorphAt(element0,0,0);
      inline(env, morph0, context, "preference-checkbox", [], {"labelKey": "topics.bulk.also_dismiss_topics", "checked": get(env, context, "dismissTopics")});
      element(env, element0, context, "action", ["dismissReadTopics", get(env, context, "dismissTopics")], {});
      inline(env, morph1, context, "i18n", ["topics.bulk.dismiss"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/edit-category"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "edit-category-tab", [], {"panels": get(env, context, "panels"), "selectedTab": get(env, context, "selectedTab"), "tab": "security"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "tab", blockArguments[0]);
        inline(env, morph0, context, "component", [get(env, context, "tab")], {"selectedTab": get(env, context, "selectedTab"), "category": get(env, context, "model")});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"class": "btn-danger pull-right", "disabled": get(env, context, "deleteDisabled"), "action": "deleteCategory", "icon": "trash-o", "label": "category.delete"});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","cannot_delete_reason");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),1,1);
        content(env, morph0, context, "model.cannot_delete_reason");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("ul");
      dom.setAttribute(el2,"class","nav nav-pills");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-body");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-footer");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [1]);
      var element2 = dom.childAt(element0, [5]);
      var morph0 = dom.createMorphAt(element1,1,1);
      var morph1 = dom.createMorphAt(element1,3,3);
      var morph2 = dom.createMorphAt(element1,5,5);
      var morph3 = dom.createMorphAt(element1,7,7);
      var morph4 = dom.createMorphAt(element1,9,9);
      var morph5 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
      var morph6 = dom.createMorphAt(element2,1,1);
      var morph7 = dom.createMorphAt(element2,3,3);
      inline(env, morph0, context, "edit-category-tab", [], {"panels": get(env, context, "panels"), "selectedTab": get(env, context, "selectedTab"), "tab": "general"});
      block(env, morph1, context, "unless", [get(env, context, "model.isUncategorizedCategory")], {}, child0, null);
      inline(env, morph2, context, "edit-category-tab", [], {"panels": get(env, context, "panels"), "selectedTab": get(env, context, "selectedTab"), "tab": "settings"});
      inline(env, morph3, context, "edit-category-tab", [], {"panels": get(env, context, "panels"), "selectedTab": get(env, context, "selectedTab"), "tab": "images"});
      inline(env, morph4, context, "edit-category-tab", [], {"panels": get(env, context, "panels"), "selectedTab": get(env, context, "selectedTab"), "tab": "topic-template"});
      block(env, morph5, context, "each", [get(env, context, "panels")], {}, child1, null);
      inline(env, morph6, context, "d-button", [], {"id": "save-category", "class": "btn-primary", "disabled": get(env, context, "disabled"), "action": "saveCategory", "label": get(env, context, "saveLabel")});
      block(env, morph7, context, "if", [get(env, context, "model.can_delete")], {}, child2, child3);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/edit-topic-auto-close"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","warning");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(element0,3,3);
        inline(env, morph0, context, "fa-icon", ["warning"], {});
        content(env, morph1, context, "willCloseI18n");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-body");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-footer");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("a");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var element2 = dom.childAt(element1, [1]);
      var element3 = dom.childAt(element1, [3]);
      var element4 = dom.childAt(element3, [3]);
      var morph0 = dom.createMorphAt(element2,1,1);
      var morph1 = dom.createMorphAt(element2,3,3);
      var morph2 = dom.createMorphAt(element3,1,1);
      var morph3 = dom.createMorphAt(element4,0,0);
      var morph4 = dom.createMorphAt(element3,5,5);
      var morph5 = dom.createMorphAt(element3,7,7);
      inline(env, morph0, context, "auto-close-form", [], {"autoCloseTime": get(env, context, "model.auto_close_time"), "autoCloseValid": get(env, context, "auto_close_valid"), "autoCloseBasedOnLastPost": get(env, context, "model.details.auto_close_based_on_last_post"), "limited": get(env, context, "model.details.auto_close_based_on_last_post")});
      block(env, morph1, context, "if", [get(env, context, "willCloseImmediately")], {}, child0, null);
      inline(env, morph2, context, "d-button", [], {"class": "btn-primary", "disabled": get(env, context, "disable_submit"), "label": "topic.auto_close_save", "action": "saveAutoClose"});
      element(env, element4, context, "action", ["closeModal"], {});
      inline(env, morph3, context, "i18n", ["cancel"], {});
      inline(env, morph4, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "loading")});
      inline(env, morph5, context, "d-button", [], {"class": "pull-right", "action": "removeAutoClose", "label": "topic.auto_close_remove"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/feature-topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "i18n", ["topic.feature_topic.already_pinned_globally"], {"count": get(env, context, "pinnedGloballyCount")});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "i18n", ["topic.feature_topic.not_pinned_globally"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "pinnedGloballyCount")], {}, child0, child1);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
          block(env, morph0, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "loading")}, child0, null);
          inline(env, morph1, context, "i18n", ["topic.feature_topic.global_pin_note"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
            content(env, morph0, context, "alreadyPinnedMessage");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
          block(env, morph0, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "loading")}, child0, null);
          inline(env, morph1, context, "i18n", ["topic.feature_topic.pin_note"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","feature-section");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","desc");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, content = hooks.content, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element4 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element4,1,1);
        var morph1 = dom.createUnsafeMorphAt(dom.childAt(element4, [3]),0,0);
        var morph2 = dom.createMorphAt(dom.childAt(element4, [5]),0,0);
        block(env, morph0, context, "if", [get(env, context, "model.pinned_globally")], {}, child0, child1);
        content(env, morph1, context, "unPinMessage");
        inline(env, morph2, context, "d-button", [], {"action": "unpin", "icon": "thumb-tack", "label": "topic.feature.unpin", "class": "btn-primary"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
          content(env, morph0, context, "alreadyPinnedMessage");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "i18n", ["topic.feature_topic.already_pinned_globally"], {"count": get(env, context, "pinnedGloballyCount")});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "i18n", ["topic.feature_topic.not_pinned_globally"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "pinnedGloballyCount")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","feature-section");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","desc");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        dom.setAttribute(el3,"class","with-validation");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("hr");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","feature-section");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","desc");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        dom.setAttribute(el3,"class","with-validation");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 1]);
        var element1 = dom.childAt(element0, [5]);
        var element2 = dom.childAt(fragment, [5, 1]);
        var element3 = dom.childAt(element2, [5]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
        var morph2 = dom.createUnsafeMorphAt(element1,1,1);
        var morph3 = dom.createMorphAt(element1,3,3);
        var morph4 = dom.createMorphAt(element1,5,5);
        var morph5 = dom.createMorphAt(element1,7,7);
        var morph6 = dom.createMorphAt(dom.childAt(element0, [7]),1,1);
        var morph7 = dom.createMorphAt(dom.childAt(element2, [1]),1,1);
        var morph8 = dom.createMorphAt(dom.childAt(element2, [3]),1,1);
        var morph9 = dom.createMorphAt(element3,1,1);
        var morph10 = dom.createMorphAt(element3,3,3);
        var morph11 = dom.createMorphAt(element3,5,5);
        var morph12 = dom.createMorphAt(element3,7,7);
        var morph13 = dom.createMorphAt(dom.childAt(element2, [7]),1,1);
        block(env, morph0, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "loading")}, child0, null);
        inline(env, morph1, context, "i18n", ["topic.feature_topic.pin_note"], {});
        content(env, morph2, context, "pinMessage");
        inline(env, morph3, context, "fa-icon", ["clock-o"], {});
        inline(env, morph4, context, "date-picker-future", [], {"value": get(env, context, "model.pinnedInCategoryUntil")});
        inline(env, morph5, context, "popup-input-tip", [], {"validation": get(env, context, "pinInCategoryValidation"), "shownAt": get(env, context, "pinInCategoryTipShownAt")});
        inline(env, morph6, context, "d-button", [], {"action": "pin", "icon": "thumb-tack", "label": "topic.feature.pin", "class": "btn-primary"});
        block(env, morph7, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "loading")}, child1, null);
        inline(env, morph8, context, "i18n", ["topic.feature_topic.global_pin_note"], {});
        inline(env, morph9, context, "i18n", ["topic.feature_topic.pin_globally"], {});
        inline(env, morph10, context, "fa-icon", ["clock-o"], {});
        inline(env, morph11, context, "date-picker-future", [], {"value": get(env, context, "model.pinnedGloballyUntil")});
        inline(env, morph12, context, "popup-input-tip", [], {"validation": get(env, context, "pinGloballyValidation"), "shownAt": get(env, context, "pinGloballyTipShownAt")});
        inline(env, morph13, context, "d-button", [], {"action": "pinGlobally", "icon": "thumb-tack", "label": "topic.feature.pin_globally", "class": "btn-primary"});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["topic.feature_topic.banner_exists"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["topic.feature_topic.no_banner_exists"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "bannerCount")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["topic.feature_topic.remove_banner"], {});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["topic.feature_topic.make_banner"], {});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "removeBanner", "icon": "thumb-tack", "label": "topic.feature.remove_banner", "class": "btn-primary"});
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "makeBanner", "icon": "thumb-tack", "label": "topic.feature.make_banner", "class": "btn-primary"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body feature-topic");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("hr");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","feature-section");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","desc");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("p");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("p");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("p");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("p");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      dom.setAttribute(el2,"class","pull-right");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element5 = dom.childAt(fragment, [0]);
      var element6 = dom.childAt(element5, [5, 1]);
      var element7 = dom.childAt(fragment, [2, 1]);
      var morph0 = dom.createMorphAt(element5,1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element6, [1]),1,1);
      var morph2 = dom.createMorphAt(dom.childAt(element6, [3]),1,1);
      var morph3 = dom.createMorphAt(dom.childAt(element6, [5]),1,1);
      var morph4 = dom.createMorphAt(dom.childAt(element6, [7]),1,1);
      var morph5 = dom.createMorphAt(element7,0,0);
      block(env, morph0, context, "if", [get(env, context, "model.pinned_at")], {}, child0, child1);
      block(env, morph1, context, "conditional-loading-spinner", [], {"size": "small", "condition": get(env, context, "loading")}, child2, null);
      inline(env, morph2, context, "i18n", ["topic.feature_topic.banner_note"], {});
      block(env, morph3, context, "if", [get(env, context, "model.isBanner")], {}, child3, child4);
      block(env, morph4, context, "if", [get(env, context, "model.isBanner")], {}, child5, child6);
      element(env, element7, context, "action", ["closeModal"], {});
      inline(env, morph5, context, "i18n", ["cancel"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/flag"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "f", blockArguments[0]);
        inline(env, morph0, context, "flag-action-type", [], {"flag": get(env, context, "f"), "message": get(env, context, "message"), "isWarning": get(env, context, "isWarning"), "selectedFlag": get(env, context, "selected"), "username": get(env, context, "model.username"), "staffFlagsAvailable": get(env, context, "staffFlagsAvailable"), "changePostActionType": "changePostActionType"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["flagging.cant"], {});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-danger");
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-exclamation-triangle");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, concat = hooks.concat, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var attrMorph0 = dom.createAttrMorph(element2, 'disabled');
        var attrMorph1 = dom.createAttrMorph(element2, 'title');
        var morph0 = dom.createMorphAt(element2,2,2);
        attribute(env, attrMorph0, element2, "disabled", get(env, context, "submitDisabled"));
        attribute(env, attrMorph1, element2, "title", concat(env, [subexpr(env, context, "i18n", ["flagging.official_warning"], {})]));
        element(env, element2, context, "action", ["createFlagAsWarning"], {});
        inline(env, morph0, context, "i18n", ["flagging.official_warning"], {});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-danger");
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-gavel");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, concat = hooks.concat, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var attrMorph0 = dom.createAttrMorph(element1, 'disabled');
        var attrMorph1 = dom.createAttrMorph(element1, 'title');
        var morph0 = dom.createMorphAt(element1,1,1);
        attribute(env, attrMorph0, element1, "disabled", get(env, context, "submitDisabled"));
        attribute(env, attrMorph1, element1, "title", concat(env, [subexpr(env, context, "i18n", ["flagging.take_action_tooltip"], {})]));
        element(env, element1, context, "action", ["takeAction"], {});
        inline(env, morph0, context, "i18n", ["flagging.take_action"], {});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-danger");
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-exclamation-triangle");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, concat = hooks.concat, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var attrMorph0 = dom.createAttrMorph(element0, 'disabled');
        var attrMorph1 = dom.createAttrMorph(element0, 'title');
        var morph0 = dom.createMorphAt(element0,2,2);
        attribute(env, attrMorph0, element0, "disabled", get(env, context, "submitDisabled"));
        attribute(env, attrMorph1, element0, "title", concat(env, [subexpr(env, context, "i18n", ["flagging.delete_spammer"], {})]));
        element(env, element0, context, "action", ["deleteSpammer", get(env, context, "userDetails")], {});
        inline(env, morph0, context, "i18n", ["flagging.delete_spammer"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body flag-modal");
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"class","btn btn-primary");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, attribute = hooks.attribute, subexpr = hooks.subexpr, concat = hooks.concat, element = hooks.element, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [2]);
      var element4 = dom.childAt(element3, [1]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0, 1]),1,1);
      var morph1 = dom.createUnsafeMorphAt(element4,0,0);
      var attrMorph0 = dom.createAttrMorph(element4, 'disabled');
      var attrMorph1 = dom.createAttrMorph(element4, 'title');
      var morph2 = dom.createMorphAt(element3,3,3);
      var morph3 = dom.createMorphAt(element3,5,5);
      var morph4 = dom.createMorphAt(element3,7,7);
      block(env, morph0, context, "each", [get(env, context, "flagsAvailable")], {}, child0, child1);
      attribute(env, attrMorph0, element4, "disabled", get(env, context, "submitDisabled"));
      attribute(env, attrMorph1, element4, "title", concat(env, [subexpr(env, context, "i18n", ["flagging.submit_tooltip"], {})]));
      element(env, element4, context, "action", ["createFlag"], {});
      content(env, morph1, context, "submitText");
      block(env, morph2, context, "if", [get(env, context, "canSendWarning")], {}, child2, null);
      block(env, morph3, context, "if", [get(env, context, "canTakeAction")], {}, child3, null);
      block(env, morph4, context, "if", [get(env, context, "canDeleteSpammer")], {}, child4, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/forgot-password"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      var el2 = dom.createTextNode("\n    ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-body");
      var el3 = dom.createTextNode("\n      ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      dom.setAttribute(el3,"for","username-or-email");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n      ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n    ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-footer");
      var el3 = dom.createTextNode("\n      ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("button");
      dom.setAttribute(el3,"class","btn btn-large btn-primary");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, attribute = hooks.attribute, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [1]);
      var element2 = dom.childAt(element0, [3, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph1 = dom.createMorphAt(element1,3,3);
      var morph2 = dom.createMorphAt(element2,0,0);
      var attrMorph0 = dom.createAttrMorph(element2, 'disabled');
      inline(env, morph0, context, "i18n", ["forgot_password.invite"], {});
      inline(env, morph1, context, "text-field", [], {"value": get(env, context, "accountEmailOrUsername"), "placeholderKey": "login.email_placeholder", "id": "username-or-email", "autocorrect": "off", "autocapitalize": "off"});
      attribute(env, attrMorph0, element2, "disabled", get(env, context, "submitDisabled"));
      element(env, element2, context, "action", ["submit"], {});
      inline(env, morph2, context, "i18n", ["forgot_password.reset"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/history"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "revisionsText");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "displaySideBySide", "label": "post.revisions.displays.side_by_side.button", "title": "post.revisions.displays.side_by_side.title", "class": get(env, context, "sideBySideClass")});
        inline(env, morph1, context, "d-button", [], {"action": "displaySideBySideMarkdown", "label": "post.revisions.displays.side_by_side_markdown.button", "title": "post.revisions.displays.side_by_side_markdown.title", "class": get(env, context, "sideBySideMarkdownClass")});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode(" ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "bound-avatar-template", [get(env, context, "model.avatar_template"), "small"], {});
        content(env, morph1, context, "model.username");
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      — ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","edit-reason");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        content(env, morph0, context, "model.edit_reason");
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        — ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode(" ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        → ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode(" ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
          var morph3 = dom.createMorphAt(fragment,7,7,contextualElement);
          inline(env, morph0, context, "bound-avatar-template", [get(env, context, "model.user_changes.previous.avatar_template"), "small"], {});
          content(env, morph1, context, "model.user_changes.previous.username");
          inline(env, morph2, context, "bound-avatar-template", [get(env, context, "model.user_changes.current.avatar_template"), "small"], {});
          content(env, morph3, context, "model.user_changes.current.username");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        — ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "disabled-icon", [], {"icon": "pencil-square-o", "secondary": get(env, context, "wikiDisabled")});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        — ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "disabled-icon", [], {"icon": "shield", "disabled": get(env, context, "postTypeDisabled")});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        — ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode(" → ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createUnsafeMorphAt(fragment,3,3,contextualElement);
          content(env, morph0, context, "previousCategory");
          content(env, morph1, context, "currentCategory");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph2 = dom.createMorphAt(fragment,2,2,contextualElement);
        var morph3 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "model.user_changes")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "model.wiki_changes")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "model.post_type_changes")], {}, child2, null);
        block(env, morph3, context, "if", [get(env, context, "model.category_id_changes")], {}, child3, null);
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","row");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("h2");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1, 1]),0,0);
        content(env, morph0, context, "titleDiff");
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","row");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          → ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element2 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element2,1,1);
          var morph1 = dom.createMorphAt(element2,3,3);
          var morph2 = dom.createMorphAt(element2,5,5);
          var morph3 = dom.createMorphAt(element2,7,7);
          inline(env, morph0, context, "bound-avatar-template", [get(env, context, "model.user_changes.previous.avatar_template"), "small"], {});
          content(env, morph1, context, "model.user_changes.previous.username");
          inline(env, morph2, context, "bound-avatar-template", [get(env, context, "model.user_changes.current.avatar_template"), "small"], {});
          content(env, morph3, context, "model.user_changes.current.username");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","row");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "disabled-icon", [], {"icon": "pencil-square-o", "secondary": get(env, context, "wikiDisabled")});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","row");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "disabled-icon", [], {"icon": "shield", "disabled": get(env, context, "postTypeDisabled")});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","row");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" → ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1]);
          var morph0 = dom.createUnsafeMorphAt(element1,1,1);
          var morph1 = dom.createUnsafeMorphAt(element1,3,3);
          content(env, morph0, context, "previousCategory");
          content(env, morph1, context, "currentCategory");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph2 = dom.createMorphAt(fragment,2,2,contextualElement);
        var morph3 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "user_changes")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "model.wiki_changes")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "model.post_type_changes")], {}, child2, null);
        block(env, morph3, context, "if", [get(env, context, "model.category_id_changes")], {}, child3, null);
        return fragment;
      }
    };
  }());
  var child7 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "t", blockArguments[0]);
          inline(env, morph0, context, "discourse-tag", [get(env, context, "t")], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "t", blockArguments[0]);
          inline(env, morph0, context, "discourse-tag", [get(env, context, "t")], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","row");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("        →\n         \n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(element0,3,3);
        var morph2 = dom.createMorphAt(element0,5,5);
        inline(env, morph0, context, "i18n", ["tagging.changed"], {});
        block(env, morph1, context, "each", [get(env, context, "previousTagChanges")], {}, child0, null);
        block(env, morph2, context, "each", [get(env, context, "currentTagChanges")], {}, child1, null);
        return fragment;
      }
    };
  }());
  var child8 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "revertToVersion", "icon": "undo", "label": "post.revisions.controls.revert", "class": "btn-danger", "disabled": get(env, context, "loading")});
        return fragment;
      }
    };
  }());
  var child9 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "hideVersion", "icon": "eye-slash", "label": "post.revisions.controls.hide", "class": "btn-danger", "disabled": get(env, context, "loading")});
        return fragment;
      }
    };
  }());
  var child10 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "showVersion", "icon": "eye", "label": "post.revisions.controls.show", "disabled": get(env, context, "loading")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"id","revision-controls");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"id","revision-numbers");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"id","display-modes");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","revision-details");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      dom.setAttribute(el3,"class","date");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","revisions");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","row");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [0]);
      var element4 = dom.childAt(element3, [1]);
      var element5 = dom.childAt(element4, [1]);
      var element6 = dom.childAt(element5, [5]);
      var element7 = dom.childAt(element4, [3]);
      var element8 = dom.childAt(element3, [3]);
      var element9 = dom.childAt(element3, [5]);
      var morph0 = dom.createMorphAt(element5,1,1);
      var morph1 = dom.createMorphAt(element5,3,3);
      var morph2 = dom.createMorphAt(element6,1,1);
      var attrMorph0 = dom.createAttrMorph(element6, 'class');
      var morph3 = dom.createMorphAt(element5,7,7);
      var morph4 = dom.createMorphAt(element5,9,9);
      var morph5 = dom.createMorphAt(element7,1,1);
      var morph6 = dom.createMorphAt(element7,3,3);
      var morph7 = dom.createMorphAt(element8,1,1);
      var morph8 = dom.createMorphAt(element8,3,3);
      var morph9 = dom.createMorphAt(dom.childAt(element8, [5]),0,0);
      var morph10 = dom.createMorphAt(element8,7,7);
      var morph11 = dom.createMorphAt(element8,8,8);
      var morph12 = dom.createMorphAt(element9,1,1);
      var morph13 = dom.createMorphAt(element9,2,2);
      var morph14 = dom.createMorphAt(element9,3,3);
      var morph15 = dom.createMorphAt(element9,5,5);
      var attrMorph1 = dom.createAttrMorph(element9, 'data-post-id');
      var attrMorph2 = dom.createAttrMorph(element9, 'class');
      var morph16 = dom.createUnsafeMorphAt(dom.childAt(element9, [7]),1,1);
      var morph17 = dom.createMorphAt(element9,9,9);
      var morph18 = dom.createMorphAt(element9,10,10);
      var morph19 = dom.createMorphAt(element9,11,11);
      inline(env, morph0, context, "d-button", [], {"action": "loadFirstVersion", "icon": "fast-backward", "title": "post.revisions.controls.first", "disabled": get(env, context, "loadFirstDisabled")});
      inline(env, morph1, context, "d-button", [], {"action": "loadPreviousVersion", "icon": "backward", "title": "post.revisions.controls.previous", "disabled": get(env, context, "loadPreviousDisabled")});
      attribute(env, attrMorph0, element6, "class", concat(env, [subexpr(env, context, "unless", [get(env, context, "displayRevisions"), "invisible"], {})]));
      block(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading"), "size": "small"}, child0, null);
      inline(env, morph3, context, "d-button", [], {"action": "loadNextVersion", "icon": "forward", "title": "post.revisions.controls.next", "disabled": get(env, context, "loadNextDisabled")});
      inline(env, morph4, context, "d-button", [], {"action": "loadLastVersion", "icon": "fast-forward", "title": "post.revisions.controls.last", "disabled": get(env, context, "loadLastDisabled")});
      inline(env, morph5, context, "d-button", [], {"action": "displayInline", "label": "post.revisions.displays.inline.button", "title": "post.revisions.displays.inline.title", "class": get(env, context, "inlineClass")});
      block(env, morph6, context, "unless", [get(env, context, "site.mobileView")], {}, child1, null);
      inline(env, morph7, context, "fa-icon", ["pencil"], {});
      block(env, morph8, context, "link-to", ["user", get(env, context, "model.username")], {}, child2, null);
      inline(env, morph9, context, "bound-date", [get(env, context, "model.created_at")], {});
      block(env, morph10, context, "if", [get(env, context, "model.edit_reason")], {}, child3, null);
      block(env, morph11, context, "unless", [get(env, context, "site.mobileView")], {}, child4, null);
      attribute(env, attrMorph1, element9, "data-post-id", concat(env, [get(env, context, "model.post_id")]));
      attribute(env, attrMorph2, element9, "class", get(env, context, "hiddenClasses"));
      block(env, morph12, context, "if", [get(env, context, "model.title_changes")], {}, child5, null);
      block(env, morph13, context, "if", [get(env, context, "site.mobileView")], {}, child6, null);
      block(env, morph14, context, "if", [get(env, context, "model.tags_changes")], {}, child7, null);
      inline(env, morph15, context, "plugin-outlet", ["post-revisions"], {});
      content(env, morph16, context, "bodyDiff");
      block(env, morph17, context, "if", [get(env, context, "displayRevert")], {}, child8, null);
      block(env, morph18, context, "if", [get(env, context, "displayHide")], {}, child9, null);
      block(env, morph19, context, "if", [get(env, context, "displayShow")], {}, child10, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/invite"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","alert alert-error");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("button");
        dom.setAttribute(el2,"class","close");
        dom.setAttribute(el2,"data-dismiss","alert");
        var el3 = dom.createTextNode("×");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),3,3);
        content(env, morph0, context, "errorMessage");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "successMessage");
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "user-selector", [], {"single": "true", "allowAny": true, "excludeCurrentUser": "true", "usernames": get(env, context, "emailOrUsername"), "allowedUsers": "true", "topicId": get(env, context, "topicId"), "placeholderKey": get(env, context, "placeholderKey")});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "user-selector", [], {"single": "true", "allowAny": true, "excludeCurrentUser": "true", "usernames": get(env, context, "emailOrUsername"), "placeholderKey": get(env, context, "placeholderKey")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "isPrivateTopic")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "text-field", [], {"value": get(env, context, "emailOrUsername"), "placeholderKey": "topic.invite_reply.email_placeholder"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("label");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          content(env, morph0, context, "groupInstructions");
          inline(env, morph1, context, "group-selector", [], {"groupFinder": get(env, context, "groupFinder"), "groupNames": get(env, context, "model.groupNames"), "placeholderKey": "topic.invite_private.group_name"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("label");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
        dom.insertBoundary(fragment, null);
        content(env, morph0, context, "inviteInstructions");
        block(env, morph1, context, "if", [get(env, context, "allowExistingMembers")], {}, child0, child1);
        block(env, morph2, context, "if", [get(env, context, "showGroups")], {}, child2, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"class": "btn-primary", "action": "closeModal", "label": "close"});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"icon": "link", "action": "generateInvitelink", "class": "btn-primary", "disabled": get(env, context, "disabledCopyLink"), "label": "user.invited.generate_link"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        inline(env, morph0, context, "d-button", [], {"icon": get(env, context, "inviteIcon"), "action": "createInvite", "class": "btn-primary", "disabled": get(env, context, "disabled"), "label": get(env, context, "buttonTitle")});
        block(env, morph1, context, "if", [get(env, context, "showCopyInviteButton")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body invite-modal");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,2,2);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      block(env, morph0, context, "if", [get(env, context, "model.error")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "model.finished")], {}, child1, child2);
      block(env, morph2, context, "if", [get(env, context, "model.finished")], {}, child3, child4);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/keyboard-shortcuts-help"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"id","keyboard-shortcuts-help");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","row");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","span6");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("ul");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("ul");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","span6");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("ul");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","span6");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("ul");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("li");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var element1 = dom.childAt(element0, [1]);
      var element2 = dom.childAt(element1, [3]);
      var element3 = dom.childAt(element1, [7]);
      var element4 = dom.childAt(element0, [3]);
      var element5 = dom.childAt(element4, [3]);
      var element6 = dom.childAt(element0, [5]);
      var element7 = dom.childAt(element6, [3]);
      var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph1 = dom.createUnsafeMorphAt(dom.childAt(element2, [1]),0,0);
      var morph2 = dom.createUnsafeMorphAt(dom.childAt(element2, [3]),0,0);
      var morph3 = dom.createUnsafeMorphAt(dom.childAt(element2, [5]),0,0);
      var morph4 = dom.createUnsafeMorphAt(dom.childAt(element2, [7]),0,0);
      var morph5 = dom.createUnsafeMorphAt(dom.childAt(element2, [9]),0,0);
      var morph6 = dom.createUnsafeMorphAt(dom.childAt(element2, [11]),0,0);
      var morph7 = dom.createUnsafeMorphAt(dom.childAt(element2, [13]),0,0);
      var morph8 = dom.createUnsafeMorphAt(dom.childAt(element2, [15]),0,0);
      var morph9 = dom.createUnsafeMorphAt(dom.childAt(element2, [17]),0,0);
      var morph10 = dom.createMorphAt(dom.childAt(element1, [5]),0,0);
      var morph11 = dom.createUnsafeMorphAt(dom.childAt(element3, [1]),0,0);
      var morph12 = dom.createUnsafeMorphAt(dom.childAt(element3, [3]),0,0);
      var morph13 = dom.createUnsafeMorphAt(dom.childAt(element3, [5]),0,0);
      var morph14 = dom.createUnsafeMorphAt(dom.childAt(element3, [7]),0,0);
      var morph15 = dom.createUnsafeMorphAt(dom.childAt(element3, [9]),0,0);
      var morph16 = dom.createMorphAt(dom.childAt(element4, [1]),0,0);
      var morph17 = dom.createUnsafeMorphAt(dom.childAt(element5, [1]),0,0);
      var morph18 = dom.createUnsafeMorphAt(dom.childAt(element5, [3]),0,0);
      var morph19 = dom.createUnsafeMorphAt(dom.childAt(element5, [5]),0,0);
      var morph20 = dom.createUnsafeMorphAt(dom.childAt(element5, [7]),0,0);
      var morph21 = dom.createUnsafeMorphAt(dom.childAt(element5, [9]),0,0);
      var morph22 = dom.createUnsafeMorphAt(dom.childAt(element5, [11]),0,0);
      var morph23 = dom.createUnsafeMorphAt(dom.childAt(element5, [13]),0,0);
      var morph24 = dom.createUnsafeMorphAt(dom.childAt(element5, [15]),0,0);
      var morph25 = dom.createUnsafeMorphAt(dom.childAt(element5, [17]),0,0);
      var morph26 = dom.createMorphAt(dom.childAt(element6, [1]),0,0);
      var morph27 = dom.createUnsafeMorphAt(dom.childAt(element7, [1]),0,0);
      var morph28 = dom.createUnsafeMorphAt(dom.childAt(element7, [3]),0,0);
      var morph29 = dom.createUnsafeMorphAt(dom.childAt(element7, [5]),0,0);
      var morph30 = dom.createUnsafeMorphAt(dom.childAt(element7, [7]),0,0);
      var morph31 = dom.createUnsafeMorphAt(dom.childAt(element7, [9]),0,0);
      var morph32 = dom.createUnsafeMorphAt(dom.childAt(element7, [11]),0,0);
      var morph33 = dom.createUnsafeMorphAt(dom.childAt(element7, [13]),0,0);
      var morph34 = dom.createUnsafeMorphAt(dom.childAt(element7, [15]),0,0);
      var morph35 = dom.createUnsafeMorphAt(dom.childAt(element7, [17]),0,0);
      var morph36 = dom.createUnsafeMorphAt(dom.childAt(element7, [19]),0,0);
      var morph37 = dom.createUnsafeMorphAt(dom.childAt(element7, [21]),0,0);
      var morph38 = dom.createUnsafeMorphAt(dom.childAt(element7, [23]),0,0);
      var morph39 = dom.createUnsafeMorphAt(dom.childAt(element7, [25]),0,0);
      var morph40 = dom.createUnsafeMorphAt(dom.childAt(element7, [27]),0,0);
      var morph41 = dom.createUnsafeMorphAt(dom.childAt(element7, [29]),0,0);
      var morph42 = dom.createUnsafeMorphAt(dom.childAt(element7, [31]),0,0);
      var morph43 = dom.createUnsafeMorphAt(dom.childAt(element7, [33]),0,0);
      inline(env, morph0, context, "i18n", ["keyboard_shortcuts_help.jump_to.title"], {});
      inline(env, morph1, context, "i18n", ["keyboard_shortcuts_help.jump_to.home"], {});
      inline(env, morph2, context, "i18n", ["keyboard_shortcuts_help.jump_to.latest"], {});
      inline(env, morph3, context, "i18n", ["keyboard_shortcuts_help.jump_to.new"], {});
      inline(env, morph4, context, "i18n", ["keyboard_shortcuts_help.jump_to.unread"], {});
      inline(env, morph5, context, "i18n", ["keyboard_shortcuts_help.jump_to.categories"], {});
      inline(env, morph6, context, "i18n", ["keyboard_shortcuts_help.jump_to.top"], {});
      inline(env, morph7, context, "i18n", ["keyboard_shortcuts_help.jump_to.bookmarks"], {});
      inline(env, morph8, context, "i18n", ["keyboard_shortcuts_help.jump_to.profile"], {});
      inline(env, morph9, context, "i18n", ["keyboard_shortcuts_help.jump_to.messages"], {});
      inline(env, morph10, context, "i18n", ["keyboard_shortcuts_help.navigation.title"], {});
      inline(env, morph11, context, "i18n", ["keyboard_shortcuts_help.navigation.back"], {});
      inline(env, morph12, context, "i18n", ["keyboard_shortcuts_help.navigation.jump"], {});
      inline(env, morph13, context, "i18n", ["keyboard_shortcuts_help.navigation.up_down"], {});
      inline(env, morph14, context, "i18n", ["keyboard_shortcuts_help.navigation.open"], {});
      inline(env, morph15, context, "i18n", ["keyboard_shortcuts_help.navigation.next_prev"], {});
      inline(env, morph16, context, "i18n", ["keyboard_shortcuts_help.application.title"], {});
      inline(env, morph17, context, "i18n", ["keyboard_shortcuts_help.application.create"], {});
      inline(env, morph18, context, "i18n", ["keyboard_shortcuts_help.application.hamburger_menu"], {});
      inline(env, morph19, context, "i18n", ["keyboard_shortcuts_help.application.user_profile_menu"], {});
      inline(env, morph20, context, "i18n", ["keyboard_shortcuts_help.application.show_incoming_updated_topics"], {});
      inline(env, morph21, context, "i18n", ["keyboard_shortcuts_help.application.search"], {});
      inline(env, morph22, context, "i18n", ["keyboard_shortcuts_help.application.help"], {});
      inline(env, morph23, context, "i18n", ["keyboard_shortcuts_help.application.dismiss_new_posts"], {});
      inline(env, morph24, context, "i18n", ["keyboard_shortcuts_help.application.dismiss_topics"], {});
      inline(env, morph25, context, "i18n", ["keyboard_shortcuts_help.application.log_out"], {});
      inline(env, morph26, context, "i18n", ["keyboard_shortcuts_help.actions.title"], {});
      inline(env, morph27, context, "i18n", ["keyboard_shortcuts_help.actions.bookmark_topic"], {});
      inline(env, morph28, context, "i18n", ["keyboard_shortcuts_help.actions.pin_unpin_topic"], {});
      inline(env, morph29, context, "i18n", ["keyboard_shortcuts_help.actions.share_topic"], {});
      inline(env, morph30, context, "i18n", ["keyboard_shortcuts_help.actions.share_post"], {});
      inline(env, morph31, context, "i18n", ["keyboard_shortcuts_help.actions.reply_as_new_topic"], {});
      inline(env, morph32, context, "i18n", ["keyboard_shortcuts_help.actions.reply_topic"], {});
      inline(env, morph33, context, "i18n", ["keyboard_shortcuts_help.actions.reply_post"], {});
      inline(env, morph34, context, "i18n", ["keyboard_shortcuts_help.actions.quote_post"], {});
      inline(env, morph35, context, "i18n", ["keyboard_shortcuts_help.actions.like"], {});
      inline(env, morph36, context, "i18n", ["keyboard_shortcuts_help.actions.flag"], {});
      inline(env, morph37, context, "i18n", ["keyboard_shortcuts_help.actions.bookmark"], {});
      inline(env, morph38, context, "i18n", ["keyboard_shortcuts_help.actions.edit"], {});
      inline(env, morph39, context, "i18n", ["keyboard_shortcuts_help.actions.delete"], {});
      inline(env, morph40, context, "i18n", ["keyboard_shortcuts_help.actions.mark_muted"], {});
      inline(env, morph41, context, "i18n", ["keyboard_shortcuts_help.actions.mark_regular"], {});
      inline(env, morph42, context, "i18n", ["keyboard_shortcuts_help.actions.mark_tracking"], {});
      inline(env, morph43, context, "i18n", ["keyboard_shortcuts_help.actions.mark_watching"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/login"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("form");
        dom.setAttribute(el1,"id","login-form");
        dom.setAttribute(el1,"method","post");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("table");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n              ");
        dom.appendChild(el5, el6);
        var el6 = dom.createElement("label");
        dom.setAttribute(el6,"for","login-account-name");
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        var el7 = dom.createTextNode(" ");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n              ");
        dom.appendChild(el5, el6);
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n                ");
        dom.appendChild(el5, el6);
        var el6 = dom.createElement("label");
        dom.setAttribute(el6,"for","login-account-password");
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        var el7 = dom.createTextNode(" ");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n                ");
        dom.appendChild(el5, el6);
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("  \n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createTextNode("\n              ");
        dom.appendChild(el5, el6);
        var el6 = dom.createElement("a");
        dom.setAttribute(el6,"id","forgot-password-link");
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode("\n            ");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("tr");
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        var el6 = dom.createElement("div");
        var el7 = dom.createElement("i");
        dom.setAttribute(el7,"class","fa fa-exclamation-triangle");
        dom.appendChild(el6, el7);
        var el7 = dom.createTextNode(" ");
        dom.appendChild(el6, el7);
        var el7 = dom.createComment("");
        dom.appendChild(el6, el7);
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n            ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("td");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n          ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, element = hooks.element, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1, 1, 1]);
        var element3 = dom.childAt(element2, [1]);
        var element4 = dom.childAt(element2, [3]);
        var element5 = dom.childAt(element4, [5, 1]);
        var element6 = dom.childAt(element2, [5, 3, 0]);
        var morph0 = dom.createMorphAt(dom.childAt(element3, [1, 1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element3, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(element4, [1, 1]),0,0);
        var morph3 = dom.createMorphAt(dom.childAt(element4, [3]),1,1);
        var morph4 = dom.createMorphAt(element5,0,0);
        var attrMorph0 = dom.createAttrMorph(element6, 'class');
        var morph5 = dom.createMorphAt(element6,2,2);
        inline(env, morph0, context, "i18n", ["login.username"], {});
        inline(env, morph1, context, "text-field", [], {"value": get(env, context, "loginName"), "placeholderKey": "login.email_placeholder", "id": "login-account-name", "autocorrect": "off", "autocapitalize": "off", "autofocus": "autofocus"});
        inline(env, morph2, context, "i18n", ["login.password"], {});
        inline(env, morph3, context, "password-field", [], {"value": get(env, context, "loginPassword"), "type": "password", "id": "login-account-password", "maxlength": "200", "capsLockOn": get(env, context, "capsLockOn")});
        element(env, element5, context, "action", ["forgotPassword"], {});
        inline(env, morph4, context, "i18n", ["forgot_password.action"], {});
        attribute(env, attrMorph0, element6, "class", concat(env, ["caps-lock-warning ", subexpr(env, context, "unless", [get(env, context, "capsLockOn"), "invisible"], {})]));
        inline(env, morph5, context, "i18n", ["login.caps_lock_warning"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("       \n      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"class","btn btn-large");
          dom.setAttribute(el1,"id","new-account-link");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,1,1);
          element(env, element0, context, "action", ["createAccount"], {});
          inline(env, morph0, context, "i18n", ["create_account.title"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-large btn-primary");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-unlock");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, content = hooks.content, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var attrMorph0 = dom.createAttrMorph(element1, 'disabled');
        var morph0 = dom.createMorphAt(element1,3,3);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        attribute(env, attrMorph0, element1, "disabled", get(env, context, "loginDisabled"));
        element(env, element1, context, "action", ["login"], {});
        content(env, morph0, context, "loginButtonText");
        block(env, morph1, context, "if", [get(env, context, "showSignupLink")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["login.authenticating"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","login-alert");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element7 = dom.childAt(fragment, [0]);
      var element8 = dom.childAt(element7, [7]);
      var element9 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(element7,1,1);
      var morph1 = dom.createMorphAt(element7,3,3);
      var morph2 = dom.createMorphAt(element7,5,5);
      var morph3 = dom.createMorphAt(element8,0,0);
      var attrMorph0 = dom.createAttrMorph(element8, 'class');
      var morph4 = dom.createMorphAt(element9,1,1);
      var morph5 = dom.createMorphAt(element9,3,3);
      var morph6 = dom.createMorphAt(element9,5,5);
      inline(env, morph0, context, "login-buttons", [], {"action": "externalLogin"});
      block(env, morph1, context, "if", [get(env, context, "canLoginLocal")], {}, child0, null);
      content(env, morph2, context, "authMessage");
      attribute(env, attrMorph0, element8, "class", get(env, context, "alertClass"));
      content(env, morph3, context, "alert");
      block(env, morph4, context, "if", [get(env, context, "canLoginLocal")], {}, child1, null);
      block(env, morph5, context, "if", [get(env, context, "authenticate")], {}, child2, null);
      inline(env, morph6, context, "conditional-loading-spinner", [], {"condition": get(env, context, "showSpinner"), "size": "small"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/merge-topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode(" ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "fa-icon", ["sign-out"], {});
        content(env, morph1, context, "buttonTitle");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"id","move-selected");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createUnsafeMorphAt(dom.childAt(element0, [1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      inline(env, morph0, context, "i18n", ["topic.merge_topic.instructions"], {"count": get(env, context, "selectedPostsCount")});
      inline(env, morph1, context, "choose-topic", [], {"currentTopicId": get(env, context, "model.id"), "selectedTopicId": get(env, context, "selectedTopicId")});
      block(env, morph2, context, "d-button", [], {"class": "btn-primary", "disabled": get(env, context, "buttonDisabled"), "action": "movePostsToExistingTopic"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/modal"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","alert alert-error");
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("button");
        dom.setAttribute(el2,"class","close");
        dom.setAttribute(el2,"data-dismiss","alert");
        var el3 = dom.createTextNode("×");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),3,3);
        set(env, context, "error", blockArguments[0]);
        content(env, morph0, context, "error");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-outer-container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-middle-container");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","modal-inner-container");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","modal-header");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("a");
      dom.setAttribute(el5,"class","close");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("h3");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("div");
      dom.setAttribute(el5,"class","clearfix");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"id","modal-alert");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, inline = hooks.inline, content = hooks.content, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1, 1]);
      var element1 = dom.childAt(element0, [1]);
      var element2 = dom.childAt(element1, [1]);
      var morph0 = dom.createMorphAt(element2,0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
      var morph2 = dom.createMorphAt(element0,5,5);
      var morph3 = dom.createMorphAt(element0,7,7);
      element(env, element2, context, "action", ["closeModal"], {});
      inline(env, morph0, context, "fa-icon", ["times"], {});
      content(env, morph1, context, "title");
      inline(env, morph2, context, "outlet", ["modalBody"], {});
      block(env, morph3, context, "each", [get(env, context, "errors")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/not-activated"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["login.sent_activation_email_again"], {"currentEmail": get(env, context, "currentEmail")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"href","");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [3]);
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(element0,0,0);
        inline(env, morph0, context, "i18n", ["login.not_activated"], {"sentTo": get(env, context, "sentTo")});
        element(env, element0, context, "action", ["sendActivationEmail"], {});
        inline(env, morph1, context, "i18n", ["login.resend_activation_email"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"class","btn btn-primary");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, element = hooks.element, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [2, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      var morph1 = dom.createMorphAt(element1,0,0);
      block(env, morph0, context, "if", [get(env, context, "emailSent")], {}, child0, child1);
      element(env, element1, context, "action", ["closeModal"], {});
      inline(env, morph1, context, "i18n", ["close"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/option_boolean"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("label");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,3,3);
      var morph2 = dom.createMorphAt(fragment,2,2,contextualElement);
      inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "checked")});
      content(env, morph1, context, "title");
      content(env, morph2, context, "description");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/post-enqueued"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createUnsafeMorphAt(dom.childAt(element0, [1]),0,0);
      var morph1 = dom.createUnsafeMorphAt(dom.childAt(element0, [3]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      content(env, morph0, context, "description");
      inline(env, morph1, context, "i18n", ["queue.approval.pending_posts"], {"count": get(env, context, "model.pending_count")});
      inline(env, morph2, context, "d-button", [], {"action": "closeModal", "class": "btn-primary", "label": "queue.approval.ok"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/raw_email"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "textarea", [], {"value": get(env, context, "rawEmail"), "class": "raw-email-textarea"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["raw_email.not_available"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      block(env, morph0, context, "if", [get(env, context, "rawEmail")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/reorder-categories"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"class": "no-text", "action": "commit", "icon": "check"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("tr");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("td");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("td");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var element1 = dom.childAt(element0, [1]);
        var attrMorph0 = dom.createAttrMorph(element0, 'data-category-id');
        var morph0 = dom.createMorphAt(element1,1,1);
        var morph1 = dom.createMorphAt(element1,3,3);
        var morph2 = dom.createMorphAt(element1,5,5);
        var morph3 = dom.createMorphAt(element1,7,7);
        var morph4 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
        set(env, context, "cat", blockArguments[0]);
        attribute(env, attrMorph0, element0, "data-category-id", concat(env, [get(env, context, "cat.id")]));
        inline(env, morph0, context, "number-field", [], {"number": get(env, context, "cat.position")});
        inline(env, morph1, context, "d-button", [], {"class": "no-text", "action": "moveUp", "actionParam": get(env, context, "cat"), "icon": "arrow-up"});
        inline(env, morph2, context, "d-button", [], {"class": "no-text", "action": "moveDown", "actionParam": get(env, context, "cat"), "icon": "arrow-down"});
        block(env, morph3, context, "if", [get(env, context, "cat.hasBufferedChanges")], {}, child0, null);
        inline(env, morph4, context, "category-badge", [get(env, context, "cat")], {"allowUncategorized": "true"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "fixIndices", "icon": "random", "label": "categories.reorder.fix_order", "title": "categories.reorder.fix_order_tooltip"});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "commit", "icon": "check", "label": "categories.reorder.apply_all"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body reorder-categories full-height-modal");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","rc-scroll-anchor");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("table");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("thead");
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("th");
      dom.setAttribute(el4,"class","th-pos");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("th");
      dom.setAttribute(el4,"class","th-cat");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"id","rc-scroll-bottom");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [0, 3]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(dom.childAt(element3, [1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element3, [3]),0,0);
      var morph2 = dom.createMorphAt(element2,3,3);
      var morph3 = dom.createMorphAt(element4,1,1);
      var morph4 = dom.createMorphAt(element4,2,2);
      var morph5 = dom.createMorphAt(element4,4,4);
      inline(env, morph0, context, "i18n", ["categories.reorder.position"], {});
      inline(env, morph1, context, "i18n", ["categories.category"], {});
      block(env, morph2, context, "each", [get(env, context, "categoriesOrdered")], {}, child0, null);
      block(env, morph3, context, "if", [get(env, context, "showFixIndices")], {}, child1, null);
      block(env, morph4, context, "if", [get(env, context, "showApplyAll")], {}, child2, null);
      inline(env, morph5, context, "d-button", [], {"class": "btn-primary", "disabled": get(env, context, "saveDisabled"), "action": "saveOrder", "label": "categories.reorder.save"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/search_help"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["google_search"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"id","search-help");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createUnsafeMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,3,3);
      content(env, morph0, context, "model");
      block(env, morph1, context, "if", [get(env, context, "showGoogleSearch")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/split-topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode(" ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "fa-icon", ["sign-out"], {});
        content(env, morph1, context, "buttonTitle");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"id","move-selected");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [3]);
      var morph0 = dom.createUnsafeMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph2 = dom.createMorphAt(element1,3,3);
      var morph3 = dom.createMorphAt(dom.childAt(element1, [5]),0,0);
      var morph4 = dom.createMorphAt(element1,7,7);
      var morph5 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      inline(env, morph0, context, "i18n", ["topic.split_topic.instructions"], {"count": get(env, context, "selectedPostsCount")});
      inline(env, morph1, context, "i18n", ["topic.split_topic.topic_name"], {});
      inline(env, morph2, context, "text-field", [], {"value": get(env, context, "topicName"), "placeholderKey": "composer.title_placeholder", "elementId": "split-topic-name"});
      inline(env, morph3, context, "i18n", ["categories.category"], {});
      inline(env, morph4, context, "category-chooser", [], {"value": get(env, context, "categoryId")});
      block(env, morph5, context, "d-button", [], {"class": "btn-primary", "disabled": get(env, context, "buttonDisabled"), "action": "movePostsToNewTopic"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/topic-bulk-actions"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createUnsafeMorphAt(dom.childAt(element0, [1]),0,0);
      var morph1 = dom.createMorphAt(element0,3,3);
      inline(env, morph0, context, "i18n", ["topics.bulk.selected"], {"count": get(env, context, "length")});
      inline(env, morph1, context, "outlet", ["bulkOutlet"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/upload-customization"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-body");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-footer");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
      inline(env, morph0, context, "json-file-uploader", [], {"value": get(env, context, "customizationFile"), "extension": ".dcstyle.json"});
      inline(env, morph1, context, "d-button", [], {"class": "btn-primary", "action": "createCustomization", "type": "submit", "disabled": get(env, context, "notReady"), "icon": "plus", "label": "admin.customize.import"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["modal/upload-selector"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","inputs");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("input");
        dom.setAttribute(el2,"type","file");
        dom.setAttribute(el2,"id","filename-input");
        dom.setAttribute(el2,"multiple","");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("br");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","description");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 4]),0,0);
        content(env, morph0, context, "tip");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","inputs");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","description");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element2,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element2, [3]),0,0);
        inline(env, morph0, context, "input", [], {"value": get(env, context, "imageUrl"), "placeholder": "http://example.com/image.png"});
        content(env, morph1, context, "tip");
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","radios");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","inputs");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","description");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element1,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
        inline(env, morph0, context, "input", [], {"value": get(env, context, "imageLink"), "laceholder": "http://example.com"});
        inline(env, morph1, context, "i18n", ["upload_selector.image_link"], {});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["upload_selector.hint"], {});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["upload_selector.hint_for_supported_browsers"], {});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("a");
        dom.setAttribute(el1,"class","pull-right");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [0]);
        var morph0 = dom.createMorphAt(element0,0,0);
        element(env, element0, context, "action", ["toggleShowMore"], {});
        inline(env, morph0, context, "i18n", ["show_more"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","radios");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("input");
      dom.setAttribute(el3,"type","radio");
      dom.setAttribute(el3,"id","local");
      dom.setAttribute(el3,"value","local");
      dom.setAttribute(el3,"name","upload");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      dom.setAttribute(el3,"class","radio");
      dom.setAttribute(el3,"for","local");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","radios");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("input");
      dom.setAttribute(el3,"type","radio");
      dom.setAttribute(el3,"id","remote");
      dom.setAttribute(el3,"value","remote");
      dom.setAttribute(el3,"name","upload");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      dom.setAttribute(el3,"class","radio");
      dom.setAttribute(el3,"for","remote");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","radios");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","inputs");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("p");
      dom.setAttribute(el4,"class","hint");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      dom.setAttribute(el2,"href","");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [0]);
      var element4 = dom.childAt(element3, [1]);
      var element5 = dom.childAt(element4, [1]);
      var element6 = dom.childAt(element3, [3]);
      var element7 = dom.childAt(element6, [1]);
      var element8 = dom.childAt(fragment, [2]);
      var element9 = dom.childAt(element8, [3]);
      var morph0 = dom.createMorphAt(dom.childAt(element4, [3]),0,0);
      var morph1 = dom.createMorphAt(element4,5,5);
      var morph2 = dom.createMorphAt(dom.childAt(element6, [3]),0,0);
      var morph3 = dom.createMorphAt(element6,5,5);
      var morph4 = dom.createMorphAt(element3,5,5);
      var morph5 = dom.createMorphAt(dom.childAt(element3, [7, 1, 1]),1,1);
      var morph6 = dom.createMorphAt(element8,1,1);
      var morph7 = dom.createMorphAt(element9,0,0);
      var morph8 = dom.createMorphAt(element8,5,5);
      element(env, element5, context, "action", ["useLocal"], {});
      inline(env, morph0, context, "i18n", ["upload_selector.from_my_computer"], {});
      block(env, morph1, context, "if", [get(env, context, "local")], {}, child0, null);
      element(env, element7, context, "action", ["useRemote"], {});
      inline(env, morph2, context, "i18n", ["upload_selector.from_the_web"], {});
      block(env, morph3, context, "if", [get(env, context, "remote")], {}, child1, null);
      block(env, morph4, context, "if", [get(env, context, "showMore")], {}, child2, null);
      block(env, morph5, context, "if", [get(env, context, "capabilities.canPasteImages")], {}, child3, child4);
      inline(env, morph6, context, "d-button", [], {"action": "upload", "class": "btn-primary", "icon": get(env, context, "uploadIcon"), "label": "upload"});
      element(env, element9, context, "action", ["closeModal"], {});
      inline(env, morph7, context, "i18n", ["cancel"], {});
      block(env, morph8, context, "if", [get(env, context, "remote")], {}, child5, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["navigation/categories"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "categories-admin-dropdown");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"id","create-topic");
        dom.setAttribute(el1,"class","btn btn-default");
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-plus");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        element(env, element0, context, "action", ["createTopic"], {});
        inline(env, morph0, context, "i18n", ["topic.create"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,5,5,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "bread-crumbs", [], {"categories": get(env, context, "categories")});
      inline(env, morph1, context, "navigation-bar", [], {"navItems": get(env, context, "navItems"), "filterMode": get(env, context, "filterMode")});
      block(env, morph2, context, "if", [get(env, context, "canCreateCategory")], {}, child0, null);
      block(env, morph3, context, "if", [get(env, context, "canCreateTopic")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["navigation/category"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "category-notifications-button", [], {"category": get(env, context, "category")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"id": "create-topic", "class": "btn-default", "action": "createTopic", "icon": "plus", "label": "topic.create", "disabled": get(env, context, "cannotCreateTopicOnCategory")});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"class": "btn-default edit-category", "action": "editCategory", "actionParam": get(env, context, "category"), "icon": "wrench", "label": "category.edit_long"});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "category.description");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        inline(env, morph0, context, "cdn-img", [], {"src": get(env, context, "category.logo_url"), "class": "category-logo"});
        block(env, morph1, context, "if", [get(env, context, "category.description")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","category-heading");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      var morph4 = dom.createMorphAt(fragment,8,8,contextualElement);
      var morph5 = dom.createMorphAt(dom.childAt(fragment, [10]),1,1);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "bread-crumbs", [], {"categories": get(env, context, "categories"), "category": get(env, context, "category"), "noSubcategories": get(env, context, "noSubcategories"), "hideSubcategories": get(env, context, "showingSubcategoryList")});
      inline(env, morph1, context, "navigation-bar", [], {"navItems": get(env, context, "navItems"), "filterMode": get(env, context, "filterMode")});
      block(env, morph2, context, "if", [get(env, context, "currentUser")], {}, child0, null);
      block(env, morph3, context, "if", [get(env, context, "canCreateTopic")], {}, child1, null);
      block(env, morph4, context, "if", [get(env, context, "canEditCategory")], {}, child2, null);
      block(env, morph5, context, "if", [get(env, context, "category.logo_url")], {}, child3, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["navigation/default"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"id","create-topic");
        dom.setAttribute(el1,"class","btn btn-default");
        var el2 = dom.createElement("i");
        dom.setAttribute(el2,"class","fa fa-plus");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        element(env, element0, context, "action", ["createTopic"], {});
        inline(env, morph0, context, "i18n", ["topic.create"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "bread-crumbs", [], {"categories": get(env, context, "categories")});
      inline(env, morph1, context, "navigation-bar", [], {"navItems": get(env, context, "navItems"), "filterMode": get(env, context, "filterMode")});
      block(env, morph2, context, "if", [get(env, context, "canCreateTopic")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["post/poster-avatar.raw"] = Discourse.EmberCompatHandlebars.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<a href=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"post.usernameUrl",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\" classNames=\"trigger-user-card "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"classNames",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\" data-user-card=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"post.username",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">"
    + container.escapeExpression((helpers.avatar || (depth0 && depth0.avatar) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"post",{"name":"avatar","hash":{"imageSize":"large"},"hashTypes":{"imageSize":"StringLiteral"},"hashContexts":{"imageSize":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"useData":true});
Ember.TEMPLATES["preferences/card-badge"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["saved"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-content");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      dom.setAttribute(el2,"class","form-horizontal");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("h3");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("button");
      dom.setAttribute(el5,"class","btn btn-primary");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, attribute = hooks.attribute, element = hooks.element, content = hooks.content, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var element1 = dom.childAt(element0, [5, 1]);
      var element2 = dom.childAt(element1, [1]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1, 1, 1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [3, 3]),1,1);
      var morph2 = dom.createMorphAt(element2,0,0);
      var attrMorph0 = dom.createAttrMorph(element2, 'disabled');
      var morph3 = dom.createMorphAt(element1,3,3);
      inline(env, morph0, context, "i18n", ["user.card_badge.title"], {});
      inline(env, morph1, context, "combo-box", [], {"valueAttribute": "id", "value": get(env, context, "selectedUserBadgeId"), "nameProperty": "badge.name", "content": get(env, context, "selectableUserBadges")});
      attribute(env, attrMorph0, element2, "disabled", get(env, context, "disableSave"));
      element(env, element2, context, "action", ["save"], {});
      content(env, morph2, context, "savingStatus");
      block(env, morph3, context, "if", [get(env, context, "saved")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["queued-posts"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "post", blockArguments[0]);
        inline(env, morph0, context, "queued-post", [], {"post": get(env, context, "post"), "currentlyEditing": get(env, context, "editing"), "removePost": "removePost"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["queue.none"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","queued-posts");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,3,3);
      block(env, morph0, context, "each", [get(env, context, "model")], {}, child0, child1);
      inline(env, morph1, context, "d-button", [], {"action": "refresh", "label": "refresh", "icon": "refresh", "disabled": get(env, context, "model.refreshing"), "id": "refresh-queued"});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["rename-tag"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("label");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("p");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-footer");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
      var morph1 = dom.createMorphAt(element0,3,3);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      inline(env, morph0, context, "i18n", ["tagging.rename_instructions"], {});
      inline(env, morph1, context, "input", [], {"value": get(env, context, "buffered.id"), "maxlength": get(env, context, "siteSettings.max_tag_length")});
      inline(env, morph2, context, "d-button", [], {"class": "btn-primary", "action": "performRename", "label": "tagging.rename_tag", "disabled": get(env, context, "renameDisabled")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["selected-posts"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1, 0]);
        var morph0 = dom.createMorphAt(element1,0,0);
        element(env, element1, context, "action", ["selectAll"], {});
        inline(env, morph0, context, "i18n", ["topic.multi_select.select_all"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 0]);
        var morph0 = dom.createMorphAt(element0,0,0);
        element(env, element0, context, "action", ["deselectAll"], {});
        inline(env, morph0, context, "i18n", ["topic.multi_select.deselect_all"], {});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "deleteSelected", "icon": "trash-o", "label": "topic.multi_select.delete"});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "splitTopic", "icon": "sign-out", "label": "topic.split_topic.action"});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "mergeTopic", "icon": "sign-out", "label": "topic.merge_topic.action"});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "changeOwner", "icon": "user", "label": "topic.change_owner.action"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("p");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("p");
      dom.setAttribute(el1,"class","cancel");
      var el2 = dom.createElement("a");
      dom.setAttribute(el2,"href","");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [14, 0]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      var morph4 = dom.createMorphAt(fragment,8,8,contextualElement);
      var morph5 = dom.createMorphAt(fragment,10,10,contextualElement);
      var morph6 = dom.createMorphAt(fragment,12,12,contextualElement);
      var morph7 = dom.createMorphAt(element2,0,0);
      inline(env, morph0, context, "count-i18n", [], {"key": "topic.multi_select.description", "count": get(env, context, "selectedPostsCount")});
      block(env, morph1, context, "if", [get(env, context, "canSelectAll")], {}, child0, null);
      block(env, morph2, context, "if", [get(env, context, "canDeselectAll")], {}, child1, null);
      block(env, morph3, context, "if", [get(env, context, "canDeleteSelected")], {}, child2, null);
      block(env, morph4, context, "if", [get(env, context, "canSplitTopic")], {}, child3, null);
      block(env, morph5, context, "if", [get(env, context, "canMergeTopic")], {}, child4, null);
      block(env, morph6, context, "if", [get(env, context, "canChangeOwner")], {}, child5, null);
      element(env, element2, context, "action", ["toggleMultiSelect"], {});
      inline(env, morph7, context, "i18n", ["topic.multi_select.cancel"], {});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["share"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","date");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "displayDate");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "s", blockArguments[0]);
          inline(env, morph0, context, "share-source", [], {"source": get(env, context, "s"), "title": get(env, context, "title"), "action": "share"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("h3");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("input");
        dom.setAttribute(el2,"type","text");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","share-for-touch");
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","overflow-ellipsis");
        var el4 = dom.createElement("a");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","link");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [9, 1]);
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph2 = dom.createMorphAt(fragment,7,7,contextualElement);
        var morph3 = dom.createMorphAt(element0,0,0);
        var attrMorph0 = dom.createAttrMorph(element0, 'aria-label');
        var attrMorph1 = dom.createAttrMorph(element0, 'title');
        content(env, morph0, context, "title");
        block(env, morph1, context, "if", [get(env, context, "date")], {}, child0, null);
        block(env, morph2, context, "each", [get(env, context, "sources")], {}, child1, null);
        attribute(env, attrMorph0, element0, "aria-label", concat(env, [subexpr(env, context, "i18n", ["share.close"], {})]));
        attribute(env, attrMorph1, element0, "title", concat(env, [subexpr(env, context, "i18n", ["share.close"], {})]));
        element(env, element0, context, "action", ["close"], {});
        inline(env, morph3, context, "fa-icon", ["times-circle"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "link")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["static"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "showCreateAccount", "class": "btn-primary sign-up-button", "label": "sign_up"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "showLogin", "class": "btn-primary login-button", "icon": "user", "label": "log_in"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","contents clearfix body-page");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, content = hooks.content, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createUnsafeMorphAt(element0,3,3);
      var morph2 = dom.createMorphAt(element0,5,5);
      var morph3 = dom.createMorphAt(element0,7,7);
      inline(env, morph0, context, "plugin-outlet", ["above-static"], {});
      content(env, morph1, context, "model.html");
      block(env, morph2, context, "if", [get(env, context, "showSignupButton")], {}, child0, null);
      block(env, morph3, context, "if", [get(env, context, "showLoginButton")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["tags"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container list-container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","row");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","full-width");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"id","list-area");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0, 1, 1, 1]),1,1);
      content(env, morph0, context, "outlet");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["tags/index"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","tag-box");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","tag-count");
        var el3 = dom.createTextNode("x ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
        set(env, context, "tag", blockArguments[0]);
        inline(env, morph0, context, "discourse-tag", [get(env, context, "tag.id")], {});
        content(env, morph1, context, "tag.count");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("h2");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","tag-sort-options");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("a");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","tag-list");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, element = hooks.element, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [4]);
      var element2 = dom.childAt(element1, [3]);
      var element3 = dom.childAt(element1, [5]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      var morph2 = dom.createMorphAt(element1,1,1);
      var morph3 = dom.createMorphAt(element2,0,0);
      var morph4 = dom.createMorphAt(element3,0,0);
      var morph5 = dom.createMorphAt(dom.childAt(fragment, [6]),1,1);
      inline(env, morph0, context, "discourse-banner", [], {"user": get(env, context, "currentUser"), "banner": get(env, context, "site.banner")});
      inline(env, morph1, context, "i18n", ["tagging.all_tags"], {});
      inline(env, morph2, context, "i18n", ["tagging.sort_by"], {});
      element(env, element2, context, "action", ["sortByCount"], {});
      inline(env, morph3, context, "i18n", ["tagging.sort_by_count"], {});
      element(env, element3, context, "action", ["sortById"], {});
      inline(env, morph4, context, "i18n", ["tagging.sort_by_name"], {});
      block(env, morph5, context, "each", [get(env, context, "sortedTags")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["tags/show"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "tag-notifications-button", [], {"action": "changeTagNotification", "notificationLevel": get(env, context, "tagNotification.notification_level")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "deleteTag", "label": "tagging.delete_tag", "icon": "trash-o", "class": "admin-tag btn-danger"});
        inline(env, morph1, context, "d-button", [], {"action": "renameTag", "actionParam": get(env, context, "tag"), "label": "tagging.rename_tag", "icon": "pencil", "class": "admin-tag"});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("button");
          dom.setAttribute(el1,"id","create-topic");
          dom.setAttribute(el1,"class","btn btn-default");
          var el2 = dom.createElement("i");
          dom.setAttribute(el2,"class","fa fa-plus");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element2 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element2,1,1);
          element(env, element2, context, "action", ["createTopic"], {});
          inline(env, morph0, context, "i18n", ["topic.create"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "canCreateTopic")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "bread-crumbs", [], {"categories": get(env, context, "categories"), "category": get(env, context, "category"), "tagId": get(env, context, "tag.id"), "noSubcategories": get(env, context, "noSubcategories"), "hideSubcategories": get(env, context, "showingSubcategoryList")});
        inline(env, morph1, context, "navigation-bar", [], {"navItems": get(env, context, "navItems"), "filterMode": get(env, context, "filterMode")});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["tagging.tags"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("h2");
        dom.setAttribute(el1,"class","tag-show-heading");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element1,1,1);
        var morph1 = dom.createMorphAt(element1,3,3);
        var morph2 = dom.createMorphAt(element1,5,5);
        block(env, morph0, context, "link-to", ["tags"], {}, child0, null);
        inline(env, morph1, context, "fa-icon", ["angle-right"], {});
        inline(env, morph2, context, "discourse-tag-bound", [], {"tagRecord": get(env, context, "tag"), "style": "simple"});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
            inline(env, morph0, context, "bulk-select-button", [], {"selected": get(env, context, "selected"), "action": "refresh"});
            inline(env, morph1, context, "topic-list", [], {"topics": get(env, context, "list.topics"), "canBulkSelect": get(env, context, "canBulkSelect"), "toggleBulkSelect": "toggleBulkSelect", "bulkSelectEnabled": get(env, context, "bulkSelectEnabled"), "selected": get(env, context, "selected"), "showPosters": true, "currentUser": get(env, context, "currentUser"), "order": get(env, context, "order"), "ascending": get(env, context, "ascending"), "changeSort": "changeSort"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "discovery-topics-list", [], {"model": get(env, context, "list"), "refresh": "refresh"}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode(" ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            dom.insertBoundary(fragment, null);
            inline(env, morph0, context, "i18n", ["topic.browse_all_categories"], {});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "i18n", ["topic.view_latest_topics"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h3");
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,1,1);
          var morph1 = dom.createMorphAt(element0,2,2);
          var morph2 = dom.createMorphAt(element0,4,4);
          var morph3 = dom.createMorphAt(element0,6,6);
          content(env, morph0, context, "footerMessage");
          block(env, morph1, context, "link-to", ["discovery.categories"], {}, child0, null);
          inline(env, morph2, context, "i18n", ["or"], {});
          block(env, morph3, context, "link-to", ["discovery.latest"], {}, child1, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "list.topics")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","list-controls");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","container");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("footer");
      dom.setAttribute(el1,"class","topic-list-bottom");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [2, 1]);
      var element4 = dom.childAt(fragment, [4]);
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      var morph1 = dom.createMorphAt(element3,1,1);
      var morph2 = dom.createMorphAt(element3,3,3);
      var morph3 = dom.createMorphAt(element3,5,5);
      var morph4 = dom.createMorphAt(element4,1,1);
      var morph5 = dom.createMorphAt(element4,3,3);
      inline(env, morph0, context, "discourse-banner", [], {"user": get(env, context, "currentUser"), "banner": get(env, context, "site.banner")});
      block(env, morph1, context, "if", [get(env, context, "tagNotification")], {}, child0, null);
      block(env, morph2, context, "if", [get(env, context, "showAdminControls")], {}, child1, child2);
      block(env, morph3, context, "if", [get(env, context, "showTagFilter")], {}, child3, child4);
      inline(env, morph4, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")});
      block(env, morph5, context, "unless", [get(env, context, "loading")], {}, child5, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["topic-entrance"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode(" ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createUnsafeMorphAt(fragment,3,3,contextualElement);
        inline(env, morph0, context, "fa-icon", ["caret-up"], {});
        content(env, morph1, context, "topDate");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode(" ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        content(env, morph0, context, "bottomDate");
        inline(env, morph1, context, "fa-icon", ["caret-down"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "d-button", [], {"action": "enterTop", "class": "full jump-top"}, child0, null);
      block(env, morph1, context, "d-button", [], {"action": "enterBottom", "class": "full jump-button"}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["topic-list-header-column.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "      <button class='btn bulk-select' title='"
    + container.escapeExpression((helpers.i18n || (depth0 && depth0.i18n) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topics.bulk.toggle",{"name":"i18n","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "'><i class='fa fa-list'></i></button>\n";
},"3":function(container,depth0,helpers,partials,data) {
    return "    <i class='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"view.sortClass",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'></i>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<th data-sort-order='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"order",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "' class='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"view.className",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'>"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"showBulkToggle",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"view.localizedName",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"view.isSorting",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(3, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "</th>\n";
},"useData":true});
Ember.TEMPLATES["topic-list-header.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "<th class='star'>\n  <button class='btn bulk-select' title='"
    + container.escapeExpression((helpers.i18n || (depth0 && depth0.i18n) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topics.bulk.toggle",{"name":"i18n","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "'><i class='fa fa-list'></i></button>\n</th>\n";
},"3":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-list-header-column",{"name":"raw","hash":{"name":"category_title","order":"category","sortable":"sortable"},"hashTypes":{"name":"StringLiteral","order":"StringLiteral","sortable":"PathExpression"},"hashContexts":{"name":depth0,"order":depth0,"sortable":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"5":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-list-header-column",{"name":"raw","hash":{"name":"users","order":"posters"},"hashTypes":{"name":"StringLiteral","order":"StringLiteral"},"hashContexts":{"name":depth0,"order":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"7":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-list-header-column",{"name":"raw","hash":{"name":"users","order":"participants"},"hashTypes":{"name":"StringLiteral","order":"StringLiteral"},"hashContexts":{"name":depth0,"order":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"9":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-list-header-column",{"name":"raw","hash":{"name":"likes","order":"likes","number":"true","sortable":"sortable"},"hashTypes":{"name":"StringLiteral","order":"StringLiteral","number":"StringLiteral","sortable":"PathExpression"},"hashContexts":{"name":depth0,"order":depth0,"number":depth0,"sortable":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"11":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-list-header-column",{"name":"raw","hash":{"name":"likes","order":"op_likes","number":"true","sortable":"sortable"},"hashTypes":{"name":"StringLiteral","order":"StringLiteral","number":"StringLiteral","sortable":"PathExpression"},"hashContexts":{"name":depth0,"order":depth0,"number":depth0,"sortable":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"bulkSelectEnabled",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-list-header-column",{"name":"raw","hash":{"showBulkToggle":"toggleInTitle","name":"topic.title","order":"default"},"hashTypes":{"showBulkToggle":"PathExpression","name":"StringLiteral","order":"StringLiteral"},"hashContexts":{"showBulkToggle":depth0,"name":depth0,"order":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n"
    + ((stack1 = helpers.unless.call(depth0 != null ? depth0 : {},"hideCategory",{"name":"unless","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(3, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"showPosters",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(5, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-list-header-column",{"name":"raw","hash":{"name":"replies","order":"posts","number":"true","sortable":"sortable"},"hashTypes":{"name":"StringLiteral","order":"StringLiteral","number":"StringLiteral","sortable":"PathExpression"},"hashContexts":{"name":depth0,"order":depth0,"number":depth0,"sortable":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"showParticipants",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(7, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"showLikes",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(9, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"showOpLikes",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(11, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-list-header-column",{"name":"raw","hash":{"name":"views","order":"views","number":"true","sortable":"sortable"},"hashTypes":{"name":"StringLiteral","order":"StringLiteral","number":"StringLiteral","sortable":"PathExpression"},"hashContexts":{"name":depth0,"order":depth0,"number":depth0,"sortable":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n"
    + container.escapeExpression((helpers.raw || (depth0 && depth0.raw) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic-list-header-column",{"name":"raw","hash":{"name":"activity","order":"activity","number":"true","sortable":"sortable"},"hashTypes":{"name":"StringLiteral","order":"StringLiteral","number":"StringLiteral","sortable":"PathExpression"},"hashContexts":{"name":depth0,"order":depth0,"number":depth0,"sortable":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "\n";
},"useData":true});
Ember.TEMPLATES["topic-post-badges.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "<a href='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"url",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "' class='badge badge-notification unread' title='"
    + container.escapeExpression((helpers.i18n || (depth0 && depth0.i18n) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic.unread_posts",{"name":"i18n","hash":{"count":"unread"},"hashTypes":{"count":"PathExpression"},"hashContexts":{"count":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "'>"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"unread",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"3":function(container,depth0,helpers,partials,data) {
    return "<a href='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"url",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "' class='badge badge-notification new-posts' title='"
    + container.escapeExpression((helpers.i18n || (depth0 && depth0.i18n) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic.total_unread_posts",{"name":"i18n","hash":{"count":"newPosts"},"hashTypes":{"count":"PathExpression"},"hashContexts":{"count":depth0},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "'>"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"newPosts",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"5":function(container,depth0,helpers,partials,data) {
    return "<a href='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"url",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "' class='badge badge-notification new-topic' title='"
    + container.escapeExpression((helpers.i18n || (depth0 && depth0.i18n) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"topic.new",{"name":"i18n","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "'>"
    + container.escapeExpression((helpers.i18n || (depth0 && depth0.i18n) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"filters.new.lower_title",{"name":"i18n","hash":{},"hashTypes":{},"hashContexts":{},"types":["StringLiteral"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<span class='topic-post-badges'>\n"
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"unread",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"newPosts",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(3, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"unseen",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(5, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "</span>\n";
},"useData":true});
Ember.TEMPLATES["topic-progress"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("nav");
        dom.setAttribute(el1,"id","topic-progress-expanded");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","jump-form");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var element1 = dom.childAt(element0, [3]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(element1,1,1);
        var morph2 = dom.createMorphAt(element1,3,3);
        var morph3 = dom.createMorphAt(element0,5,5);
        inline(env, morph0, context, "d-button", [], {"action": "jumpTop", "disabled": get(env, context, "jumpTopDisabled"), "class": "full no-text", "icon": "caret-up", "label": "topic.progress.go_top"});
        inline(env, morph1, context, "input", [], {"value": get(env, context, "toPostIndex")});
        inline(env, morph2, context, "d-button", [], {"action": "jumpPost", "label": "topic.progress.go"});
        inline(env, morph3, context, "d-button", [], {"action": "jumpBottom", "disabled": get(env, context, "jumpBottomDisabled"), "class": "full no-text jump-bottom", "icon": "caret-down", "label": "topic.progress.go_bottom"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("nav");
      dom.setAttribute(el1,"id","topic-progress");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","nums");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("h4");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("span");
      var el4 = dom.createTextNode(" ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("span");
      var el5 = dom.createTextNode("/");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode(" ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h4");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("i");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","bg");
      var el3 = dom.createTextNode(" ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [1]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(element3, [2]);
      var element5 = dom.childAt(element2, [3]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var attrMorph0 = dom.createAttrMorph(element2, 'title');
      var attrMorph1 = dom.createAttrMorph(element2, 'class');
      var morph1 = dom.createMorphAt(dom.childAt(element3, [1]),0,0);
      var attrMorph2 = dom.createAttrMorph(element4, 'class');
      var morph2 = dom.createMorphAt(dom.childAt(element4, [3]),0,0);
      var attrMorph3 = dom.createAttrMorph(element5, 'class');
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "expanded")], {}, child0, null);
      attribute(env, attrMorph0, element2, "title", concat(env, [subexpr(env, context, "i18n", ["topic.progress.title"], {})]));
      attribute(env, attrMorph1, element2, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "hideProgress"), "hidden"], {})]));
      content(env, morph1, context, "progressPosition");
      attribute(env, attrMorph2, element4, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "hugeNumberOfPosts"), "hidden"], {})]));
      content(env, morph2, context, "model.postStream.filteredPostsCount");
      attribute(env, attrMorph3, element5, "class", concat(env, ["fa ", subexpr(env, context, "unless", [get(env, context, "expanded"), "fa-sort"], {})]));
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["topic-status.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "<div class='topic-statuses'>\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"status.href",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(4, data, 0),"inverse":container.program(6, data, 0),"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"4":function(container,depth0,helpers,partials,data) {
    return "<a href='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"status.href",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "' title='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"status.title",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "' class='topic-status "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"status.extraClasses",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'><i class='fa fa-"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"status.icon",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'></i></a>";
},"6":function(container,depth0,helpers,partials,data) {
    return "<"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"status.openTag",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + " title='"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"status.title",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "' class='topic-status'><i class='fa fa-"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"status.icon",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "'></i></"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"status.closeTag",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + ">";
},"8":function(container,depth0,helpers,partials,data) {
    return "</div>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"view.renderDiv",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"status","in","view.statuses",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(3, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"view.renderDiv",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(8, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"useData":true});
Ember.TEMPLATES["topic"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","container");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        inline(env, morph0, context, "discourse-banner", [], {"user": get(env, context, "currentUser"), "banner": get(env, context, "site.banner"), "overlay": get(env, context, "view.hasScrolled"), "hide": get(env, context, "model.errorLoading")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("span");
              dom.setAttribute(el1,"class","private-message-glyph");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              inline(env, morph0, context, "fa-icon", ["envelope"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("br");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,3,3,contextualElement);
              inline(env, morph0, context, "category-chooser", [], {"valueAttribute": "id", "value": get(env, context, "buffered.category_id")});
              return fragment;
            }
          };
        }());
        var child2 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "tag-chooser", [], {"tags": get(env, context, "buffered.tags")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
            var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
            var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
            var morph4 = dom.createMorphAt(fragment,8,8,contextualElement);
            var morph5 = dom.createMorphAt(fragment,10,10,contextualElement);
            var morph6 = dom.createMorphAt(fragment,12,12,contextualElement);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "model.isPrivateMessage")], {}, child0, null);
            inline(env, morph1, context, "text-field", [], {"id": "edit-title", "value": get(env, context, "buffered.title"), "maxlength": get(env, context, "siteSettings.max_topic_title_length"), "autofocus": "true"});
            block(env, morph2, context, "if", [get(env, context, "showCategoryChooser")], {}, child1, null);
            block(env, morph3, context, "if", [get(env, context, "canEditTags")], {}, child2, null);
            inline(env, morph4, context, "plugin-outlet", ["edit-topic"], {});
            inline(env, morph5, context, "d-button", [], {"action": "finishedEditingTopic", "class": "btn-primary btn-small submit-edit", "icon": "check"});
            inline(env, morph6, context, "d-button", [], {"action": "cancelEditingTopic", "class": "btn-small cancel-edit", "icon": "times"});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("a");
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("span");
              dom.setAttribute(el2,"class","private-message-glyph");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element6 = dom.childAt(fragment, [1]);
              var attrMorph0 = dom.createAttrMorph(element6, 'href');
              var morph0 = dom.createMorphAt(dom.childAt(element6, [1]),0,0);
              attribute(env, attrMorph0, element6, "href", get(env, context, "pmPath"));
              inline(env, morph0, context, "fa-icon", ["envelope"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("a");
              dom.setAttribute(el1,"class","fancy-title");
              var el2 = dom.createTextNode("\n                  ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element5 = dom.childAt(fragment, [3]);
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              var morph1 = dom.createUnsafeMorphAt(element5,1,1);
              var attrMorph0 = dom.createAttrMorph(element5, 'href');
              inline(env, morph0, context, "topic-status", [], {"topic": get(env, context, "model")});
              attribute(env, attrMorph0, element5, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "model.url")], {})]));
              element(env, element5, context, "action", ["jumpTop"], {});
              content(env, morph1, context, "model.fancyTitle");
              return fragment;
            }
          };
        }());
        var child2 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("a");
              dom.setAttribute(el1,"href","");
              dom.setAttribute(el1,"class","edit-topic");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element4 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(element4,0,0);
              var attrMorph0 = dom.createAttrMorph(element4, 'title');
              attribute(env, attrMorph0, element4, "title", concat(env, [subexpr(env, context, "i18n", ["edit"], {})]));
              element(env, element4, context, "action", ["editTopic"], {});
              inline(env, morph0, context, "fa-icon", ["pencil"], {});
              return fragment;
            }
          };
        }());
        var child3 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "topic-category", [], {"topic": get(env, context, "model")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h1");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("            ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element7 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element7,1,1);
            var morph1 = dom.createMorphAt(element7,3,3);
            var morph2 = dom.createMorphAt(element7,5,5);
            var morph3 = dom.createMorphAt(fragment,3,3,contextualElement);
            dom.insertBoundary(fragment, null);
            block(env, morph0, context, "unless", [get(env, context, "model.is_warning")], {}, child0, null);
            block(env, morph1, context, "if", [get(env, context, "model.details.loaded")], {}, child1, null);
            block(env, morph2, context, "if", [get(env, context, "model.details.can_edit")], {}, child2, null);
            block(env, morph3, context, "unless", [get(env, context, "model.isPrivateMessage")], {}, child3, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"id","topic-title");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","container");
          var el3 = dom.createTextNode("\n\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","title-wrapper");
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("        ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element8 = dom.childAt(fragment, [1, 1]);
          var morph0 = dom.createMorphAt(dom.childAt(element8, [1]),1,1);
          var morph1 = dom.createMorphAt(element8,3,3);
          block(env, morph0, context, "if", [get(env, context, "editingTopic")], {}, child0, child1);
          inline(env, morph1, context, "plugin-outlet", ["topic-title"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "scrolling-post-stream", [], {"posts": get(env, context, "postsToRender"), "canCreatePost": get(env, context, "model.details.can_create_post"), "multiSelect": get(env, context, "multiSelect"), "selectedPostsCount": get(env, context, "selectedPostsCount"), "selectedQuery": get(env, context, "selectedQuery"), "gaps": get(env, context, "model.postStream.gaps"), "showFlags": "showFlags", "editPost": "editPost", "showHistory": "showHistory", "showRawEmail": "showRawEmail", "deletePost": "deletePost", "recoverPost": "recoverPost", "expandHidden": "expandHidden", "newTopicAction": "replyAsNewTopic", "expandFirstPost": "expandFirstPost", "toggleBookmark": "toggleBookmark", "togglePostType": "togglePostType", "rebakePost": "rebakePost", "changePostOwner": "changePostOwner", "unhidePost": "unhidePost", "replyToPost": "replyToPost", "toggleWiki": "toggleWiki", "toggleSummary": "toggleSummary", "removeAllowedUser": "removeAllowedUser", "showInvite": "showInvite", "topVisibleChanged": "topVisibleChanged", "bottomVisibleChanged": "bottomVisibleChanged", "selectPost": "toggledSelectedPost", "selectReplies": "toggledSelectedPostReplies", "fillGapBefore": "fillGapBefore", "fillGapAfter": "fillGapAfter"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              content(env, morph0, context, "signup-cta");
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "topic-footer-buttons", [], {"topic": get(env, context, "model")});
              return fragment;
            }
          };
        }());
        var child2 = (function() {
          var child0 = (function() {
            var child0 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.2",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createTextNode("                    ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createComment("");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n                    ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createComment("");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n");
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, inline = hooks.inline;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                  var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
                  inline(env, morph0, context, "fa-icon", ["check"], {});
                  inline(env, morph1, context, "i18n", ["queue.view_pending"], {});
                  return fragment;
                }
              };
            }());
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, block = hooks.block;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
                dom.insertBoundary(fragment, null);
                dom.insertBoundary(fragment, 0);
                block(env, morph0, context, "link-to", ["queued-posts"], {}, child0, null);
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","has-pending-posts");
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("              ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element3 = dom.childAt(fragment, [1]);
              var morph0 = dom.createUnsafeMorphAt(element3,1,1);
              var morph1 = dom.createMorphAt(element3,3,3);
              inline(env, morph0, context, "i18n", ["queue.has_pending_posts"], {"count": get(env, context, "model.pending_posts_count")});
              block(env, morph1, context, "if", [get(env, context, "currentUser.show_queued_posts")], {}, child0, null);
              return fragment;
            }
          };
        }());
        var child3 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n              ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element2 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(element2,1,1);
              var attrMorph0 = dom.createAttrMorph(element2, 'class');
              attribute(env, attrMorph0, element2, "class", concat(env, ["selected-posts ", subexpr(env, context, "unless", [get(env, context, "multiSelect"), "hidden"], {})]));
              inline(env, morph0, context, "partial", ["selected-posts"], {});
              return fragment;
            }
          };
        }());
        var child4 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                    ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "basic-topic-list", [], {"hideCategory": "true", "showPosters": "true", "topics": get(env, context, "model.details.suggested_topics"), "postsAction": "showTopicEntrance"});
                return fragment;
              }
            };
          }());
          var child1 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                    ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "basic-topic-list", [], {"topics": get(env, context, "model.details.suggested_topics"), "postsAction": "showTopicEntrance"});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"id","suggested-topics");
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("h3");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("div");
              dom.setAttribute(el2,"class","topics");
              var el3 = dom.createTextNode("\n");
              dom.appendChild(el2, el3);
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              var el3 = dom.createTextNode("                ");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n                ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("h3");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n              ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element1 = dom.childAt(fragment, [1]);
              var morph0 = dom.createUnsafeMorphAt(dom.childAt(element1, [1]),0,0);
              var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
              var morph2 = dom.createUnsafeMorphAt(dom.childAt(element1, [5]),0,0);
              content(env, morph0, context, "suggestedTitle");
              block(env, morph1, context, "if", [get(env, context, "model.isPrivateMessage")], {}, child0, child1);
              content(env, morph2, context, "browseMoreMessage");
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
            var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
            var morph3 = dom.createMorphAt(fragment,7,7,contextualElement);
            var morph4 = dom.createMorphAt(fragment,9,9,contextualElement);
            var morph5 = dom.createMorphAt(fragment,11,11,contextualElement);
            inline(env, morph0, context, "topic-closing", [], {"topic": get(env, context, "model")});
            block(env, morph1, context, "if", [get(env, context, "session.showSignupCta")], {}, child0, child1);
            block(env, morph2, context, "if", [get(env, context, "model.pending_posts_count")], {}, child2, null);
            block(env, morph3, context, "if", [get(env, context, "showSelectedPostsAtBottom")], {}, child3, null);
            inline(env, morph4, context, "plugin-outlet", ["topic-above-suggested"], {});
            block(env, morph5, context, "if", [get(env, context, "model.details.suggested_topics.length")], {}, child4, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "loadedAllPosts")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","container posts");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","row");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("section");
        dom.setAttribute(el3,"class","topic-area");
        dom.setAttribute(el3,"id","topic");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("div");
        dom.setAttribute(el4,"class","posts-wrapper");
        var el5 = dom.createTextNode("\n\n          ");
        dom.appendChild(el4, el5);
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n\n          ");
        dom.appendChild(el4, el5);
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n\n          ");
        dom.appendChild(el4, el5);
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n\n");
        dom.appendChild(el4, el5);
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("        ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("div");
        dom.setAttribute(el4,"id","topic-bottom");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element9 = dom.childAt(fragment, [2]);
        var element10 = dom.childAt(element9, [1]);
        var element11 = dom.childAt(element9, [3, 1]);
        var element12 = dom.childAt(element11, [1]);
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(element10,1,1);
        var attrMorph0 = dom.createAttrMorph(element10, 'class');
        var attrMorph1 = dom.createAttrMorph(element11, 'data-topic-id');
        var morph2 = dom.createMorphAt(element12,1,1);
        var morph3 = dom.createMorphAt(element12,3,3);
        var morph4 = dom.createMorphAt(element12,5,5);
        var morph5 = dom.createMorphAt(element12,7,7);
        var morph6 = dom.createMorphAt(element11,5,5);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "model.postStream.firstPostPresent")], {}, child0, null);
        attribute(env, attrMorph0, element10, "class", concat(env, ["selected-posts ", subexpr(env, context, "unless", [get(env, context, "multiSelect"), "hidden"], {})]));
        inline(env, morph1, context, "partial", ["selected-posts"], {});
        attribute(env, attrMorph1, element11, "data-topic-id", concat(env, [subexpr(env, context, "unbound", [get(env, context, "model.id")], {})]));
        inline(env, morph2, context, "render", ["topic-progress"], {});
        inline(env, morph3, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.postStream.loadingAbove")});
        inline(env, morph4, context, "plugin-outlet", ["topic-above-posts"], {});
        block(env, morph5, context, "unless", [get(env, context, "model.postStream.loadingFilter")], {}, child1, null);
        block(env, morph6, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.postStream.loadingFilter")}, child2, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","not-found");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
            content(env, morph0, context, "model.notFoundHtml");
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("              ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "d-button", [], {"action": "showLogin", "class": "btn-primary topic-retry", "icon": "user", "label": "log_in"});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              block(env, morph0, context, "unless", [get(env, context, "currentUser")], {}, child0, null);
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-button", [], {"action": "retryLoading", "class": "btn-primary topic-retry", "icon": "refresh", "label": "errors.buttons.again"});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","topic-error");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("div");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
            var morph1 = dom.createMorphAt(element0,3,3);
            var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
            content(env, morph0, context, "model.message");
            block(env, morph1, context, "if", [get(env, context, "model.noRetry")], {}, child0, child1);
            inline(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "retrying")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "model.notFoundHtml")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","container");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "conditional-loading-spinner", [], {"condition": get(env, context, "noErrorYet")}, child0, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "render", ["quote-button"], {});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            dom.setAttribute(el1,"class","topic-admin-delete");
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            inline(env, morph0, context, "d-button", [], {"action": "deleteTopic", "icon": "trash-o", "label": "topic.actions.delete", "class": "btn-danger"});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            dom.setAttribute(el1,"class","topic-admin-recover");
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            inline(env, morph0, context, "d-button", [], {"action": "recoverTopic", "icon": "undo", "label": "topic.actions.recover"});
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "toggleClosed", "icon": "unlock", "label": "topic.actions.open"});
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "toggleClosed", "icon": "lock", "label": "topic.actions.close"});
            inline(env, morph1, context, "d-button", [], {"action": "showAutoClose", "icon": "clock-o", "label": "topic.actions.auto_close"});
            return fragment;
          }
        };
      }());
      var child4 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("            ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "d-button", [], {"action": "showFeatureTopic", "icon": "thumb-tack", "label": "topic.actions.unpin"});
                return fragment;
              }
            };
          }());
          var child1 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("            ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "d-button", [], {"action": "showFeatureTopic", "icon": "thumb-tack", "label": "topic.actions.pin"});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("        ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("li");
              dom.setAttribute(el1,"class","topic-admin-pin");
              var el2 = dom.createTextNode("\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("        ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              block(env, morph0, context, "if", [get(env, context, "isFeatured")], {}, child0, child1);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "model.visible")], {}, child0, null);
            return fragment;
          }
        };
      }());
      var child5 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "toggleArchived", "icon": "folder", "label": "topic.actions.unarchive"});
            return fragment;
          }
        };
      }());
      var child6 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("        ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-button", [], {"action": "toggleArchived", "icon": "folder", "label": "topic.actions.archive"});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "unless", [get(env, context, "model.isPrivateMessage")], {}, child0, null);
            return fragment;
          }
        };
      }());
      var child7 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "toggleVisibility", "icon": "eye-slash", "label": "topic.actions.invisible"});
            return fragment;
          }
        };
      }());
      var child8 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "toggleVisibility", "icon": "eye", "label": "topic.actions.visible"});
            return fragment;
          }
        };
      }());
      var child9 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-button", [], {"action": "convertToPublicTopic", "icon": "comment", "label": "topic.actions.make_public"});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-button", [], {"action": "convertToPrivateMessage", "icon": "envelope", "label": "topic.actions.make_private"});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            dom.setAttribute(el1,"class","topic-admin-convert");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            block(env, morph0, context, "if", [get(env, context, "model.isPrivateMessage")], {}, child0, child1);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          dom.setAttribute(el1,"class","topic-admin-multi-select");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          dom.setAttribute(el1,"class","topic-admin-autoclose");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          dom.setAttribute(el1,"class","topic-admin-change-timestamp");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          dom.setAttribute(el1,"class","topic-admin-archive");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          dom.setAttribute(el1,"class","topic-admin-visible");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
          var morph3 = dom.createMorphAt(dom.childAt(fragment, [7]),1,1);
          var morph4 = dom.createMorphAt(fragment,9,9,contextualElement);
          var morph5 = dom.createMorphAt(dom.childAt(fragment, [11]),1,1);
          var morph6 = dom.createMorphAt(dom.childAt(fragment, [13]),1,1);
          var morph7 = dom.createMorphAt(dom.childAt(fragment, [15]),1,1);
          var morph8 = dom.createMorphAt(fragment,17,17,contextualElement);
          var morph9 = dom.createMorphAt(fragment,19,19,contextualElement);
          inline(env, morph0, context, "d-button", [], {"action": "toggleMultiSelect", "icon": "tasks", "label": "topic.actions.multi_select"});
          block(env, morph1, context, "if", [get(env, context, "model.details.can_delete")], {}, child0, null);
          block(env, morph2, context, "if", [get(env, context, "showRecover")], {}, child1, null);
          block(env, morph3, context, "if", [get(env, context, "model.closed")], {}, child2, child3);
          block(env, morph4, context, "unless", [get(env, context, "model.isPrivateMessage")], {}, child4, null);
          inline(env, morph5, context, "d-button", [], {"action": "showChangeTimestamp", "icon": "calendar", "label": "topic.change_timestamp.title"});
          block(env, morph6, context, "if", [get(env, context, "model.archived")], {}, child5, child6);
          block(env, morph7, context, "if", [get(env, context, "model.visible")], {}, child7, child8);
          block(env, morph8, context, "if", [get(env, context, "currentUser.staff")], {}, child9, null);
          inline(env, morph9, context, "plugin-outlet", ["topic-admin-menu-buttons"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        inline(env, morph0, context, "show-popup-button", [], {"action": "showTopicAdminMenu", "class": "show-topic-admin", "title": "topic_admin_menu", "icon": "wrench"});
        block(env, morph1, context, "popup-menu", [], {"visible": get(env, context, "adminMenuVisible"), "hide": "hideTopicAdminMenu", "title": "admin_title", "extraClasses": "topic-admin-popup-menu"}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      var morph4 = dom.createMorphAt(fragment,8,8,contextualElement);
      var morph5 = dom.createMorphAt(fragment,10,10,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "model")], {}, child0, null);
      inline(env, morph1, context, "plugin-outlet", ["topic-above-post-stream"], {});
      block(env, morph2, context, "if", [get(env, context, "model.postStream.loaded")], {}, child1, child2);
      inline(env, morph3, context, "render", ["share"], {});
      block(env, morph4, context, "if", [get(env, context, "currentUser.enable_quoting")], {}, child3, null);
      block(env, morph5, context, "if", [get(env, context, "currentUser.canManageTopic")], {}, child4, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["topic/unsubscribe"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","container");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("p");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode(" ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content, inline = hooks.inline, get = hooks.get;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [3]);
      var morph0 = dom.createUnsafeMorphAt(dom.childAt(element0, [1]),1,1);
      var morph1 = dom.createMorphAt(element1,1,1);
      var morph2 = dom.createMorphAt(element1,3,3);
      content(env, morph0, context, "stopNotificiationsText");
      inline(env, morph1, context, "i18n", ["topic.unsubscribe.change_notification_state"], {});
      inline(env, morph2, context, "topic-notifications-button", [], {"topic": get(env, context, "model")});
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user-card"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h2");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "user.name");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h2");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "user.title");
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"class","btn btn-primary");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element14 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element14,0,0);
          var morph1 = dom.createMorphAt(element14,1,1);
          element(env, element14, context, "action", ["composePrivateMessage", get(env, context, "user"), get(env, context, "post")], {});
          inline(env, morph0, context, "fa-icon", ["envelope"], {});
          inline(env, morph1, context, "i18n", ["user.private_message"], {});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"class","btn");
          dom.setAttribute(el2,"href","");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element13 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element13,0,0);
          var morph1 = dom.createMorphAt(element13,1,1);
          element(env, element13, context, "action", ["togglePosts", get(env, context, "user")], {});
          inline(env, morph0, context, "fa-icon", ["filter"], {});
          inline(env, morph1, context, "i18n", ["topic.filter_to"], {"username": get(env, context, "username"), "post_count": get(env, context, "topicPostCount")});
          return fragment;
        }
      };
    }());
    var child4 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"class","btn");
          dom.setAttribute(el2,"href","");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element12 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element12,0,0);
          var morph1 = dom.createMorphAt(element12,1,1);
          element(env, element12, context, "action", ["cancelFilter"], {});
          inline(env, morph0, context, "fa-icon", ["times"], {});
          inline(env, morph1, context, "i18n", ["topic.filters.cancel"], {});
          return fragment;
        }
      };
    }());
    var child5 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"class","btn btn-danger");
          dom.setAttribute(el2,"href","");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element11 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element11,0,0);
          var morph1 = dom.createMorphAt(element11,1,1);
          element(env, element11, context, "action", ["deleteUser", get(env, context, "user")], {});
          inline(env, morph0, context, "fa-icon", ["exclamation-triangle"], {});
          inline(env, morph1, context, "i18n", ["admin.user.delete"], {});
          return fragment;
        }
      };
    }());
    var child6 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","suspended");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("b");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("br");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("b");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element10 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element10,1,1);
          var morph1 = dom.createMorphAt(dom.childAt(element10, [3]),0,0);
          var morph2 = dom.createMorphAt(dom.childAt(element10, [6]),0,0);
          var morph3 = dom.createMorphAt(element10,8,8);
          inline(env, morph0, context, "fa-icon", ["ban"], {});
          inline(env, morph1, context, "i18n", ["user.suspended_notice"], {"date": get(env, context, "user.suspendedTillDate")});
          inline(env, morph2, context, "i18n", ["user.suspended_reason"], {});
          content(env, morph3, context, "user.suspend_reason");
          return fragment;
        }
      };
    }());
    var child7 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","bio");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),0,0);
            inline(env, morph0, context, "text-overflow", [], {"class": "overflow", "text": get(env, context, "user.bio_excerpt")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          block(env, morph0, context, "if", [get(env, context, "user.bio_cooked")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child8 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "icon-or-image", [get(env, context, "user.card_badge.image")], {"title": get(env, context, "user.card_badge.name")});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "link-to", ["badges.show", get(env, context, "user.card_badge")], {"class": "card-badge", "title": get(env, context, "user.card_badge.name")}, child0, null);
          return fragment;
        }
      };
    }());
    var child9 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","location");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element8 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element8,0,0);
            var morph1 = dom.createMorphAt(element8,2,2);
            inline(env, morph0, context, "fa-icon", ["map-marker"], {});
            content(env, morph1, context, "user.location");
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("a");
              dom.setAttribute(el1,"target","_blank");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element6 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(element6,0,0);
              var attrMorph0 = dom.createAttrMorph(element6, 'href');
              var attrMorph1 = dom.createAttrMorph(element6, 'rel');
              attribute(env, attrMorph0, element6, "href", get(env, context, "user.website"));
              attribute(env, attrMorph1, element6, "rel", subexpr(env, context, "unless", [get(env, context, "removeNoFollow"), "nofollow"], {}));
              content(env, morph0, context, "user.website_name");
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("span");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element5 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(element5,0,0);
              var attrMorph0 = dom.createAttrMorph(element5, 'title');
              attribute(env, attrMorph0, element5, "title", get(env, context, "user.website"));
              content(env, morph0, context, "user.website_name");
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","website-name");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element7 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element7,1,1);
            var morph1 = dom.createMorphAt(element7,3,3);
            inline(env, morph0, context, "fa-icon", ["globe"], {});
            block(env, morph1, context, "if", [get(env, context, "linkWebsite")], {}, child0, child1);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","location-and-website");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element9 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element9,1,1);
          var morph1 = dom.createMorphAt(element9,3,3);
          block(env, morph0, context, "if", [get(env, context, "user.location")], {}, child0, null);
          block(env, morph1, context, "if", [get(env, context, "user.website_name")], {}, child1, null);
          return fragment;
        }
      };
    }());
    var child10 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("h3");
            var el2 = dom.createElement("span");
            dom.setAttribute(el2,"class","desc");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element2 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(dom.childAt(element2, [0]),0,0);
            var morph1 = dom.createMorphAt(element2,2,2);
            inline(env, morph0, context, "i18n", ["last_post"], {});
            inline(env, morph1, context, "format-date", [get(env, context, "user.last_posted_at")], {"leaveAgo": "true"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","metadata");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("h3");
          var el3 = dom.createElement("span");
          dom.setAttribute(el3,"class","desc");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode(" ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element3 = dom.childAt(fragment, [1]);
          var element4 = dom.childAt(element3, [3]);
          var morph0 = dom.createMorphAt(element3,1,1);
          var morph1 = dom.createMorphAt(dom.childAt(element4, [0]),0,0);
          var morph2 = dom.createMorphAt(element4,2,2);
          var morph3 = dom.createMorphAt(element3,5,5);
          block(env, morph0, context, "if", [get(env, context, "user.last_posted_at")], {}, child0, null);
          inline(env, morph1, context, "i18n", ["joined"], {});
          inline(env, morph2, context, "format-date", [get(env, context, "user.created_at")], {"leaveAgo": "true"});
          inline(env, morph3, context, "plugin-outlet", ["user-card-metadata"], {});
          return fragment;
        }
      };
    }());
    var child11 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("span");
              dom.setAttribute(el2,"class","user-field-name");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              var el3 = dom.createTextNode(":");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("span");
              dom.setAttribute(el2,"class","user-field-value");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n          ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element1 = dom.childAt(fragment, [1]);
              var attrMorph0 = dom.createAttrMorph(element1, 'class');
              var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
              var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
              attribute(env, attrMorph0, element1, "class", concat(env, ["public-user-field ", get(env, context, "uf.field.dasherized_name")]));
              content(env, morph0, context, "uf.field.name");
              content(env, morph1, context, "uf.value");
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            set(env, context, "uf", blockArguments[0]);
            block(env, morph0, context, "if", [get(env, context, "uf.value")], {}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","public-user-fields");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          block(env, morph0, context, "each", [get(env, context, "publicUserFields")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child12 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            set(env, context, "ub", blockArguments[0]);
            inline(env, morph0, context, "user-badge", [], {"badge": get(env, context, "ub.badge"), "user": get(env, context, "user")});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "i18n", ["badges.more_badges"], {"count": get(env, context, "moreBadgesCount")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "link-to", ["user.badges", get(env, context, "user")], {"class": "btn more-user-badges"}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","badge-section");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element0,1,1);
          var morph1 = dom.createMorphAt(element0,2,2);
          block(env, morph0, context, "each", [get(env, context, "user.featured_user_badges")], {}, child0, null);
          block(env, morph1, context, "if", [get(env, context, "showMoreBadges")], {}, child1, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","card-content");
        var el2 = dom.createTextNode("\n\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"class","card-huge-avatar");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","names");
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("h1");
        var el5 = dom.createTextNode("\n        ");
        dom.appendChild(el4, el5);
        var el5 = dom.createElement("a");
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        var el6 = dom.createTextNode(" ");
        dom.appendChild(el5, el6);
        var el6 = dom.createComment("");
        dom.appendChild(el5, el6);
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("\n      ");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n    ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n  ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("ul");
        dom.setAttribute(el2,"class","usercard-controls");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("  ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline, concat = hooks.concat, content = hooks.content, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element15 = dom.childAt(fragment, [0]);
        var element16 = dom.childAt(element15, [1]);
        var element17 = dom.childAt(element15, [3, 1]);
        var element18 = dom.childAt(element17, [1]);
        var element19 = dom.childAt(element18, [1]);
        var element20 = dom.childAt(element15, [5]);
        var morph0 = dom.createMorphAt(element16,0,0);
        var attrMorph0 = dom.createAttrMorph(element16, 'href');
        var attrMorph1 = dom.createAttrMorph(element18, 'class');
        var morph1 = dom.createMorphAt(element19,0,0);
        var morph2 = dom.createMorphAt(element19,2,2);
        var attrMorph2 = dom.createAttrMorph(element19, 'href');
        var morph3 = dom.createMorphAt(element17,3,3);
        var morph4 = dom.createMorphAt(element17,5,5);
        var morph5 = dom.createMorphAt(element17,7,7);
        var morph6 = dom.createMorphAt(element20,1,1);
        var morph7 = dom.createMorphAt(element20,3,3);
        var morph8 = dom.createMorphAt(element20,5,5);
        var morph9 = dom.createMorphAt(element20,7,7);
        var morph10 = dom.createMorphAt(element15,7,7);
        var morph11 = dom.createMorphAt(element15,9,9);
        var morph12 = dom.createMorphAt(element15,11,11);
        var morph13 = dom.createMorphAt(element15,13,13);
        var morph14 = dom.createMorphAt(element15,15,15);
        var morph15 = dom.createMorphAt(element15,17,17);
        attribute(env, attrMorph0, element16, "href", get(env, context, "user.path"));
        element(env, element16, context, "action", ["showUser"], {});
        inline(env, morph0, context, "bound-avatar", [get(env, context, "avatar"), "huge"], {});
        attribute(env, attrMorph1, element18, "class", concat(env, [get(env, context, "staff"), " ", get(env, context, "new_user")]));
        attribute(env, attrMorph2, element19, "href", get(env, context, "user.path"));
        element(env, element19, context, "action", ["showUser"], {});
        content(env, morph1, context, "username");
        inline(env, morph2, context, "user-status", [get(env, context, "user")], {"currentUser": get(env, context, "currentUser")});
        block(env, morph3, context, "if", [get(env, context, "user.name")], {}, child0, null);
        block(env, morph4, context, "if", [get(env, context, "user.title")], {}, child1, null);
        inline(env, morph5, context, "plugin-outlet", ["user-card-post-names"], {});
        block(env, morph6, context, "if", [get(env, context, "user.can_send_private_message_to_user")], {}, child2, null);
        block(env, morph7, context, "if", [get(env, context, "showFilter")], {}, child3, null);
        block(env, morph8, context, "if", [get(env, context, "hasUserFilters")], {}, child4, null);
        block(env, morph9, context, "if", [get(env, context, "showDelete")], {}, child5, null);
        block(env, morph10, context, "if", [get(env, context, "isSuspended")], {}, child6, child7);
        block(env, morph11, context, "if", [get(env, context, "user.card_badge")], {}, child8, null);
        block(env, morph12, context, "if", [get(env, context, "hasLocationOrWebsite")], {}, child9, null);
        block(env, morph13, context, "if", [get(env, context, "user")], {}, child10, null);
        block(env, morph14, context, "if", [get(env, context, "publicUserFields")], {}, child11, null);
        block(env, morph15, context, "if", [get(env, context, "showBadges")], {}, child12, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "visible")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user-invited-show"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "resumable-upload", [], {"target": "/invites/upload", "success": "uploadSuccess", "error": "uploadError", "uploadText": get(env, context, "uploadText")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","user-invite-controls");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("div");
            dom.setAttribute(el2,"class","span15");
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("ul");
            dom.setAttribute(el3,"class","nav nav-pills");
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n            ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n          ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("div");
            dom.setAttribute(el2,"class","pull-right");
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("          ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element6 = dom.childAt(fragment, [1]);
            var element7 = dom.childAt(element6, [1, 1]);
            var element8 = dom.childAt(element6, [3]);
            var morph0 = dom.createMorphAt(element7,1,1);
            var morph1 = dom.createMorphAt(element7,3,3);
            var morph2 = dom.createMorphAt(element8,1,1);
            var morph3 = dom.createMorphAt(element8,3,3);
            inline(env, morph0, context, "nav-item", [], {"route": "userInvited.show", "routeParam": "pending", "i18nLabel": get(env, context, "pendingLabel")});
            inline(env, morph1, context, "nav-item", [], {"route": "userInvited.show", "routeParam": "redeemed", "i18nLabel": get(env, context, "redeemedLabel")});
            inline(env, morph2, context, "d-button", [], {"icon": "plus", "action": "showInvite", "label": "user.invited.create", "class": "btn"});
            block(env, morph3, context, "if", [get(env, context, "canBulkInvite")], {}, child0, null);
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","user-invite-search");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("form");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1]),0,0);
            inline(env, morph0, context, "text-field", [], {"value": get(env, context, "searchTerm"), "placeholderKey": "user.invited.search"});
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("th");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("th");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("th");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("th");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("th");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
                var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
                var morph2 = dom.createMorphAt(dom.childAt(fragment, [5]),0,0);
                var morph3 = dom.createMorphAt(dom.childAt(fragment, [7]),0,0);
                var morph4 = dom.createMorphAt(dom.childAt(fragment, [9]),0,0);
                inline(env, morph0, context, "i18n", ["user.last_seen"], {});
                inline(env, morph1, context, "i18n", ["user.invited.topics_entered"], {});
                inline(env, morph2, context, "i18n", ["user.invited.posts_read_count"], {});
                inline(env, morph3, context, "i18n", ["user.invited.time_read"], {});
                inline(env, morph4, context, "i18n", ["user.invited.days_visited"], {});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("th");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("th");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
              var morph2 = dom.createMorphAt(fragment,5,5,contextualElement);
              dom.insertBoundary(fragment, null);
              inline(env, morph0, context, "i18n", ["user.invited.user"], {});
              inline(env, morph1, context, "i18n", ["user.invited.redeemed_at"], {});
              block(env, morph2, context, "if", [get(env, context, "model.can_see_invite_details")], {}, child0, null);
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("th");
              dom.setAttribute(el1,"colspan","1");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n              ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("th");
              dom.setAttribute(el1,"colspan","6");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
              inline(env, morph0, context, "i18n", ["user.invited.user"], {});
              inline(env, morph1, context, "i18n", ["user.invited.sent"], {});
              return fragment;
            }
          };
        }());
        var child2 = (function() {
          var child0 = (function() {
            var child0 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.2",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createComment("");
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
                  dom.insertBoundary(fragment, null);
                  dom.insertBoundary(fragment, 0);
                  inline(env, morph0, context, "avatar", [get(env, context, "invite.user")], {"imageSize": "tiny"});
                  return fragment;
                }
              };
            }());
            var child1 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.2",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createComment("");
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, content = hooks.content;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
                  dom.insertBoundary(fragment, null);
                  dom.insertBoundary(fragment, 0);
                  content(env, morph0, context, "invite.user.username");
                  return fragment;
                }
              };
            }());
            var child2 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.2",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createTextNode("                  ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createElement("td");
                  var el2 = dom.createComment("");
                  dom.appendChild(el1, el2);
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n                  ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createElement("td");
                  var el2 = dom.createComment("");
                  dom.appendChild(el1, el2);
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n                  ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createElement("td");
                  var el2 = dom.createComment("");
                  dom.appendChild(el1, el2);
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n                  ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createElement("td");
                  var el2 = dom.createComment("");
                  dom.appendChild(el1, el2);
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n                  ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createElement("td");
                  var el2 = dom.createElement("span");
                  var el3 = dom.createComment("");
                  dom.appendChild(el2, el3);
                  dom.appendChild(el1, el2);
                  var el2 = dom.createTextNode("\n                      /\n                    ");
                  dom.appendChild(el1, el2);
                  var el2 = dom.createElement("span");
                  var el3 = dom.createComment("");
                  dom.appendChild(el2, el3);
                  dom.appendChild(el1, el2);
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n");
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, get = hooks.get, inline = hooks.inline, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var element1 = dom.childAt(fragment, [9]);
                  var element2 = dom.childAt(element1, [0]);
                  var element3 = dom.childAt(element1, [2]);
                  var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
                  var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
                  var morph2 = dom.createMorphAt(dom.childAt(fragment, [5]),0,0);
                  var morph3 = dom.createUnsafeMorphAt(dom.childAt(fragment, [7]),0,0);
                  var morph4 = dom.createUnsafeMorphAt(element2,0,0);
                  var attrMorph0 = dom.createAttrMorph(element2, 'title');
                  var morph5 = dom.createUnsafeMorphAt(element3,0,0);
                  var attrMorph1 = dom.createAttrMorph(element3, 'title');
                  inline(env, morph0, context, "format-date", [get(env, context, "invite.user.last_seen_at")], {});
                  inline(env, morph1, context, "number", [get(env, context, "invite.user.topics_entered")], {});
                  inline(env, morph2, context, "number", [get(env, context, "invite.user.posts_read_count")], {});
                  inline(env, morph3, context, "unbound", [get(env, context, "invite.user.time_read")], {});
                  attribute(env, attrMorph0, element2, "title", concat(env, [subexpr(env, context, "i18n", ["user.invited.days_visited"], {})]));
                  inline(env, morph4, context, "unbound", [get(env, context, "invite.user.days_visited")], {});
                  attribute(env, attrMorph1, element3, "title", concat(env, [subexpr(env, context, "i18n", ["user.invited.account_age_days"], {})]));
                  inline(env, morph5, context, "unbound", [get(env, context, "invite.user.days_since_created")], {});
                  return fragment;
                }
              };
            }());
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("td");
                var el2 = dom.createTextNode("\n                  ");
                dom.appendChild(el1, el2);
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                var el2 = dom.createTextNode("\n                  ");
                dom.appendChild(el1, el2);
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                var el2 = dom.createTextNode("\n                ");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("td");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element4 = dom.childAt(fragment, [1]);
                var morph0 = dom.createMorphAt(element4,1,1);
                var morph1 = dom.createMorphAt(element4,3,3);
                var morph2 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
                var morph3 = dom.createMorphAt(fragment,5,5,contextualElement);
                dom.insertBoundary(fragment, null);
                block(env, morph0, context, "link-to", ["user", get(env, context, "invite.user")], {}, child0, null);
                block(env, morph1, context, "link-to", ["user", get(env, context, "invite.user")], {}, child1, null);
                inline(env, morph2, context, "format-date", [get(env, context, "invite.redeemed_at")], {});
                block(env, morph3, context, "if", [get(env, context, "model.can_see_invite_details")], {}, child2, null);
                return fragment;
              }
            };
          }());
          var child1 = (function() {
            var child0 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.2",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createTextNode("                    ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createComment("");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n                        \n");
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, inline = hooks.inline;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                  inline(env, morph0, context, "i18n", ["user.invited.expired"], {});
                  return fragment;
                }
              };
            }());
            var child1 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.2",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createTextNode("                    ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createComment("");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n");
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, inline = hooks.inline;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                  inline(env, morph0, context, "i18n", ["user.invited.rescinded"], {});
                  return fragment;
                }
              };
            }());
            var child2 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.2",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createTextNode("                    ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createComment("");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n");
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                  inline(env, morph0, context, "d-button", [], {"icon": "times", "action": "rescind", "actionParam": get(env, context, "invite"), "class": "btn", "label": "user.invited.rescind"});
                  return fragment;
                }
              };
            }());
            var child3 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.2",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createTextNode("                    ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createComment("");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n");
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, inline = hooks.inline;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                  inline(env, morph0, context, "i18n", ["user.invited.reinvited"], {});
                  return fragment;
                }
              };
            }());
            var child4 = (function() {
              return {
                isHTMLBars: true,
                revision: "Ember@1.12.2",
                blockParams: 0,
                cachedFragment: null,
                hasRendered: false,
                build: function build(dom) {
                  var el0 = dom.createDocumentFragment();
                  var el1 = dom.createTextNode("                    ");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createComment("");
                  dom.appendChild(el0, el1);
                  var el1 = dom.createTextNode("\n");
                  dom.appendChild(el0, el1);
                  return el0;
                },
                render: function render(context, env, contextualElement) {
                  var dom = env.dom;
                  var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                  dom.detectNamespace(contextualElement);
                  var fragment;
                  if (env.useFragmentCache && dom.canClone) {
                    if (this.cachedFragment === null) {
                      fragment = this.build(dom);
                      if (this.hasRendered) {
                        this.cachedFragment = fragment;
                      } else {
                        this.hasRendered = true;
                      }
                    }
                    if (this.cachedFragment) {
                      fragment = dom.cloneNode(this.cachedFragment, true);
                    }
                  } else {
                    fragment = this.build(dom);
                  }
                  var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                  inline(env, morph0, context, "d-button", [], {"icon": "refresh", "action": "reinvite", "actionParam": get(env, context, "invite"), "class": "btn", "label": "user.invited.reinvite"});
                  return fragment;
                }
              };
            }());
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("td");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("td");
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n                ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("td");
                dom.setAttribute(el1,"colspan","5");
                var el2 = dom.createTextNode("\n");
                dom.appendChild(el1, el2);
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                var el2 = dom.createTextNode("                      \n");
                dom.appendChild(el1, el2);
                var el2 = dom.createComment("");
                dom.appendChild(el1, el2);
                var el2 = dom.createTextNode("                ");
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var element0 = dom.childAt(fragment, [5]);
                var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
                var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
                var morph2 = dom.createMorphAt(element0,1,1);
                var morph3 = dom.createMorphAt(element0,2,2);
                var morph4 = dom.createMorphAt(element0,4,4);
                inline(env, morph0, context, "unbound", [get(env, context, "invite.email")], {});
                inline(env, morph1, context, "format-date", [get(env, context, "invite.created_at")], {});
                block(env, morph2, context, "if", [get(env, context, "invite.expired")], {}, child0, null);
                block(env, morph3, context, "if", [get(env, context, "invite.rescinded")], {}, child1, child2);
                block(env, morph4, context, "if", [get(env, context, "invite.reinvited")], {}, child3, child4);
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("tr");
              var el2 = dom.createTextNode("\n");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("            ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              set(env, context, "invite", blockArguments[0]);
              block(env, morph0, context, "if", [get(env, context, "invite.user")], {}, child0, child1);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("table");
            dom.setAttribute(el1,"class","table user-invite-list");
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("tr");
            var el3 = dom.createTextNode("\n");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("          ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element5 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(dom.childAt(element5, [1]),1,1);
            var morph1 = dom.createMorphAt(element5,3,3);
            var morph2 = dom.createMorphAt(fragment,3,3,contextualElement);
            block(env, morph0, context, "if", [get(env, context, "inviteRedeemed")], {}, child0, child1);
            block(env, morph1, context, "each", [get(env, context, "model.invites")], {}, child2, null);
            inline(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "invitesLoading")});
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createUnsafeMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "i18n", ["user.invited.bulk_invite.none"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "i18n", ["user.invited.none"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","user-invite-none");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            block(env, morph0, context, "if", [get(env, context, "canBulkInvite")], {}, child0, child1);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("section");
          dom.setAttribute(el1,"class","user-content");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("h2");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element9 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(element9, [1]),0,0);
          var morph1 = dom.createMorphAt(element9,3,3);
          var morph2 = dom.createMorphAt(element9,5,5);
          var morph3 = dom.createMorphAt(element9,7,7);
          inline(env, morph0, context, "i18n", ["user.invited.title"], {});
          block(env, morph1, context, "if", [get(env, context, "model.can_see_invite_details")], {}, child0, null);
          block(env, morph2, context, "if", [get(env, context, "showSearch")], {}, child1, null);
          block(env, morph3, context, "if", [get(env, context, "model.invites")], {}, child2, child3);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "load-more", [], {"class": "paginated-topics-list", "selector": ".paginated-topics-list .user-invite-list tr", "action": "loadMore"}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "canInviteToForum")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user-selector-autocomplete.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "      <li>\n        <a href>\n          "
    + container.escapeExpression((helpers.avatar || (depth0 && depth0.avatar) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"user",{"name":"avatar","hash":{"imageSize":"tiny"},"hashTypes":{"imageSize":"StringLiteral"},"hashContexts":{"imageSize":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n          <span class='username'>"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"user.username",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</span>\n          <span class='name'>"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"user.name",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</span>\n        </a>\n      </li>\n";
},"3":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"group","in","options.groups",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(4, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "");
},"4":function(container,depth0,helpers,partials,data) {
    return "        <li>\n          <a href>\n            <i class='fa fa-users'></i>\n            <span class='username'>"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"group.name",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</span>\n            <span class='name'>"
    + container.escapeExpression((helpers["max-usernames"] || (depth0 && depth0["max-usernames"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"group.usernames",{"name":"max-usernames","hash":{"max":"3"},"hashTypes":{"max":"StringLiteral"},"hashContexts":{"max":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</span>\n          </a>\n        </li>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<div class='autocomplete'>\n  <ul>\n"
    + ((stack1 = helpers.each.call(depth0 != null ? depth0 : {},"user","in","options.users",{"name":"each","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.noop,"types":["PathExpression","CommentStatement","PathExpression"],"contexts":[depth0,depth0,depth0],"data":data})) != null ? stack1 : "")
    + ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"options.groups",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(3, data, 0),"inverse":container.noop,"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "  </ul>\n</div>\n";
},"useData":true});
Ember.TEMPLATES["user-topics-list"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "basic-topic-list", [], {"topicList": get(env, context, "model"), "hideCategory": get(env, context, "hideCategory"), "showParticipants": get(env, context, "showParticipants"), "showPosters": get(env, context, "showPosters"), "canBulkSelect": get(env, context, "canBulkSelect"), "bulkSelectEnabled": get(env, context, "bulkSelectEnabled"), "selected": get(env, context, "selected"), "postsAction": "showTopicEntrance"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "load-more", [], {"class": "paginated-topics-list", "selector": ".paginated-topics-list .topic-list tr", "action": "loadMore"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/about"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "saveButtonText");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      dom.setAttribute(el1,"class","form-horizontal");
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","control-group");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","controls");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("h3");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","control-group");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("label");
      dom.setAttribute(el3,"class","control-label");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","controls");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","control-group");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","controls");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(element0, [3]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1, 1, 1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
      var morph3 = dom.createMorphAt(dom.childAt(element0, [5, 1]),1,1);
      inline(env, morph0, context, "i18n", ["user.change_about.title"], {});
      inline(env, morph1, context, "i18n", ["user.bio"], {});
      inline(env, morph2, context, "d-editor", [], {"value": get(env, context, "model.bio_raw")});
      block(env, morph3, context, "d-button", [], {"action": "changeAbout", "class": "btn btn-primary"}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/activity"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["user.filters.all"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["user_action_groups.4"], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("i");
          dom.setAttribute(el1,"class","glyph fa fa-reply");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,2,2,contextualElement);
          inline(env, morph0, context, "i18n", ["user_action_groups.5"], {});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("i");
          dom.setAttribute(el1,"class","glyph fa fa-heart");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,2,2,contextualElement);
          inline(env, morph0, context, "i18n", ["user_action_groups.1"], {});
          return fragment;
        }
      };
    }());
    var child4 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("i");
            dom.setAttribute(el1,"class","glyph fa fa-bookmark");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,2,2,contextualElement);
            inline(env, morph0, context, "i18n", ["user_action_groups.3"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          block(env, morph0, context, "link-to", ["userActivity.bookmarks"], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","no-glyph");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","no-glyph");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(fragment, [5]),1,1);
        var morph3 = dom.createMorphAt(dom.childAt(fragment, [7]),1,1);
        var morph4 = dom.createMorphAt(fragment,9,9,contextualElement);
        var morph5 = dom.createMorphAt(fragment,11,11,contextualElement);
        block(env, morph0, context, "link-to", ["userActivity.index"], {}, child0, null);
        block(env, morph1, context, "link-to", ["userActivity.topics"], {}, child1, null);
        block(env, morph2, context, "link-to", ["userActivity.replies"], {}, child2, null);
        block(env, morph3, context, "link-to", ["userActivity.likesGiven"], {}, child3, null);
        block(env, morph4, context, "if", [get(env, context, "showBookmarks")], {}, child4, null);
        inline(env, morph5, context, "plugin-outlet", ["user-activity-bottom"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","user-archive");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        inline(env, morph0, context, "d-button", [], {"action": "exportUserArchive", "label": "user.download_archive", "icon": "download"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-navigation");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-right");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,3,3);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      block(env, morph0, context, "mobile-nav", [], {"class": "activity-nav", "desktopClass": "action-list activity-list nav-stacked", "currentPath": get(env, context, "currentPath")}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "viewingSelf")], {}, child1, null);
      content(env, morph2, context, "outlet");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/badge-title"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["saved"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-content");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      dom.setAttribute(el2,"class","form-horizontal");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("h3");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("button");
      dom.setAttribute(el5,"class","btn btn-primary");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, attribute = hooks.attribute, element = hooks.element, content = hooks.content, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var element1 = dom.childAt(element0, [5, 1]);
      var element2 = dom.childAt(element1, [1]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1, 1, 1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [3, 3]),1,1);
      var morph2 = dom.createMorphAt(element2,0,0);
      var attrMorph0 = dom.createAttrMorph(element2, 'disabled');
      var morph3 = dom.createMorphAt(element1,3,3);
      inline(env, morph0, context, "i18n", ["badges.select_badge_for_title"], {});
      inline(env, morph1, context, "combo-box", [], {"valueAttribute": "id", "value": get(env, context, "selectedUserBadgeId"), "nameProperty": "badge.name", "content": get(env, context, "selectableUserBadges")});
      attribute(env, attrMorph0, element2, "disabled", get(env, context, "disableSave"));
      element(env, element2, context, "action", ["save"], {});
      content(env, morph2, context, "savingStatus");
      block(env, morph3, context, "if", [get(env, context, "saved")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/badges"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "ub", blockArguments[0]);
        inline(env, morph0, context, "badge-card", [], {"badge": get(env, context, "ub.badge"), "count": get(env, context, "ub.count"), "navigateOnClick": "true", "username": get(env, context, "user.username_lower")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-content user-badges-list");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [0]),1,1);
      block(env, morph0, context, "each", [get(env, context, "model")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/email"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group");
        var el2 = dom.createTextNode("\n          ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n            ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1, 1]),0,0);
        inline(env, morph0, context, "i18n", ["user.change_email.success"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","control-group");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","instructions");
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("div");
          dom.setAttribute(el3,"class","alert alert-error");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n          ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1, 1]),0,0);
          content(env, morph0, context, "errorMessage");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.change_email.taken"], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.email.instructions"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("button");
        dom.setAttribute(el3,"class","btn btn-primary");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [2]);
        var element1 = dom.childAt(fragment, [4, 1, 1]);
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
        var morph2 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
        var morph3 = dom.createMorphAt(dom.childAt(element0, [5]),1,1);
        var morph4 = dom.createMorphAt(element1,0,0);
        var attrMorph0 = dom.createAttrMorph(element1, 'disabled');
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "error")], {}, child0, null);
        inline(env, morph1, context, "i18n", ["user.email.title"], {});
        inline(env, morph2, context, "text-field", [], {"value": get(env, context, "newEmail"), "id": "change_email", "classNames": "input-xxlarge"});
        block(env, morph3, context, "if", [get(env, context, "taken")], {}, child1, child2);
        attribute(env, attrMorph0, element1, "disabled", get(env, context, "saveDisabled"));
        element(env, element1, context, "action", ["changeEmail"], {});
        content(env, morph4, context, "saveButtonText");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-content");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      dom.setAttribute(el2,"class","form-horizontal");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("h3");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element2 = dom.childAt(fragment, [0, 1]);
      var morph0 = dom.createMorphAt(dom.childAt(element2, [1, 1, 1]),0,0);
      var morph1 = dom.createMorphAt(element2,3,3);
      inline(env, morph0, context, "i18n", ["user.change_email.title"], {});
      block(env, morph1, context, "if", [get(env, context, "success")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/messages"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"class": "btn-primary new-private-message", "action": "composePrivateMessage", "icon": "envelope", "label": "user.new_private_message"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "showNewPM")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.messages.inbox"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.messages.sent"], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.messages.archive"], {});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("        ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("i");
              dom.setAttribute(el1,"class","glyph fa fa-group");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n        ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,3,3,contextualElement);
              inline(env, morph0, context, "capitalize-string", [get(env, context, "group.name")], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("        ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "i18n", ["user.messages.archive"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("    ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("    ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n    ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("li");
            dom.setAttribute(el1,"class","archive");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("    ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
            block(env, morph0, context, "link-to", ["userPrivateMessages.group", get(env, context, "group.name")], {}, child0, null);
            block(env, morph1, context, "link-to", ["userPrivateMessages.groupArchive", get(env, context, "group.name")], {}, child1, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          set(env, context, "group", blockArguments[0]);
          block(env, morph0, context, "if", [get(env, context, "group.has_messages")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","noGlyph");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","noGlyph");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        dom.setAttribute(el1,"class","noGlyph");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(fragment, [5]),1,1);
        var morph3 = dom.createMorphAt(fragment,7,7,contextualElement);
        dom.insertBoundary(fragment, null);
        block(env, morph0, context, "link-to", ["userPrivateMessages.index", get(env, context, "model")], {}, child0, null);
        block(env, morph1, context, "link-to", ["userPrivateMessages.sent", get(env, context, "model")], {}, child1, null);
        block(env, morph2, context, "link-to", ["userPrivateMessages.archive", get(env, context, "model")], {}, child2, null);
        block(env, morph3, context, "each", [get(env, context, "model.groups")], {}, child3, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"class": "btn-primary new-private-message", "action": "composePrivateMessage", "icon": "envelope", "label": "user.new_private_message"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "showNewPM")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-archive");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element2,1,1);
        element(env, element2, context, "action", ["archive"], {});
        inline(env, morph0, context, "i18n", ["user.messages.move_to_archive"], {});
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-to-inbox");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element1,1,1);
        element(env, element1, context, "action", ["toInbox"], {});
        inline(env, morph0, context, "i18n", ["user.messages.move_to_inbox"], {});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("button");
        dom.setAttribute(el1,"class","btn btn-select-all");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        element(env, element0, context, "action", ["selectAll"], {});
        inline(env, morph0, context, "i18n", ["user.messages.select_all"], {});
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "group-notifications-button", [], {"group": get(env, context, "group")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-navigation");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-right messages");
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","clearfix list-actions");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("button");
      dom.setAttribute(el3,"class","btn bulk-select");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("i");
      dom.setAttribute(el4,"class","fa fa-list");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [0]);
      var element4 = dom.childAt(fragment, [2]);
      var element5 = dom.childAt(element4, [1]);
      var element6 = dom.childAt(element5, [1]);
      var morph0 = dom.createMorphAt(element3,1,1);
      var morph1 = dom.createMorphAt(element3,3,3);
      var attrMorph0 = dom.createAttrMorph(element6, 'title');
      var morph2 = dom.createMorphAt(element5,3,3);
      var morph3 = dom.createMorphAt(element5,5,5);
      var morph4 = dom.createMorphAt(element5,7,7);
      var morph5 = dom.createMorphAt(element5,9,9);
      var morph6 = dom.createMorphAt(element5,11,11);
      var morph7 = dom.createMorphAt(element4,3,3);
      block(env, morph0, context, "unless", [get(env, context, "site.mobileView")], {}, child0, null);
      block(env, morph1, context, "mobile-nav", [], {"class": "messages-nav", "desktopClass": "nav-stacked action-list", "currentPath": get(env, context, "currentPath")}, child1, null);
      attribute(env, attrMorph0, element6, "title", concat(env, [subexpr(env, context, "i18n", ["user.messages.bulk_select"], {})]));
      element(env, element6, context, "action", ["toggleBulkSelect"], {});
      block(env, morph2, context, "if", [get(env, context, "site.mobileView")], {}, child2, null);
      block(env, morph3, context, "if", [get(env, context, "canArchive")], {}, child3, null);
      block(env, morph4, context, "if", [get(env, context, "canMoveToInbox")], {}, child4, null);
      block(env, morph5, context, "if", [get(env, context, "bulkSelectEnabled")], {}, child5, null);
      block(env, morph6, context, "if", [get(env, context, "isGroup")], {}, child6, null);
      content(env, morph7, context, "outlet");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/notifications-index"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["errors.reasons.forbidden"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["errors.desc.unknown"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","item error");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "if", [get(env, context, "model.forbidden")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","notification-buttons");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("button");
          dom.setAttribute(el2,"id","dismiss-notifications");
          dom.setAttribute(el2,"class","btn notifications-read");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1, 1]);
          var morph0 = dom.createMorphAt(element0,0,0);
          var attrMorph0 = dom.createAttrMorph(element0, 'title');
          attribute(env, attrMorph0, element0, "title", concat(env, [subexpr(env, context, "i18n", ["user.dismiss_notifications_tooltip"], {})]));
          element(env, element0, context, "action", ["resetNew"], {});
          inline(env, morph0, context, "i18n", ["user.dismiss_notifications"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "unless", [get(env, context, "model.canLoadMore")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","notification-buttons");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("button");
      dom.setAttribute(el2,"id","dismiss-notifications-top");
      dom.setAttribute(el2,"class","btn notifications-read");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, element = hooks.element, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [2, 1]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(element1,0,0);
      var attrMorph0 = dom.createAttrMorph(element1, 'title');
      var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
      var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "model.error")], {}, child0, null);
      attribute(env, attrMorph0, element1, "title", concat(env, [subexpr(env, context, "i18n", ["user.dismiss_notifications_tooltip"], {})]));
      element(env, element1, context, "action", ["resetNew"], {});
      inline(env, morph1, context, "i18n", ["user.dismiss_notifications"], {});
      inline(env, morph2, context, "user-notifications-large", [], {"notifications": get(env, context, "model")});
      block(env, morph3, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/notifications"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "i18n", ["user.filters.all"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          dom.setAttribute(el1,"class","no-glyph");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          block(env, morph0, context, "link-to", ["userNotifications.index"], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("i");
          dom.setAttribute(el1,"class","glyph fa fa-reply");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "i18n", ["user_action_groups.6"], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("i");
          dom.setAttribute(el1,"class","glyph fa fa-heart");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,2,2,contextualElement);
          inline(env, morph0, context, "i18n", ["user_action_groups.2"], {});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createElement("i");
          dom.setAttribute(el1,"class","glyph fa fa-at");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          dom.insertBoundary(fragment, null);
          inline(env, morph0, context, "i18n", ["user_action_groups.7"], {});
          return fragment;
        }
      };
    }());
    var child4 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createElement("i");
          dom.setAttribute(el1,"class","glyph fa fa-pencil");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          dom.insertBoundary(fragment, null);
          inline(env, morph0, context, "i18n", ["user_action_groups.11"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(fragment, [4]),1,1);
        var morph3 = dom.createMorphAt(dom.childAt(fragment, [6]),0,0);
        var morph4 = dom.createMorphAt(dom.childAt(fragment, [8]),0,0);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "model")], {}, child0, null);
        block(env, morph1, context, "link-to", ["userNotifications.responses"], {}, child1, null);
        block(env, morph2, context, "link-to", ["userNotifications.likesReceived"], {}, child2, null);
        block(env, morph3, context, "link-to", ["userNotifications.mentions"], {}, child3, null);
        block(env, morph4, context, "link-to", ["userNotifications.edits"], {}, child4, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "outlet");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-navigation");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-right");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
      block(env, morph0, context, "mobile-nav", [], {"class": "notifications-nav", "desktopClass": "notification-list action-list nav-stacked", "currentPath": get(env, context, "currentPath")}, child0, null);
      block(env, morph1, context, "load-more", [], {"class": "notification-history user-stream", "selector": ".user-stream .notification", "action": "loadMore"}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/posts"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","delete-info");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("i");
            dom.setAttribute(el2,"class","fa fa-trash-o");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(" ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1]);
            var morph0 = dom.createMorphAt(element0,3,3);
            var morph1 = dom.createMorphAt(element0,5,5);
            inline(env, morph0, context, "avatar", [get(env, context, "p.deleted_by")], {"imageSize": "tiny", "extraClasses": "actor", "ignoreTitle": "true"});
            inline(env, morph1, context, "format-date", [get(env, context, "p.deleted_at")], {"leaveAgo": "true"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("div");
          dom.setAttribute(el2,"class","clearfix info");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("a");
          dom.setAttribute(el3,"class","avatar-link");
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("div");
          dom.setAttribute(el4,"class","avatar-wrapper");
          var el5 = dom.createTextNode("\n            ");
          dom.appendChild(el4, el5);
          var el5 = dom.createComment("");
          dom.appendChild(el4, el5);
          var el5 = dom.createTextNode("\n          ");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("span");
          dom.setAttribute(el3,"class","time");
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("span");
          dom.setAttribute(el3,"class","title");
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          var el4 = dom.createElement("a");
          var el5 = dom.createComment("");
          dom.appendChild(el4, el5);
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("span");
          dom.setAttribute(el3,"class","category");
          var el4 = dom.createTextNode("\n          ");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("\n        ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("p");
          dom.setAttribute(el2,"class","excerpt");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, block = hooks.block, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1]);
          var element2 = dom.childAt(element1, [1]);
          var element3 = dom.childAt(element2, [1]);
          var element4 = dom.childAt(element2, [5, 1]);
          var attrMorph0 = dom.createAttrMorph(element1, 'class');
          var attrMorph1 = dom.createAttrMorph(element3, 'href');
          var morph0 = dom.createMorphAt(dom.childAt(element3, [1]),1,1);
          var morph1 = dom.createMorphAt(dom.childAt(element2, [3]),1,1);
          var morph2 = dom.createMorphAt(element4,0,0);
          var attrMorph2 = dom.createAttrMorph(element4, 'href');
          var morph3 = dom.createMorphAt(dom.childAt(element2, [7]),1,1);
          var morph4 = dom.createMorphAt(element2,9,9);
          var morph5 = dom.createUnsafeMorphAt(dom.childAt(element1, [3]),1,1);
          set(env, context, "p", blockArguments[0]);
          attribute(env, attrMorph0, element1, "class", concat(env, ["item ", subexpr(env, context, "if", [get(env, context, "p.hidden"), "hidden"], {}), " ", subexpr(env, context, "if", [get(env, context, "p.deleted"), "deleted"], {}), " ", subexpr(env, context, "if", [get(env, context, "p.moderator_action"), "moderator-action"], {})]));
          attribute(env, attrMorph1, element3, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "p.usernameUrl")], {})]));
          inline(env, morph0, context, "avatar", [get(env, context, "p")], {"imageSize": "large", "extraClasses": "actor", "ignoreTitle": "true"});
          inline(env, morph1, context, "format-date", [get(env, context, "p.created_at")], {"leaveAgo": "true"});
          attribute(env, attrMorph2, element4, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "p.url")], {})]));
          inline(env, morph2, context, "unbound", [get(env, context, "p.topic_title")], {});
          inline(env, morph3, context, "category-link", [get(env, context, "p.category")], {});
          block(env, morph4, context, "if", [get(env, context, "p.deleted")], {}, child0, null);
          content(env, morph5, context, "p.excerpt");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "each", [get(env, context, "model.content")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "user-stream", [], {"stream": get(env, context, "model")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/preferences"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createElement("i");
          dom.setAttribute(el1,"class","fa fa-pencil");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        block(env, morph0, context, "link-to", ["preferences.username"], {"class": "btn btn-small pad-left no-text"}, child0, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "text-field", [], {"value": get(env, context, "newNameInput"), "classNames": "input-xxlarge"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","static");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "model.name");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-name");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element11 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element11, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element11, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(element11, [5]),1,1);
        inline(env, morph0, context, "i18n", ["user.name.title"], {});
        block(env, morph1, context, "if", [get(env, context, "model.can_edit_name")], {}, child0, child1);
        content(env, morph2, context, "nameInstructions");
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "fa-icon", ["pencil"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-title");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("span");
        dom.setAttribute(el3,"class","static");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element9 = dom.childAt(fragment, [1]);
        var element10 = dom.childAt(element9, [3]);
        var morph0 = dom.createMorphAt(dom.childAt(element9, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element10, [1]),0,0);
        var morph2 = dom.createMorphAt(element10,3,3);
        inline(env, morph0, context, "i18n", ["user.title.title"], {});
        content(env, morph1, context, "model.title");
        block(env, morph2, context, "link-to", ["preferences.badgeTitle"], {"class": "btn btn-small pad-left no-text"}, child0, null);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "fa-icon", ["pencil"], {});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            block(env, morph0, context, "link-to", ["preferences.email"], {"class": "btn btn-small pad-left no-text"}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","controls");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("span");
          dom.setAttribute(el2,"class","static");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","instructions");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element7 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(element7, [1]),0,0);
          var morph1 = dom.createMorphAt(element7,3,3);
          var morph2 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
          content(env, morph0, context, "model.email");
          block(env, morph1, context, "if", [get(env, context, "model.can_edit_email")], {}, child0, null);
          inline(env, morph2, context, "i18n", ["user.email.instructions"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","controls");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "d-button", [], {"action": "checkEmail", "actionParam": get(env, context, "model"), "title": "admin.users.check_email.title", "icon": "envelope-o", "label": "admin.users.check_email.text"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-email");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element8 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element8, [1]),0,0);
        var morph1 = dom.createMorphAt(element8,3,3);
        inline(env, morph0, context, "i18n", ["user.email.title"], {});
        block(env, morph1, context, "if", [get(env, context, "model.email")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.change_password.set_password"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.change_password.action"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-password");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("a");
        dom.setAttribute(el3,"href","");
        dom.setAttribute(el3,"class","btn");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, element = hooks.element, get = hooks.get, block = hooks.block, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element4 = dom.childAt(fragment, [1]);
        var element5 = dom.childAt(element4, [3]);
        var element6 = dom.childAt(element5, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element4, [1]),0,0);
        var morph1 = dom.createMorphAt(element6,1,1);
        var morph2 = dom.createMorphAt(element6,3,3);
        var morph3 = dom.createMorphAt(element5,3,3);
        inline(env, morph0, context, "i18n", ["user.password.title"], {});
        element(env, element6, context, "action", ["changePassword"], {});
        inline(env, morph1, context, "fa-icon", ["envelope"], {});
        block(env, morph2, context, "if", [get(env, context, "model.no_password")], {}, child0, child1);
        content(env, morph3, context, "passwordProgress");
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "showAvatarSelector", "class": "pad-left", "icon": "pencil"});
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-profile-bg");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-profile-bg");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1]);
        var element3 = dom.childAt(fragment, [3]);
        var morph0 = dom.createMorphAt(dom.childAt(element2, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element2, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(element2, [5]),1,1);
        var morph3 = dom.createMorphAt(dom.childAt(element3, [1]),0,0);
        var morph4 = dom.createMorphAt(dom.childAt(element3, [3]),1,1);
        var morph5 = dom.createMorphAt(dom.childAt(element3, [5]),1,1);
        inline(env, morph0, context, "i18n", ["user.change_profile_background.title"], {});
        inline(env, morph1, context, "image-uploader", [], {"imageUrl": get(env, context, "model.profile_background"), "type": "profile_background"});
        inline(env, morph2, context, "i18n", ["user.change_profile_background.instructions"], {});
        inline(env, morph3, context, "i18n", ["user.change_card_background.title"], {});
        inline(env, morph4, context, "image-uploader", [], {"imageUrl": get(env, context, "model.card_background"), "type": "card_background"});
        inline(env, morph5, context, "i18n", ["user.change_card_background.instructions"], {});
        return fragment;
      }
    };
  }());
  var child7 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group pref-locale");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
        var morph1 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
        var morph2 = dom.createMorphAt(dom.childAt(element1, [5]),1,1);
        inline(env, morph0, context, "i18n", ["user.locale.title"], {});
        inline(env, morph1, context, "combo-box", [], {"valueAttribute": "value", "content": get(env, context, "availableLocales"), "value": get(env, context, "model.locale"), "none": "user.locale.default"});
        inline(env, morph2, context, "i18n", ["user.locale.instructions"], {});
        return fragment;
      }
    };
  }());
  var child8 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "uf", blockArguments[0]);
        inline(env, morph0, context, "user-field", [], {"field": get(env, context, "uf.field"), "value": get(env, context, "uf.value")});
        return fragment;
      }
    };
  }());
  var child9 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "icon-or-image", [get(env, context, "model.card_image_badge")], {});
        return fragment;
      }
    };
  }());
  var child10 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "fa-icon", ["pencil"], {});
        return fragment;
      }
    };
  }());
  var child11 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","controls controls-dropdown");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          inline(env, morph0, context, "combo-box", [], {"valueAttribute": "value", "content": get(env, context, "digestFrequencies"), "value": get(env, context, "model.user_option.digest_after_minutes")});
          inline(env, morph1, context, "preference-checkbox", [], {"labelKey": "user.include_tl0_in_digests", "checked": get(env, context, "model.user_option.include_tl0_in_digests")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        inline(env, morph0, context, "preference-checkbox", [], {"labelKey": "user.email_digests.title", "checked": get(env, context, "model.user_option.email_digests")});
        block(env, morph1, context, "if", [get(env, context, "model.user_option.email_digests")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child12 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "preference-checkbox", [], {"warning": "checkMailingList", "labelKey": "user.mailing_list_mode", "checked": get(env, context, "model.user_option.mailing_list_mode")});
        return fragment;
      }
    };
  }());
  var child13 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.email.frequency"], {"count": get(env, context, "siteSettings.email_time_window_mins")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "i18n", ["user.email.frequency_immediately"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","instructions");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "if", [get(env, context, "siteSettings.email_time_window_mins")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child14 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "preference-checkbox", [], {"labelKey": "user.edit_history_public", "checked": get(env, context, "model.user_option.edit_history_public")});
        return fragment;
      }
    };
  }());
  var child15 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group topics");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("label");
        dom.setAttribute(el2,"class","control-label");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
        var morph1 = dom.createMorphAt(element0,3,3);
        inline(env, morph0, context, "i18n", ["categories.topics"], {});
        inline(env, morph1, context, "preference-checkbox", [], {"labelKey": "user.automatically_unpin_topics", "checked": get(env, context, "model.user_option.automatically_unpin_topics")});
        return fragment;
      }
    };
  }());
  var child16 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group delete-account");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("hr");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","controls");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 3]),1,1);
        inline(env, morph0, context, "d-button", [], {"action": "delete", "disabled": get(env, context, "deleteDisabled"), "class": "btn-danger", "icon": "trash-o", "label": "user.delete_account"});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-content user-preferences");
      var el2 = dom.createTextNode("\n\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      dom.setAttribute(el2,"class","form-horizontal");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group save-button");
      dom.setAttribute(el3,"id","save-button-top");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-username");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("span");
      dom.setAttribute(el5,"class","static");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-avatar");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-bio");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls bio-composer");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","clearfix");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-location");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-website");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-card-badge");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group pref-email-settings");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("br");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls controls-dropdown");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group notifications");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group other");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls controls-dropdown");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls controls-dropdown");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls controls-dropdown");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group category");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls category-controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createElement("span");
      dom.setAttribute(el6,"class","icon fa fa-exclamation-circle watching");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(" ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls category-controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createElement("span");
      dom.setAttribute(el6,"class","icon fa fa-circle tracking");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(" ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls category-controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createElement("span");
      dom.setAttribute(el6,"class","icon fa fa-times-circle muted");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(" ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls category-controls");
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("a");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group muting");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls category-controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("label");
      var el6 = dom.createElement("span");
      dom.setAttribute(el6,"class","icon fa fa-times-circle muted");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode(" ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group save-button");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, content = hooks.content, get = hooks.get, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element12 = dom.childAt(fragment, [0, 1]);
      var element13 = dom.childAt(element12, [3]);
      var element14 = dom.childAt(element13, [3]);
      var element15 = dom.childAt(element12, [13]);
      var element16 = dom.childAt(element15, [3]);
      var element17 = dom.childAt(element12, [19]);
      var element18 = dom.childAt(element12, [25]);
      var element19 = dom.childAt(element12, [27]);
      var element20 = dom.childAt(element12, [29]);
      var element21 = dom.childAt(element20, [3]);
      var element22 = dom.childAt(element12, [31]);
      var element23 = dom.childAt(element22, [7]);
      var element24 = dom.childAt(element12, [33]);
      var element25 = dom.childAt(element12, [35]);
      var element26 = dom.childAt(element25, [3]);
      var element27 = dom.childAt(element25, [5]);
      var element28 = dom.childAt(element25, [7]);
      var element29 = dom.childAt(element12, [37]);
      var element30 = dom.childAt(element29, [3]);
      var element31 = dom.childAt(element29, [7]);
      var element32 = dom.childAt(element29, [11]);
      var element33 = dom.childAt(element29, [15, 1]);
      var element34 = dom.childAt(element12, [39]);
      var element35 = dom.childAt(element34, [3]);
      var morph0 = dom.createMorphAt(dom.childAt(element12, [1, 1]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element13, [1]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(element14, [1]),0,0);
      var morph3 = dom.createMorphAt(element14,3,3);
      var morph4 = dom.createUnsafeMorphAt(dom.childAt(element13, [5]),1,1);
      var morph5 = dom.createMorphAt(element12,5,5);
      var morph6 = dom.createMorphAt(element12,7,7);
      var morph7 = dom.createMorphAt(element12,9,9);
      var morph8 = dom.createMorphAt(element12,11,11);
      var morph9 = dom.createMorphAt(dom.childAt(element15, [1]),0,0);
      var morph10 = dom.createMorphAt(element16,1,1);
      var morph11 = dom.createMorphAt(element16,3,3);
      var morph12 = dom.createMorphAt(element12,15,15);
      var morph13 = dom.createMorphAt(element12,17,17);
      var morph14 = dom.createMorphAt(dom.childAt(element17, [1]),0,0);
      var morph15 = dom.createMorphAt(dom.childAt(element17, [3]),1,1);
      var morph16 = dom.createMorphAt(element12,21,21);
      var morph17 = dom.createMorphAt(dom.childAt(element18, [1]),0,0);
      var morph18 = dom.createMorphAt(dom.childAt(element18, [3]),1,1);
      var morph19 = dom.createMorphAt(dom.childAt(element19, [1]),0,0);
      var morph20 = dom.createMorphAt(dom.childAt(element19, [3]),1,1);
      var morph21 = dom.createMorphAt(dom.childAt(element20, [1]),0,0);
      var morph22 = dom.createMorphAt(element21,1,1);
      var morph23 = dom.createMorphAt(element21,3,3);
      var morph24 = dom.createMorphAt(dom.childAt(element22, [1]),0,0);
      var morph25 = dom.createMorphAt(element22,3,3);
      var morph26 = dom.createMorphAt(dom.childAt(element23, [1]),0,0);
      var morph27 = dom.createMorphAt(element23,3,3);
      var morph28 = dom.createMorphAt(element22,9,9);
      var morph29 = dom.createMorphAt(element22,11,11);
      var morph30 = dom.createMorphAt(element22,13,13);
      var morph31 = dom.createMorphAt(element22,15,15);
      var morph32 = dom.createMorphAt(element22,17,17);
      var morph33 = dom.createMorphAt(element22,19,19);
      var morph34 = dom.createMorphAt(dom.childAt(element24, [1]),0,0);
      var morph35 = dom.createMorphAt(element24,3,3);
      var morph36 = dom.createMorphAt(dom.childAt(element24, [5]),0,0);
      var morph37 = dom.createMorphAt(dom.childAt(element25, [1]),0,0);
      var morph38 = dom.createMorphAt(dom.childAt(element26, [1]),0,0);
      var morph39 = dom.createMorphAt(element26,3,3);
      var morph40 = dom.createMorphAt(dom.childAt(element27, [1]),0,0);
      var morph41 = dom.createMorphAt(element27,3,3);
      var morph42 = dom.createMorphAt(dom.childAt(element28, [1]),0,0);
      var morph43 = dom.createMorphAt(element28,3,3);
      var morph44 = dom.createMorphAt(element25,9,9);
      var morph45 = dom.createMorphAt(element25,11,11);
      var morph46 = dom.createMorphAt(element25,13,13);
      var morph47 = dom.createMorphAt(element25,15,15);
      var morph48 = dom.createMorphAt(element25,17,17);
      var morph49 = dom.createMorphAt(element25,19,19);
      var morph50 = dom.createMorphAt(dom.childAt(element29, [1]),0,0);
      var morph51 = dom.createMorphAt(dom.childAt(element30, [1]),2,2);
      var morph52 = dom.createMorphAt(element30,3,3);
      var morph53 = dom.createMorphAt(dom.childAt(element29, [5]),0,0);
      var morph54 = dom.createMorphAt(dom.childAt(element31, [1]),2,2);
      var morph55 = dom.createMorphAt(element31,3,3);
      var morph56 = dom.createMorphAt(dom.childAt(element29, [9]),0,0);
      var morph57 = dom.createMorphAt(dom.childAt(element32, [1]),2,2);
      var morph58 = dom.createMorphAt(element32,3,3);
      var morph59 = dom.createMorphAt(dom.childAt(element29, [13]),0,0);
      var morph60 = dom.createMorphAt(element33,0,0);
      var attrMorph0 = dom.createAttrMorph(element33, 'href');
      var morph61 = dom.createMorphAt(dom.childAt(element34, [1]),0,0);
      var morph62 = dom.createMorphAt(dom.childAt(element35, [1]),2,2);
      var morph63 = dom.createMorphAt(element35,3,3);
      var morph64 = dom.createMorphAt(dom.childAt(element34, [5]),0,0);
      var morph65 = dom.createMorphAt(element12,41,41);
      var morph66 = dom.createMorphAt(element12,43,43);
      var morph67 = dom.createMorphAt(dom.childAt(element12, [45, 1]),1,1);
      var morph68 = dom.createMorphAt(element12,47,47);
      inline(env, morph0, context, "partial", ["user/preferences/save-button"], {});
      inline(env, morph1, context, "i18n", ["user.username.title"], {});
      content(env, morph2, context, "model.username");
      block(env, morph3, context, "if", [get(env, context, "model.can_edit_username")], {}, child0, null);
      inline(env, morph4, context, "i18n", ["user.username.short_instructions"], {"username": get(env, context, "model.username")});
      block(env, morph5, context, "if", [get(env, context, "canEditName")], {}, child1, null);
      block(env, morph6, context, "if", [get(env, context, "canSelectTitle")], {}, child2, null);
      block(env, morph7, context, "if", [get(env, context, "canCheckEmails")], {}, child3, null);
      block(env, morph8, context, "if", [get(env, context, "canChangePassword")], {}, child4, null);
      inline(env, morph9, context, "i18n", ["user.avatar.title"], {});
      inline(env, morph10, context, "bound-avatar", [get(env, context, "model"), "huge"], {});
      block(env, morph11, context, "unless", [get(env, context, "siteSettings.sso_overrides_avatar")], {}, child5, null);
      block(env, morph12, context, "if", [get(env, context, "siteSettings.allow_profile_backgrounds")], {}, child6, null);
      block(env, morph13, context, "if", [get(env, context, "siteSettings.allow_user_locale")], {}, child7, null);
      inline(env, morph14, context, "i18n", ["user.bio"], {});
      inline(env, morph15, context, "d-editor", [], {"value": get(env, context, "model.bio_raw")});
      block(env, morph16, context, "each", [get(env, context, "userFields")], {}, child8, null);
      inline(env, morph17, context, "i18n", ["user.location"], {});
      inline(env, morph18, context, "input", [], {"type": "text", "value": get(env, context, "model.location"), "class": "input-xxlarge", "id": "edit-location"});
      inline(env, morph19, context, "i18n", ["user.website"], {});
      inline(env, morph20, context, "input", [], {"type": "text", "value": get(env, context, "model.website"), "class": "input-xxlarge"});
      inline(env, morph21, context, "i18n", ["user.card_badge.title"], {});
      block(env, morph22, context, "if", [get(env, context, "model.card_image_badge")], {}, child9, null);
      block(env, morph23, context, "link-to", ["preferences.card-badge"], {"class": "btn btn-small pad-left no-text"}, child10, null);
      inline(env, morph24, context, "i18n", ["user.email_settings"], {});
      block(env, morph25, context, "if", [get(env, context, "canReceiveDigest")], {}, child11, null);
      inline(env, morph26, context, "i18n", ["user.email_previous_replies.title"], {});
      inline(env, morph27, context, "combo-box", [], {"valueAttribute": "value", "content": get(env, context, "previousRepliesOptions"), "value": get(env, context, "model.user_option.email_previous_replies")});
      inline(env, morph28, context, "preference-checkbox", [], {"labelKey": "user.email_in_reply_to", "checked": get(env, context, "model.user_option.email_in_reply_to")});
      inline(env, morph29, context, "preference-checkbox", [], {"labelKey": "user.email_private_messages", "checked": get(env, context, "model.user_option.email_private_messages")});
      inline(env, morph30, context, "preference-checkbox", [], {"labelKey": "user.email_direct", "checked": get(env, context, "model.user_option.email_direct")});
      block(env, morph31, context, "unless", [get(env, context, "siteSettings.disable_mailing_list_mode")], {}, child12, null);
      inline(env, morph32, context, "preference-checkbox", [], {"labelKey": "user.email_always", "checked": get(env, context, "model.user_option.email_always")});
      block(env, morph33, context, "unless", [get(env, context, "model.user_option.email_always")], {}, child13, null);
      inline(env, morph34, context, "i18n", ["user.desktop_notifications.label"], {});
      content(env, morph35, context, "desktop-notification-config");
      inline(env, morph36, context, "i18n", ["user.desktop_notifications.each_browser_note"], {});
      inline(env, morph37, context, "i18n", ["user.other_settings"], {});
      inline(env, morph38, context, "i18n", ["user.new_topic_duration.label"], {});
      inline(env, morph39, context, "combo-box", [], {"valueAttribute": "value", "content": get(env, context, "considerNewTopicOptions"), "value": get(env, context, "model.user_option.new_topic_duration_minutes")});
      inline(env, morph40, context, "i18n", ["user.auto_track_topics"], {});
      inline(env, morph41, context, "combo-box", [], {"valueAttribute": "value", "content": get(env, context, "autoTrackDurations"), "value": get(env, context, "model.user_option.auto_track_topics_after_msecs")});
      inline(env, morph42, context, "i18n", ["user.like_notification_frequency.title"], {});
      inline(env, morph43, context, "combo-box", [], {"valueAttribute": "value", "content": get(env, context, "likeNotificationFrequencies"), "value": get(env, context, "model.user_option.like_notification_frequency")});
      inline(env, morph44, context, "preference-checkbox", [], {"labelKey": "user.external_links_in_new_tab", "checked": get(env, context, "model.user_option.external_links_in_new_tab")});
      inline(env, morph45, context, "preference-checkbox", [], {"labelKey": "user.enable_quoting", "checked": get(env, context, "model.user_option.enable_quoting")});
      inline(env, morph46, context, "preference-checkbox", [], {"labelKey": "user.dynamic_favicon", "checked": get(env, context, "model.user_option.dynamic_favicon")});
      inline(env, morph47, context, "preference-checkbox", [], {"labelKey": "user.disable_jump_reply", "checked": get(env, context, "model.user_option.disable_jump_reply")});
      block(env, morph48, context, "unless", [get(env, context, "siteSettings.edit_history_visible_to_public")], {}, child14, null);
      inline(env, morph49, context, "plugin-outlet", ["user-custom-preferences"], {});
      inline(env, morph50, context, "i18n", ["user.categories_settings"], {});
      inline(env, morph51, context, "i18n", ["user.watched_categories"], {});
      inline(env, morph52, context, "category-group", [], {"categories": get(env, context, "model.watchedCategories"), "blacklist": get(env, context, "selectedCategories")});
      inline(env, morph53, context, "i18n", ["user.watched_categories_instructions"], {});
      inline(env, morph54, context, "i18n", ["user.tracked_categories"], {});
      inline(env, morph55, context, "category-group", [], {"categories": get(env, context, "model.trackedCategories"), "blacklist": get(env, context, "selectedCategories")});
      inline(env, morph56, context, "i18n", ["user.tracked_categories_instructions"], {});
      inline(env, morph57, context, "i18n", ["user.muted_categories"], {});
      inline(env, morph58, context, "category-group", [], {"categories": get(env, context, "model.mutedCategories"), "blacklist": get(env, context, "selectedCategories")});
      inline(env, morph59, context, "i18n", ["user.muted_categories_instructions"], {});
      attribute(env, attrMorph0, element33, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "model.mutedTopicsPath")], {})]));
      inline(env, morph60, context, "i18n", ["user.muted_topics_link"], {});
      inline(env, morph61, context, "i18n", ["user.users"], {});
      inline(env, morph62, context, "i18n", ["user.muted_users"], {});
      inline(env, morph63, context, "user-selector", [], {"excludeCurrentUser": true, "usernames": get(env, context, "model.muted_usernames"), "class": "user-selector"});
      inline(env, morph64, context, "i18n", ["user.muted_users_instructions"], {});
      block(env, morph65, context, "if", [get(env, context, "siteSettings.automatically_unpin_topics")], {}, child15, null);
      inline(env, morph66, context, "plugin-outlet", ["user-custom-controls"], {});
      inline(env, morph67, context, "partial", ["user/preferences/save-button"], {});
      block(env, morph68, context, "if", [get(env, context, "model.canDeleteAccount")], {}, child16, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/preferences/_save-button"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "saveButtonText");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("span");
        dom.setAttribute(el1,"class","saved-user");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["saved"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "d-button", [], {"action": "save", "disabled": get(env, context, "model.isSaving"), "class": "btn btn-primary save-user"}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "saved")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/stream"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "item", blockArguments[0]);
          inline(env, morph0, context, "stream-item", [], {"item": get(env, context, "item"), "removeBookmark": "removeBookmark"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "each", [get(env, context, "model.content")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "user-stream", [], {"stream": get(env, context, "model")}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/summary"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "user-stat", [], {"value": get(env, context, "model.bookmark_count"), "label": "user.summary.bookmark_count"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ·\n                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode(" ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","like-count");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "fa-icon", ["heart"], {});
            inline(env, morph1, context, "number", [get(env, context, "reply.like_count")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("span");
          dom.setAttribute(el2,"class","topic-info");
          var el3 = dom.createTextNode("\n              ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("            ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("br");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("a");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element7 = dom.childAt(fragment, [1]);
          var element8 = dom.childAt(element7, [1]);
          var element9 = dom.childAt(element7, [5]);
          var morph0 = dom.createMorphAt(element8,1,1);
          var morph1 = dom.createMorphAt(element8,3,3);
          var morph2 = dom.createUnsafeMorphAt(element9,0,0);
          var attrMorph0 = dom.createAttrMorph(element9, 'href');
          set(env, context, "reply", blockArguments[0]);
          inline(env, morph0, context, "format-date", [get(env, context, "reply.createdAt")], {"format": "tiny", "noTitle": "true"});
          block(env, morph1, context, "if", [get(env, context, "reply.like_count")], {}, child0, null);
          attribute(env, attrMorph0, element9, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "reply.url")], {})]));
          content(env, morph2, context, "reply.topic.fancyTitle");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "i18n", ["user.summary.more_replies"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          block(env, morph0, context, "link-to", ["userActivity.replies", get(env, context, "user")], {"class": "more"}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("ul");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        block(env, morph0, context, "each", [get(env, context, "model.replies")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "moreReplies")], {}, child1, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["user.summary.no_replies"], {});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ·\n                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode(" ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","like-count");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "fa-icon", ["heart"], {});
            inline(env, morph1, context, "number", [get(env, context, "topic.like_count")], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("span");
          dom.setAttribute(el2,"class","topic-info");
          var el3 = dom.createTextNode("\n              ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("            ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("br");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("a");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [1]);
          var element5 = dom.childAt(element4, [1]);
          var element6 = dom.childAt(element4, [5]);
          var morph0 = dom.createMorphAt(element5,1,1);
          var morph1 = dom.createMorphAt(element5,3,3);
          var morph2 = dom.createUnsafeMorphAt(element6,0,0);
          var attrMorph0 = dom.createAttrMorph(element6, 'href');
          set(env, context, "topic", blockArguments[0]);
          inline(env, morph0, context, "format-date", [get(env, context, "topic.createdAt")], {"format": "tiny", "noTitle": "true"});
          block(env, morph1, context, "if", [get(env, context, "topic.like_count")], {}, child0, null);
          attribute(env, attrMorph0, element6, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "topic.url")], {})]));
          content(env, morph2, context, "topic.fancyTitle");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "i18n", ["user.summary.more_topics"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          block(env, morph0, context, "link-to", ["userActivity.topics", get(env, context, "user")], {"class": "more"}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("ul");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        block(env, morph0, context, "each", [get(env, context, "model.topics")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "moreTopics")], {}, child1, null);
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["user.summary.no_topics"], {});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"class","domain");
          dom.setAttribute(el2,"target","_blank");
          var el3 = dom.createTextNode("\n              ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n            ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("span");
          dom.setAttribute(el2,"class","badge badge-notification clicks");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("br");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("a");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var element1 = dom.childAt(element0, [1]);
          var element2 = dom.childAt(element0, [3]);
          var element3 = dom.childAt(element0, [7]);
          var morph0 = dom.createMorphAt(element1,1,1);
          var attrMorph0 = dom.createAttrMorph(element1, 'href');
          var attrMorph1 = dom.createAttrMorph(element1, 'title');
          var attrMorph2 = dom.createAttrMorph(element1, 'rel');
          var morph1 = dom.createMorphAt(element2,0,0);
          var attrMorph3 = dom.createAttrMorph(element2, 'title');
          var morph2 = dom.createUnsafeMorphAt(element3,0,0);
          var attrMorph4 = dom.createAttrMorph(element3, 'href');
          set(env, context, "link", blockArguments[0]);
          attribute(env, attrMorph0, element1, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "link.url")], {})]));
          attribute(env, attrMorph1, element1, "title", concat(env, [subexpr(env, context, "unbound", [get(env, context, "link.title")], {})]));
          attribute(env, attrMorph2, element1, "rel", concat(env, [subexpr(env, context, "unless", [get(env, context, "user.removeNoFollow"), "nofollow"], {})]));
          inline(env, morph0, context, "shorten-url", [get(env, context, "link.url")], {});
          attribute(env, attrMorph3, element2, "title", concat(env, [subexpr(env, context, "i18n", ["topic_map.clicks"], {"count": get(env, context, "link.clicks")})]));
          content(env, morph1, context, "link.clicks");
          attribute(env, attrMorph4, element3, "href", concat(env, [subexpr(env, context, "unbound", [get(env, context, "link.post_url")], {})]));
          content(env, morph2, context, "link.topic.fancyTitle");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("ul");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "each", [get(env, context, "model.links")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["user.summary.no_links"], {});
        return fragment;
      }
    };
  }());
  var child7 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","replies");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "fa-icon", ["reply"], {});
            content(env, morph1, context, "user.count");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          set(env, context, "user", blockArguments[0]);
          block(env, morph0, context, "user-info", [], {"user": get(env, context, "user")}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("ul");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "each", [get(env, context, "model.most_replied_to_users")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child8 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["user.summary.no_likes"], {});
        return fragment;
      }
    };
  }());
  var child9 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","likes");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "fa-icon", ["heart"], {});
            content(env, morph1, context, "user.count");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          set(env, context, "user", blockArguments[0]);
          block(env, morph0, context, "user-info", [], {"user": get(env, context, "user")}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("ul");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "each", [get(env, context, "model.most_liked_by_users")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child10 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["user.summary.no_likes"], {});
        return fragment;
      }
    };
  }());
  var child11 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n              ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","likes");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "fa-icon", ["heart"], {});
            content(env, morph1, context, "user.count");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("          ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          set(env, context, "user", blockArguments[0]);
          block(env, morph0, context, "user-info", [], {"user": get(env, context, "user")}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("ul");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "each", [get(env, context, "model.most_liked_users")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child12 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["user.summary.no_likes"], {});
        return fragment;
      }
    };
  }());
  var child13 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "badge", blockArguments[0]);
        inline(env, morph0, context, "badge-card", [], {"badge": get(env, context, "badge"), "count": get(env, context, "badge.count"), "navigateOnClick": "true", "username": get(env, context, "user.username_lower")});
        return fragment;
      }
    };
  }());
  var child14 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["user.summary.no_badges"], {});
        return fragment;
      }
    };
  }());
  var child15 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["user.summary.more_badges"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        block(env, morph0, context, "link-to", ["user.badges", get(env, context, "user")], {"class": "more"}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","top-section stats-section");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("h3");
      dom.setAttribute(el2,"class","stats-title");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("ul");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("span");
      dom.setAttribute(el4,"class","value");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("span");
      dom.setAttribute(el4,"class","label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","top-section");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","top-sub-section replies-section pull-left");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("h3");
      dom.setAttribute(el3,"class","stats-title");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","top-sub-section topics-section pull-right");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("h3");
      dom.setAttribute(el3,"class","stats-title");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","top-section");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","top-sub-section links-section pull-left");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("h3");
      dom.setAttribute(el3,"class","stats-title");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","top-sub-section likes-section pull-right");
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("h3");
      dom.setAttribute(el3,"class","stats-title");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","top-section");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","top-sub-section likes-section pull-left");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("h3");
      dom.setAttribute(el3,"class","stats-title");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","top-sub-section likes-section pull-right");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("h3");
      dom.setAttribute(el3,"class","stats-title");
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","top-section badges-section");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("h3");
      dom.setAttribute(el2,"class","stats-title");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element10 = dom.childAt(fragment, [0]);
      var element11 = dom.childAt(element10, [3]);
      var element12 = dom.childAt(element11, [3]);
      var element13 = dom.childAt(fragment, [2]);
      var element14 = dom.childAt(element13, [1]);
      var element15 = dom.childAt(element13, [3]);
      var element16 = dom.childAt(fragment, [4]);
      var element17 = dom.childAt(element16, [1]);
      var element18 = dom.childAt(element16, [3]);
      var element19 = dom.childAt(fragment, [6]);
      var element20 = dom.childAt(element19, [1]);
      var element21 = dom.childAt(element19, [3]);
      var element22 = dom.childAt(fragment, [8]);
      var morph0 = dom.createMorphAt(dom.childAt(element10, [1]),0,0);
      var morph1 = dom.createMorphAt(dom.childAt(element11, [1]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(element12, [1]),0,0);
      var morph3 = dom.createUnsafeMorphAt(dom.childAt(element12, [3]),0,0);
      var morph4 = dom.createMorphAt(dom.childAt(element11, [5]),0,0);
      var morph5 = dom.createMorphAt(dom.childAt(element11, [7]),0,0);
      var morph6 = dom.createMorphAt(element11,9,9);
      var morph7 = dom.createMorphAt(dom.childAt(element11, [11]),0,0);
      var morph8 = dom.createMorphAt(dom.childAt(element11, [13]),0,0);
      var morph9 = dom.createMorphAt(dom.childAt(element11, [15]),0,0);
      var morph10 = dom.createMorphAt(dom.childAt(element14, [1]),0,0);
      var morph11 = dom.createMorphAt(element14,3,3);
      var morph12 = dom.createMorphAt(dom.childAt(element15, [1]),0,0);
      var morph13 = dom.createMorphAt(element15,3,3);
      var morph14 = dom.createMorphAt(dom.childAt(element17, [1]),0,0);
      var morph15 = dom.createMorphAt(element17,3,3);
      var morph16 = dom.createMorphAt(dom.childAt(element18, [1]),0,0);
      var morph17 = dom.createMorphAt(element18,3,3);
      var morph18 = dom.createMorphAt(dom.childAt(element20, [1]),0,0);
      var morph19 = dom.createMorphAt(element20,3,3);
      var morph20 = dom.createMorphAt(dom.childAt(element21, [1]),0,0);
      var morph21 = dom.createMorphAt(element21,3,3);
      var morph22 = dom.createMorphAt(dom.childAt(element22, [1]),0,0);
      var morph23 = dom.createMorphAt(element22,3,3);
      var morph24 = dom.createMorphAt(element22,4,4);
      inline(env, morph0, context, "i18n", ["user.summary.stats"], {});
      inline(env, morph1, context, "user-stat", [], {"value": get(env, context, "model.days_visited"), "label": "user.summary.days_visited"});
      content(env, morph2, context, "model.time_read");
      inline(env, morph3, context, "i18n", ["user.summary.time_read"], {});
      inline(env, morph4, context, "user-stat", [], {"value": get(env, context, "model.posts_read_count"), "label": "user.summary.posts_read"});
      inline(env, morph5, context, "user-stat", [], {"value": get(env, context, "model.likes_given"), "label": "user.summary.likes_given"});
      block(env, morph6, context, "if", [get(env, context, "model.bookmark_count")], {}, child0, null);
      inline(env, morph7, context, "user-stat", [], {"value": get(env, context, "model.topic_count"), "label": "user.summary.topic_count"});
      inline(env, morph8, context, "user-stat", [], {"value": get(env, context, "model.post_count"), "label": "user.summary.post_count"});
      inline(env, morph9, context, "user-stat", [], {"value": get(env, context, "model.likes_received"), "label": "user.summary.likes_received"});
      inline(env, morph10, context, "i18n", ["user.summary.top_replies"], {});
      block(env, morph11, context, "if", [get(env, context, "model.replies.length")], {}, child1, child2);
      inline(env, morph12, context, "i18n", ["user.summary.top_topics"], {});
      block(env, morph13, context, "if", [get(env, context, "model.topics.length")], {}, child3, child4);
      inline(env, morph14, context, "i18n", ["user.summary.top_links"], {});
      block(env, morph15, context, "if", [get(env, context, "model.links.length")], {}, child5, child6);
      inline(env, morph16, context, "i18n", ["user.summary.most_replied_to_users"], {});
      block(env, morph17, context, "if", [get(env, context, "model.most_replied_to_users.length")], {}, child7, child8);
      inline(env, morph18, context, "i18n", ["user.summary.most_liked_by"], {});
      block(env, morph19, context, "if", [get(env, context, "model.most_liked_by_users.length")], {}, child9, child10);
      inline(env, morph20, context, "i18n", ["user.summary.most_liked_users"], {});
      block(env, morph21, context, "if", [get(env, context, "model.most_liked_users.length")], {}, child11, child12);
      inline(env, morph22, context, "i18n", ["user.summary.top_badges"], {});
      block(env, morph23, context, "each", [get(env, context, "model.badges")], {}, child13, child14);
      block(env, morph24, context, "if", [get(env, context, "moreBadges")], {}, child15, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/user"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createElement("span");
          dom.setAttribute(el2,"class","helpful-flags");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element13 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(element13, [0]),0,0);
          var morph1 = dom.createMorphAt(element13,2,2);
          content(env, morph0, context, "model.number_of_flags_given");
          inline(env, morph1, context, "i18n", ["user.staff_counters.flags_given"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","flagged-posts");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode(" ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
            content(env, morph0, context, "model.number_of_flagged_posts");
            inline(env, morph1, context, "i18n", ["user.staff_counters.flagged_posts"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          block(env, morph0, context, "link-to", ["user.flaggedPosts", get(env, context, "model")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","deleted-posts");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode(" ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
            content(env, morph0, context, "model.number_of_deleted_posts");
            inline(env, morph1, context, "i18n", ["user.staff_counters.deleted_posts"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          block(env, morph0, context, "link-to", ["user.deletedPosts", get(env, context, "model")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createElement("span");
          dom.setAttribute(el2,"class","suspensions");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element12 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(element12, [0]),0,0);
          var morph1 = dom.createMorphAt(element12,2,2);
          content(env, morph0, context, "model.number_of_suspensions");
          inline(env, morph1, context, "i18n", ["user.staff_counters.suspensions"], {});
          return fragment;
        }
      };
    }());
    var child4 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createElement("span");
          dom.setAttribute(el2,"class","warnings-received");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode(" ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element11 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(element11, [0]),0,0);
          var morph1 = dom.createMorphAt(element11,2,2);
          content(env, morph0, context, "model.number_of_warnings");
          inline(env, morph1, context, "i18n", ["user.staff_counters.warnings_received"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","staff-counters");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element14 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element14,1,1);
        var morph1 = dom.createMorphAt(element14,2,2);
        var morph2 = dom.createMorphAt(element14,3,3);
        var morph3 = dom.createMorphAt(element14,4,4);
        var morph4 = dom.createMorphAt(element14,5,5);
        block(env, morph0, context, "if", [get(env, context, "model.number_of_flags_given")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "model.number_of_flagged_posts")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "model.number_of_deleted_posts")], {}, child2, null);
        block(env, morph3, context, "if", [get(env, context, "model.number_of_suspensions")], {}, child3, null);
        block(env, morph4, context, "if", [get(env, context, "model.number_of_warnings")], {}, child4, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("              ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n                ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"class","btn btn-primary");
        var el3 = dom.createTextNode("\n                  ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n                  ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n                ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n              ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element10 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element10,1,1);
        var morph1 = dom.createMorphAt(element10,3,3);
        element(env, element10, context, "action", ["composePrivateMessage", get(env, context, "model")], {});
        inline(env, morph0, context, "fa-icon", ["envelope"], {});
        inline(env, morph1, context, "i18n", ["user.private_message"], {});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("                ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"class","btn");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element9 = dom.childAt(fragment, [1, 0]);
        var morph0 = dom.createMorphAt(element9,0,0);
        var morph1 = dom.createMorphAt(element9,1,1);
        var attrMorph0 = dom.createAttrMorph(element9, 'href');
        attribute(env, attrMorph0, element9, "href", get(env, context, "model.adminPath"));
        inline(env, morph0, context, "fa-icon", ["wrench"], {});
        inline(env, morph1, context, "i18n", ["admin.user.show_admin_profile"], {});
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("              ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"href","");
          dom.setAttribute(el2,"class","btn");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element8 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element8,0,0);
          var morph1 = dom.createMorphAt(element8,1,1);
          element(env, element8, context, "action", ["expandProfile"], {});
          inline(env, morph0, context, "fa-icon", ["angle-double-down"], {});
          inline(env, morph1, context, "i18n", ["user.expand_profile"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "viewingSelf")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("              ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("h3");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        content(env, morph0, context, "model.title");
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode(" ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "fa-icon", ["map-marker"], {});
        content(env, morph1, context, "model.location");
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("                ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          dom.setAttribute(el1,"target","_blank");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, subexpr = hooks.subexpr, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element7 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element7,0,0);
          var attrMorph0 = dom.createAttrMorph(element7, 'href');
          var attrMorph1 = dom.createAttrMorph(element7, 'rel');
          attribute(env, attrMorph0, element7, "href", get(env, context, "model.website"));
          attribute(env, attrMorph1, element7, "rel", subexpr(env, context, "unless", [get(env, context, "removeNoFollow"), "nofollow"], {}));
          content(env, morph0, context, "model.website_name");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("                ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, attribute = hooks.attribute, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element6 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element6,0,0);
          var attrMorph0 = dom.createAttrMorph(element6, 'title');
          attribute(env, attrMorph0, element6, "title", get(env, context, "model.website"));
          content(env, morph0, context, "model.website_name");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("              ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        dom.insertBoundary(fragment, null);
        inline(env, morph0, context, "fa-icon", ["globe"], {});
        block(env, morph1, context, "if", [get(env, context, "linkWebsite")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child7 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("                ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","suspended");
        var el2 = dom.createTextNode("\n                  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n                  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("b");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("br");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n                  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("b");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n                ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline, get = hooks.get, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element5 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element5,1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element5, [3]),0,0);
        var morph2 = dom.createMorphAt(dom.childAt(element5, [6]),0,0);
        var morph3 = dom.createMorphAt(element5,8,8);
        inline(env, morph0, context, "fa-icon", ["ban"], {});
        inline(env, morph1, context, "i18n", ["user.suspended_notice"], {"date": get(env, context, "model.suspendedTillDate")});
        inline(env, morph2, context, "i18n", ["user.suspended_reason"], {});
        content(env, morph3, context, "model.suspend_reason");
        return fragment;
      }
    };
  }());
  var child8 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                    ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            var el2 = dom.createTextNode("\n                      ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("span");
            dom.setAttribute(el2,"class","user-field-name");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode(":\n                      ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("span");
            dom.setAttribute(el2,"class","user-field-value");
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n                    ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element3 = dom.childAt(fragment, [1]);
            var attrMorph0 = dom.createAttrMorph(element3, 'class');
            var morph0 = dom.createMorphAt(dom.childAt(element3, [1]),0,0);
            var morph1 = dom.createMorphAt(dom.childAt(element3, [3]),0,0);
            attribute(env, attrMorph0, element3, "class", concat(env, ["public-user-field ", get(env, context, "uf.field.dasherized_name")]));
            content(env, morph0, context, "uf.field.name");
            content(env, morph1, context, "uf.value");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          set(env, context, "uf", blockArguments[0]);
          block(env, morph0, context, "if", [get(env, context, "uf.value")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("              ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","public-user-fields");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n                ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n              ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element4 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element4,1,1);
        var morph1 = dom.createMorphAt(element4,3,3);
        block(env, morph0, context, "each", [get(env, context, "publicUserFields")], {}, child0, null);
        inline(env, morph1, context, "plugin-outlet", ["user-profile-public-fields"], {});
        return fragment;
      }
    };
  }());
  var child9 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dt");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dd");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
          inline(env, morph0, context, "i18n", ["user.created"], {});
          inline(env, morph1, context, "bound-date", [get(env, context, "model.created_at")], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dt");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dd");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
          inline(env, morph0, context, "i18n", ["user.last_posted"], {});
          inline(env, morph1, context, "bound-date", [get(env, context, "model.last_posted_at")], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dt");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dd");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
          inline(env, morph0, context, "i18n", ["user.last_seen"], {});
          inline(env, morph1, context, "bound-date", [get(env, context, "model.last_seen_at")], {});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            content(env, morph0, context, "model.invited_by.username");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dt");
          dom.setAttribute(el1,"class","invited-by");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dd");
          dom.setAttribute(el1,"class","invited-by");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
          inline(env, morph0, context, "i18n", ["user.invited_by"], {});
          block(env, morph1, context, "link-to", ["user", get(env, context, "model.invited_by")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child4 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            content(env, morph0, context, "model.email");
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "checkEmail", "actionParam": get(env, context, "model"), "icon": "envelope-o", "label": "admin.users.check_email.text", "class": "btn-primary"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dt");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dd");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("            ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, attribute = hooks.attribute, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [3]);
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(element0,1,1);
          var attrMorph0 = dom.createAttrMorph(element0, 'title');
          inline(env, morph0, context, "i18n", ["user.email.title"], {});
          attribute(env, attrMorph0, element0, "title", get(env, context, "model.email"));
          block(env, morph1, context, "if", [get(env, context, "model.email")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    var child5 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              content(env, morph0, context, "group.name");
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("                ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            set(env, context, "group", blockArguments[0]);
            block(env, morph0, context, "link-to", ["group", get(env, context, "group")], {"class": "group-link"}, child0, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dt");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("dd");
          dom.setAttribute(el1,"class","groups");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("            ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
          inline(env, morph0, context, "i18n", ["groups.title"], {"count": get(env, context, "model.displayGroups.length")});
          block(env, morph1, context, "each", [get(env, context, "model.displayGroups")], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child6 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"action": "adminDelete", "icon": "exclamation-triangle", "label": "user.admin_delete", "class": "btn-danger"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","secondary");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("dl");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("dt");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("dd");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("dt");
        dom.setAttribute(el3,"class","trust-level");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("dd");
        dom.setAttribute(el3,"class","trust-level");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1]);
        var element2 = dom.childAt(element1, [1]);
        var morph0 = dom.createMorphAt(element2,1,1);
        var morph1 = dom.createMorphAt(element2,2,2);
        var morph2 = dom.createMorphAt(element2,3,3);
        var morph3 = dom.createMorphAt(dom.childAt(element2, [5]),0,0);
        var morph4 = dom.createMorphAt(dom.childAt(element2, [6]),0,0);
        var morph5 = dom.createMorphAt(element2,8,8);
        var morph6 = dom.createMorphAt(dom.childAt(element2, [10]),0,0);
        var morph7 = dom.createMorphAt(dom.childAt(element2, [11]),0,0);
        var morph8 = dom.createMorphAt(element2,13,13);
        var morph9 = dom.createMorphAt(element2,14,14);
        var morph10 = dom.createMorphAt(element2,15,15);
        var morph11 = dom.createMorphAt(element1,3,3);
        block(env, morph0, context, "if", [get(env, context, "model.created_at")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "model.last_posted_at")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "model.last_seen_at")], {}, child2, null);
        inline(env, morph3, context, "i18n", ["views"], {});
        content(env, morph4, context, "model.profile_view_count");
        block(env, morph5, context, "if", [get(env, context, "model.invited_by")], {}, child3, null);
        inline(env, morph6, context, "i18n", ["user.trust_level"], {});
        content(env, morph7, context, "model.trustLevel.name");
        block(env, morph8, context, "if", [get(env, context, "canCheckEmails")], {}, child4, null);
        block(env, morph9, context, "if", [get(env, context, "model.displayGroups")], {}, child5, null);
        block(env, morph10, context, "if", [get(env, context, "canDeleteUser")], {}, child6, null);
        inline(env, morph11, context, "plugin-outlet", ["user-profile-secondary"], {});
        return fragment;
      }
    };
  }());
  var child10 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["user.activity_stream"], {});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("            ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
            inline(env, morph0, context, "fa-icon", ["comment"], {"class": "glyph"});
            inline(env, morph1, context, "i18n", ["user.notifications"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          block(env, morph0, context, "link-to", ["userNotifications"], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "fa-icon", ["envelope-o"], {});
            inline(env, morph1, context, "i18n", ["user.private_messages"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          block(env, morph0, context, "link-to", ["userPrivateMessages"], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "fa-icon", ["user-plus"], {});
            inline(env, morph1, context, "i18n", ["user.invited.title"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          block(env, morph0, context, "link-to", ["userInvited"], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child4 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "fa-icon", ["certificate"], {});
            inline(env, morph1, context, "i18n", ["badges.title"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          block(env, morph0, context, "link-to", ["user.badges"], {}, child0, null);
          return fragment;
        }
      };
    }());
    var child5 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          inline(env, morph0, context, "i18n", ["user.summary.title"], {});
          return fragment;
        }
      };
    }());
    var child6 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            var morph1 = dom.createMorphAt(fragment,1,1,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            inline(env, morph0, context, "fa-icon", ["cog"], {});
            inline(env, morph1, context, "i18n", ["user.preferences"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          block(env, morph0, context, "link-to", ["preferences"], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block, get = hooks.get;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
        var morph3 = dom.createMorphAt(fragment,5,5,contextualElement);
        var morph4 = dom.createMorphAt(fragment,6,6,contextualElement);
        var morph5 = dom.createMorphAt(dom.childAt(fragment, [8]),0,0);
        var morph6 = dom.createMorphAt(fragment,10,10,contextualElement);
        dom.insertBoundary(fragment, null);
        block(env, morph0, context, "link-to", ["userActivity"], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "showNotificationsTab")], {}, child1, null);
        block(env, morph2, context, "if", [get(env, context, "showPrivateMessages")], {}, child2, null);
        block(env, morph3, context, "if", [get(env, context, "canInviteToForum")], {}, child3, null);
        block(env, morph4, context, "if", [get(env, context, "showBadges")], {}, child4, null);
        block(env, morph5, context, "link-to", ["user.summary"], {}, child5, null);
        block(env, morph6, context, "if", [get(env, context, "model.can_edit")], {}, child6, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("section");
      dom.setAttribute(el2,"class","user-main");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("section");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","profile-image");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","details");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("div");
      dom.setAttribute(el5,"class","primary");
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("section");
      dom.setAttribute(el6,"class","controls");
      var el7 = dom.createTextNode("\n            ");
      dom.appendChild(el6, el7);
      var el7 = dom.createElement("ul");
      var el8 = dom.createTextNode("\n");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode("              ");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode("\n\n");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode("\n            ");
      dom.appendChild(el7, el8);
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n          ");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n\n          ");
      dom.appendChild(el5, el6);
      var el6 = dom.createElement("div");
      dom.setAttribute(el6,"class","primary-textual");
      var el7 = dom.createTextNode("\n            ");
      dom.appendChild(el6, el7);
      var el7 = dom.createElement("h1");
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode(" ");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n            ");
      dom.appendChild(el6, el7);
      var el7 = dom.createElement("h2");
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n");
      dom.appendChild(el6, el7);
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("            ");
      dom.appendChild(el6, el7);
      var el7 = dom.createElement("h3");
      var el8 = dom.createTextNode("\n            ");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode("\n");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode("            ");
      dom.appendChild(el7, el8);
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n\n            ");
      dom.appendChild(el6, el7);
      var el7 = dom.createElement("div");
      dom.setAttribute(el7,"class","bio");
      var el8 = dom.createTextNode("\n");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode("              ");
      dom.appendChild(el7, el8);
      var el8 = dom.createComment("");
      dom.appendChild(el7, el8);
      var el8 = dom.createTextNode("\n            ");
      dom.appendChild(el7, el8);
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n\n");
      dom.appendChild(el6, el7);
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n            ");
      dom.appendChild(el6, el7);
      var el7 = dom.createComment("");
      dom.appendChild(el6, el7);
      var el7 = dom.createTextNode("\n\n          ");
      dom.appendChild(el6, el7);
      dom.appendChild(el5, el6);
      var el6 = dom.createTextNode("\n        ");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("div");
      dom.setAttribute(el5,"style","clear: both");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n\n\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","user-table");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","wrapper");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element15 = dom.childAt(fragment, [0]);
      var element16 = dom.childAt(element15, [1]);
      var element17 = dom.childAt(element16, [1]);
      var element18 = dom.childAt(element17, [5, 1]);
      var element19 = dom.childAt(element18, [3, 1]);
      var element20 = dom.childAt(element18, [5]);
      var element21 = dom.childAt(element20, [1]);
      var element22 = dom.childAt(element20, [7]);
      var element23 = dom.childAt(element20, [9]);
      var attrMorph0 = dom.createAttrMorph(element15, 'class');
      var morph0 = dom.createMorphAt(element17,1,1);
      var attrMorph1 = dom.createAttrMorph(element17, 'class');
      var attrMorph2 = dom.createAttrMorph(element17, 'style');
      var morph1 = dom.createMorphAt(element18,1,1);
      var morph2 = dom.createMorphAt(element19,1,1);
      var morph3 = dom.createMorphAt(element19,2,2);
      var morph4 = dom.createMorphAt(element19,4,4);
      var morph5 = dom.createMorphAt(element19,6,6);
      var morph6 = dom.createMorphAt(element21,0,0);
      var morph7 = dom.createMorphAt(element21,2,2);
      var morph8 = dom.createMorphAt(dom.childAt(element20, [3]),0,0);
      var morph9 = dom.createMorphAt(element20,5,5);
      var morph10 = dom.createMorphAt(element22,1,1);
      var morph11 = dom.createMorphAt(element22,3,3);
      var morph12 = dom.createMorphAt(element23,1,1);
      var morph13 = dom.createUnsafeMorphAt(element23,3,3);
      var morph14 = dom.createMorphAt(element20,11,11);
      var morph15 = dom.createMorphAt(element20,13,13);
      var morph16 = dom.createMorphAt(element17,7,7);
      var morph17 = dom.createMorphAt(element16,3,3);
      var morph18 = dom.createMorphAt(dom.childAt(element16, [5, 1]),1,1);
      attribute(env, attrMorph0, element15, "class", concat(env, ["container", subexpr(env, context, "if", [get(env, context, "viewingSelf"), " viewing-self"], {})]));
      attribute(env, attrMorph1, element17, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "collapsedInfo"), "collapsed-info"], {}), " about ", subexpr(env, context, "if", [get(env, context, "model.profileBackground"), "has-background", "no-background"], {})]));
      attribute(env, attrMorph2, element17, "style", get(env, context, "model.profileBackground"));
      block(env, morph0, context, "unless", [get(env, context, "collapsedInfo")], {}, child0, null);
      inline(env, morph1, context, "bound-avatar", [get(env, context, "model"), "huge"], {});
      block(env, morph2, context, "if", [get(env, context, "model.can_send_private_message_to_user")], {}, child1, null);
      block(env, morph3, context, "if", [get(env, context, "currentUser.staff")], {}, child2, null);
      inline(env, morph4, context, "plugin-outlet", ["user-profile-controls"], {"tagName": "li"});
      block(env, morph5, context, "if", [get(env, context, "collapsedInfo")], {}, child3, null);
      content(env, morph6, context, "model.username");
      inline(env, morph7, context, "user-status", [get(env, context, "model")], {"currentUser": get(env, context, "currentUser")});
      content(env, morph8, context, "model.name");
      block(env, morph9, context, "if", [get(env, context, "model.title")], {}, child4, null);
      block(env, morph10, context, "if", [get(env, context, "model.location")], {}, child5, null);
      block(env, morph11, context, "if", [get(env, context, "model.website_name")], {}, child6, null);
      block(env, morph12, context, "if", [get(env, context, "model.isSuspended")], {}, child7, null);
      content(env, morph13, context, "model.bio_cooked");
      block(env, morph14, context, "if", [get(env, context, "publicUserFields")], {}, child8, null);
      inline(env, morph15, context, "plugin-outlet", ["user-profile-primary"], {});
      block(env, morph16, context, "unless", [get(env, context, "collapsedInfo")], {}, child9, null);
      block(env, morph17, context, "mobile-nav", [], {"class": "main-nav", "desktopClass": "nav nav-pills user-nav", "currentPath": get(env, context, "currentPath")}, child10, null);
      content(env, morph18, context, "outlet");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["user/username"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","control-group");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","instructions");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","alert alert-error");
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1, 1]),0,0);
        inline(env, morph0, context, "i18n", ["user.change_username.error"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("          ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "i18n", ["user.change_username.taken"], {});
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "i18n", ["saved"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("section");
      dom.setAttribute(el1,"class","user-content");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("form");
      dom.setAttribute(el2,"class","form-horizontal");
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("h3");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("label");
      dom.setAttribute(el4,"class","control-label");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","instructions");
      var el5 = dom.createTextNode("\n");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("span");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("div");
      dom.setAttribute(el3,"class","control-group");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("div");
      dom.setAttribute(el4,"class","controls");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createElement("button");
      dom.setAttribute(el5,"class","btn btn-primary");
      var el6 = dom.createComment("");
      dom.appendChild(el5, el6);
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n          ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block, content = hooks.content, attribute = hooks.attribute, element = hooks.element;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0, 1]);
      var element1 = dom.childAt(element0, [5]);
      var element2 = dom.childAt(element1, [5]);
      var element3 = dom.childAt(element0, [7, 1]);
      var element4 = dom.childAt(element3, [1]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1, 1, 1]),0,0);
      var morph1 = dom.createMorphAt(element0,3,3);
      var morph2 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
      var morph3 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
      var morph4 = dom.createMorphAt(element2,1,1);
      var morph5 = dom.createMorphAt(dom.childAt(element2, [3]),0,0);
      var morph6 = dom.createMorphAt(element4,0,0);
      var attrMorph0 = dom.createAttrMorph(element4, 'disabled');
      var morph7 = dom.createMorphAt(element3,3,3);
      inline(env, morph0, context, "i18n", ["user.change_username.title"], {});
      block(env, morph1, context, "if", [get(env, context, "error")], {}, child0, null);
      inline(env, morph2, context, "i18n", ["user.username.title"], {});
      inline(env, morph3, context, "text-field", [], {"value": get(env, context, "newUsername"), "id": "change_username", "classNames": "input-xxlarge", "maxlength": get(env, context, "maxLength")});
      block(env, morph4, context, "if", [get(env, context, "taken")], {}, child1, null);
      content(env, morph5, context, "errorMessage");
      attribute(env, attrMorph0, element4, "disabled", get(env, context, "saveDisabled"));
      element(env, element4, context, "action", ["changeUsername"], {});
      content(env, morph6, context, "saveButtonText");
      block(env, morph7, context, "if", [get(env, context, "saved")], {}, child2, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["users"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("th");
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
              inline(env, morph0, context, "i18n", ["directory.time_read"], {});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              set(env, context, "item", blockArguments[0]);
              inline(env, morph0, context, "directory-item", [], {"item": get(env, context, "item"), "showTimeRead": get(env, context, "showTimeRead")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","total-rows");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("table");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("thead");
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("th");
            var el4 = dom.createTextNode(" ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("tbody");
            var el3 = dom.createTextNode("\n");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [3]);
            var element1 = dom.childAt(element0, [1]);
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            var morph1 = dom.createMorphAt(element1,3,3);
            var morph2 = dom.createMorphAt(element1,5,5);
            var morph3 = dom.createMorphAt(element1,7,7);
            var morph4 = dom.createMorphAt(element1,9,9);
            var morph5 = dom.createMorphAt(element1,11,11);
            var morph6 = dom.createMorphAt(element1,13,13);
            var morph7 = dom.createMorphAt(element1,15,15);
            var morph8 = dom.createMorphAt(element1,17,17);
            var morph9 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
            var morph10 = dom.createMorphAt(fragment,5,5,contextualElement);
            inline(env, morph0, context, "i18n", ["directory.total_rows"], {"count": get(env, context, "model.totalRows")});
            inline(env, morph1, context, "directory-toggle", [], {"field": "likes_received", "order": get(env, context, "order"), "asc": get(env, context, "asc"), "icon": "heart"});
            inline(env, morph2, context, "directory-toggle", [], {"field": "likes_given", "order": get(env, context, "order"), "asc": get(env, context, "asc"), "icon": "heart"});
            inline(env, morph3, context, "directory-toggle", [], {"field": "topic_count", "order": get(env, context, "order"), "asc": get(env, context, "asc")});
            inline(env, morph4, context, "directory-toggle", [], {"field": "post_count", "order": get(env, context, "order"), "asc": get(env, context, "asc")});
            inline(env, morph5, context, "directory-toggle", [], {"field": "topics_entered", "order": get(env, context, "order"), "asc": get(env, context, "asc")});
            inline(env, morph6, context, "directory-toggle", [], {"field": "posts_read", "order": get(env, context, "order"), "asc": get(env, context, "asc")});
            inline(env, morph7, context, "directory-toggle", [], {"field": "days_visited", "order": get(env, context, "order"), "asc": get(env, context, "asc")});
            block(env, morph8, context, "if", [get(env, context, "showTimeRead")], {}, child0, null);
            block(env, morph9, context, "each", [get(env, context, "model")], {}, child1, null);
            inline(env, morph10, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.loadingMore")});
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","clearfix");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("p");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [3]),0,0);
            inline(env, morph0, context, "i18n", ["directory.no_results"], {});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "model.length")], {}, child0, child1);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","container");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","directory");
        var el3 = dom.createTextNode("\n\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","clearfix");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1, 1]);
        var element3 = dom.childAt(element2, [1]);
        var morph0 = dom.createMorphAt(element3,1,1);
        var morph1 = dom.createMorphAt(element3,3,3);
        var morph2 = dom.createMorphAt(element2,3,3);
        inline(env, morph0, context, "period-chooser", [], {"period": get(env, context, "period")});
        inline(env, morph1, context, "text-field", [], {"value": get(env, context, "nameInput"), "placeholderKey": "directory.filter_name", "class": "filter-name"});
        block(env, morph2, context, "conditional-loading-spinner", [], {"condition": get(env, context, "model.loading")}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "load-more", [], {"selector": ".directory tbody tr", "action": "loadMore"}, child0, null);
      return fragment;
    }
  };
}()));
define("discourse/routes/about", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        return Discourse.ajax("/about.json").then(function (result) {
          return result.about;
        });
      },

      titleToken: function () {
        return I18n.t('about.simple_title');
      },

      actions: {
        didTransition: function () {
          this.controllerFor("application").set("showFooter", true);
          return true;
        }
      }
    });
  });
define("discourse/routes/app-route-map", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = function () {
      // Error page
      this.route('exception', { path: '/exception' });

      this.resource('about', { path: '/about' });

      // Topic routes
      this.resource('topic', { path: '/t/:slug/:id' }, function () {
        this.route('fromParams', { path: '/' });
        this.route('fromParamsNear', { path: '/:nearPost' });
      });
      this.resource('topicBySlug', { path: '/t/:slug' });
      this.route('topicUnsubscribe', { path: '/t/:slug/:id/unsubscribe' });

      this.resource('discovery', { path: '/' }, function () {
        var _this = this;

        // top
        this.route('top');
        this.route('topParentCategory', { path: '/c/:slug/l/top' });
        this.route('topCategoryNone', { path: '/c/:slug/none/l/top' });
        this.route('topCategory', { path: '/c/:parentSlug/:slug/l/top' });

        // top by periods
        Discourse.Site.currentProp('periods').forEach(function (period) {
          var top = 'top' + period.capitalize();
          _this.route(top, { path: '/top/' + period });
          _this.route(top + 'ParentCategory', { path: '/c/:slug/l/top/' + period });
          _this.route(top + 'CategoryNone', { path: '/c/:slug/none/l/top/' + period });
          _this.route(top + 'Category', { path: '/c/:parentSlug/:slug/l/top/' + period });
        });

        // filters
        Discourse.Site.currentProp('filters').forEach(function (filter) {
          _this.route(filter, { path: '/' + filter });
          _this.route(filter + 'ParentCategory', { path: '/c/:slug/l/' + filter });
          _this.route(filter + 'CategoryNone', { path: '/c/:slug/none/l/' + filter });
          _this.route(filter + 'Category', { path: '/c/:parentSlug/:slug/l/' + filter });
        });

        this.route('categories');

        // default filter for a category
        this.route('parentCategory', { path: '/c/:slug' });
        this.route('categoryNone', { path: '/c/:slug/none' });
        this.route('category', { path: '/c/:parentSlug/:slug' });
        this.route('categoryWithID', { path: '/c/:parentSlug/:slug/:id' });

        // homepage
        this.route(Discourse.Utilities.defaultHomepage(), { path: '/' });
      });

      this.resource('group', { path: '/groups/:name' }, function () {
        this.route('topics');
        this.route('mentions');
        this.route('members');
        this.route('messages');
      });

      // User routes
      this.resource('users');
      this.resource('user', { path: '/users/:username' }, function () {
        this.route('summary');
        this.resource('userActivity', { path: '/activity' }, function () {
          this.route('topics');
          this.route('replies');
          this.route('likesGiven', { path: 'likes-given' });
          this.route('bookmarks');
          this.route('pending');
        });

        this.resource('userNotifications', { path: '/notifications' }, function () {
          this.route('responses');
          this.route('likesReceived', { path: 'likes-received' });
          this.route('mentions');
          this.route('edits');
        });

        this.route('badges');
        this.route('flaggedPosts', { path: '/flagged-posts' });
        this.route('deletedPosts', { path: '/deleted-posts' });

        this.resource('userPrivateMessages', { path: '/messages' }, function () {
          this.route('sent');
          this.route('archive');
          this.route('group', { path: 'group/:name' });
          this.route('groupArchive', { path: 'group/:name/archive' });
        });

        this.resource('preferences', function () {
          this.route('username');
          this.route('email');
          this.route('about', { path: '/about-me' });
          this.route('badgeTitle', { path: '/badge_title' });
          this.route('card-badge', { path: '/card-badge' });
        });

        this.resource('userInvited', { path: '/invited' }, function () {
          this.route('show', { path: '/:filter' });
        });
      });

      this.route('signup', { path: '/signup' });
      this.route('login', { path: '/login' });
      this.route('login-preferences');
      this.route('forgot-password', { path: '/password-reset' });
      this.route('faq', { path: '/faq' });
      this.route('tos', { path: '/tos' });
      this.route('privacy', { path: '/privacy' });
      this.route('guidelines', { path: '/guidelines' });

      this.route('new-topic', { path: '/new-topic' });
      this.route('new-message', { path: '/new-message' });

      this.resource('badges', function () {
        this.route('show', { path: '/:id/:slug' });
      });

      this.resource('queued-posts', { path: '/queued-posts' });

      this.route('full-page-search', { path: '/search' });

      this.resource('tags', function () {
        var _this2 = this;

        this.route('show', { path: '/:tag_id' });
        this.route('showCategory', { path: '/c/:category/:tag_id' });
        this.route('showParentCategory', { path: '/c/:parent_category/:category/:tag_id' });

        Discourse.Site.currentProp('filters').forEach(function (filter) {
          _this2.route('show' + filter.capitalize(), { path: '/:tag_id/l/' + filter });
          _this2.route('showCategory' + filter.capitalize(), { path: '/c/:category/:tag_id/l/' + filter });
          _this2.route('showParentCategory' + filter.capitalize(), { path: '/c/:parent_category/:category/:tag_id/l/' + filter });
        });
      });
    }
  });
define("discourse/routes/application", 
  ["discourse/lib/computed","discourse/lib/logout","discourse/lib/show-modal","discourse/mixins/open-composer","discourse/models/category","discourse/lib/mobile","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __exports__) {
    "use strict";
    var setting = __dependency1__.setting;
    var logout = __dependency2__["default"];
    var showModal = __dependency3__["default"];
    var OpenComposer = __dependency4__["default"];
    var Category = __dependency5__["default"];
    var mobile = __dependency6__["default"];

    function unlessReadOnly(method, message) {
      return function () {
        if (this.site.get("isReadOnly")) {
          bootbox.alert(message);
        } else {
          this[method]();
        }
      };
    }

    var ApplicationRoute = Discourse.Route.extend(OpenComposer, {
      siteTitle: setting('title'),

      _handleLogout: function () {
        var _this = this;

        if (this.currentUser) {
          this.currentUser.destroySession().then(function () {
            return logout(_this.siteSettings, _this.keyValueStore);
          });
        }
      },

      actions: {

        showSearchHelp: function () {
          Discourse.ajax("/static/search_help.html", { dataType: 'html' }).then(function (model) {
            showModal('searchHelp', { model: model });
          });
        },

        toggleAnonymous: function () {
          Discourse.ajax("/users/toggle-anon", { method: 'POST' }).then(function () {
            window.location.reload();
          });
        },

        toggleMobileView: function () {
          mobile.toggleMobileView();
        },

        logout: unlessReadOnly('_handleLogout', I18n.t("read_only_mode.logout_disabled")),

        _collectTitleTokens: function (tokens) {
          tokens.push(this.get('siteTitle'));
          Discourse.set('_docTitle', tokens.join(' - '));
        },

        // Ember doesn't provider a router `willTransition` event so let's make one
        willTransition: function () {
          var router = this.container.lookup('router:main');
          Ember.run.once(router, router.trigger, 'willTransition');
          return this._super();
        },

        showTopicEntrance: function (data) {
          this.controllerFor('topic-entrance').send('show', data);
        },

        postWasEnqueued: function (details) {
          var title = details.reason ? 'queue_reason.' + details.reason + '.title' : 'queue.approval.title';
          showModal('post-enqueued', { model: details, title: title });
        },

        composePrivateMessage: function (user, post) {

          var recipient = user ? user.get('username') : '',
              reply = post ? window.location.protocol + "//" + window.location.host + post.get("url") : null;

          // used only once, one less dependency
          var Composer = require('discourse/models/composer').default;
          return this.controllerFor('composer').open({
            action: Composer.PRIVATE_MESSAGE,
            usernames: recipient,
            archetypeId: 'private_message',
            draftKey: 'new_private_message',
            reply: reply
          });
        },

        error: function (err, transition) {
          var xhr = {};
          if (err.jqXHR) {
            xhr = err.jqXHR;
          }

          var xhrOrErr = err.jqXHR ? xhr : err;

          var exceptionController = this.controllerFor('exception');

          var c = window.console;
          if (c && c.error) {
            c.error(xhrOrErr);
          }

          exceptionController.setProperties({ lastTransition: transition, thrown: xhrOrErr });

          this.intermediateTransitionTo('exception');
          return true;
        },

        showLogin: unlessReadOnly('handleShowLogin', I18n.t("read_only_mode.login_disabled")),

        showCreateAccount: unlessReadOnly('handleShowCreateAccount', I18n.t("read_only_mode.login_disabled")),

        showForgotPassword: function () {
          showModal('forgotPassword', { title: 'forgot_password.title' });
        },

        showNotActivated: function (props) {
          showModal('not-activated', { title: 'log_in' }).setProperties(props);
        },

        showUploadSelector: function (toolbarEvent) {
          showModal('uploadSelector').setProperties({ toolbarEvent: toolbarEvent, imageUrl: null, imageLink: null });
        },

        showKeyboardShortcutsHelp: function () {
          showModal('keyboard-shortcuts-help', { title: 'keyboard_shortcuts_help.title' });
        },

        // Close the current modal, and destroy its state.
        closeModal: function () {
          this.render('hide-modal', { into: 'modal', outlet: 'modalBody' });
        },

        /**
          Hide the modal, but keep it with all its state so that it can be shown again later.
          This is useful if you want to prompt for confirmation. hideModal, ask "Are you sure?",
          user clicks "No", reopenModal. If user clicks "Yes", be sure to call closeModal.
        **/
        hideModal: function () {
          $('#discourse-modal').modal('hide');
        },

        reopenModal: function () {
          $('#discourse-modal').modal('show');
        },

        editCategory: function (category) {
          var _this2 = this;

          Category.reloadById(category.get('id')).then(function (atts) {
            var model = _this2.store.createRecord('category', atts.category);
            model.setupGroupsAndPermissions();
            _this2.site.updateCategory(model);
            showModal('editCategory', { model: model });
            _this2.controllerFor('editCategory').set('selectedTab', 'general');
          });
        },

        deleteSpammer: function (user) {
          this.send('closeModal');
          user.deleteAsSpammer(function () {
            window.location.reload();
          });
        },

        checkEmail: function (user) {
          user.checkEmail();
        },

        changeBulkTemplate: function (w) {
          var controllerName = w.replace('modal/', ''),
              factory = this.container.lookupFactory('controller:' + controllerName);

          this.render(w, { into: 'modal/topic-bulk-actions', outlet: 'bulkOutlet', controller: factory ? controllerName : 'topic-bulk-actions' });
        },

        createNewTopicViaParams: function (title, body, category_id, category) {
          this.openComposerWithTopicParams(this.controllerFor('discovery/topics'), title, body, category_id, category);
        },

        createNewMessageViaParams: function (username, title, body) {
          this.openComposerWithMessageParams(username, title, body);
        }
      },

      activate: function () {
        this._super();
        Em.run.next(function () {
          // Support for callbacks once the application has activated
          ApplicationRoute.trigger('activate');
        });
      },

      handleShowLogin: function () {
        var _this3 = this;

        if (this.siteSettings.enable_sso) {
          var returnPath = encodeURIComponent(window.location.pathname);
          window.location = Discourse.getURL('/session/sso?return_path=' + returnPath);
        } else {
          this._autoLogin('login', 'login-modal', function () {
            return _this3.controllerFor('login').resetForm();
          });
        }
      },

      handleShowCreateAccount: function () {
        if (this.siteSettings.enable_sso) {
          var returnPath = encodeURIComponent(window.location.pathname);
          window.location = Discourse.getURL('/session/sso?return_path=' + returnPath);
        } else {
          this._autoLogin('createAccount', 'create-account');
        }
      },

      _autoLogin: function (modal, modalClass, notAuto) {
        var methods = Em.get('Discourse.LoginMethod.all');
        if (!this.siteSettings.enable_local_logins && methods.length === 1) {
          this.controllerFor('login').send('externalLogin', methods[0]);
        } else {
          showModal(modal);
          this.controllerFor('modal').set('modalClass', modalClass);
          if (notAuto) {
            notAuto();
          }
        }
      }

    });

    RSVP.EventTarget.mixin(ApplicationRoute);
    __exports__["default"] = ApplicationRoute;
  });
define("discourse/routes/badges-index", 
  ["discourse/models/badge","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Badge = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        if (PreloadStore.get("badges")) {
          return PreloadStore.getAndRemove("badges").then(function (json) {
            return Badge.createFromJson(json);
          });
        } else {
          return Badge.findAll({ onlyListable: true });
        }
      },

      titleToken: function () {
        return I18n.t("badges.title");
      },

      actions: {
        didTransition: function () {
          this.controllerFor("application").set("showFooter", true);
          return true;
        }
      }
    });
  });
define("discourse/routes/badges-show", 
  ["discourse/models/user-badge","discourse/models/badge","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserBadge = __dependency1__["default"];
    var Badge = __dependency2__["default"];

    __exports__["default"] = Discourse.Route.extend({
      queryParams: {
        username: {
          refreshModel: true
        }
      },
      actions: {
        didTransition: function () {
          this.controllerFor("badges/show")._showFooter();
          return true;
        }
      },

      serialize: function (model) {
        return model.getProperties('id', 'slug');
      },

      model: function (params) {
        if (PreloadStore.get("badge")) {
          return PreloadStore.getAndRemove("badge").then(function (json) {
            return Badge.createFromJson(json);
          });
        } else {
          return Badge.findById(params.id);
        }
      },

      afterModel: function (model, transition) {
        var _this = this;

        var username = transition.queryParams && transition.queryParams.username;

        return UserBadge.findByBadgeId(model.get("id"), { username: username }).then(function (userBadges) {
          _this.userBadges = userBadges;
        });
      },

      titleToken: function () {
        var model = this.modelFor("badges.show");
        if (model) {
          return model.get("name");
        }
      },

      setupController: function (controller, model) {
        controller.set("model", model);
        controller.set("userBadges", this.userBadges);
      }
    });
  });
define("discourse/routes/build-admin-user-posts-route", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = function (filter) {
      return Discourse.Route.extend({
        actions: {
          didTransition: function () {
            this.controllerFor("user").set("indexStream", true);
            this.controllerFor("user-posts")._showFooter();
            return true;
          }
        },

        model: function () {
          return this.modelFor("user").get("postsStream");
        },

        afterModel: function () {
          return this.modelFor("user").get("postsStream").filterBy(filter);
        },

        setupController: function (controller, model) {
          // initialize "canLoadMore"
          model.set("canLoadMore", model.get("itemsLoaded") === 60);

          this.controllerFor("user-posts").set("model", model);
        },

        renderTemplate: function () {
          this.render("user/posts", { into: "user" });
        }
      });
    }
  });
define("discourse/routes/build-category-route", 
  ["discourse/routes/build-topic-route","discourse/controllers/discovery-sortable","discourse/models/topic-list","discourse/models/permission-type","discourse/models/category-list","discourse/models/category","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __exports__) {
    "use strict";
    var filterQueryParams = __dependency1__.filterQueryParams;
    var findTopicList = __dependency1__.findTopicList;
    var queryParams = __dependency2__.queryParams;
    var TopicList = __dependency3__["default"];
    var PermissionType = __dependency4__["default"];
    var CategoryList = __dependency5__["default"];
    var Category = __dependency6__["default"];

    // A helper function to create a category route with parameters
    __exports__["default"] = function (filter, params) {
      return Discourse.Route.extend({
        queryParams: queryParams,

        model: function (modelParams) {
          var _this = this;

          var category = Category.findBySlug(modelParams.slug, modelParams.parentSlug);
          if (!category) {
            return Category.reloadBySlug(modelParams.slug, modelParams.parentSlug).then(function (atts) {
              if (modelParams.parentSlug) {
                atts.category.parentCategory = Category.findBySlug(modelParams.parentSlug);
              }
              var record = _this.store.createRecord('category', atts.category);
              record.setupGroupsAndPermissions();
              _this.site.updateCategory(record);
              return { category: Category.findBySlug(modelParams.slug, modelParams.parentSlug) };
            });
          };
          return { category: category };
        },

        afterModel: function (model, transition) {
          if (!model) {
            this.replaceWith('/404');
            return;
          }

          this._setupNavigation(model.category);
          return Em.RSVP.all([this._createSubcategoryList(model.category), this._retrieveTopicList(model.category, transition)]);
        },

        _setupNavigation: function (category) {
          var noSubcategories = params && !!params.no_subcategories,
              filterMode = 'c/' + Discourse.Category.slugFor(category) + (noSubcategories ? "/none" : "") + '/l/' + filter;

          this.controllerFor('navigation/category').setProperties({
            category: category,
            filterMode: filterMode,
            noSubcategories: params && params.no_subcategories,
            canEditCategory: category.get('can_edit')
          });
        },

        _createSubcategoryList: function (category) {
          var _this2 = this;

          this._categoryList = null;
          if (Em.isNone(category.get('parentCategory')) && Discourse.SiteSettings.show_subcategory_list) {
            return CategoryList.listForParent(this.store, category).then(function (list) {
              return _this2._categoryList = list;
            });
          }

          // If we're not loading a subcategory list just resolve
          return Em.RSVP.resolve();
        },

        _retrieveTopicList: function (category, transition) {
          var _this3 = this;

          var listFilter = 'c/' + Discourse.Category.slugFor(category) + '/l/' + filter,
              findOpts = filterQueryParams(transition.queryParams, params),
              extras = { cached: this.isPoppedState(transition) };

          return findTopicList(this.store, this.topicTrackingState, listFilter, findOpts, extras).then(function (list) {
            TopicList.hideUniformCategory(list, category);
            _this3.set('topics', list);
            return list;
          });
        },

        titleToken: function () {
          var filterText = I18n.t('filters.' + filter.replace('/', '.') + '.title'),
              category = this.currentModel.category;

          return I18n.t('filters.with_category', { filter: filterText, category: category.get('name') });
        },

        setupController: function (controller, model) {
          var topics = this.get('topics'),
              category = model.category,
              canCreateTopic = topics.get('can_create_topic'),
              canCreateTopicOnCategory = category.get('permission') === PermissionType.FULL;

          this.controllerFor('navigation/category').setProperties({
            canCreateTopicOnCategory: canCreateTopicOnCategory,
            cannotCreateTopicOnCategory: !canCreateTopicOnCategory,
            canCreateTopic: canCreateTopic
          });

          var topicOpts = {
            model: topics,
            category: category,
            period: topics.get('for_period') || (filter.indexOf('/') > 0 ? filter.split('/')[1] : ''),
            selected: [],
            noSubcategories: params && !!params.no_subcategories,
            expandAllPinned: true,
            canCreateTopic: canCreateTopic,
            canCreateTopicOnCategory: canCreateTopicOnCategory
          };

          var p = category.get('params');
          if (p && Object.keys(p).length) {
            if (p.order !== undefined) {
              topicOpts.order = p.order;
            }
            if (p.ascending !== undefined) {
              topicOpts.ascending = p.ascending;
            }
          }

          this.controllerFor('discovery/topics').setProperties(topicOpts);
          this.searchService.set('searchContext', category.get('searchContext'));
          this.set('topics', null);

          this.openTopicDraft(topics);
        },

        renderTemplate: function () {
          this.render('navigation/category', { outlet: 'navigation-bar' });

          if (this._categoryList) {
            this.render('discovery/categories', { outlet: 'header-list-container', model: this._categoryList });
          }
          this.render('discovery/topics', { controller: 'discovery/topics', outlet: 'list-container' });
        },

        resetController: function (controller, isExiting) {
          if (isExiting) {
            controller.setProperties({ order: "default", ascending: false });
          }
        },

        deactivate: function () {
          this._super();
          this.searchService.set('searchContext', null);
        },

        actions: {
          setNotification: function (notification_level) {
            this.currentModel.setNotification(notification_level);
          }
        }
      });
    }
  });
define("discourse/routes/build-private-messages-route", 
  ["discourse/routes/user-topic-list","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var UserTopicListRoute = __dependency1__["default"];

    // A helper to build a user topic list route
    __exports__["default"] = function (viewName, path) {
      return UserTopicListRoute.extend({
        userActionType: Discourse.UserAction.TYPES.messages_received,

        actions: {
          didTransition: function () {
            this.controllerFor("user-topics-list")._showFooter();
            return true;
          }
        },

        model: function () {
          return this.store.findFiltered("topicList", { filter: "topics/" + path + "/" + this.modelFor("user").get("username_lower") });
        },

        setupController: function () {
          this._super.apply(this, arguments);

          this.controllerFor("user-topics-list").setProperties({
            hideCategory: true,
            showPosters: true,
            canBulkSelect: true,
            selected: []
          });

          this.controllerFor("user-private-messages").set("archive", false);
          this.controllerFor("user-private-messages").set("pmView", viewName);
          this.searchService.set('contextType', 'private_messages');
        },

        deactivate: function () {
          this.searchService.set('contextType', 'private_messages');
        }
      });
    }
  });
define("discourse/routes/build-static-route", 
  ["discourse/routes/discourse","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseRoute = __dependency1__["default"];

    __exports__["default"] = function (pageName) {
      var route = {
        model: function () {
          return Discourse.StaticPage.find(pageName);
        },

        renderTemplate: function () {
          this.render('static');
        },

        setupController: function (controller, model) {
          this.controllerFor('static').set('model', model);
        }
      };
      return DiscourseRoute.extend(route);
    }
  });
define("discourse/routes/discovery-categories", 
  ["discourse/lib/show-modal","discourse/mixins/open-composer","discourse/models/category-list","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var showModal = __dependency1__["default"];
    var OpenComposer = __dependency2__["default"];
    var CategoryList = __dependency3__["default"];

    var DiscoveryCategoriesRoute = Discourse.Route.extend(OpenComposer, {
      renderTemplate: function () {
        this.render("navigation/categories", { outlet: "navigation-bar" });
        this.render("discovery/categories", { outlet: "list-container" });
      },

      beforeModel: function () {
        this.controllerFor("navigation/categories").set("filterMode", "categories");
      },

      model: function () {
        var _this = this;

        // TODO: Remove this and ensure server side does not supply `topic_list`
        // if default page is categories
        PreloadStore.remove("topic_list");

        return CategoryList.list(this.store, 'categories').then(function (list) {
          var tracking = _this.topicTrackingState;
          if (tracking) {
            tracking.sync(list, "categories");
            tracking.trackIncoming("categories");
          }
          return list;
        });
      },

      titleToken: function () {
        if (Discourse.Utilities.defaultHomepage() === "categories") {
          return;
        }
        return I18n.t("filters.categories.title");
      },

      setupController: function (controller, model) {
        controller.set("model", model);

        this.controllerFor("navigation/categories").setProperties({
          canCreateCategory: model.get("can_create_category"),
          canCreateTopic: model.get("can_create_topic")
        });

        this.openTopicDraft(model);
      },

      actions: {
        createCategory: function () {
          var groups = this.site.groups,
              everyoneName = groups.findBy("id", 0).name;

          var model = this.store.createRecord('category', {
            color: "AB9364", text_color: "FFFFFF", group_permissions: [{ group_name: everyoneName, permission_type: 1 }],
            available_groups: groups.map(function (g) {
              return g.name;
            }),
            allow_badges: true
          });

          showModal("editCategory", { model: model });
          this.controllerFor("editCategory").set("selectedTab", "general");
        },

        reorderCategories: function () {
          showModal("reorderCategories");
        },

        createTopic: function () {
          this.openComposer(this.controllerFor("discovery/categories"));
        },

        didTransition: function () {
          var _this2 = this;

          Ember.run.next(function () {
            return _this2.controllerFor("application").set("showFooter", true);
          });
          return true;
        }
      }
    });

    __exports__["default"] = DiscoveryCategoriesRoute;
  });
define("discourse/routes/discovery-category-with-id", 
  ["discourse/models/category","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Category = __dependency1__["default"];

    __exports__["default"] = Discourse.DiscoveryCategoryRoute.extend({
      model: function (params) {
        return { category: Category.findById(params.id) };
      }
    });
  });
define("discourse/routes/discovery", 
  ["discourse/mixins/open-composer","discourse/mixins/scroll-top","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    /**
      The parent route for all discovery routes.
      Handles the logic for showing the loading spinners.
    **/

    var OpenComposer = __dependency1__["default"];
    var scrollTop = __dependency2__.scrollTop;

    __exports__["default"] = Discourse.Route.extend(OpenComposer, {
      redirect: function () {
        return this.redirectIfLoginRequired();
      },

      beforeModel: function (transition) {
        if (transition.intent.url === "/" && transition.targetName.indexOf("discovery.top") === -1 && Discourse.User.currentProp("should_be_redirected_to_top")) {
          Discourse.User.currentProp("should_be_redirected_to_top", false);
          var period = Discourse.User.currentProp("redirect_to_top.period") || "all";
          this.replaceWith("discovery.top" + period.capitalize());
        }
      },

      actions: {
        loading: function () {
          this.controllerFor("discovery").set("loading", true);
          return true;
        },

        loadingComplete: function () {
          this.controllerFor("discovery").set("loading", false);
          if (!this.session.get("topicListScrollPosition")) {
            scrollTop();
          }
        },

        didTransition: function () {
          this.controllerFor("discovery")._showFooter();
          this.send("loadingComplete");
          return true;
        },

        // clear a pinned topic
        clearPin: function (topic) {
          topic.clearPin();
        },

        createTopic: function () {
          this.openComposer(this.controllerFor("discovery/topics"));
        },

        dismissReadTopics: function (dismissTopics) {
          var operationType = dismissTopics ? "topics" : "posts";
          this.controllerFor("discovery/topics").send('dismissRead', operationType);
        },

        dismissRead: function (operationType) {
          this.controllerFor("discovery/topics").send('dismissRead', operationType);
        }
      }

    });
  });
define("discourse/routes/exception", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      serialize: function () {
        return "";
      },

      actions: {
        didTransition: function () {
          this.controllerFor("application").set("showFooter", true);
          return true;
        }
      }
    });
  });
define("discourse/routes/faq", 
  ["discourse/lib/static-route-builder","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var staticRouteBuilder = __dependency1__["default"];

    __exports__["default"] = staticRouteBuilder('faq');
  });
define("discourse/routes/forgot-password", 
  ["discourse/routes/build-static-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildStaticRoute = __dependency1__["default"];

    var ForgotPasswordRoute = buildStaticRoute('password-reset');

    ForgotPasswordRoute.reopen({
      beforeModel: function () {
        this.replaceWith(this.controllerFor('application').get('loginRequired') ? 'login' : 'discovery').then(function (e) {
          Ember.run.next(function () {
            return e.send('showForgotPassword');
          });
        });
      }
    });

    __exports__["default"] = ForgotPasswordRoute;
  });
define("discourse/routes/full-page-search", 
  ["discourse/lib/search","discourse/models/composer","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var translateResults = __dependency1__.translateResults;
    var getSearchKey = __dependency1__.getSearchKey;
    var isValidSearchTerm = __dependency1__.isValidSearchTerm;
    var Composer = __dependency2__["default"];

    __exports__["default"] = Discourse.Route.extend({
      queryParams: { q: {}, context_id: {}, context: {}, skip_context: {} },

      model: function (params) {
        var router = Discourse.__container__.lookup('router:main');
        var cached = router.transientCache('lastSearch');
        var args = { q: params.q };
        if (params.context_id && !args.skip_context) {
          args.search_context = {
            type: params.context,
            id: params.context_id
          };
        }

        var searchKey = getSearchKey(args);

        if (cached && cached.data.searchKey === searchKey) {
          // extend expiry
          router.transientCache('lastSearch', { searchKey: searchKey, model: cached.data.model }, 5);
          return cached.data.model;
        }

        return PreloadStore.getAndRemove("search", function () {
          if (isValidSearchTerm(params.q)) {
            return Discourse.ajax("/search", { data: args });
          } else {
            return null;
          }
        }).then(function (results) {
          var model = results && translateResults(results) || {};
          router.transientCache('lastSearch', { searchKey: searchKey, model: model }, 5);
          return model;
        });
      },

      actions: {
        didTransition: function () {
          this.controllerFor("full-page-search")._showFooter();
          return true;
        },

        createTopic: function (searchTerm) {
          var category = undefined;
          if (searchTerm.indexOf("category:")) {
            var match = searchTerm.match(/category:(\S*)/);
            if (match && match[1]) {
              category = match[1];
            }
          }
          this.container.lookup('controller:composer').open({ action: Composer.CREATE_TOPIC, draftKey: Composer.CREATE_TOPIC, topicCategory: category });
        }
      }

    });
  });
define("discourse/routes/group-index", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.buildIndex = buildIndex;

    function buildIndex(type) {
      return Discourse.Route.extend({
        type: type,

        model: function () {
          return this.modelFor("group").findPosts({ type: type });
        },

        setupController: function (controller, model) {
          this.controllerFor('group-index').setProperties({ model: model, type: type });
          this.controllerFor("group").set("showing", type);
        },

        renderTemplate: function () {
          this.render('group-index');
        },

        actions: {
          didTransition: function () {
            return true;
          }
        }
      });
    }

    __exports__["default"] = buildIndex('posts');
  });
define("discourse/routes/group-members", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        return this.modelFor("group");
      },

      setupController: function (controller, model) {
        this.controllerFor("group").set("showing", "members");
        controller.set("model", model);
        model.findMembers();
      }
    });
  });
define("discourse/routes/group-mentions", 
  ["discourse/routes/group-index","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildIndex = __dependency1__.buildIndex;

    __exports__["default"] = buildIndex('mentions');
  });
define("discourse/routes/group-messages", 
  ["discourse/routes/group-index","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildIndex = __dependency1__.buildIndex;

    __exports__["default"] = buildIndex('messages');
  });
define("discourse/routes/group-topics", 
  ["discourse/routes/group-index","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildIndex = __dependency1__.buildIndex;

    __exports__["default"] = buildIndex('topics');
  });
define("discourse/routes/group", 
  ["discourse/models/group","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Group = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend({

      model: function (params) {
        return Group.find(params.name);
      },

      serialize: function (model) {
        return { name: model.get('name').toLowerCase() };
      },

      afterModel: function (model) {
        var self = this;
        return Group.findGroupCounts(model.get('name')).then(function (counts) {
          self.set('counts', counts);
        });
      },

      setupController: function (controller, model) {
        controller.setProperties({
          model: model,
          counts: this.get('counts')
        });
      }
    });
  });
define("discourse/routes/guidelines", 
  ["discourse/lib/static-route-builder","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var staticRouteBuilder = __dependency1__["default"];

    __exports__["default"] = staticRouteBuilder('guidelines');
  });
define("discourse/routes/loading", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Route.extend();
  });
define("discourse/routes/login", 
  ["discourse/routes/build-static-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildStaticRoute = __dependency1__["default"];

    var LoginRoute = buildStaticRoute('login');

    LoginRoute.reopen({
      beforeModel: function () {
        if (!this.siteSettings.login_required) {
          this.replaceWith('discovery.latest').then(function (e) {
            Ember.run.next(function () {
              return e.send('showLogin');
            });
          });
        }
      }
    });

    __exports__["default"] = LoginRoute;
  });
define("discourse/routes/new-message", 
  ["discourse/models/group","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Group = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend({
      beforeModel: function (transition) {
        var self = this;
        if (Discourse.User.current()) {
          // User is logged in
          self.replaceWith('discovery.latest').then(function (e) {
            if (transition.queryParams.username) {
              // send a message to user
              Discourse.User.findByUsername(transition.queryParams.username).then(function (user) {
                if (user.can_send_private_message_to_user) {
                  Ember.run.next(function () {
                    e.send('createNewMessageViaParams', user.username, transition.queryParams.title, transition.queryParams.body);
                  });
                } else {
                  bootbox.alert(I18n.t("composer.cant_send_pm", { username: user.username }));
                }
              }).catch(function () {
                bootbox.alert(I18n.t("generic_error"));
              });
            } else {
              // send a message to group
              Group.find(transition.queryParams.groupname).then(function (group) {
                if (!group.automatic && group.mentionable) {
                  Ember.run.next(function () {
                    e.send('createNewMessageViaParams', group.name, transition.queryParams.title, transition.queryParams.body);
                  });
                } else {
                  bootbox.alert(I18n.t("composer.cant_send_pm", { username: group.name }));
                }
              }).catch(function () {
                bootbox.alert(I18n.t("generic_error"));
              });
            }
          });
        } else {
          // User is not logged in
          self.session.set("shouldRedirectToUrl", window.location.href);
          self.replaceWith('login');
        }
      }
    });
  });
define("discourse/routes/new-topic", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      beforeModel: function (transition) {
        var self = this;
        if (Discourse.User.current()) {
          // User is logged in
          self.replaceWith('discovery.latest').then(function (e) {
            if (self.controllerFor('navigation/default').get('canCreateTopic')) {
              // User can create topic
              Ember.run.next(function () {
                e.send('createNewTopicViaParams', transition.queryParams.title, transition.queryParams.body, transition.queryParams.category_id, transition.queryParams.category);
              });
            }
          });
        } else {
          // User is not logged in
          self.session.set("shouldRedirectToUrl", window.location.href);
          self.replaceWith('login');
        }
      }
    });
  });
define("discourse/routes/preferences-about", 
  ["discourse/routes/restricted-user","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestrictedUserRoute = __dependency1__["default"];

    __exports__["default"] = RestrictedUserRoute.extend({
      model: function () {
        return this.modelFor('user');
      },

      renderTemplate: function () {
        this.render({ into: 'user' });
      },

      setupController: function (controller, model) {
        controller.setProperties({ model: model, newBio: model.get('bio_raw') });
      },

      // A bit odd, but if we leave to /preferences we need to re-render that outlet
      deactivate: function () {
        this._super();
        this.render('preferences', { into: 'user', controller: 'preferences' });
      },

      actions: {
        changeAbout: function () {
          var route = this;
          var controller = route.controllerFor('preferences/about');

          controller.setProperties({ saving: true });
          return controller.get('model').save().then(function () {
            controller.set('saving', false);
            route.transitionTo('user.index');
          }, function () {
            // model failed to save
            controller.set('saving', false);
            alert(I18n.t('generic_error'));
          });
        }
      }

    });
  });
define("discourse/routes/preferences-badge-title", 
  ["discourse/models/user-badge","discourse/routes/restricted-user","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserBadge = __dependency1__["default"];
    var RestrictedUserRoute = __dependency2__["default"];

    __exports__["default"] = RestrictedUserRoute.extend({
      model: function () {
        return UserBadge.findByUsername(this.modelFor('user').get('username'));
      },

      renderTemplate: function () {
        return this.render('user/badge-title', { into: 'user' });
      },

      // A bit odd, but if we leave to /preferences we need to re-render that outlet
      deactivate: function () {
        this._super();
        this.render('preferences', { into: 'user', controller: 'preferences' });
      },

      setupController: function (controller, model) {
        controller.set('model', model);
        controller.set('user', this.modelFor('user'));

        model.forEach(function (userBadge) {
          if (userBadge.get('badge.name') === controller.get('user.title')) {
            controller.set('selectedUserBadgeId', userBadge.get('id'));
          }
        });
        if (!controller.get('selectedUserBadgeId') && controller.get('selectableUserBadges.length') > 0) {
          controller.set('selectedUserBadgeId', controller.get('selectableUserBadges')[0].get('id'));
        }
      }
    });
  });
define("discourse/routes/preferences-card-badge", 
  ["discourse/models/user-badge","discourse/routes/restricted-user","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserBadge = __dependency1__["default"];
    var RestrictedUserRoute = __dependency2__["default"];

    __exports__["default"] = RestrictedUserRoute.extend({
      model: function () {
        return UserBadge.findByUsername(this.modelFor('user').get('username'));
      },

      renderTemplate: function () {
        return this.render({ into: 'user' });
      },

      // A bit odd, but if we leave to /preferences we need to re-render that outlet
      deactivate: function () {
        this._super();
        this.render('preferences', { into: 'user', controller: 'preferences' });
      },

      setupController: function (controller, model) {
        controller.set('model', model);
        controller.set('user', this.modelFor('user'));

        model.forEach(function (userBadge) {
          if (userBadge.get('badge.image') === controller.get('user.card_image_badge')) {
            controller.set('selectedUserBadgeId', userBadge.get('id'));
          }
        });
      }
    });
  });
define("discourse/routes/preferences-email", 
  ["discourse/routes/restricted-user","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestrictedUserRoute = __dependency1__["default"];

    __exports__["default"] = RestrictedUserRoute.extend({
      model: function () {
        return this.modelFor('user');
      },

      renderTemplate: function () {
        this.render({ into: 'user' });
      },

      setupController: function (controller, model) {
        controller.setProperties({ model: model, newEmail: model.get('email') });
      },

      // A bit odd, but if we leave to /preferences we need to re-render that outlet
      deactivate: function () {
        this._super();
        this.render('preferences', { into: 'user', controller: 'preferences' });
      }
    });
  });
define("discourse/routes/preferences-index", 
  ["discourse/routes/restricted-user","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestrictedUserRoute = __dependency1__["default"];

    __exports__["default"] = RestrictedUserRoute.extend({
      renderTemplate: function () {
        this.render('preferences', { into: 'user', controller: 'preferences' });
      }
    });
  });
define("discourse/routes/preferences-username", 
  ["discourse/routes/restricted-user","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestrictedUserRoute = __dependency1__["default"];

    __exports__["default"] = RestrictedUserRoute.extend({
      model: function () {
        return this.modelFor('user');
      },

      renderTemplate: function () {
        return this.render({ into: 'user' });
      },

      // A bit odd, but if we leave to /preferences we need to re-render that outlet
      deactivate: function () {
        this._super();
        this.render('preferences', { into: 'user', controller: 'preferences' });
      },

      setupController: function (controller, user) {
        controller.setProperties({ model: user, newUsername: user.get('username') });
      }
    });
  });
define("discourse/routes/preferences", 
  ["discourse/routes/restricted-user","discourse/lib/show-modal","discourse/lib/ajax-error","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var RestrictedUserRoute = __dependency1__["default"];
    var showModal = __dependency2__["default"];
    var popupAjaxError = __dependency3__.popupAjaxError;

    __exports__["default"] = RestrictedUserRoute.extend({
      model: function () {
        return this.modelFor('user');
      },

      setupController: function (controller, user) {
        controller.reset();
        controller.setProperties({
          model: user,
          newNameInput: user.get('name')
        });
      },

      actions: {
        showAvatarSelector: function () {
          showModal('avatar-selector');

          // all the properties needed for displaying the avatar selector modal
          var props = this.modelFor('user').getProperties('id', 'email', 'username', 'avatar_template', 'system_avatar_template', 'gravatar_avatar_template', 'custom_avatar_template', 'system_avatar_upload_id', 'gravatar_avatar_upload_id', 'custom_avatar_upload_id');

          switch (props.avatar_template) {
            case props.system_avatar_template:
              props.selected = "system";
              break;
            case props.gravatar_avatar_template:
              props.selected = "gravatar";
              break;
            default:
              props.selected = "uploaded";
          }

          this.controllerFor('avatar-selector').setProperties(props);
        },

        saveAvatarSelection: function () {
          var user = this.modelFor('user'),
              controller = this.controllerFor('avatar-selector'),
              selectedUploadId = controller.get("selectedUploadId"),
              selectedAvatarTemplate = controller.get("selectedAvatarTemplate"),
              type = controller.get("selected");

          user.pickAvatar(selectedUploadId, type, selectedAvatarTemplate).then(function () {
            user.setProperties(controller.getProperties('system_avatar_template', 'gravatar_avatar_template', 'custom_avatar_template'));
            bootbox.alert(I18n.t("user.change_avatar.cache_notice"));
          }).catch(popupAjaxError);

          // saves the data back
          controller.send('closeModal');
        }

      }
    });
  });
define("discourse/routes/privacy", 
  ["discourse/lib/static-route-builder","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var staticRouteBuilder = __dependency1__["default"];

    __exports__["default"] = staticRouteBuilder('privacy');
  });
define("discourse/routes/queued-posts", 
  ["discourse/lib/load-script","discourse/routes/discourse","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var loadScript = __dependency1__["default"];
    var DiscourseRoute = __dependency2__["default"];

    __exports__["default"] = DiscourseRoute.extend({

      // this route requires the sanitizer
      beforeModel: function () {
        loadScript('defer/html-sanitizer-bundle');
      },

      model: function () {
        return this.store.find('queuedPost', { status: 'new' });
      },

      actions: {
        removePost: function (post) {
          this.modelFor('queued-posts').removeObject(post);
        },

        refresh: function () {
          this.modelFor('queued-posts').refresh();
        }
      }
    });
  });
define("discourse/routes/signup", 
  ["discourse/routes/build-static-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildStaticRoute = __dependency1__["default"];

    var SignupRoute = buildStaticRoute('signup');

    SignupRoute.reopen({
      beforeModel: function () {
        var canSignUp = this.controllerFor("application").get('canSignUp');

        if (!this.siteSettings.login_required) {
          this.replaceWith('discovery.latest').then(function (e) {
            if (canSignUp) {
              Ember.run.next(function () {
                return e.send('showCreateAccount');
              });
            }
          });
        } else {
          this.replaceWith('login').then(function (e) {
            if (canSignUp) {
              Ember.run.next(function () {
                return e.send('showCreateAccount');
              });
            }
          });
        }
      }
    });

    __exports__["default"] = SignupRoute;
  });
define("discourse/routes/tags-index", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        return this.store.findAll('tag');
      },

      titleToken: function () {
        return I18n.t("tagging.tags");
      },

      setupController: function (controller, model) {
        this.controllerFor('tags.index').setProperties({
          model: model,
          sortProperties: this.siteSettings.tags_sort_alphabetically ? ['id'] : ['count:desc', 'id']
        });
      },

      actions: {
        didTransition: function () {
          this.controllerFor("application").set("showFooter", true);
          return true;
        }
      }
    });
  });
define("discourse/routes/tags-show", 
  ["discourse/models/composer","discourse/lib/show-modal","discourse/routes/build-topic-route","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var Composer = __dependency1__["default"];
    var showModal = __dependency2__["default"];
    var findTopicList = __dependency3__.findTopicList;

    __exports__["default"] = Discourse.Route.extend({
      navMode: 'latest',

      renderTemplate: function () {
        var controller = this.controllerFor('tags.show');
        this.render('tags.show', { controller: controller });
      },

      model: function (params) {
        var _this = this;

        var tag = this.store.createRecord("tag", { id: Handlebars.Utils.escapeExpression(params.tag_id) }),
            f = '';

        if (params.category) {
          f = 'c/';
          if (params.parent_category) {
            f += params.parent_category + '/';
          }
          f += params.category + '/l/';
        }
        f += this.get('navMode');
        this.set('filterMode', f);

        if (params.category) {
          this.set('categorySlug', params.category);
        }
        if (params.parent_category) {
          this.set('parentCategorySlug', params.parent_category);
        }

        if (this.get("currentUser")) {
          // If logged in, we should get the tag"s user settings
          return this.store.find("tagNotification", tag.get("id")).then(function (tn) {
            _this.set("tagNotification", tn);
            return tag;
          });
        }

        return tag;
      },

      afterModel: function (tag) {
        var controller = this.controllerFor('tags.show');
        controller.set('loading', true);

        var params = controller.getProperties('order', 'ascending');

        var categorySlug = this.get('categorySlug');
        var parentCategorySlug = this.get('parentCategorySlug');
        var filter = this.get('navMode');

        if (categorySlug) {
          var category = Discourse.Category.findBySlug(categorySlug, parentCategorySlug);
          if (parentCategorySlug) {
            params.filter = 'tags/c/' + parentCategorySlug + '/' + categorySlug + '/' + tag.id + '/l/' + filter;
          } else {
            params.filter = 'tags/c/' + categorySlug + '/' + tag.id + '/l/' + filter;
          }

          this.set('category', category);
        } else {
          params.filter = 'tags/' + tag.id + '/l/' + filter;
          this.set('category', null);
        }

        return findTopicList(this.store, this.topicTrackingState, params.filter, params, {}).then(function (list) {
          controller.set('list', list);
          controller.set('canCreateTopic', list.get('can_create_topic'));
          if (list.topic_list.tags) {
            Discourse.Site.currentProp('top_tags', list.topic_list.tags);
          }
          controller.set('loading', false);
        });
      },

      titleToken: function () {
        var filterText = I18n.t('filters.' + this.get('navMode').replace('/', '.') + '.title'),
            controller = this.controllerFor('tags.show');

        if (this.get('category')) {
          return I18n.t('tagging.filters.with_category', { filter: filterText, tag: controller.get('model.id'), category: this.get('category.name') });
        } else {
          return I18n.t('tagging.filters.without_category', { filter: filterText, tag: controller.get('model.id') });
        }
      },

      setupController: function (controller, model) {
        this.controllerFor('tags.show').setProperties({
          model: model,
          tag: model,
          category: this.get('category'),
          filterMode: this.get('filterMode'),
          navMode: this.get('navMode'),
          tagNotification: this.get('tagNotification')
        });
      },

      actions: {
        invalidateModel: function () {
          this.refresh();
        },

        renameTag: function (tag) {
          showModal("rename-tag", { model: tag });
        },

        createTopic: function () {
          var controller = this.controllerFor("tags.show"),
              self = this;

          this.controllerFor('composer').open({
            categoryId: controller.get('category.id'),
            action: Composer.CREATE_TOPIC,
            draftKey: controller.get('list.draft_key'),
            draftSequence: controller.get('list.draft_sequence')
          }).then(function () {
            // Pre-fill the tags input field
            if (controller.get('model.id')) {
              var c = self.controllerFor('composer').get('model');
              c.set('tags', [controller.get('model.id')]);
            }
          });
        },

        didTransition: function () {
          this.controllerFor("tags.show")._showFooter();
          return true;
        },

        willTransition: function (transition) {
          if (!Discourse.SiteSettings.show_filter_by_tag) {
            return true;
          }

          if ((transition.targetName.indexOf("discovery.parentCategory") !== -1 || transition.targetName.indexOf("discovery.category") !== -1) && !transition.queryParams.allTags) {
            this.transitionTo("/tags" + transition.intent.url + "/" + this.currentModel.get("id"));
          }
          return true;
        }
      }
    });
  });
define("discourse/routes/topic-by-slug", 
  ["discourse/models/topic","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var Topic = __dependency1__["default"];
    var DiscourseURL = __dependency2__["default"];

    __exports__["default"] = Discourse.Route.extend({
      model: function (params) {
        return Topic.idForSlug(params.slug);
      },

      afterModel: function (result) {
        DiscourseURL.routeTo(result.url, { replaceURL: true });
      }
    });
  });
define("discourse/routes/topic-from-params-near", 
  ["discourse/routes/topic-from-params","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var TopicFromParamsRoute = __dependency1__["default"];

    __exports__["default"] = TopicFromParamsRoute;
  });
define("discourse/routes/topic-unsubscribe", 
  ["discourse/models/topic","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var loadTopicView = __dependency1__.loadTopicView;

    __exports__["default"] = Discourse.Route.extend({
      model: function (params) {
        var topic = this.store.createRecord("topic", { id: params.id });
        return loadTopicView(topic).then(function () {
          return topic;
        });
      },

      afterModel: function (topic) {
        topic.set("details.notificationReasonText", null);
      },

      actions: {
        didTransition: function () {
          this.controllerFor("application").set("showFooter", true);
          return true;
        }
      }
    });
  });
define("discourse/routes/topic", 
  ["discourse/lib/url","discourse/lib/show-modal","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    var showModal = __dependency2__["default"];

    var isTransitioning = false,
        scheduledReplace = null,
        lastScrollPos = null;

    var SCROLL_DELAY = 500;var TopicRoute = Discourse.Route.extend({
      redirect: function () {
        return this.redirectIfLoginRequired();
      },

      queryParams: {
        filter: { replace: true },
        username_filters: { replace: true },
        show_deleted: { replace: true }
      },

      titleToken: function () {
        var model = this.modelFor('topic');
        if (model) {
          var result = model.get('title'),
              cat = model.get('category');

          // Only display uncategorized in the title tag if it was renamed
          if (cat && !(cat.get('isUncategorizedCategory') && cat.get('name').toLowerCase() === "uncategorized")) {
            var catName = cat.get('name');

            var parentCategory = cat.get('parentCategory');
            if (parentCategory) {
              catName = parentCategory.get('name') + " / " + catName;
            }

            return [result, catName];
          }
          return result;
        }
      },

      actions: {

        showFlags: function (model) {
          showModal('flag', { model: model });
          this.controllerFor('flag').setProperties({ selected: null, flagTopic: false });
        },

        showFlagTopic: function (model) {
          showModal('flag', { model: model });
          this.controllerFor('flag').setProperties({ selected: null, flagTopic: true });
        },

        showAutoClose: function () {
          showModal('edit-topic-auto-close', { model: this.modelFor('topic') });
          this.controllerFor('modal').set('modalClass', 'edit-auto-close-modal');
        },

        showChangeTimestamp: function () {
          showModal('change-timestamp', { model: this.modelFor('topic'), title: 'topic.change_timestamp.title' });
        },

        showFeatureTopic: function () {
          showModal('featureTopic', { model: this.modelFor('topic'), title: 'topic.feature_topic.title' });
          this.controllerFor('modal').set('modalClass', 'feature-topic-modal');
          this.controllerFor('feature_topic').reset();
        },

        showInvite: function () {
          showModal('invite', { model: this.modelFor('topic') });
          this.controllerFor('invite').reset();
        },

        showHistory: function (model) {
          showModal('history', { model: model });
          this.controllerFor('history').refresh(model.get("id"), "latest");
          this.controllerFor('history').set('post', model);
          this.controllerFor('modal').set('modalClass', 'history-modal');
        },

        showRawEmail: function (model) {
          showModal('raw-email', { model: model });
          this.controllerFor('raw_email').loadRawEmail(model.get("id"));
        },

        mergeTopic: function () {
          showModal('merge-topic', { model: this.modelFor('topic'), title: 'topic.merge_topic.title' });
        },

        splitTopic: function () {
          showModal('split-topic', { model: this.modelFor('topic') });
        },

        changeOwner: function () {
          showModal('change-owner', { model: this.modelFor('topic'), title: 'topic.change_owner.title' });
        },

        // Use replaceState to update the URL once it changes
        postChangedRoute: function (currentPost) {
          // do nothing if we are transitioning to another route
          if (isTransitioning || TopicRoute.disableReplaceState) {
            return;
          }

          var topic = this.modelFor('topic');
          if (topic && currentPost) {
            var postUrl = topic.get('url');
            if (currentPost > 1) {
              postUrl += "/" + currentPost;
            }

            Em.run.cancel(scheduledReplace);
            lastScrollPos = parseInt($(document).scrollTop(), 10);
            scheduledReplace = Em.run.later(this, '_replaceUnlessScrolling', postUrl, SCROLL_DELAY);
          }
        },

        didTransition: function () {
          this.controllerFor("topic")._showFooter();
          return true;
        },

        willTransition: function () {
          this._super();
          this.controllerFor("quote-button").deselectText();
          Em.run.cancel(scheduledReplace);
          isTransitioning = true;
          return true;
        }
      },

      // replaceState can be very slow on Android Chrome. This function debounces replaceState
      // within a topic until scrolling stops
      _replaceUnlessScrolling: function (url) {
        var currentPos = parseInt($(document).scrollTop(), 10);
        if (currentPos === lastScrollPos) {
          DiscourseURL.replaceState(url);
          return;
        }
        lastScrollPos = currentPos;
        scheduledReplace = Em.run.later(this, '_replaceUnlessScrolling', url, SCROLL_DELAY);
      },

      setupParams: function (topic, params) {
        var postStream = topic.get('postStream');
        postStream.set('summary', Em.get(params, 'filter') === 'summary');
        postStream.set('show_deleted', !!Em.get(params, 'show_deleted'));

        var usernames = Em.get(params, 'username_filters'),
            userFilters = postStream.get('userFilters');

        userFilters.clear();
        if (!Em.isEmpty(usernames) && usernames !== 'undefined') {
          userFilters.addObjects(usernames.split(','));
        }

        return topic;
      },

      model: function (params, transition) {
        var queryParams = transition.queryParams;

        var topic = this.modelFor('topic');
        if (topic && topic.get('id') === parseInt(params.id, 10)) {
          this.setupParams(topic, queryParams);
          return topic;
        } else {
          topic = this.store.createRecord('topic', _.omit(params, 'username_filters', 'filter'));
          return this.setupParams(topic, queryParams);
        }
      },

      activate: function () {
        this._super();
        isTransitioning = false;

        var topic = this.modelFor('topic');
        this.session.set('lastTopicIdViewed', parseInt(topic.get('id'), 10));
      },

      deactivate: function () {
        this._super();

        this.searchService.set('searchContext', null);
        this.controllerFor('user-card').set('visible', false);

        var topicController = this.controllerFor('topic');
        var postStream = topicController.get('model.postStream');

        postStream.cancelFilter();

        topicController.set('multiSelect', false);
        topicController.unsubscribe();
        this.controllerFor('composer').set('topic', null);
        this.screenTrack.stop();

        this.appEvents.trigger('header:hide-topic');
      },

      setupController: function (controller, model) {
        // In case we navigate from one topic directly to another
        isTransitioning = false;

        controller.setProperties({
          model: model,
          editingTopic: false,
          firstPostExpanded: false
        });

        TopicRoute.trigger('setupTopicController', this);

        this.searchService.set('searchContext', model.get('searchContext'));

        this.controllerFor('composer').set('topic', model);
        this.topicTrackingState.trackIncoming('all');
        controller.subscribe();

        this.controllerFor('topic-progress').set('model', model);

        // We reset screen tracking every time a topic is entered
        this.screenTrack.start(model.get('id'), controller);
      }

    });

    RSVP.EventTarget.mixin(TopicRoute);
    __exports__["default"] = TopicRoute;
  });
define("discourse/routes/tos", 
  ["discourse/lib/static-route-builder","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var staticRouteBuilder = __dependency1__["default"];

    __exports__["default"] = staticRouteBuilder('tos');
  });
define("discourse/routes/unknown", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        return Discourse.ajax("/404-body", { dataType: 'html' });
      }
    });
  });
define("discourse/routes/user-activity-bookmarks", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["bookmarks"]
    });
  });
define("discourse/routes/user-activity-index", 
  ["discourse/routes/user-activity-stream","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: undefined,

      actions: {
        didTransition: function () {
          this._super();
          this.controllerFor("user").set("indexStream", true);
          return true;
        }
      }

    });
  });
define("discourse/routes/user-activity-likes-given", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["likes_given"]
    });
  });
define("discourse/routes/user-activity-pending", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES.pending
    });
  });
define("discourse/routes/user-activity-replies", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["posts"]
    });
  });
define("discourse/routes/user-activity-topics", 
  ["discourse/routes/user-topic-list","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserTopicListRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserTopicListRoute.extend({
      userActionType: UserAction.TYPES.topics,

      model: function () {
        return this.store.findFiltered('topicList', { filter: 'topics/created-by/' + this.modelFor('user').get('username_lower') });
      }
    });
  });
define("discourse/routes/user-activity", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        return this.modelFor("user");
      },

      setupController: function (controller, user) {
        this.controllerFor("user-activity").set("model", user);
      }
    });
  });
define("discourse/routes/user-badges", 
  ["discourse/mixins/viewing-action-type","discourse/models/user-badge","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ViewingActionType = __dependency1__["default"];
    var UserBadge = __dependency2__["default"];

    __exports__["default"] = Discourse.Route.extend(ViewingActionType, {
      model: function () {
        return UserBadge.findByUsername(this.modelFor("user").get("username_lower"), { grouped: true });
      },

      setupController: function (controller, model) {
        this.viewingActionType(-1);
        controller.set("model", model);
      },

      renderTemplate: function () {
        this.render("user/badges", { into: "user" });
      },

      actions: {
        didTransition: function () {
          this.controllerFor("application").set("showFooter", true);
          return true;
        }
      }
    });
  });
define("discourse/routes/user-deleted-posts", 
  ["discourse/routes/build-admin-user-posts-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createAdminUserPostsRoute = __dependency1__["default"];

    __exports__["default"] = createAdminUserPostsRoute("deleted");
  });
define("discourse/routes/user-flagged-posts", 
  ["discourse/routes/build-admin-user-posts-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createAdminUserPostsRoute = __dependency1__["default"];

    __exports__["default"] = createAdminUserPostsRoute("flagged");
  });
define("discourse/routes/user-index", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({

      beforeModel: function () {
        // HACK: Something with the way the user card intercepts clicks seems to break how the
        // transition into a user's activity works. This makes the back button work on mobile
        // where there is no user card as well as desktop where there is.
        if (this.site.mobileView) {
          this.replaceWith('userActivity');
        } else {
          this.transitionTo('userActivity');
        }
      }

    });
  });
define("discourse/routes/user-invited-index", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      beforeModel: function () {
        this.replaceWith('userInvited.show', 'pending');
      }
    });
  });
define("discourse/routes/user-invited-show", 
  ["discourse/models/invite","discourse/lib/show-modal","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var Invite = __dependency1__["default"];
    var showModal = __dependency2__["default"];

    __exports__["default"] = Discourse.Route.extend({

      model: function (params) {
        var self = this;
        Invite.findInvitedCount(self.modelFor("user")).then(function (result) {
          self.set('invitesCount', result);
        });
        self.inviteFilter = params.filter;
        return Invite.findInvitedBy(self.modelFor("user"), params.filter);
      },

      afterModel: function (model) {
        if (!model.can_see_invite_details) {
          this.replaceWith("userInvited.show", "redeemed");
        }
      },

      setupController: function (controller, model) {
        controller.setProperties({
          model: model,
          user: this.controllerFor("user").get("model"),
          filter: this.inviteFilter,
          searchTerm: "",
          totalInvites: model.invites.length,
          invitesCount: this.get('invitesCount')
        });
      },

      actions: {
        showInvite: function () {
          showModal("invite", { model: this.currentUser });
          this.controllerFor("invite").reset();
        },

        uploadSuccess: function (filename) {
          bootbox.alert(I18n.t("user.invited.bulk_invite.success", { filename: filename }));
        },

        uploadError: function (filename, message) {
          bootbox.alert(I18n.t("user.invited.bulk_invite.error", { filename: filename, message: message }));
        }
      }
    });
  });
define("discourse/routes/user-notifications-edits", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["edits"]
    });
  });
define("discourse/routes/user-notifications-index", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      controllerName: 'user-notifications',
      renderTemplate: function () {
        this.render("user/notifications-index");
      },

      afterModel: function (model) {
        if (!model) {
          this.transitionTo('userNotifications.responses');
        }
      }
    });
  });
define("discourse/routes/user-notifications-likes-received", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["likes_received"]
    });
  });
define("discourse/routes/user-notifications-mentions", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["mentions"]
    });
  });
define("discourse/routes/user-notifications-responses", 
  ["discourse/routes/user-activity-stream","discourse/models/user-action","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var UserActivityStreamRoute = __dependency1__["default"];
    var UserAction = __dependency2__["default"];

    __exports__["default"] = UserActivityStreamRoute.extend({
      userActionType: UserAction.TYPES["replies"]
    });
  });
define("discourse/routes/user-notifications", 
  ["discourse/mixins/viewing-action-type","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ViewingActionType = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend(ViewingActionType, {

      renderTemplate: function () {
        this.render('user/notifications');
      },

      actions: {
        didTransition: function () {
          this.controllerFor("user-notifications")._showFooter();
          return true;
        }
      },

      model: function () {
        var username = this.modelFor("user").get("username");

        if (this.get("currentUser.username") === username || this.get("currentUser.admin")) {
          return this.store.find("notification", { username: username });
        }
      },

      setupController: function (controller, model) {
        controller.set("model", model);
        controller.set("user", this.modelFor("user"));
        this.viewingActionType(-1);
      }
    });
  });
define("discourse/routes/user-private-messages-archive", 
  ["discourse/routes/build-private-messages-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createPMRoute = __dependency1__["default"];

    __exports__["default"] = createPMRoute('archive', 'private-messages-archive');
  });
define("discourse/routes/user-private-messages-group-archive", 
  ["discourse/routes/build-private-messages-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createPMRoute = __dependency1__["default"];

    __exports__["default"] = createPMRoute('groups', 'private-messages-groups').extend({
      model: function (params) {
        var username = this.modelFor("user").get("username_lower");
        return this.store.findFiltered("topicList", {
          filter: 'topics/private-messages-group/' + username + '/' + params.name + '/archive'
        });
      },

      setupController: function (controller, model) {
        this._super.apply(this, arguments);
        var split = model.get("filter").split('/');
        var group = split[split.length - 2];
        this.controllerFor("user-private-messages").set("groupFilter", group);
        this.controllerFor("user-private-messages").set("archive", true);
      }
    });
  });
define("discourse/routes/user-private-messages-group", 
  ["discourse/routes/build-private-messages-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createPMRoute = __dependency1__["default"];

    __exports__["default"] = createPMRoute('groups', 'private-messages-groups').extend({
      model: function (params) {
        var username = this.modelFor("user").get("username_lower");
        return this.store.findFiltered("topicList", {
          filter: 'topics/private-messages-group/' + username + '/' + params.name
        });
      },

      afterModel: function (model) {
        var groupName = _.last(model.get("filter").split('/'));
        var groups = this.modelFor("user").get("groups");
        var group = _.first(groups.filterBy("name", groupName));
        this.controllerFor("user-private-messages").set("group", group);
      },

      setupController: function (controller, model) {
        this._super.apply(this, arguments);
        var group = _.last(model.get("filter").split('/'));
        this.controllerFor("user-private-messages").set("groupFilter", group);
        this.controllerFor("user-private-messages").set("archive", false);
      }
    });
  });
define("discourse/routes/user-private-messages-index", 
  ["discourse/routes/build-private-messages-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createPMRoute = __dependency1__["default"];

    __exports__["default"] = createPMRoute('index', 'private-messages');
  });
define("discourse/routes/user-private-messages-sent", 
  ["discourse/routes/build-private-messages-route","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createPMRoute = __dependency1__["default"];

    __exports__["default"] = createPMRoute('sent', 'private-messages-sent');
  });
define("discourse/routes/user-private-messages", 
  ["discourse/models/draft","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Draft = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend({

      renderTemplate: function () {
        this.render('user/messages');
      },

      model: function () {
        return this.modelFor("user");
      },

      setupController: function (controller, user) {
        this._super();
        // Bring up a draft
        var composerController = this.controllerFor("composer");
        controller.set("model", user);
        if (this.currentUser) {
          Draft.get("new_private_message").then(function (data) {
            if (data.draft) {
              composerController.open({
                draft: data.draft,
                draftKey: "new_private_message",
                ignoreIfChanged: true,
                draftSequence: data.draft_sequence
              });
            }
          });
        }
      },

      actions: {
        willTransition: function () {
          this._super();
          this.controllerFor('user').set('pmView', null);
          return true;
        }
      }
    });
  });
define("discourse/routes/user-summary", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      model: function () {
        return this.modelFor("User").summary();
      }
    });
  });
define("discourse/routes/user", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var INDEX_STREAM_ROUTES = ["user.deletedPosts", "user.flaggedPosts", "userActivity.index"];

    __exports__["default"] = Discourse.Route.extend({

      titleToken: function () {
        var model = this.modelFor('user');
        var username = model.get('username');
        if (username) {
          return [I18n.t("user.profile"), username];
        }
      },

      actions: {
        willTransition: function (transition) {
          // will reset the indexStream when transitioning to routes that aren't "indexStream"
          // otherwise the "header" will jump
          var isIndexStream = INDEX_STREAM_ROUTES.indexOf(transition.targetName) !== -1;
          this.controllerFor('user').set('indexStream', isIndexStream);
          return true;
        }
      },

      beforeModel: function () {
        if (this.siteSettings.hide_user_profiles_from_public && !this.currentUser) {
          this.replaceWith("discovery");
        }
      },

      model: function (params) {
        // If we're viewing the currently logged in user, return that object instead
        var currentUser = this.currentUser;
        if (currentUser && params.username.toLowerCase() === currentUser.get('username_lower')) {
          return currentUser;
        }

        return Discourse.User.create({ username: params.username });
      },

      afterModel: function () {
        var user = this.modelFor('user');
        var self = this;

        return user.findDetails().then(function () {
          return user.findStaffInfo();
        }).catch(function () {
          return self.replaceWith('/404');
        });
      },

      serialize: function (model) {
        if (!model) return {};
        return { username: (Em.get(model, 'username') || '').toLowerCase() };
      },

      setupController: function (controller, user) {
        controller.set('model', user);
        this.searchService.set('searchContext', user.get('searchContext'));
      },

      activate: function () {
        this._super();
        var user = this.modelFor('user');
        this.messageBus.subscribe("/users/" + user.get('username_lower'), function (data) {
          user.loadUserAction(data);
        });
      },

      deactivate: function () {
        this._super();
        this.messageBus.unsubscribe("/users/" + this.modelFor('user').get('username_lower'));

        // Remove the search context
        this.searchService.set('searchContext', null);
      }

    });
  });
define("discourse/routes/users", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Discourse.Route.extend({
      queryParams: {
        period: { refreshModel: true },
        order: { refreshModel: true },
        asc: { refreshModel: true },
        name: { refreshModel: true, replace: true }
      },

      refreshQueryWithoutTransition: true,

      titleToken: function () {
        return I18n.t("directory.title");
      },

      resetController: function (controller, isExiting) {
        if (isExiting) {
          controller.setProperties({
            period: "weekly",
            order: "likes_received",
            asc: null,
            name: ""
          });
        }
      },

      beforeModel: function () {
        if (this.siteSettings.hide_user_profiles_from_public && !this.currentUser) {
          this.replaceWith("discovery");
        }
      },

      model: function (params) {
        // If we refresh via `refreshModel` set the old model to loading
        this._params = params;
        return this.store.find("directoryItem", params);
      },

      setupController: function (controller, model) {
        var params = this._params;
        controller.setProperties({ model: model, period: params.period, nameInput: params.name });
      },

      actions: {
        didTransition: function () {
          this.controllerFor("users")._showFooter();
          return true;
        }
      }
    });
  });
define("discourse/pre-initializers/dynamic-route-builders", 
  ["discourse/routes/build-category-route","discourse/routes/build-topic-route","discourse/controllers/discovery-sortable","discourse/routes/tags-show","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var buildCategoryRoute = __dependency1__["default"];
    var buildTopicRoute = __dependency2__["default"];
    var DiscoverySortableController = __dependency3__["default"];
    var TagsShowRoute = __dependency4__["default"];

    __exports__["default"] = {
      after: 'inject-discourse-objects',
      name: 'dynamic-route-builders',

      initialize: function (registry, app) {
        app.DiscoveryCategoryController = DiscoverySortableController.extend();
        app.DiscoveryParentCategoryController = DiscoverySortableController.extend();
        app.DiscoveryCategoryNoneController = DiscoverySortableController.extend();
        app.DiscoveryCategoryWithIDController = DiscoverySortableController.extend();

        app.DiscoveryCategoryRoute = buildCategoryRoute('latest');
        app.DiscoveryParentCategoryRoute = buildCategoryRoute('latest');
        app.DiscoveryCategoryNoneRoute = buildCategoryRoute('latest', { no_subcategories: true });

        var site = Discourse.Site.current();
        site.get('filters').forEach(function (filter) {
          var filterCapitalized = filter.capitalize();
          app['Discovery' + filterCapitalized + 'Controller'] = DiscoverySortableController.extend();
          app['Discovery' + filterCapitalized + 'CategoryController'] = DiscoverySortableController.extend();
          app['Discovery' + filterCapitalized + 'ParentCategoryController'] = DiscoverySortableController.extend();
          app['Discovery' + filterCapitalized + 'CategoryNoneController'] = DiscoverySortableController.extend();
          app['Discovery' + filterCapitalized + 'Route'] = buildTopicRoute(filter);
          app['Discovery' + filterCapitalized + 'CategoryRoute'] = buildCategoryRoute(filter);
          app['Discovery' + filterCapitalized + 'ParentCategoryRoute'] = buildCategoryRoute(filter);
          app['Discovery' + filterCapitalized + 'CategoryNoneRoute'] = buildCategoryRoute(filter, { no_subcategories: true });
        });

        Discourse.DiscoveryTopController = DiscoverySortableController.extend();
        Discourse.DiscoveryTopCategoryController = DiscoverySortableController.extend();
        Discourse.DiscoveryTopParentCategoryController = DiscoverySortableController.extend();
        Discourse.DiscoveryTopCategoryNoneController = DiscoverySortableController.extend();

        Discourse.DiscoveryTopRoute = buildTopicRoute('top', {
          actions: {
            willTransition: function () {
              Discourse.User.currentProp("should_be_redirected_to_top", false);
              Discourse.User.currentProp("redirected_to_top.reason", null);
              return this._super();
            }
          }
        });
        Discourse.DiscoveryTopCategoryRoute = buildCategoryRoute('top');
        Discourse.DiscoveryTopParentCategoryRoute = buildCategoryRoute('top');
        Discourse.DiscoveryTopCategoryNoneRoute = buildCategoryRoute('top', { no_subcategories: true });

        site.get('periods').forEach(function (period) {
          var periodCapitalized = period.capitalize();
          app['DiscoveryTop' + periodCapitalized + 'Controller'] = DiscoverySortableController.extend();
          app['DiscoveryTop' + periodCapitalized + 'CategoryController'] = DiscoverySortableController.extend();
          app['DiscoveryTop' + periodCapitalized + 'ParentCategoryController'] = DiscoverySortableController.extend();
          app['DiscoveryTop' + periodCapitalized + 'CategoryNoneController'] = DiscoverySortableController.extend();
          app['DiscoveryTop' + periodCapitalized + 'Route'] = buildTopicRoute('top/' + period);
          app['DiscoveryTop' + periodCapitalized + 'CategoryRoute'] = buildCategoryRoute('top/' + period);
          app['DiscoveryTop' + periodCapitalized + 'ParentCategoryRoute'] = buildCategoryRoute('top/' + period);
          app['DiscoveryTop' + periodCapitalized + 'CategoryNoneRoute'] = buildCategoryRoute('top/' + period, { no_subcategories: true });
        });

        app["TagsShowCategoryRoute"] = TagsShowRoute.extend();
        app["TagsShowParentCategoryRoute"] = TagsShowRoute.extend();

        site.get('filters').forEach(function (filter) {
          app["TagsShow" + filter.capitalize() + "Route"] = TagsShowRoute.extend({ filterMode: filter });
          app["TagsShowCategory" + filter.capitalize() + "Route"] = TagsShowRoute.extend({ filterMode: filter });
          app["TagsShowParentCategory" + filter.capitalize() + "Route"] = TagsShowRoute.extend({ filterMode: filter });
        });
      }
    };
  });
define("discourse/pre-initializers/inject-discourse-objects", 
  ["discourse/models/session","discourse/lib/key-value-store","discourse/lib/app-events","discourse/models/store","discourse/lib/url","discourse/lib/discourse-location","discourse/services/search","discourse/models/topic-tracking-state","discourse/lib/screen-track","discourse/components/topic-footer-buttons","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __dependency9__, __dependency10__, __exports__) {
    "use strict";
    var Session = __dependency1__["default"];
    var KeyValueStore = __dependency2__["default"];
    var AppEvents = __dependency3__["default"];
    var Store = __dependency4__["default"];
    var DiscourseURL = __dependency5__["default"];
    var DiscourseLocation = __dependency6__["default"];
    var SearchService = __dependency7__["default"];
    var startTracking = __dependency8__.startTracking;
    var TopicTrackingState = __dependency8__.default;
    var ScreenTrack = __dependency9__["default"];
    var TopicFooterButtons = __dependency10__["default"];

    function inject() {
      var app = arguments[0],
          name = arguments[1],
          singletonName = Ember.String.underscore(name).replace(/_/g, '-') + ':main';

      Array.prototype.slice.call(arguments, 2).forEach(function (dest) {
        return app.inject(dest, name, singletonName);
      });
    }

    function injectAll(app, name) {
      inject(app, name, 'controller', 'component', 'route', 'view', 'model', 'adapter');
    }

    __exports__["default"] = {
      name: "inject-discourse-objects",

      initialize: function (container, app) {
        var appEvents = AppEvents.create();
        app.register('app-events:main', appEvents, { instantiate: false });
        injectAll(app, 'appEvents');
        DiscourseURL.appEvents = appEvents;

        app.register('store:main', Store);
        inject(app, 'store', 'route', 'controller');

        var messageBus = window.MessageBus;
        app.register('message-bus:main', messageBus, { instantiate: false });
        injectAll(app, 'messageBus');

        var currentUser = Discourse.User.current();
        app.register('current-user:main', currentUser, { instantiate: false });

        var topicTrackingState = TopicTrackingState.create({ messageBus: messageBus, currentUser: currentUser });
        app.register('topic-tracking-state:main', topicTrackingState, { instantiate: false });
        injectAll(app, 'topicTrackingState');

        var site = Discourse.Site.current();
        app.register('site:main', site, { instantiate: false });
        injectAll(app, 'site');

        var siteSettings = Discourse.SiteSettings;
        app.register('site-settings:main', siteSettings, { instantiate: false });
        injectAll(app, 'siteSettings');

        app.register('search-service:main', SearchService);
        injectAll(app, 'searchService');

        var session = Session.current();
        app.register('session:main', session, { instantiate: false });
        injectAll(app, 'session');

        var screenTrack = new ScreenTrack(topicTrackingState, siteSettings, session, currentUser);
        app.register('screen-track:main', screenTrack, { instantiate: false });
        inject(app, 'screenTrack', 'component', 'route');

        inject(app, 'currentUser', 'component', 'route', 'controller');

        app.register('location:discourse-location', DiscourseLocation);

        var keyValueStore = new KeyValueStore("discourse_");
        app.register('key-value-store:main', keyValueStore, { instantiate: false });
        injectAll(app, 'keyValueStore');

        Discourse.TopicFooterButtonsView = {
          reopen: function (obj) {
            Ember.warn('`Discourse.TopicFooterButtonsView` is deprecated. Use the `topic-footer-buttons` component instead');
            TopicFooterButtons.reopen(obj);
          }
        };

        startTracking(topicTrackingState);
      }
    };
  });
define("discourse/pre-initializers/map-routes", 
  ["discourse/router","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var mapRoutes = __dependency1__.mapRoutes;

    __exports__["default"] = {
      name: "map-routes",
      after: 'inject-discourse-objects',

      initialize: function (container, app) {
        app.register('router:main', mapRoutes());

        // HACK to fix: https://github.com/emberjs/ember.js/issues/10310
        var originalBuildInstance = originalBuildInstance || Ember.Application.prototype.buildInstance;
        Ember.Application.prototype.buildInstance = function () {
          this.registry = this.buildRegistry();
          return originalBuildInstance.apply(this);
        };
      }
    };
  });
define("discourse/pre-initializers/register-dom-templates", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: "register-discourse-dom-templates",
      before: 'domTemplates',

      initialize: function () {
        $('script[type="text/x-handlebars"]').each(function () {
          var $this = $(this);
          var name = $this.attr("name") || $this.data("template-name");

          if (window.console) {
            window.console.log("WARNING: you have a handlebars template named " + name + " this is an unsupported setup, precompile your templates");
          }
          $this.remove();
        });
      }
    };
  });
define("discourse/pre-initializers/sniff-capabilities", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /*global Modernizr:true*/

    // Initializes an object that lets us know about our capabilities.
    __exports__["default"] = {
      name: "sniff-capabilities",
      initialize: function (container, application) {
        var $html = $('html'),
            touch = $html.hasClass('touch') || Modernizr.prefixed("MaxTouchPoints", navigator) > 1,
            caps = { touch: touch };

        // Store the touch ability in our capabilities object
        $html.addClass(touch ? 'discourse-touch' : 'discourse-no-touch');

        // Detect Devices
        if (navigator) {
          var ua = navigator.userAgent;
          if (ua) {
            caps.isAndroid = ua.indexOf('Android') !== -1;
            caps.isWinphone = ua.indexOf('Windows Phone') !== -1;

            caps.isOpera = !!window.opera || ua.indexOf(' OPR/') >= 0;
            caps.isFirefox = typeof InstallTrigger !== 'undefined';
            caps.isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
            caps.isChrome = !!window.chrome && !caps.isOpera;
            caps.canPasteImages = caps.isChrome || caps.isFirefox;
          }

          caps.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }

        // We consider high res a device with 1280 horizontal pixels. High DPI tablets like
        // iPads should report as 1024.
        caps.highRes = window.screen.width >= 1280;

        // Inject it
        application.register('capabilities:main', caps, { instantiate: false });
        application.inject('view', 'capabilities', 'capabilities:main');
        application.inject('controller', 'capabilities', 'capabilities:main');
        application.inject('component', 'capabilities', 'capabilities:main');
      }
    };
  });
define("discourse/initializers/android-app-banner-service-worker", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Android Chrome App Banner requires at least **one** service worker to be instantiate and https.
    // After Discourse starts to use service workers for other stuff (like mobile notification, offline mode, or ember)
    // we can ditch this.

    __exports__["default"] = {
      name: 'android-app-banner-service-worker',

      initialize: function (container) {
        var caps = container.lookup('capabilities:main');
        var isSecure = document.location.protocol === 'https:';

        if (isSecure && caps.isAndroid && 'serviceWorker' in navigator) {
          navigator.serviceWorker.register(Discourse.BaseUri + '/service-worker.js', { scope: './' });
        }
      }
    };
  });
define("discourse/initializers/apply-flagged-properties", 
  ["discourse/components/site-header","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var applyFlaggedProperties = __dependency1__.applyFlaggedProperties;

    __exports__["default"] = {
      name: 'apply-flagged-properties',
      initialize: applyFlaggedProperties
    };
  });
define("discourse/initializers/asset-version", 
  ["exports"],
  function(__exports__) {
    "use strict";
    //  Subscribe to "asset-version" change events via the Message Bus
    __exports__["default"] = {
      name: "asset-version",
      after: "message-bus",

      initialize: function (container) {
        var timeoutIsSet = false;
        var messageBus = container.lookup('message-bus:main');
        if (!messageBus) {
          return;
        }

        messageBus.subscribe("/global/asset-version", function (version) {
          Discourse.set("assetVersion", version);

          if (!timeoutIsSet && Discourse.get("requiresRefresh")) {
            // since we can do this transparently for people browsing the forum
            //  hold back the message a couple of hours
            setTimeout(function () {
              bootbox.confirm(I18n.lookup("assets_changed_confirm"), function (result) {
                if (result) {
                  document.location.reload();
                }
              });
            }, 1000 * 60 * 120);
            timeoutIsSet = true;
          }
        });
      }
    };
  });
define("discourse/initializers/auto-load-modules", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__.autoLoadModules = autoLoadModules;

    function autoLoadModules() {
      Object.keys(requirejs.entries).forEach(function (entry) {
        if (/\/helpers\//.test(entry)) {
          require(entry, null, null, true);
        }
        if (/\/widgets\//.test(entry)) {
          require(entry, null, null, true);
        }
      });
    }

    __exports__["default"] = {
      name: 'auto-load-modules',
      initialize: autoLoadModules
    };
  });
define("discourse/initializers/banner", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: "banner",
      after: "message-bus",

      initialize: function (container) {

        var banner = Em.Object.create(PreloadStore.get("banner")),
            site = container.lookup('site:main');

        site.set("banner", banner);

        var messageBus = container.lookup('message-bus:main');
        if (!messageBus) {
          return;
        }

        messageBus.subscribe("/site/banner", function (ban) {
          site.set("banner", Em.Object.create(ban));
        });
      }
    };
  });
define("discourse/initializers/click-interceptor", 
  ["discourse/lib/intercept-click","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var interceptClick = __dependency1__["default"];
    var DiscourseURL = __dependency2__["default"];

    __exports__["default"] = {
      name: "click-interceptor",
      initialize: function () {
        $('#main').on('click.discourse', 'a', interceptClick);
        $(window).on('hashchange', function () {
          return DiscourseURL.routeTo(document.location.hash);
        });
      }
    };
  });
define("discourse/initializers/csrf-token", 
  ["exports"],
  function(__exports__) {
    "use strict";
    //  Append our CSRF token to AJAX requests when necessary.
    __exports__["default"] = {
      name: "csrf-token",
      initialize: function (container) {

        var session = container.lookup('session:main');

        // Add a CSRF token to all AJAX requests
        session.set('csrfToken', $('meta[name=csrf-token]').attr('content'));

        $.ajaxPrefilter(function (options, originalOptions, xhr) {
          if (!options.crossDomain) {
            xhr.setRequestHeader('X-CSRF-Token', session.get('csrfToken'));
          }
        });
      }
    };
  });
define("discourse/initializers/ember-events", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: "ember-events",

      initialize: function () {

        // By default Ember listens to too many events. This tells it the only events
        // we're interested in.
        Ember.EventDispatcher.reopen({
          events: {
            touchstart: 'touchStart',
            touchend: 'touchEnd',
            touchcancel: 'touchCancel',
            keydown: 'keyDown',
            keyup: 'keyUp',
            keypress: 'keyPress',
            mousedown: 'mouseDown',
            mouseup: 'mouseUp',
            contextmenu: 'contextMenu',
            click: 'click',
            dblclick: 'doubleClick',
            focusin: 'focusIn',
            focusout: 'focusOut',
            mouseenter: 'mouseEnter',
            mouseleave: 'mouseLeave',
            submit: 'submit',
            input: 'input',
            change: 'change',
            dragstart: 'dragStart',
            drag: 'drag',
            dragenter: 'dragEnter',
            dragleave: 'dragLeave',
            dragover: 'dragOver',
            drop: 'drop',
            dragend: 'dragEnd'
          }
        });
      }
    };
  });
define("discourse/initializers/enable-emoji", 
  ["discourse/lib/plugin-api","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var withPluginApi = __dependency1__.withPluginApi;

    __exports__["default"] = {
      name: 'enable-emoji',

      initialize: function (container) {
        var siteSettings = container.lookup('site-settings:main');

        if (siteSettings.enable_emoji) {
          withPluginApi('0.1', function (api) {
            api.onToolbarCreate(function (toolbar) {
              toolbar.addButton({
                id: 'emoji',
                group: 'extras',
                icon: 'smile-o',
                action: 'emoji',
                title: 'composer.emoji'
              });
            });
          });

          // enable plugin emojis
          Discourse.Emoji.applyCustomEmojis();
        }
      }
    };
  });
define("discourse/initializers/ensure-max-image-dimensions", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: 'ensure-image-dimensions',
      after: 'mobile',
      initialize: function (container) {
        if (!window) {
          return;
        }

        // This enforces maximum dimensions of images based on site settings
        // for mobile we use the window width as a safeguard
        // This rule should never really be at play unless for some reason images do not have dimensions

        var width = Discourse.SiteSettings.max_image_width;
        var height = Discourse.SiteSettings.max_image_height;

        var site = container.lookup('site:main');
        if (site.mobileView) {
          width = $(window).width() - 20;
        }

        var style = 'max-width:' + width + 'px;' + 'max-height:' + height + 'px;';

        $('<style id="image-sizing-hack">#reply-control .d-editor-preview img:not(.thumbnail), .cooked img:not(.thumbnail) {' + style + '}</style>').appendTo('head');
      }
    };
  });
define("discourse/initializers/focus-event", 
  ["exports"],
  function(__exports__) {
    "use strict";
    /**
      Keep track of when the browser is in focus.
    **/

    __exports__["default"] = {
      name: 'focus-event',

      initialize: function () {
        var hidden = "hidden";

        // Default to true
        Discourse.set('hasFocus', true);

        var gotFocus = function () {
          if (!Discourse.get('hasFocus')) {
            Discourse.setProperties({ hasFocus: true, notify: false });
          }
        };

        var lostFocus = function () {
          if (Discourse.get('hasFocus')) {
            Discourse.set('hasFocus', false);
          }
        };

        var onchange = function (evt) {
          var v = 'visible',
              h = 'hidden',
              evtMap = {
            focus: v, focusin: v, pageshow: v, blur: h, focusout: h, pagehide: h
          };

          evt = evt || window.event;
          if (evt.type in evtMap) {
            if (evtMap[evt.type] === 'hidden') {
              lostFocus();
            } else {
              gotFocus();
            }
          } else {
            if (this[hidden]) {
              lostFocus();
            } else {
              gotFocus();
            }
          }
        };

        // from StackOverflow http://stackoverflow.com/a/1060034/17174
        if (hidden in document) {
          document.addEventListener('visibilitychange', onchange);
        } else if ((hidden = 'mozHidden') in document) {
          document.addEventListener('mozvisibilitychange', onchange);
        } else if ((hidden = 'webkitHidden') in document) {
          document.addEventListener('webkitvisibilitychange', onchange);
        } else if ((hidden = 'msHidden') in document) {
          document.addEventListener('msvisibilitychange', onchange);
        }
        // All others (including iPad which is a bit weird and gives onpageshow / hide
        else {
            window.onpageshow = window.onpagehide = window.onfocus = window.onblur = onchange;
          }
      }
    };
  });
define("discourse/initializers/inject-objects", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // backwards compatibility for plugins that depend on this initializer

    __exports__["default"] = {
      name: "inject-objects",
      initialize: Ember.K
    };
  });
define("discourse/initializers/jquery-plugins", 
  ["discourse/lib/autocomplete","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var autocomplete = __dependency1__["default"];

    __exports__["default"] = {
      name: "jquery-plugins",
      initialize: function () {

        // Settings for bootbox
        bootbox.animate(false);
        bootbox.backdrop(true);

        // Initialize the autocomplete tool
        $.fn.autocomplete = autocomplete;
      }
    };
  });
define("discourse/initializers/keyboard-shortcuts", 
  ["discourse/lib/keyboard-shortcuts","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    /*global Mousetrap:true*/

    var KeyboardShortcuts = __dependency1__["default"];

    __exports__["default"] = {
      name: "keyboard-shortcuts",

      initialize: function (container) {
        KeyboardShortcuts.bindEvents(Mousetrap, container);
      }
    };
  });
define("discourse/initializers/live-development", 
  ["discourse/lib/load-script","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var loadScript = __dependency1__["default"];

    //  Use the message bus for live reloading of components for faster development.
    __exports__["default"] = {
      name: "live-development",
      initialize: function (container) {
        var messageBus = container.lookup('message-bus:main');

        // subscribe to any site customizations that are loaded
        $('link.custom-css').each(function () {
          var split = this.href.split("/"),
              id = split[split.length - 1].split(".css")[0],
              self = this;

          return messageBus.subscribe("/file-change/" + id, function (data) {
            if (!$(self).data('orig')) {
              $(self).data('orig', self.href);
            }
            var orig = $(self).data('orig');

            self.href = orig.replace(/v=.*/, "v=" + data);
          });
        });

        // Custom header changes
        $('header.custom').each(function () {
          var header = $(this);
          return messageBus.subscribe("/header-change/" + $(this).data('key'), function (data) {
            return header.html(data);
          });
        });

        // Observe file changes
        messageBus.subscribe("/file-change", function (data) {
          if (Handlebars.compile && !Ember.TEMPLATES.empty) {
            // hbs notifications only happen in dev
            Ember.TEMPLATES.empty = Handlebars.compile("<div></div>");
          }
          _.each(data, function (me) {

            if (me === "refresh") {
              // Refresh if necessary
              document.location.reload(true);
            } else if (me.name.substr(-10) === "hbs") {
              (function () {

                // Reload handlebars
                var js = me.name.replace(".hbs", "").replace("app/assets/javascripts", "/assets");
                loadScript(js + "?hash=" + me.hash).then(function () {
                  var templateName = js.replace(".js", "").replace("/assets/", "");
                  return _.each(Ember.View.views, function (view) {
                    if (view.get('templateName') === templateName) {
                      view.set('templateName', 'empty');
                      view.rerender();
                      Em.run.schedule('afterRender', function () {
                        view.set('templateName', templateName);
                        view.rerender();
                      });
                    }
                  });
                });
              })();
            } else {
              $('link').each(function () {
                // TODO: stop bundling css in DEV please
                if (true || this.href.match(me.name) && me.hash) {
                  if (!$(this).data('orig')) {
                    $(this).data('orig', this.href);
                  }
                  var orig = $(this).data('orig');
                  if (!me.hash) {
                    window.__uniq = window.__uniq || 1;
                    me.hash = window.__uniq++;
                  }
                  this.href = orig + (orig.indexOf('?') >= 0 ? "&hash=" : "?hash=") + me.hash;
                }
              });
            }
          });
        });
      }
    };
  });
define("discourse/initializers/localization", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: 'localization',
      after: 'inject-objects',

      initialize: function (container) {
        var siteSettings = container.lookup('site-settings:main');
        if (siteSettings.verbose_localization) {
          I18n.enable_verbose_localization();
        }

        // Merge any overrides into our object
        var overrides = PreloadStore.get('translationOverrides') || {};
        Object.keys(overrides).forEach(function (k) {
          var v = overrides[k];

          // Special case: Message format keys are functions
          if (/\_MF$/.test(k)) {
            k = k.replace(/^[a-z_]*js\./, '');
            I18n._compiledMFs[k] = new Function('transKey', 'return (' + v + ')(transKey);');

            return;
          }

          k = k.replace('admin_js', 'js');
          var segs = k.split('.');
          var node = I18n.translations[I18n.locale];
          var i = 0;
          for (; node && i < segs.length - 1; i++) {
            node = node[segs[i]];
          }

          if (node && i === segs.length - 1) {
            node[segs[segs.length - 1]] = v;
          }
        });
      }
    };
  });
define("discourse/initializers/logout", 
  ["discourse/lib/logout","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var logout = __dependency1__["default"];

    //  Subscribe to "logout" change events via the Message Bus
    __exports__["default"] = {
      name: "logout",
      after: "message-bus",

      initialize: function (container) {
        var messageBus = container.lookup('message-bus:main');
        var siteSettings = container.lookup('site-settings:main');
        var keyValueStore = container.lookup('key-value-store:main');

        if (!messageBus) {
          return;
        }
        var callback = function () {
          return logout(siteSettings, keyValueStore);
        };

        messageBus.subscribe("/logout", function () {
          bootbox.dialog(I18n.t("logout"), { label: I18n.t("refresh"), callback: callback }, { onEscape: callback, backdrop: 'static' });
        });
      }
    };
  });
define("discourse/initializers/logs-notice", 
  ["discourse/services/logs-notice","discourse/mixins/singleton","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var LogsNotice = __dependency1__["default"];
    var Singleton = __dependency2__["default"];

    __exports__["default"] = {
      name: "logs-notice",
      after: "message-bus",

      initialize: function (container) {
        var siteSettings = container.lookup('site-settings:main');
        var messageBus = container.lookup('message-bus:main');
        var keyValueStore = container.lookup('key-value-store:main');
        var currentUser = container.lookup('current-user:main');
        LogsNotice.reopenClass(Singleton, {
          createCurrent: function () {
            return this.create({ messageBus: messageBus, keyValueStore: keyValueStore, siteSettings: siteSettings, currentUser: currentUser });
          }
        });
      }
    };
  });
define("discourse/initializers/message-bus", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Initialize the message bus to receive messages.
    __exports__["default"] = {
      name: "message-bus",
      after: 'inject-objects',

      initialize: function (container) {
        // We don't use the message bus in testing
        if (Discourse.testing) {
          return;
        }

        var messageBus = container.lookup('message-bus:main'),
            user = container.lookup('current-user:main'),
            siteSettings = container.lookup('site-settings:main');

        messageBus.alwaysLongPoll = Discourse.Environment === "development";

        // we do not want to start anything till document is complete
        messageBus.stop();
        // jQuery ready is called on "interactive" we want "complete"
        // Possibly change to document.addEventListener('readystatechange',...
        // but would only stop a handful of interval, message bus being delayed by
        // 500ms on load is fine. stuff that needs to catch up correctly should
        // pass in a position
        var interval = setInterval(function () {
          if (document.readyState === "complete") {
            clearInterval(interval);
            messageBus.start();
          }
        }, 500);

        messageBus.callbackInterval = siteSettings.anon_polling_interval;
        messageBus.backgroundCallbackInterval = siteSettings.background_polling_interval;
        messageBus.baseUrl = siteSettings.long_polling_base_url;

        if (messageBus.baseUrl !== '/') {
          // zepto compatible, 1 param only
          messageBus.ajax = function (opts) {
            opts.headers = opts.headers || {};
            opts.headers['X-Shared-Session-Key'] = $('meta[name=shared_session_key]').attr('content');
            return $.ajax(opts);
          };
        } else {
          messageBus.baseUrl = Discourse.getURL('/');
        }

        if (user) {
          messageBus.callbackInterval = siteSettings.polling_interval;
          messageBus.enableLongPolling = true;
        }
      }
    };
  });
define("discourse/initializers/mobile", 
  ["discourse/lib/mobile","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Mobile = __dependency1__["default"];

    // Initializes the `Mobile` helper object.
    __exports__["default"] = {
      name: 'mobile',
      after: 'inject-objects',

      initialize: function (container, app) {
        Mobile.init();
        var site = container.lookup('site:main');

        site.set('mobileView', Mobile.mobileView);
        site.set('isMobileDevice', Mobile.isMobileDevice);

        // This is a bit weird but you can't seem to inject into the resolver?
        app.registry.resolver.__resolver__.mobileView = Mobile.mobileView;
      }
    };
  });
define("discourse/initializers/page-tracking", 
  ["discourse/routes/discourse","discourse/lib/page-tracker","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var cleanDOM = __dependency1__.cleanDOM;
    var startPageTracking = __dependency2__.startPageTracking;
    var onPageChange = __dependency2__.onPageChange;

    __exports__["default"] = {
      name: "page-tracking",

      initialize: function (container) {

        var cache = {};
        var transitionCount = 0;

        // Tell our AJAX system to track a page transition
        var router = container.lookup('router:main');
        router.on('willTransition', function () {
          Discourse.viewTrackingRequired();
        });

        router.on('didTransition', function () {
          Em.run.scheduleOnce('afterRender', Ember.Route, cleanDOM);
          transitionCount++;
          _.each(cache, function (v, k) {
            if (v && v.target && v.target < transitionCount) {
              delete cache[k];
            }
          });
        });

        router.transientCache = function (key, data, count) {
          if (data === undefined) {
            return cache[key];
          } else {
            return cache[key] = { data: data, target: transitionCount + count };
          }
        };

        startPageTracking(router);

        // Out of the box, Discourse tries to track google analytics
        // if it is present
        if (typeof window._gaq !== 'undefined') {
          onPageChange(function (url, title) {
            window._gaq.push(["_set", "title", title]);
            window._gaq.push(['_trackPageview', url]);
          });
          return;
        }

        // Also use Universal Analytics if it is present
        if (typeof window.ga !== 'undefined') {
          onPageChange(function (url, title) {
            window.ga('send', 'pageview', { page: url, title: title });
          });
        }
      }
    };
  });
define("discourse/initializers/post-decorations", 
  ["discourse/lib/highlight-syntax","discourse/lib/lightbox","discourse/lib/plugin-api","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var highlightSyntax = __dependency1__["default"];
    var lightbox = __dependency2__["default"];
    var withPluginApi = __dependency3__.withPluginApi;

    __exports__["default"] = {
      name: "post-decorations",
      initialize: function () {
        withPluginApi('0.1', function (api) {
          api.decorateCooked(highlightSyntax);
          api.decorateCooked(lightbox);
        });
      }
    };
  });
define("discourse/initializers/read-only", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // Subscribe to "read-only" status change events via the Message Bus
    __exports__["default"] = {
      name: "read-only",
      after: "message-bus",

      initialize: function (container) {
        var messageBus = container.lookup('message-bus:main');
        if (!messageBus) {
          return;
        }

        var site = container.lookup('site:main');
        messageBus.subscribe("/site/read-only", function (enabled) {
          site.set('isReadOnly', enabled);
        });
      }
    };
  });
define("discourse/initializers/register-discourse-location", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // backwards compatibility for plugins that depend on this initializer

    __exports__["default"] = {
      name: "register-discourse-location",
      initialize: Ember.K
    };
  });
define("discourse/initializers/relative-ages", 
  ["discourse/lib/formatter","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var updateRelativeAge = __dependency1__.updateRelativeAge;

    // Updates the relative ages of dates on the screen.
    __exports__["default"] = {
      name: "relative-ages",
      initialize: function () {
        setInterval(function () {
          updateRelativeAge($('.relative-date'));
        }, 60 * 1000);
      }
    };
  });
define("discourse/initializers/sharing-sources", 
  ["discourse/lib/sharing","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Sharing = __dependency1__["default"];

    __exports__["default"] = {
      name: 'sharing-sources',

      initialize: function () {
        Sharing.addSource({
          id: 'twitter',
          faIcon: 'fa-twitter-square',
          generateUrl: function (link, title) {
            return "http://twitter.com/intent/tweet?url=" + encodeURIComponent(link) + "&text=" + encodeURIComponent(title);
          },
          shouldOpenInPopup: true,
          title: I18n.t('share.twitter'),
          popupHeight: 265
        });

        Sharing.addSource({
          id: 'facebook',
          faIcon: 'fa-facebook-square',
          title: I18n.t('share.facebook'),
          generateUrl: function (link, title) {
            return "http://www.facebook.com/sharer.php?u=" + encodeURIComponent(link) + '&t=' + encodeURIComponent(title);
          },
          shouldOpenInPopup: true
        });

        Sharing.addSource({
          id: 'google+',
          faIcon: 'fa-google-plus-square',
          title: I18n.t('share.google+'),
          generateUrl: function (link) {
            return "https://plus.google.com/share?url=" + encodeURIComponent(link);
          },
          shouldOpenInPopup: true,
          popupHeight: 600
        });

        Sharing.addSource({
          id: 'email',
          faIcon: 'fa-envelope-square',
          title: I18n.t('share.email'),
          generateUrl: function (link, title) {
            return "mailto:?to=&subject=" + encodeURIComponent('[' + Discourse.SiteSettings.title + '] ' + title) + "&body=" + encodeURIComponent(link);
          }
        });
      }
    };
  });
define("discourse/initializers/show-footer", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: "show-footer",

      initialize: function (container) {
        var router = container.lookup("router:main");
        var application = container.lookup("controller:application");

        // only take care of hiding the footer here
        // controllers MUST take care of displaying it
        router.on("willTransition", function () {
          application.set("showFooter", false);
          return true;
        });
      }
    };
  });
define("discourse/initializers/signup-cta", 
  ["discourse/models/session","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var Session = __dependency1__["default"];

    var ANON_TOPIC_IDS = 2;
    var ANON_PROMPT_READ_TIME = 2 * 60 * 1000;
    var ONE_DAY = 24 * 60 * 60 * 1000;
    var PROMPT_HIDE_DURATION = ONE_DAY;

    __exports__["default"] = {
      name: "signup-cta",

      initialize: function (container) {
        var screenTrack = container.lookup('screen-track:main');
        var session = Session.current();
        var siteSettings = container.lookup('site-settings:main');
        var keyValueStore = container.lookup('key-value-store:main');
        var user = container.lookup('current-user:main');

        screenTrack.keyValueStore = keyValueStore;

        // Preconditions
        if (user) return; // must not be logged in
        if (keyValueStore.get('anon-cta-never')) return; // "never show again"
        if (!siteSettings.allow_new_registrations) return;
        if (siteSettings.invite_only) return;
        if (siteSettings.must_approve_users) return;
        if (siteSettings.login_required) return;
        if (!siteSettings.enable_signup_cta) return;

        function checkSignupCtaRequirements() {
          if (session.get('showSignupCta')) {
            return; // already shown
          }

          if (session.get('hideSignupCta')) {
            return; // hidden for session
          }

          if (keyValueStore.get('anon-cta-never')) {
            return; // hidden forever
          }

          var now = new Date().getTime();
          var hiddenAt = keyValueStore.getInt('anon-cta-hidden', 0);
          if (hiddenAt > now - PROMPT_HIDE_DURATION) {
            return; // hidden in last 24 hours
          }

          var readTime = keyValueStore.getInt('anon-topic-time');
          if (readTime < ANON_PROMPT_READ_TIME) {
            return;
          }

          var topicIdsString = keyValueStore.get('anon-topic-ids');
          if (!topicIdsString) {
            return;
          }
          var topicIdsAry = topicIdsString.split(',');
          if (topicIdsAry.length < ANON_TOPIC_IDS) {
            return;
          }

          // Requirements met.
          session.set('showSignupCta', true);
        }

        screenTrack.registerAnonCallback(checkSignupCtaRequirements);

        checkSignupCtaRequirements();
      }
    };
  });
define("discourse/initializers/subscribe-user-notifications", 
  ["discourse/lib/desktop-notifications","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    // Subscribes to user events on the message bus
    var initDesktopNotifications = __dependency1__.init;
    var onNotification = __dependency1__.onNotification;

    __exports__["default"] = {
      name: 'subscribe-user-notifications',
      after: 'message-bus',
      initialize: function (container) {
        var user = container.lookup('current-user:main'),
            site = container.lookup('site:main'),
            siteSettings = container.lookup('site-settings:main'),
            bus = container.lookup('message-bus:main'),
            keyValueStore = container.lookup('key-value-store:main'),
            store = container.lookup('store:main'),
            appEvents = container.lookup('app-events:main');

        // clear old cached notifications, we used to store in local storage
        // TODO 2017 delete this line
        keyValueStore.remove('recent-notifications');

        if (user) {

          if (user.get('staff')) {
            bus.subscribe('/flagged_counts', function (data) {
              user.set('site_flagged_posts_count', data.total);
            });
            bus.subscribe('/queue_counts', function (data) {
              user.set('post_queue_new_count', data.post_queue_new_count);
              if (data.post_queue_new_count > 0) {
                user.set('show_queued_posts', 1);
              }
            });
          }

          bus.subscribe('/notification/' + user.get('id'), function (data) {
            var oldUnread = user.get('unread_notifications');
            var oldPM = user.get('unread_private_messages');

            user.set('unread_notifications', data.unread_notifications);
            user.set('unread_private_messages', data.unread_private_messages);

            if (oldUnread !== data.unread_notifications || oldPM !== data.unread_private_messages) {
              appEvents.trigger('notifications:changed');
            }

            var stale = store.findStale('notification', {}, { cacheKey: 'recent-notifications' });
            var lastNotification = data.last_notification && data.last_notification.notification;

            if (stale && stale.hasResults && lastNotification) {

              var oldNotifications = stale.results.get('content');
              var staleIndex = _.findIndex(oldNotifications, { id: lastNotification.id });

              if (staleIndex === -1) {
                // this gets a bit tricky, uread pms are bumped to front
                var insertPosition = 0;
                if (lastNotification.notification_type !== 6) {
                  insertPosition = _.findIndex(oldNotifications, function (n) {
                    return n.notification_type !== 6 || n.read;
                  });
                  insertPosition = insertPosition === -1 ? oldNotifications.length - 1 : insertPosition;
                }

                oldNotifications.insertAt(insertPosition, Em.Object.create(lastNotification));
              }

              for (var idx = 0; idx < data.recent.length; idx++) {
                var old;
                while (old = oldNotifications[idx]) {
                  var info = data.recent[idx];

                  if (old.get('id') !== info[0]) {
                    oldNotifications.removeAt(idx);
                  } else {
                    if (old.get('read') !== info[1]) {
                      old.set('read', info[1]);
                    }
                    break;
                  }
                }
                if (!old) {
                  break;
                }
              }
            }
          }, user.notification_channel_position);

          bus.subscribe("/categories", function (data) {
            _.each(data.categories, function (c) {
              site.updateCategory(c);
            });
            _.each(data.deleted_categories, function (id) {
              site.removeCategory(id);
            });
          });

          bus.subscribe("/client_settings", function (data) {
            siteSettings[data.name] = data.value;
          });

          if (!Ember.testing) {
            if (!site.mobileView) {
              bus.subscribe("/notification-alert/" + user.get('id'), function (data) {
                onNotification(data, user);
              });

              initDesktopNotifications(bus);
            }
          }
        }
      }
    };
  });
define("discourse/initializers/url-redirects", 
  ["discourse/lib/url","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var DiscourseURL = __dependency1__["default"];

    __exports__["default"] = {
      name: 'url-redirects',
      initialize: function () {

        // URL rewrites (usually due to refactoring)
        DiscourseURL.rewrite(/^\/category\//, "/c/");
        DiscourseURL.rewrite(/^\/group\//, "/groups/");
        DiscourseURL.rewrite(/\/private-messages\/$/, "/messages/");
        DiscourseURL.rewrite(/^\/users\/([^\/]+)\/?$/, "/users/$1/activity");
      }
    };
  });
define("discourse/services/logs-notice", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;
    var observes = __dependency1__.observes;
    var computed = __dependency1__["default"];

    var LOGS_NOTICE_KEY = "logs-notice-text";

    var LogsNotice = Ember.Object.extend(_createDecoratedObject([{
      key: 'text',
      initializer: function () {
        return "";
      }
    }, {
      key: '_setup',
      decorators: [on('init')],
      value: function () {
        var _this = this;

        if (!this.get('isActivated')) return;

        var text = this.keyValueStore.getItem(LOGS_NOTICE_KEY);
        if (text) this.set('text', text);

        this.messageBus.subscribe("/logs_error_rate_exceeded", function (data) {
          var duration = data.duration;
          var rate = data.rate;
          var siteSettingLimit = 0;

          if (duration === 'minute') {
            siteSettingLimit = _this.siteSettings.alert_admins_if_errors_per_minute;
          } else if (duration === 'hour') {
            siteSettingLimit = _this.siteSettings.alert_admins_if_errors_per_hour;
          }

          var translationKey = rate === siteSettingLimit ? 'reached' : 'exceeded';

          _this.set('text', I18n.t('logs_error_rate_notice.' + translationKey, {
            timestamp: moment().format("YYYY-MM-DD H:mm:ss"),
            siteSettingRate: I18n.t('logs_error_rate_notice.rate', { count: siteSettingLimit, duration: duration }),
            rate: I18n.t('logs_error_rate_notice.rate', { count: rate, duration: duration }),
            url: Discourse.getURL('/logs')
          }));
        });
      }
    }, {
      key: 'isEmpty',
      decorators: [computed('text')],
      value: function (text) {
        return Ember.isEmpty(text);
      }
    }, {
      key: 'message',
      decorators: [computed('text')],
      value: function (text) {
        return new Handlebars.SafeString(text);
      }
    }, {
      key: 'isAdmin',
      decorators: [computed('currentUser')],
      value: function (currentUser) {
        return currentUser && currentUser.admin;
      }
    }, {
      key: 'hidden',
      decorators: [computed('isEmpty', 'isAdmin')],
      value: function (isEmpty, isAdmin) {
        return !isAdmin || isEmpty;
      }
    }, {
      key: '_updateKeyValueStore',
      decorators: [observes('text')],
      value: function () {
        this.keyValueStore.setItem(LOGS_NOTICE_KEY, this.get('text'));
      }
    }, {
      key: 'isActivated',
      decorators: [computed('siteSettings.alert_admins_if_errors_per_hour', 'siteSettings.alert_admins_if_errors_per_minute')],
      value: function (errorsPerHour, errorsPerMinute) {
        return errorsPerHour > 0 || errorsPerMinute > 0;
      }
    }]));

    __exports__["default"] = LogsNotice;
  });
define("discourse/services/search", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__.default;
    var observes = __dependency1__.observes;

    __exports__["default"] = Ember.Object.extend(_createDecoratedObject([{
      key: 'searchContextEnabled',
      initializer: function () {
        return false;
      }
    }, {
      key: 'searchContext',
      initializer: function () {
        return null;
      }
    }, {
      key: 'term',
      initializer: function () {
        return null;
      }
    }, {
      key: 'highlightTerm',
      initializer: function () {
        return null;
      }
    }, {
      key: '_sethighlightTerm',
      decorators: [observes('term')],
      value: function () {
        this.set('highlightTerm', this.get('term'));
      }
    }, {
      key: 'contextType',
      decorators: [computed('searchContext')],
      initializer: function () {
        return {
          get: function (searchContext) {
            if (searchContext) {
              return Ember.get(searchContext, 'type');
            }
          },
          set: function (value, searchContext) {
            // a bit hacky, consider cleaning this up, need to work through all observers though
            var context = $.extend({}, searchContext);
            context.type = value;
            this.set('searchContext', context);
            return this.get('searchContext.type');
          }
        };
      }
    }]));
  });
define("discourse/widgets/actions-summary", 
  ["discourse/widgets/widget","discourse/widgets/post","discourse/helpers/fa-icon","virtual-dom","discourse/helpers/node","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    __exports__.avatarAtts = avatarAtts;
    var createWidget = __dependency1__.createWidget;
    var avatarFor = __dependency2__.avatarFor;
    var iconNode = __dependency3__.iconNode;
    var h = __dependency4__.h;
    var dateNode = __dependency5__.dateNode;

    function avatarAtts(user) {
      return { template: user.avatar_template,
        username: user.username,
        post_url: user.post_url,
        url: Discourse.getURL('/users/') + user.username_lower };
    }

    createWidget('small-user-list', {
      tagName: 'div.clearfix',

      buildClasses: function (atts) {
        return atts.listClassName;
      },

      html: function (atts) {
        var _this = this;

        var users = atts.users;
        if (users) {
          var _ret = (function () {
            var currentUser = _this.currentUser;
            if (atts.addSelf && !users.some(function (u) {
              return u.username === currentUser.username;
            })) {
              users = users.concat(avatarAtts(currentUser));
            }

            var description = I18n.t(atts.description, { icons: '' });

            // oddly post_url is on the user
            var postUrl = undefined;
            var icons = users.map(function (u) {
              postUrl = postUrl || u.post_url;
              return avatarFor.call(_this, 'small', u);
            });

            if (postUrl) {
              description = h('a', { attributes: { href: Discourse.getURL(postUrl) } }, description);
            }
            return {
              v: [icons, description, '.']
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
      }
    });

    createWidget('action-link', {
      tagName: 'span.action-link',

      buildClasses: function (attrs) {
        return attrs.className;
      },

      html: function (attrs) {
        return h('a', [attrs.text, '. ']);
      },

      click: function () {
        this.sendWidgetAction(this.attrs.action);
      }
    });

    createWidget('actions-summary-item', {
      tagName: 'div.post-action',
      buildKey: function (attrs) {
        return 'actions-summary-item-' + attrs.id;
      },

      defaultState: function () {
        return { users: [] };
      },

      html: function (attrs, state) {
        var users = state.users;

        var result = [];
        var action = attrs.action;

        if (users.length === 0) {
          result.push(this.attach('action-link', { action: 'whoActed', text: attrs.description }));
        } else {
          result.push(this.attach('small-user-list', { users: users, description: 'post.actions.people.' + action }));
        }

        if (attrs.canUndo) {
          result.push(this.attach('action-link', { action: 'undo', className: 'undo', text: I18n.t('post.actions.undo.' + action) }));
        }

        if (attrs.canDeferFlags) {
          var flagsDesc = I18n.t('post.actions.defer_flags', { count: attrs.count });
          result.push(this.attach('action-link', { action: 'deferFlags', className: 'defer-flags', text: flagsDesc }));
        }

        return result;
      },

      whoActed: function () {
        var attrs = this.attrs;
        var state = this.state;
        return this.store.find('post-action-user', { id: attrs.postId, post_action_type_id: attrs.id }).then(function (users) {
          state.users = users.map(avatarAtts);
        });
      },

      undo: function () {
        this.sendWidgetAction('undoPostAction', this.attrs.id);
      },

      deferFlags: function () {
        this.sendWidgetAction('deferPostActionFlags', this.attrs.id);
      }
    });

    __exports__["default"] = createWidget('actions-summary', {
      tagName: 'section.post-actions',

      html: function (attrs) {
        var _this2 = this;

        var actionsSummary = attrs.actionsSummary || [];
        var body = [];
        actionsSummary.forEach(function (as) {
          body.push(_this2.attach('actions-summary-item', as));
          body.push(h('div.clearfix'));
        });

        if (attrs.deleted_at) {
          body.push(h('div.post-action', [iconNode('trash-o'), ' ', avatarFor.call(this, 'small', {
            template: attrs.deletedByAvatarTemplate,
            username: attrs.deletedByUsername
          }), ' ', dateNode(attrs.deleted_at)]));
        }

        return body;
      }
    });
  });
define("discourse/widgets/button", 
  ["discourse/widgets/widget","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var iconNode = __dependency2__.iconNode;

    __exports__["default"] = createWidget('button', {
      tagName: 'button.widget-button',

      buildClasses: function () {
        if (this.attrs.className) {
          return this.attrs.className;
        }
      },

      buildAttributes: function () {
        var attrs = this.attrs;

        var title = undefined;
        if (attrs.title) {
          title = I18n.t(attrs.title, attrs.titleOptions);
        } else if (attrs.label) {
          title = I18n.t(attrs.label, attrs.labelOptions);
        }

        var attributes = { "aria-label": title, title: title };
        if (attrs.disabled) {
          attributes.disabled = "true";
        }

        if (attrs.data) {
          Object.keys(attrs.data).forEach(function (k) {
            return attributes['data-' + k] = attrs.data[k];
          });
        }

        return attributes;
      },

      html: function (attrs) {
        var contents = [];

        var left = !attrs.iconRight;
        if (attrs.icon && left) {
          contents.push(iconNode(attrs.icon));
        }
        if (attrs.label) {
          contents.push(I18n.t(attrs.label, attrs.labelOptions));
        }
        if (attrs.contents) {
          contents.push(attrs.contents);
        }
        if (attrs.icon && !left) {
          contents.push(iconNode(attrs.icon));
        }

        return contents;
      },

      click: function () {
        var attrs = this.attrs;
        if (attrs.disabled) {
          return;
        }

        $('button.widget-button').removeClass('d-hover').blur();
        return this.sendWidgetAction(attrs.action);
      }
    });
  });
define("discourse/widgets/category-link", 
  ["discourse/widgets/raw-html","discourse/helpers/category-link","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var RawHtml = __dependency1__["default"];
    var categoryBadgeHTML = __dependency2__.categoryBadgeHTML;

    // Right now it's RawHTML. Eventually it should emit nodes

    var CategoryLink = (function (_RawHtml) {
      _inherits(CategoryLink, _RawHtml);

      function CategoryLink(attrs) {
        _classCallCheck(this, CategoryLink);

        attrs.html = categoryBadgeHTML(attrs.category, attrs);
        _get(Object.getPrototypeOf(CategoryLink.prototype), 'constructor', this).call(this, attrs);
      }

      return CategoryLink;
    })(RawHtml);

    __exports__["default"] = CategoryLink;;
  });
define("discourse/widgets/connector", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var Connector = (function () {
      function Connector(widget, opts) {
        _classCallCheck(this, Connector);

        this.widget = widget;
        this.opts = opts;
      }

      _createClass(Connector, [{
        key: 'init',
        value: function init() {
          var $elem = $('<div class=\'widget-connector\'></div>');
          var elem = $elem[0];

          var opts = this.opts;
          var widget = this.widget;

          Ember.run.next(function () {

            var mounted = widget._findView();

            var context = undefined;
            if (opts.context === 'model') {
              var model = widget.findAncestorModel();
              context = model;
            }

            var view = Ember.View.create({
              container: widget.container,
              templateName: opts.templateName,
              context: context
            });
            mounted._connected.push(view);

            view.renderer.replaceIn(view, $elem[0]);
          });

          return elem;
        }
      }, {
        key: 'update',
        value: function update() {}
      }]);

      return Connector;
    })();

    __exports__["default"] = Connector;

    Connector.prototype.type = 'Widget';
  });
define("discourse/widgets/decorator-helper", 
  ["discourse/widgets/connector","virtual-dom","discourse/widgets/post-cooked","discourse/widgets/raw-html","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var Connector = __dependency1__["default"];
    var h = __dependency2__.h;
    var PostCooked = __dependency3__["default"];
    var RawHtml = __dependency4__["default"];

    var DecoratorHelper = (function () {
      function DecoratorHelper(widget, attrs, state) {
        _classCallCheck(this, DecoratorHelper);

        this.widget = widget;
        this.attrs = attrs;
        this.state = state;
        this.container = widget.container;
      }

      /**
       * The `h` helper allows you to build up a virtual dom easily.
       *
       * Example:
       *
       * ```
       * // renders `<div class='some-class'><p>paragraph</p></div>`
       * return helper.h('div.some-class', helper.h('p', 'paragraph'));
       * ```
       * Check out  https://github.com/Matt-Esch/virtual-dom/blob/master/virtual-hyperscript/README.md
       * for more details on how to construct markup with h.
       **/
      // h() is attached via `prototype` below

      /**
       * Attach another widget inside this one.
       *
       * ```
       * return helper.attach('widget-name');
       * ```
       */

      _createClass(DecoratorHelper, [{
        key: 'attach',
        value: function attach(name, attrs, state) {
          attrs = attrs || this.widget.attrs;
          state = state || this.widget.state;

          return this.widget.attach(name, attrs, state);
        }

        /**
         * Returns the model associated with this widget. When decorating
         * posts this will normally be the post.
         *
         * Example:
         *
         * ```
         * const post = helper.getModel();
         * console.log(post.get('id'));
         * ```
         **/
      }, {
        key: 'getModel',
        value: function getModel() {
          return this.widget.findAncestorModel();
        }

        /**
         * If your decorator must produce raw HTML, you can use this helper
         * to display it. It is preferred to use the `h` helper and create
         * the HTML yourself whenever possible.
         *
         * Example:
         *
         * ```
         * return helper.rawHtml(`<p>I will be displayed</p`);
         * ```
         **/
      }, {
        key: 'rawHtml',
        value: function rawHtml(html) {
          return new RawHtml({ html: html });
        }

        /**
         * Renders `cooked` content using all the helpers and decorators that
         * are attached to that. This is useful if you want to render a post's
         * content or a different version of it.
         *
         * Example:
         *
         * ```
         * return helper.cooked(`<p>Cook me</p>`);
         * ```
         **/
      }, {
        key: 'cooked',
        value: function cooked(_cooked) {
          return new PostCooked({ cooked: _cooked });
        }

        /**
         * You can use this bridge to mount an Ember View inside the virtual
         * DOM post stream. Note that this is a bit bizarre, as our core app
         * is rendered in Ember, then we switch to a virtual dom, and this
         * allows part of that virtual dom to use Ember again!
         *
         * It really only exists as backwards compatibility for some old
         * plugins that would be difficult to update otherwise. There are
         * performance reasons not to use this, so be careful and avoid
         * using it whenever possible.
         *
         * Example:
         *
         * ```
         * helper.connect({ templateName: 'my-handlebars-template' });
         * ```
         **/
      }, {
        key: 'connect',
        value: function connect(details) {
          return new Connector(this.widget, details);
        }
      }]);

      return DecoratorHelper;
    })();

    DecoratorHelper.prototype.h = h;

    __exports__["default"] = DecoratorHelper;
  });
define("discourse/widgets/embedded-post", 
  ["discourse/widgets/post-cooked","discourse/widgets/decorator-helper","discourse/widgets/widget","virtual-dom","discourse/helpers/fa-icon","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __exports__) {
    "use strict";
    var PostCooked = __dependency1__["default"];
    var DecoratorHelper = __dependency2__["default"];
    var createWidget = __dependency3__.createWidget;
    var h = __dependency4__.h;
    var iconNode = __dependency5__.iconNode;
    var DiscourseURL = __dependency6__["default"];

    createWidget('post-link-arrow', {
      html: function (attrs) {
        if (attrs.above) {
          return h('a.post-info.arrow', {
            attributes: { title: I18n.t('topic.jump_reply_up') }
          }, iconNode('arrow-up'));
        } else {
          return h('a.post-info.arrow', {
            attributes: { title: I18n.t('topic.jump_reply_down') }
          }, iconNode('arrow-down'));
        }
      },

      click: function () {
        DiscourseURL.routeTo(this.attrs.shareUrl);
      }
    });

    __exports__["default"] = createWidget('embedded-post', {
      buildKey: function (attrs) {
        return 'embedded-post-' + attrs.id;
      },

      html: function (attrs, state) {
        return [h('div.reply', { attributes: { 'data-post-id': attrs.id } }, [h('div.row', [this.attach('post-avatar', attrs), h('div.topic-body', [h('div.topic-meta-data', [this.attach('poster-name', attrs), this.attach('post-link-arrow', { above: state.above, shareUrl: attrs.shareUrl })]), new PostCooked(attrs, new DecoratorHelper(this))])])])];
      }
    });
  });
define("discourse/widgets/emoji", 
  ["discourse/widgets/widget","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;

    __exports__["default"] = createWidget('emoji', {
      tagName: 'img.emoji',

      buildAttributes: function (attrs) {
        return { src: Discourse.Emoji.urlFor(attrs.name) };
      }
    });
  });
define("discourse/widgets/hamburger-categories", 
  ["discourse/widgets/widget","virtual-dom","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var h = __dependency2__.h;

    createWidget('hamburger-category', {
      tagName: 'li.category-link',

      html: function (c) {
        var results = [this.attach('category-link', { category: c, allowUncategorized: true })];

        var unreadTotal = parseInt(c.get('unreadTopics'), 10) + parseInt(c.get('newTopics'), 10);
        if (unreadTotal) {
          results.push(h('a.badge.badge-notification', { attributes: { href: c.get('url') } }, unreadTotal.toString()));
        }

        if (!this.currentUser) {
          results.push(h('b.topics-count', c.get('topic_count').toString()));
        }

        return results;
      }
    });

    __exports__["default"] = createWidget('hamburger-categories', {
      tagName: 'ul.category-links.clearfix',

      html: function (attrs) {
        var _this = this;

        var href = Discourse.getURL('/categories');
        var result = [h('li.heading', h('a.d-link.categories-link', { attributes: { href: href } }, I18n.t('filters.categories.title')))];

        var categories = attrs.categories;
        if (categories.length === 0) {
          return;
        }
        return result.concat(categories.map(function (c) {
          return _this.attach('hamburger-category', c);
        }));
      }
    });
  });
define("discourse/widgets/hamburger-menu", 
  ["discourse/widgets/widget","virtual-dom","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var applyDecorators = __dependency1__.applyDecorators;
    var h = __dependency2__.h;

    __exports__["default"] = createWidget('hamburger-menu', {
      tagName: 'div.hamburger-panel',

      faqLink: function (href) {
        return h('a.faq-priority', { attributes: { href: href } }, [I18n.t('faq'), ' ', h('span.badge.badge-notification', I18n.t('new_item'))]);
      },

      adminLinks: function () {
        var _this = this;

        var currentUser = this.currentUser;

        var links = [{ route: 'admin', className: 'admin-link', icon: 'wrench', label: 'admin_title' }, { route: 'adminFlags',
          className: 'flagged-posts-link',
          icon: 'flag',
          label: 'flags_title',
          badgeClass: 'flagged-posts',
          badgeTitle: 'notifications.total_flagged',
          badgeCount: 'site_flagged_posts_count' }];

        if (currentUser.show_queued_posts) {
          links.push({ route: 'queued-posts',
            className: 'queued-posts-link',
            label: 'queue.title',
            badgeCount: 'post_queue_new_count',
            badgeClass: 'queued-posts' });
        }

        if (currentUser.admin) {
          links.push({ route: 'adminSiteSettings',
            icon: 'gear',
            label: 'admin.site_settings.title',
            className: 'settings-link' });
        }

        return links.map(function (l) {
          return _this.attach('link', l);
        });
      },

      lookupCount: function (type) {
        var tts = this.container.lookup('topic-tracking-state:main');
        return tts ? tts.lookupCount(type) : 0;
      },

      showUserDirectory: function () {
        if (!this.siteSettings.enable_user_directory) return false;
        if (this.siteSettings.hide_user_profiles_from_public && !this.currentUser) return false;
        return true;
      },

      generalLinks: function () {
        var _this2 = this;

        var siteSettings = this.siteSettings;

        var links = [];

        links.push({ route: 'discovery.latest', className: 'latest-topics-link', label: 'filters.latest.title' });

        if (this.currentUser) {
          links.push({ route: 'discovery.new',
            className: 'new-topics-link',
            labelCount: 'filters.new.title_with_count',
            label: 'filters.new.title',
            count: this.lookupCount('new') });

          links.push({ route: 'discovery.unread',
            className: 'unread-topics-link',
            labelCount: 'filters.unread.title_with_count',
            label: 'filters.unread.title',
            count: this.lookupCount('unread') });
        }

        links.push({ route: 'discovery.top', className: 'top-topics-link', label: 'filters.top.title' });

        if (siteSettings.enable_badges) {
          links.push({ route: 'badges', className: 'badge-link', label: 'badges.title' });
        }

        if (this.showUserDirectory()) {
          links.push({ route: 'users', className: 'user-directory-link', label: 'directory.title' });
        }

        if (this.siteSettings.tagging_enabled) {
          links.push({ route: 'tags', label: 'tagging.tags' });
        }

        var extraLinks = applyDecorators(this, 'generalLinks', this.attrs, this.state);

        return links.concat(extraLinks).map(function (l) {
          return _this2.attach('link', l);
        });
      },

      listCategories: function () {
        var hideUncategorized = !this.siteSettings.allow_uncategorized_topics;
        var showSubcatList = this.siteSettings.show_subcategory_list;
        var isStaff = Discourse.User.currentProp('staff');

        var categories = Discourse.Category.list().reject(function (c) {
          if (showSubcatList && c.get('parent_category_id')) {
            return true;
          }
          if (hideUncategorized && c.get('isUncategorizedCategory') && !isStaff) {
            return true;
          }
          return false;
        });

        return this.attach('hamburger-categories', { categories: categories });
      },

      footerLinks: function (prioritizeFaq, faqUrl) {
        var _this3 = this;

        var links = [];
        links.push({ route: 'about', className: 'about-link', label: 'about.simple_title' });

        if (!prioritizeFaq) {
          links.push({ href: faqUrl, className: 'faq-link', label: 'faq' });
        }

        var site = this.site;

        if (!site.mobileView && !this.capabilities.touch) {
          links.push({ action: 'showKeyboard', className: 'keyboard-shortcuts-link', label: 'keyboard_shortcuts_help.title' });
        }

        if (this.site.mobileView || this.siteSettings.enable_mobile_theme && this.capabilities.touch) {
          links.push({ action: 'toggleMobileView',
            className: 'mobile-toggle-link',
            label: this.site.mobileView ? "desktop_view" : "mobile_view" });
        }

        return links.map(function (l) {
          return _this3.attach('link', l);
        });
      },

      panelContents: function () {
        var _this4 = this;

        var currentUser = this.currentUser;

        var results = [];

        var faqUrl = this.siteSettings.faq_url;
        if (!faqUrl || faqUrl.length === 0) {
          faqUrl = Discourse.getURL('/faq');
        }

        var prioritizeFaq = this.currentUser && !this.currentUser.read_faq;
        if (prioritizeFaq) {
          results.push(this.attach('menu-links', { heading: true, contents: function () {
              return _this4.faqLink(faqUrl);
            } }));
        }

        if (currentUser && currentUser.staff) {
          results.push(this.attach('menu-links', { contents: function () {
              var extraLinks = applyDecorators(_this4, 'admin-links', _this4.attrs, _this4.state) || [];
              return _this4.adminLinks().concat(extraLinks);
            } }));
        }

        results.push(this.attach('menu-links', { contents: function () {
            return _this4.generalLinks();
          } }));
        results.push(this.listCategories());
        results.push(h('hr'));
        results.push(this.attach('menu-links', { omitRule: true, contents: function () {
            return _this4.footerLinks(prioritizeFaq, faqUrl);
          } }));

        return results;
      },

      html: function () {
        var _this5 = this;

        return this.attach('menu-panel', { contents: function () {
            return _this5.panelContents();
          } });
      },

      clickOutside: function () {
        this.sendWidgetAction('toggleHamburger');
      }
    });
  });
define("discourse/widgets/header-topic-info", 
  ["discourse/widgets/widget","virtual-dom","discourse/helpers/fa-icon","discourse/lib/url","discourse/widgets/raw-html","discourse/lib/render-tag","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var h = __dependency2__.h;
    var iconNode = __dependency3__.iconNode;
    var DiscourseURL = __dependency4__["default"];
    var RawHtml = __dependency5__["default"];
    var tagNode = __dependency6__.tagNode;

    __exports__["default"] = createWidget('header-topic-info', {
      tagName: 'div.extra-info-wrapper',

      html: function (attrs) {
        var _this = this;

        var topic = attrs.topic;

        var heading = [];

        var showPM = !topic.get('is_warning') && topic.get('isPrivateMessage');
        if (showPM) {
          var href = this.currentUser && this.currentUser.pmPath(topic);
          if (href) {
            heading.push(h('a', { attributes: { href: href } }, h('span.private-message-glyph', iconNode('envelope'))));
          }
        }
        var loaded = topic.get('details.loaded');

        if (loaded) {
          (function () {
            heading.push(_this.attach('topic-status', attrs));

            var titleHTML = new RawHtml({ html: '<span>' + topic.get('fancyTitle') + '</span>' });
            heading.push(_this.attach('link', { className: 'topic-link',
              action: 'jumpToTopPost',
              href: topic.get('url'),
              contents: function () {
                return titleHTML;
              } }));
          })();
        }

        var title = [h('h1', heading)];
        if (loaded) {
          var category = topic.get('category');
          if (category && (!category.get('isUncategorizedCategory') || !this.siteSettings.suppress_uncategorized_badge)) {
            var parentCategory = category.get('parentCategory');
            if (parentCategory) {
              title.push(this.attach('category-link', { category: parentCategory }));
            }
            title.push(this.attach('category-link', { category: category }));
          }

          if (this.siteSettings.tagging_enabled) {
            var tags = topic.get('tags') || [];
            if (tags.length) {
              title.push(h('div.list-tags', tags.map(tagNode)));
            }
          }
        }

        var contents = h('div.title-wrapper', title);
        return h('div.extra-info', { className: title.length > 1 ? 'two-rows' : '' }, contents);
      },

      jumpToTopPost: function () {
        var topic = this.attrs.topic;
        if (topic) {
          DiscourseURL.routeTo(topic.get('firstPostUrl'));
        }
      }
    });
  });
define("discourse/widgets/header", 
  ["discourse/widgets/widget","discourse/helpers/fa-icon","discourse/widgets/post","discourse/lib/url","discourse/lib/intercept-click","virtual-dom","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var iconNode = __dependency2__.iconNode;
    var avatarImg = __dependency3__.avatarImg;
    var DiscourseURL = __dependency4__["default"];
    var wantsNewWindow = __dependency5__.wantsNewWindow;

    var h = __dependency6__.h;

    var dropdown = {
      buildClasses: function (attrs) {
        if (attrs.active) {
          return "active";
        }
      },

      click: function (e) {
        if (wantsNewWindow(e)) {
          return;
        }
        e.preventDefault();
        if (!this.attrs.active) {
          this.sendWidgetAction(this.attrs.action);
        }
      }
    };

    createWidget('header-notifications', {
      html: function (attrs) {
        var currentUser = this.currentUser;

        var contents = [avatarImg('medium', { template: currentUser.get('avatar_template'),
          username: currentUser.get('username') })];

        var unreadNotifications = currentUser.get('unread_notifications');
        if (!!unreadNotifications) {
          contents.push(this.attach('link', { action: attrs.action,
            className: 'badge-notification unread-notifications',
            rawLabel: unreadNotifications }));
        }

        var unreadPMs = currentUser.get('unread_private_messages');
        if (!!unreadPMs) {
          contents.push(this.attach('link', { action: attrs.action,
            className: 'badge-notification unread-private-messages',
            rawLabel: unreadPMs }));
        }

        return contents;
      }
    });

    createWidget('user-dropdown', jQuery.extend({
      tagName: 'li.header-dropdown-toggle.current-user',

      buildId: function () {
        return 'current-user';
      },

      html: function (attrs) {
        var currentUser = this.currentUser;

        return h('a.icon', { attributes: { href: currentUser.get('path'), 'data-auto-route': true } }, this.attach('header-notifications', attrs));
      }
    }, dropdown));

    createWidget('header-dropdown', jQuery.extend({
      tagName: 'li.header-dropdown-toggle',

      html: function (attrs) {
        var title = I18n.t(attrs.title);

        var body = [iconNode(attrs.icon)];
        if (attrs.contents) {
          body.push(attrs.contents.call(this));
        }

        return h('a.icon', { attributes: { href: attrs.href,
            'data-auto-route': true,
            title: title,
            'aria-label': title,
            id: attrs.iconId } }, body);
      }
    }, dropdown));

    createWidget('header-icons', {
      tagName: 'ul.icons.clearfix',

      buildAttributes: function () {
        return { role: 'navigation' };
      },

      html: function (attrs) {
        var hamburger = this.attach('header-dropdown', {
          title: 'hamburger_menu',
          icon: 'bars',
          iconId: 'toggle-hamburger-menu',
          active: attrs.hamburgerVisible,
          action: 'toggleHamburger',
          contents: function () {
            if (!attrs.flagCount) {
              return;
            }
            return this.attach('link', {
              href: '/admin/flags/active',
              title: 'notifications.total_flagged',
              rawLabel: attrs.flagCount,
              className: 'badge-notification flagged-posts'
            });
          }
        });

        var search = this.attach('header-dropdown', {
          title: 'search.title',
          icon: 'search',
          iconId: 'search-button',
          action: 'toggleSearchMenu',
          active: attrs.searchVisible,
          href: '/search'
        });

        var icons = [search, hamburger];
        if (this.currentUser) {
          icons.push(this.attach('user-dropdown', { active: attrs.userVisible,
            action: 'toggleUserMenu' }));
        }

        return icons;
      }
    });

    createWidget('header-buttons', {
      tagName: 'span',

      html: function (attrs) {
        if (this.currentUser) {
          return;
        }

        var buttons = [];

        if (attrs.canSignUp && !attrs.topic) {
          buttons.push(this.attach('button', { label: "sign_up",
            className: 'btn-primary btn-small sign-up-button',
            action: "showCreateAccount" }));
        }

        buttons.push(this.attach('button', { label: 'log_in',
          className: 'btn-primary btn-small login-button',
          action: 'showLogin',
          icon: 'user' }));
        return buttons;
      }
    });

    __exports__["default"] = createWidget('header', {
      tagName: 'header.d-header.clearfix',
      buildKey: function () {
        return 'header';
      },

      defaultState: function () {
        return { searchVisible: false,
          hamburgerVisible: false,
          userVisible: false,
          contextEnabled: false };
      },

      html: function (attrs, state) {
        var panels = [this.attach('header-buttons', attrs), this.attach('header-icons', { hamburgerVisible: state.hamburgerVisible,
          userVisible: state.userVisible,
          searchVisible: state.searchVisible,
          flagCount: attrs.flagCount })];

        if (state.searchVisible) {
          panels.push(this.attach('search-menu', { contextEnabled: state.contextEnabled }));
        } else if (state.hamburgerVisible) {
          panels.push(this.attach('hamburger-menu'));
        } else if (state.userVisible) {
          panels.push(this.attach('user-menu'));
        }

        var contents = [this.attach('home-logo', { minimized: !!attrs.topic }), h('div.panel.clearfix', panels)];

        if (attrs.topic) {
          contents.push(this.attach('header-topic-info', attrs));
        }

        return h('div.wrap', h('div.contents.clearfix', contents));
      },

      updateHighlight: function () {
        if (!this.state.searchVisible) {
          var service = this.container.lookup('search-service:main');
          service.set('highlightTerm', '');
        }
      },

      closeAll: function () {
        this.state.userVisible = false;
        this.state.hamburgerVisible = false;
        this.state.searchVisible = false;
      },

      linkClickedEvent: function () {
        this.closeAll();
        this.updateHighlight();
      },

      toggleSearchMenu: function () {
        if (this.site.mobileView) {
          var searchService = this.container.lookup('search-service:main');
          var context = searchService.get('searchContext');
          var params = "";

          if (context) {
            params = '?context=' + context.type + '&context_id=' + context.id + '&skip_context=true';
          }

          return DiscourseURL.routeTo('/search' + params);
        }

        this.state.searchVisible = !this.state.searchVisible;
        this.updateHighlight();
        Ember.run.next(function () {
          return $('#search-term').focus();
        });
      },

      toggleUserMenu: function () {
        this.state.userVisible = !this.state.userVisible;
      },

      toggleHamburger: function () {
        this.state.hamburgerVisible = !this.state.hamburgerVisible;
      },

      togglePageSearch: function () {
        var state = this.state;

        state.contextEnabled = false;

        var currentPath = this.container.lookup('controller:application').get('currentPath');
        var blacklist = [/^discovery\.categories/];
        var whitelist = [/^topic\./];
        var check = function (regex) {
          return !!currentPath.match(regex);
        };
        var showSearch = whitelist.any(check) && !blacklist.any(check);

        // If we're viewing a topic, only intercept search if there are cloaked posts
        if (showSearch && currentPath.match(/^topic\./)) {
          showSearch = $('.topic-post .cooked, .small-action:not(.time-gap)').length < this.container.lookup('controller:topic').get('model.postStream.stream.length');
        }

        if (state.searchVisible) {
          this.toggleSearchMenu();
          return showSearch;
        }

        if (showSearch) {
          state.contextEnabled = true;
          this.toggleSearchMenu();
          return false;
        }

        return true;
      },

      searchMenuContextChanged: function (value) {
        this.state.contextEnabled = value;
      },

      domClean: function () {
        var state = this.state;

        if (state.searchVisible || state.hamburgerVisible || state.userVisible) {
          this.closeAll();
        }
      },

      headerKeyboardTrigger: function (msg) {
        switch (msg.type) {
          case 'search':
            this.toggleSearchMenu();
            break;
          case 'user':
            this.toggleUserMenu();
            break;
          case 'hamburger':
            this.toggleHamburger();
            break;
          case 'page-search':
            if (!this.togglePageSearch()) {
              msg.event.preventDefault();
              msg.event.stopPropagation();
            }
            break;
        }
      }

    });
  });
define("discourse/widgets/home-logo", 
  ["discourse/widgets/widget","virtual-dom","discourse/helpers/fa-icon","discourse/lib/intercept-click","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var h = __dependency2__.h;
    var iconNode = __dependency3__.iconNode;
    var wantsNewWindow = __dependency4__.wantsNewWindow;
    var DiscourseURL = __dependency5__["default"];

    __exports__["default"] = createWidget('home-logo', {
      tagName: 'div.title',

      settings: {
        href: '/'
      },

      href: function () {
        var href = this.settings.href;
        return typeof href === "function" ? href() : href;
      },

      logo: function () {
        var siteSettings = this.siteSettings;

        var mobileView = this.site.mobileView;

        var mobileLogoUrl = siteSettings.mobile_logo_url || "";
        var showMobileLogo = mobileView && mobileLogoUrl.length > 0;

        var logoUrl = siteSettings.logo_url || '';
        var title = siteSettings.title;

        if (!mobileView && this.attrs.minimized) {
          var logoSmallUrl = siteSettings.logo_small_url || '';
          if (logoSmallUrl.length) {
            return h('img#site-logo.logo-small', { key: 'logo-small', attributes: { src: logoSmallUrl, width: 33, height: 33, alt: title } });
          } else {
            return iconNode('home');
          }
        } else if (showMobileLogo) {
          return h('img#site-logo.logo-big', { key: 'logo-mobile', attributes: { src: mobileLogoUrl, alt: title } });
        } else if (logoUrl.length) {
          return h('img#site-logo.logo-big', { key: 'logo-big', attributes: { src: logoUrl, alt: title } });
        } else {
          return h('h2#site-text-logo.text-logo', { key: 'logo-text' }, title);
        }
      },

      html: function () {
        return h('a', { attributes: { href: this.href(), 'data-auto-route': true } }, this.logo());
      },

      click: function (e) {
        if (wantsNewWindow(e)) {
          return false;
        }
        e.preventDefault();

        DiscourseURL.routeToTag($(e.target).closest('a')[0]);
        return false;
      }
    });
  });
define("discourse/widgets/hooks", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    /*eslint no-loop-func:0*/

    var CLICK_ATTRIBUTE_NAME = '_discourse_click_widget';
    var CLICK_OUTSIDE_ATTRIBUTE_NAME = '_discourse_click_outside_widget';
    var KEY_UP_ATTRIBUTE_NAME = '_discourse_key_up_widget';

    function buildHook(attributeName, setAttr) {
      return (function () {
        function _class(widget) {
          _classCallCheck(this, _class);

          this.widget = widget;
        }

        _createClass(_class, [{
          key: 'hook',
          value: function hook(node) {
            if (setAttr) {
              node.setAttribute(setAttr, true);
            }
            node[attributeName] = this.widget;
          }
        }, {
          key: 'unhook',
          value: function unhook(node) {
            if (setAttr) {
              node.removeAttribute(setAttr, true);
            }
            node[attributeName] = null;
          }
        }]);

        return _class;
      })();
    }

    var WidgetClickHook = buildHook(CLICK_ATTRIBUTE_NAME);
    __exports__.WidgetClickHook = WidgetClickHook;
    var WidgetClickOutsideHook = buildHook(CLICK_OUTSIDE_ATTRIBUTE_NAME, 'data-click-outside');
    __exports__.WidgetClickOutsideHook = WidgetClickOutsideHook;
    var WidgetKeyUpHook = buildHook(KEY_UP_ATTRIBUTE_NAME);

    __exports__.WidgetKeyUpHook = WidgetKeyUpHook;
    function findNode(node, attrName, cb) {
      var _loop = function () {
        var widget = node[attrName];
        if (widget) {
          widget.rerenderResult(function () {
            return cb(widget);
          });
          return 'break';
        }
        node = node.parentNode;
      };

      while (node) {
        var _ret = _loop();

        if (_ret === 'break') break;
      }
    }

    var _watchingDocument = false;
    WidgetClickHook.setupDocumentCallback = function () {
      if (_watchingDocument) {
        return;
      }

      $(document).on('click.discourse-widget', function (e) {
        findNode(e.target, CLICK_ATTRIBUTE_NAME, function (w) {
          return w.click(e);
        });

        var node = e.target;
        var $outside = $('[data-click-outside]');
        $outside.each(function (i, outNode) {
          if (outNode.contains(node)) {
            return;
          }
          var widget = outNode[CLICK_OUTSIDE_ATTRIBUTE_NAME];
          if (widget) {
            widget.clickOutside(e);
          }
        });
      });

      $(document).on('keyup.discourse-widget', function (e) {
        findNode(e.target, KEY_UP_ATTRIBUTE_NAME, function (w) {
          return w.keyUp(e);
        });
      });

      _watchingDocument = true;
    };
  });
define("discourse/widgets/link", 
  ["discourse/lib/intercept-click","discourse/widgets/widget","discourse/helpers/fa-icon","virtual-dom","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __exports__) {
    "use strict";
    var wantsNewWindow = __dependency1__.wantsNewWindow;
    var createWidget = __dependency2__.createWidget;
    var iconNode = __dependency3__.iconNode;
    var h = __dependency4__.h;
    var DiscourseURL = __dependency5__["default"];

    __exports__["default"] = createWidget('link', {
      tagName: 'a',

      href: function (attrs) {
        var route = attrs.route;
        if (route) {
          var router = this.container.lookup('router:main');
          if (router && router.router) {
            var params = [route];
            if (attrs.model) {
              params.push(attrs.model);
            }
            return Discourse.getURL(router.router.generate.apply(router.router, params));
          }
        } else {
          return attrs.href;
        }
      },

      buildClasses: function (attrs) {
        var result = [];
        result.push('widget-link');
        if (attrs.className) {
          result.push(attrs.className);
        };
        return result;
      },

      buildAttributes: function (attrs) {
        return { href: this.href(attrs), title: this.label(attrs) };
      },

      label: function (attrs) {
        if (attrs.labelCount && attrs.count) {
          return I18n.t(attrs.labelCount, { count: attrs.count });
        }
        return attrs.rawLabel || (attrs.label ? I18n.t(attrs.label) : '');
      },

      html: function (attrs) {
        if (attrs.contents) {
          return attrs.contents();
        }

        var result = [];
        if (attrs.icon) {
          result.push(iconNode(attrs.icon));
          result.push(' ');
        }

        if (!attrs.hideLabel) {
          result.push(this.label(attrs));
        }

        var currentUser = this.currentUser;
        if (currentUser && attrs.badgeCount) {
          var val = parseInt(currentUser.get(attrs.badgeCount));
          if (val > 0) {
            var title = attrs.badgeTitle ? I18n.t(attrs.badgeTitle) : '';
            result.push(' ');
            result.push(h('span.badge-notification', { className: attrs.badgeClass,
              attributes: { title: title } }, val));
          }
        }

        return result;
      },

      click: function (e) {
        if (wantsNewWindow(e)) {
          return;
        }
        e.preventDefault();

        if (this.attrs.action) {
          e.preventDefault();
          return this.sendWidgetAction(this.attrs.action, this.attrs.actionParam);
        } else {
          this.sendWidgetEvent('linkClicked');
        }

        return DiscourseURL.routeToTag($(e.target).closest('a')[0]);
      }
    });
  });
define("discourse/widgets/menu-panel", 
  ["discourse/widgets/widget","virtual-dom"],
  function(__dependency1__, __dependency2__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var h = __dependency2__.h;

    createWidget('menu-links', {
      html: function (attrs) {
        var links = [].concat(attrs.contents());
        var liOpts = { className: attrs.heading ? 'heading' : '' };

        var result = [];
        result.push(h('ul.menu-links.columned', links.map(function (l) {
          return h('li', liOpts, l);
        })));

        result.push(h('div.clearfix'));
        if (!attrs.omitRule) {
          result.push(h('hr'));
        }
        return result;
      }
    });

    createWidget('menu-panel', {
      tagName: 'div.menu-panel',

      buildAttributes: function (attrs) {
        if (attrs.maxWidth) {
          return { 'data-max-width': attrs.maxWidth };
        }
      },

      html: function (attrs) {
        return h('div.panel-body', h('div.panel-body-contents.clearfix', attrs.contents()));
      }
    });
  });
define("discourse/widgets/notification-item", 
  ["discourse/lib/intercept-click","discourse/widgets/raw-html","discourse/widgets/widget","discourse/lib/url","virtual-dom"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
    "use strict";
    var wantsNewWindow = __dependency1__.wantsNewWindow;
    var RawHtml = __dependency2__["default"];
    var createWidget = __dependency3__.createWidget;
    var DiscourseURL = __dependency4__["default"];
    var h = __dependency5__.h;

    var LIKED_TYPE = 5;
    var INVITED_TYPE = 8;
    var GROUP_SUMMARY_TYPE = 16;

    createWidget('notification-item', {
      tagName: 'li',

      buildClasses: function (attrs) {
        var classNames = [];
        if (attrs.get('read')) {
          classNames.push('read');
        }
        if (attrs.is_warning) {
          classNames.push('is-warning');
        }
        return classNames;
      },

      url: function () {
        var attrs = this.attrs;
        var data = attrs.data;

        var badgeId = data.badge_id;
        if (badgeId) {
          var badgeSlug = data.badge_slug;

          if (!badgeSlug) {
            var badgeName = data.badge_name;
            badgeSlug = badgeName.replace(/[^A-Za-z0-9_]+/g, '-').toLowerCase();
          }

          var username = data.username;
          username = username ? "?username=" + username.toLowerCase() : "";
          return Discourse.getURL('/badges/' + badgeId + '/' + badgeSlug + username);
        }

        var topicId = attrs.topic_id;
        if (topicId) {
          return Discourse.Utilities.postUrl(attrs.slug, topicId, attrs.post_number);
        }

        if (attrs.notification_type === INVITED_TYPE) {
          return Discourse.getURL('/users/' + data.display_username);
        }

        if (data.group_id) {
          return Discourse.getURL('/users/' + data.username + '/messages/group/' + data.group_name);
        }
      },

      description: function () {
        var data = this.attrs.data;
        var badgeName = data.badge_name;
        if (badgeName) {
          return Discourse.Utilities.escapeExpression(badgeName);
        }

        var title = data.topic_title;
        return Ember.isEmpty(title) ? "" : Discourse.Utilities.escapeExpression(title);
      },

      text: function (notificationType, notName) {
        var attrs = this.attrs;

        var data = attrs.data;
        var scope = notName === 'custom' ? data.message : 'notifications.' + notName;

        if (notificationType === GROUP_SUMMARY_TYPE) {
          var count = data.inbox_count;
          var group_name = data.group_name;
          return I18n.t(scope, { count: count, group_name: group_name });
        }

        var username = data.display_username;
        var description = this.description();
        if (notificationType === LIKED_TYPE && data.count > 1) {
          var count = data.count - 2;
          var username2 = data.username2;
          if (count === 0) {
            return I18n.t('notifications.liked_2', { description: description, username: username, username2: username2 });
          } else {
            return I18n.t('notifications.liked_many', { description: description, username: username, username2: username2, count: count });
          }
        }

        return I18n.t(scope, { description: description, username: username });
      },

      html: function (attrs) {
        var notificationType = attrs.notification_type;
        var lookup = this.site.get('notificationLookup');
        var notName = lookup[notificationType];

        var contents = new RawHtml({ html: '<div>' + Discourse.Emoji.unescape(this.text(notificationType, notName)) + '</div>' });
        var href = this.url();
        var alt = I18n.t('notifications.alt.' + notName);
        return href ? h('a', { attributes: { href: href, alt: alt, 'data-auto-route': true } }, contents) : contents;
      },

      click: function (e) {
        this.attrs.set('read', true);
        var id = this.attrs.id;
        Discourse.setTransientHeader("Discourse-Clear-Notifications", id);
        if (document && document.cookie) {
          document.cookie = 'cn=' + id + '; expires=Fri, 31 Dec 9999 23:59:59 GMT';
        }
        if (wantsNewWindow(e)) {
          return;
        }
        e.preventDefault();

        this.sendWidgetEvent('linkClicked');
        DiscourseURL.routeTo(this.url());
      }
    });
  });
define("discourse/widgets/post-admin-menu", 
  ["discourse/helpers/fa-icon","discourse/widgets/widget","virtual-dom","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var iconNode = __dependency1__.iconNode;
    var createWidget = __dependency2__.createWidget;
    var h = __dependency3__.h;

    createWidget('post-admin-menu-button', {
      tagName: 'li.btn',
      buildClasses: function (attrs) {
        return attrs.className;
      },
      html: function (attrs) {
        return [iconNode(attrs.icon), I18n.t(attrs.label)];
      },
      click: function () {
        this.sendWidgetAction('closeAdminMenu');
        return this.sendWidgetAction(this.attrs.action);
      }
    });

    __exports__["default"] = createWidget('post-admin-menu', {
      tagName: 'div.post-admin-menu.popup-menu',

      html: function (attrs) {
        var contents = [];
        contents.push(h('h3', I18n.t('admin_title')));

        if (!attrs.isWhisper && this.currentUser.staff) {
          var buttonAtts = { action: 'togglePostType', icon: 'shield', className: 'toggle-post-type' };

          if (attrs.isModeratorAction) {
            buttonAtts.label = 'post.controls.revert_to_regular';
          } else {
            buttonAtts.label = 'post.controls.convert_to_moderator';
          }
          contents.push(this.attach('post-admin-menu-button', buttonAtts));
        }

        if (attrs.canManage) {
          contents.push(this.attach('post-admin-menu-button', {
            icon: 'cog', label: 'post.controls.rebake', action: 'rebakePost', className: 'rebuild-html'
          }));

          if (attrs.hidden) {
            contents.push(this.attach('post-admin-menu-button', {
              icon: 'eye', label: 'post.controls.unhide', action: 'unhidePost', className: 'unhide-post'
            }));
          }
        }

        if (this.currentUser.admin) {
          contents.push(this.attach('post-admin-menu-button', {
            icon: 'user', label: 'post.controls.change_owner', action: 'changePostOwner', className: 'change-owner'
          }));
        }

        // toggle Wiki button
        if (attrs.wiki) {
          contents.push(this.attach('post-admin-menu-button', {
            action: 'toggleWiki', label: 'post.controls.unwiki', icon: 'pencil-square-o', className: 'wiki wikied'
          }));
        } else {
          contents.push(this.attach('post-admin-menu-button', {
            action: 'toggleWiki', label: 'post.controls.wiki', icon: 'pencil-square-o', className: 'wiki'
          }));
        }

        return contents;
      },

      clickOutside: function () {
        this.sendWidgetAction('closeAdminMenu');
      }
    });
  });
define("discourse/widgets/post-cooked", 
  ["discourse/lib/click-track","discourse/lib/formatter","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    __exports__.addDecorator = addDecorator;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var isValidLink = __dependency1__.isValidLink;
    var number = __dependency2__.number;

    var _decorators = [];

    // Don't call this directly: use `plugin-api/decorateCooked`

    function addDecorator(cb) {
      _decorators.push(cb);
    }

    var PostCooked = (function () {
      function PostCooked(attrs, getModel) {
        _classCallCheck(this, PostCooked);

        this.attrs = attrs;
        this.expanding = false;
        this._highlighted = false;
        this.getModel = getModel;
      }

      _createClass(PostCooked, [{
        key: 'update',
        value: function update(prev) {
          if (prev.attrs.cooked !== this.attrs.cooked) {
            return this.init();
          }
        }
      }, {
        key: 'init',
        value: function init() {
          var _this = this;

          var $html = $('<div class=\'cooked\'>' + this.attrs.cooked + '</div>');
          this._insertQuoteControls($html);
          this._showLinkCounts($html);
          this._fixImageSizes($html);
          this._applySearchHighlight($html);

          _decorators.forEach(function (cb) {
            return cb($html, _this.getModel);
          });
          return $html[0];
        }
      }, {
        key: '_applySearchHighlight',
        value: function _applySearchHighlight($html) {
          var highlight = this.attrs.highlightTerm;

          if (highlight && highlight.length > 2) {
            if (this._highlighted) {
              $html.unhighlight();
            }
            $html.highlight(highlight.split(/\s+/));
            this._highlighted = true;
          } else if (this._highlighted) {
            $html.unhighlight();
            this._highlighted = false;
          }
        }
      }, {
        key: '_fixImageSizes',
        value: function _fixImageSizes($html) {
          var _this2 = this;

          var maxImageWidth = Discourse.SiteSettings.max_image_width;
          var maxImageHeight = Discourse.SiteSettings.max_image_height;

          var maxWindowWidth = undefined;
          $html.find('img:not(.avatar)').each(function (idx, img) {
            // deferring work only for posts with images
            // we got to use screen here, cause nothing is rendered yet.
            // long term we may want to allow for weird margins that are enforced, instead of hardcoding at 70/20
            maxWindowWidth = maxWindowWidth || $(window).width() - (_this2.attrs.mobileView ? 20 : 70);
            if (maxImageWidth < maxWindowWidth) {
              maxWindowWidth = maxImageWidth;
            }

            var aspect = img.height / img.width;
            if (img.width > maxWindowWidth) {
              img.width = maxWindowWidth;
              img.height = parseInt(maxWindowWidth * aspect, 10);
            }

            // very unlikely but lets fix this too
            if (img.height > maxImageHeight) {
              img.height = maxImageHeight;
              img.width = parseInt(maxWindowWidth / aspect, 10);
            }
          });
        }
      }, {
        key: '_showLinkCounts',
        value: function _showLinkCounts($html) {
          var linkCounts = this.attrs.linkCounts;
          if (!linkCounts) {
            return;
          }

          linkCounts.forEach(function (lc) {
            if (!lc.clicks || lc.clicks < 1) {
              return;
            }

            $html.find('a[href]').each(function (i, e) {
              var $link = $(e);
              var href = $link.attr('href');

              var valid = href === lc.url;

              // this might be an attachment
              if (lc.internal && /^\/uploads\//.test(lc.url)) {
                valid = href.indexOf(lc.url) >= 0;
              }

              // don't display badge counts on category badge & oneboxes (unless when explicitely stated)
              if (valid && isValidLink($link)) {
                var title = I18n.t("topic_map.clicks", { count: lc.clicks });
                $link.append('<span class=\'badge badge-notification clicks\' title=\'' + title + '\'>' + number(lc.clicks) + '</span>');
              }
            });
          });
        }
      }, {
        key: '_toggleQuote',
        value: function _toggleQuote($aside) {
          var _this3 = this;

          if (this.expanding) {
            return;
          }

          this.expanding = true;

          $aside.data('expanded', !$aside.data('expanded'));

          var finished = function () {
            return _this3.expanding = false;
          };

          if ($aside.data('expanded')) {
            (function () {
              _this3._updateQuoteElements($aside, 'chevron-up');
              // Show expanded quote
              var $blockQuote = $('blockquote', $aside);
              $aside.data('original-contents', $blockQuote.html());

              var originalText = $blockQuote.text().trim();
              $blockQuote.html(I18n.t("loading"));
              var topicId = _this3.attrs.topicId;
              if ($aside.data('topic')) {
                topicId = $aside.data('topic');
              }

              var postId = parseInt($aside.data('post'), 10);
              topicId = parseInt(topicId, 10);

              Discourse.ajax('/posts/by_number/' + topicId + '/' + postId).then(function (result) {
                var div = $("<div class='expanded-quote'></div>");
                div.html(result.cooked);
                div.highlight(originalText, { caseSensitive: true, element: 'span', className: 'highlighted' });
                $blockQuote.showHtml(div, 'fast', finished);
              });
            })();
          } else {
            // Hide expanded quote
            this._updateQuoteElements($aside, 'chevron-down');
            $('blockquote', $aside).showHtml($aside.data('original-contents'), 'fast', finished);
          }
          return false;
        }
      }, {
        key: '_urlForPostNumber',
        value: function _urlForPostNumber(postNumber) {
          return postNumber > 0 ? this.attrs.topicUrl + '/' + postNumber : this.attrs.topicUrl;
        }
      }, {
        key: '_updateQuoteElements',
        value: function _updateQuoteElements($aside, desc) {
          var navLink = "";
          var quoteTitle = I18n.t("post.follow_quote");
          var postNumber = $aside.data('post');

          if (postNumber) {

            // If we have a topic reference
            var asideTopicId = parseInt($aside.data('topic'));

            if (asideTopicId) {
              // If it's the same topic as ours, build the URL from the topic object
              if (this.attrs.topicId === asideTopicId) {
                navLink = '<a href=\'' + this._urlForPostNumber(postNumber) + '\' title=\'' + quoteTitle + '\' class=\'back\'></a>';
              } else {
                // Made up slug should be replaced with canonical URL
                var asideLink = Discourse.getURL("/t/via-quote/") + asideTopicId + "/" + postNumber;
                navLink = '<a href=\'' + asideLink + '\' title=\'' + quoteTitle + '\' class=\'quote-other-topic\'></a>';
              }
            } else {
              // assume the same topic
              navLink = '<a href=\'' + this._urlForPostNumber(postNumber) + '\' title=\'' + quoteTitle + '\' class=\'back\'></a>';
            }
          }
          // Only add the expand/contract control if it's not a full post
          var expandContract = "";
          if (!$aside.data('full')) {
            expandContract = '<i class=\'fa fa-' + desc + '\' title=\'' + I18n.t("post.expand_collapse") + '\'></i>';
            $('.title', $aside).css('cursor', 'pointer');
          }
          $('.quote-controls', $aside).html(expandContract + navLink);
        }
      }, {
        key: '_insertQuoteControls',
        value: function _insertQuoteControls($html) {
          var _this4 = this;

          var $quotes = $html.find('aside.quote');
          if ($quotes.length === 0) {
            return;
          }

          $quotes.each(function (i, e) {
            var $aside = $(e);
            if ($aside.data('post')) {
              _this4._updateQuoteElements($aside, 'chevron-down');
              var $title = $('.title', $aside);

              // Unless it's a full quote, allow click to expand
              if (!($aside.data('full') || $title.data('has-quote-controls'))) {
                $title.on('click', function (e2) {
                  if ($(e2.target).is('a')) return true;
                  _this4._toggleQuote($aside);
                });
                $title.data('has-quote-controls', true);
              }
            }
          });
        }
      }]);

      return PostCooked;
    })();

    __exports__["default"] = PostCooked;

    PostCooked.prototype.type = 'Widget';
  });
define("discourse/widgets/post-edits-indicator", 
  ["discourse/widgets/widget","discourse/helpers/fa-icon","discourse/lib/formatter","virtual-dom","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var iconNode = __dependency2__.iconNode;
    var longDate = __dependency3__.longDate;
    var h = __dependency4__.h;

    var FIFTY_HOURS = 60 * 50 * 1000;

    __exports__["default"] = createWidget('post-edits-indicator', {
      tagName: 'div.post-info.edits',

      historyHeat: function (updatedAt) {
        if (!updatedAt) {
          return;
        }

        // Show heat on age
        var rightNow = new Date().getTime();
        var updatedAtTime = updatedAt.getTime();

        var siteSettings = this.siteSettings;
        if (updatedAtTime > rightNow - FIFTY_HOURS * siteSettings.history_hours_low) return 'heatmap-high';
        if (updatedAtTime > rightNow - FIFTY_HOURS * siteSettings.history_hours_medium) return 'heatmap-med';
        if (updatedAtTime > rightNow - FIFTY_HOURS * siteSettings.history_hours_high) return 'heatmap-low';
      },

      html: function (attrs) {
        var contents = [attrs.version - 1, ' ', iconNode('pencil')];
        var updatedAt = new Date(attrs.updated_at);

        var title = I18n.t('post.last_edited_on') + ' ' + longDate(updatedAt);
        return h('a', {
          className: this.historyHeat(updatedAt),
          attributes: { title: title }
        }, contents);
      },

      click: function () {
        if (this.attrs.canViewEditHistory) {
          this.sendWidgetAction('showHistory');
        }
      }
    });
  });
define("discourse/widgets/post-gap", 
  ["discourse/widgets/widget","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;

    __exports__["default"] = createWidget('post-gap', {
      tagName: 'div.gap.jagged-border',
      buildKey: function (attrs) {
        return 'post-gap-' + attrs.pos + '-' + attrs.postId;
      },

      defaultState: function () {
        return { loading: false };
      },

      html: function (attrs, state) {
        return state.loading ? I18n.t('loading') : I18n.t('post.gap', { count: attrs.gap.length });
      },

      click: function () {
        var attrs = this.attrs;
        var state = this.state;

        if (state.loading) {
          return;
        }
        state.loading = true;

        var args = { gap: attrs.gap, post: this.model };
        return this.sendWidgetAction(attrs.pos === 'before' ? 'fillGapBefore' : 'fillGapAfter', args);
      }
    });
  });
define("discourse/widgets/post-gutter", 
  ["discourse/helpers/fa-icon","discourse/widgets/widget","virtual-dom","discourse/widgets/raw-html","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var iconNode = __dependency1__.iconNode;
    var createWidget = __dependency2__.createWidget;
    var h = __dependency3__.h;
    var RawHtml = __dependency4__["default"];

    var MAX_GUTTER_LINKS = 5;

    __exports__["default"] = createWidget('post-gutter', {
      tagName: 'div.gutter',
      buildKey: function (attrs) {
        return 'post-gutter-' + attrs.id;
      },

      defaultState: function () {
        return { collapsed: true };
      },

      html: function (attrs, state) {
        var links = this.attrs.links || [];

        var result = [];
        var toShow = links.length;
        if (state.collapsed && toShow > MAX_GUTTER_LINKS) {
          toShow = MAX_GUTTER_LINKS;
        }

        var seenTitles = {};

        var titleCount = 0;
        links.forEach(function (l) {
          var title = l.title;
          if (title && !seenTitles[title]) {
            seenTitles[title] = true;
            titleCount++;
            if (result.length < toShow) {
              var linkBody = [new RawHtml({ html: '<span>' + Discourse.Emoji.unescape(title) + '</span>' })];
              if (l.clicks) {
                linkBody.push(h('span.badge.badge-notification.clicks', l.clicks.toString()));
              }

              var className = l.reflection ? 'inbound' : 'outbound';
              var link = h('a.track-link', { className: className, attributes: { href: l.url } }, linkBody);
              result.push(h('li', link));
            }
          }
        });

        if (state.collapsed) {
          var remaining = titleCount - MAX_GUTTER_LINKS;

          if (remaining > 0) {
            result.push(h('li', h('a.toggle-more', I18n.t('post.more_links', { count: remaining }))));
          }
        }

        if (attrs.canReplyAsNewTopic) {
          result.push(h('a.reply-new', [iconNode('plus'), I18n.t('post.reply_as_new_topic')]));
        }

        return h('ul.post-links', result);
      },

      click: function (e) {
        var $target = $(e.target);
        if ($target.hasClass('toggle-more')) {
          this.sendWidgetAction('showAll');
        } else if ($target.closest('.reply-new').length) {
          this.sendWidgetAction('newTopicAction');
        }
        return true;
      },

      showAll: function () {
        this.state.collapsed = false;
      }
    });
  });
define("discourse/widgets/post-menu", 
  ["discourse/widgets/widget","discourse/widgets/actions-summary","virtual-dom","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    __exports__.addButton = addButton;
    var createWidget = __dependency1__.createWidget;
    var avatarAtts = __dependency2__.avatarAtts;
    var h = __dependency3__.h;

    var LIKE_ACTION = 2;

    function animateHeart($elem, start, end, complete) {
      if (Ember.testing) {
        return Ember.run(this, complete);
      }

      $elem.stop().css('textIndent', start).animate({ textIndent: end }, {
        complete: complete,
        step: function (now) {
          $(this).css('transform', 'scale(' + now + ')');
        },
        duration: 150
      }, 'linear');
    }

    var _builders = {};
    var _extraButtons = {};

    function addButton(name, builder) {
      _extraButtons[name] = builder;
    }

    function registerButton(name, builder) {
      _builders[name] = builder;
    }

    registerButton('like', function (attrs) {
      if (!attrs.showLike) {
        return;
      }
      var className = attrs.liked ? 'toggle-like has-like fade-out' : 'toggle-like like';

      var button = {
        action: 'like',
        icon: 'heart',
        className: className
      };

      if (attrs.canToggleLike) {
        button.title = attrs.liked ? 'post.controls.undo_like' : 'post.controls.like';
      } else if (attrs.liked) {
        button.title = 'post.controls.has_liked';
        button.disabled = true;
      }
      return button;
    });

    registerButton('like-count', function (attrs) {
      var count = attrs.likeCount;

      if (count > 0) {
        var title = attrs.liked ? count === 1 ? 'post.has_likes_title_only_you' : 'post.has_likes_title_you' : 'post.has_likes_title';

        return { action: 'toggleWhoLiked',
          title: title,
          className: 'like-count highlight-action',
          contents: I18n.t("post.has_likes", { count: count }),
          titleOptions: { count: attrs.liked ? count - 1 : count }
        };
      }
    });

    registerButton('flag', function (attrs) {
      if (attrs.canFlag) {
        return { action: 'showFlags',
          title: 'post.controls.flag',
          icon: 'flag',
          className: 'create-flag' };
      }
    });

    registerButton('edit', function (attrs) {
      if (attrs.canEdit) {
        return {
          action: 'editPost',
          className: 'edit',
          title: 'post.controls.edit',
          icon: 'pencil',
          alwaysShowYours: true
        };
      }
    });

    registerButton('replies', function (attrs, state, siteSettings) {
      var replyCount = attrs.replyCount;

      if (!replyCount) {
        return;
      }

      // Omit replies if the setting `suppress_reply_directly_below` is enabled
      if (replyCount === 1 && attrs.replyDirectlyBelow && siteSettings.suppress_reply_directly_below) {
        return;
      }

      return {
        action: 'toggleRepliesBelow',
        className: 'show-replies',
        icon: state.repliesShown ? 'chevron-up' : 'chevron-down',
        titleOptions: { count: replyCount },
        title: 'post.has_replies',
        labelOptions: { count: replyCount },
        label: 'post.has_replies',
        iconRight: true
      };
    });

    registerButton('share', function (attrs) {
      return {
        action: 'share',
        title: 'post.controls.share',
        icon: 'link',
        data: {
          'share-url': attrs.shareUrl,
          'post-number': attrs.post_number
        }
      };
    });

    registerButton('reply', function (attrs) {
      var args = {
        action: 'replyToPost',
        title: 'post.controls.reply',
        icon: 'reply',
        className: 'reply create fade-out'
      };

      if (!attrs.canCreatePost) {
        return;
      }

      if (!attrs.mobileView) {
        args.label = 'topic.reply.title';
      }

      return args;
    });

    registerButton('bookmark', function (attrs) {
      if (!attrs.canBookmark) {
        return;
      }

      var iconClass = 'read-icon';
      var buttonClass = 'bookmark';
      var tooltip = 'bookmarks.not_bookmarked';

      if (attrs.bookmarked) {
        iconClass += ' bookmarked';
        buttonClass += ' bookmarked';
        tooltip = 'bookmarks.created';
      }

      return { action: 'toggleBookmark',
        title: tooltip,
        className: buttonClass,
        contents: h('div', { className: iconClass }) };
    });

    registerButton('admin', function (attrs) {
      if (!attrs.canManage && !attrs.canWiki) {
        return;
      }
      return { action: 'openAdminMenu',
        title: 'post.controls.admin',
        className: 'show-post-admin-menu',
        icon: 'wrench' };
    });

    registerButton('delete', function (attrs) {
      if (attrs.canRecoverTopic) {
        return { action: 'recoverPost', title: 'topic.actions.recover', icon: 'undo', className: 'recover' };
      } else if (attrs.canDeleteTopic) {
        return { action: 'deletePost', title: 'topic.actions.delete', icon: 'trash-o', className: 'delete' };
      } else if (attrs.canRecover) {
        return { action: 'recoverPost', title: 'post.controls.undelete', icon: 'undo', className: 'recover' };
      } else if (attrs.canDelete) {
        return { action: 'deletePost', title: 'post.controls.delete', icon: 'trash-o', className: 'delete' };
      }
    });

    __exports__["default"] = createWidget('post-menu', {
      tagName: 'section.post-menu-area.clearfix',

      defaultState: function () {
        return { collapsed: true, likedUsers: [], adminVisible: false };
      },

      buildKey: function (attrs) {
        return 'post-menu-' + attrs.id;
      },

      attachButton: function (name, attrs) {
        var builder = _builders[name];
        if (builder) {
          var buttonAtts = builder(attrs, this.state, this.siteSettings);
          if (buttonAtts) {
            return this.attach('button', buttonAtts);
          }
        }
      },

      html: function (attrs, state) {
        var _this = this;

        var siteSettings = this.siteSettings;

        var hiddenSetting = siteSettings.post_menu_hidden_items || '';
        var hiddenButtons = hiddenSetting.split('|').filter(function (s) {
          return !attrs.bookmarked || s !== 'bookmark';
        });

        var allButtons = [];
        var visibleButtons = [];
        siteSettings.post_menu.split('|').forEach(function (i) {
          var button = _this.attachButton(i, attrs);
          if (button) {
            allButtons.push(button);
            if (attrs.yours && button.attrs.alwaysShowYours || hiddenButtons.indexOf(i) === -1) {
              visibleButtons.push(button);
            }
          }
        });

        // Only show ellipsis if there is more than one button hidden
        // if there are no more buttons, we are not collapsed
        if (!state.collapsed || allButtons.length <= visibleButtons.length + 1) {
          visibleButtons = allButtons;
          if (state.collapsed) {
            state.collapsed = false;
          }
        } else {
          var showMore = this.attach('button', {
            action: 'showMoreActions',
            title: 'show_more',
            className: 'show-more-actions',
            icon: 'ellipsis-h' });
          visibleButtons.splice(visibleButtons.length - 1, 0, showMore);
        }

        Object.keys(_extraButtons).forEach(function (k) {
          var builder = _extraButtons[k];
          if (builder) {
            var buttonAtts = builder(attrs, _this.state, _this.siteSettings);
            if (buttonAtts) {
              var position = buttonAtts.position;
              var beforeButton = buttonAtts.beforeButton;

              delete buttonAtts.position;

              var button = _this.attach('button', buttonAtts);

              if (beforeButton) {
                button = h('span', [beforeButton(h), button]);
              }

              if (button) {
                switch (position) {
                  case 'first':
                    visibleButtons.unshift(button);
                    break;
                  case 'second':
                    visibleButtons.splice(1, 0, button);
                    break;
                  case 'second-last-hidden':
                    if (!state.collapsed) {
                      visibleButtons.splice(visibleButtons.length - 2, 0, button);
                    }
                    break;
                  default:
                    visibleButtons.push(button);
                    break;
                }
              }
            }
          }
        });

        var postControls = [];

        var repliesButton = this.attachButton('replies', attrs);
        if (repliesButton) {
          postControls.push(repliesButton);
        }

        postControls.push(h('div.actions', visibleButtons));
        if (state.adminVisible) {
          postControls.push(this.attach('post-admin-menu', attrs));
        }

        var contents = [h('nav.post-controls.clearfix', postControls)];
        if (state.likedUsers.length) {
          contents.push(this.attach('small-user-list', {
            users: state.likedUsers,
            addSelf: attrs.liked,
            listClassName: 'who-liked',
            description: 'post.actions.people.like'
          }));
        }

        return contents;
      },

      openAdminMenu: function () {
        this.state.adminVisible = true;
      },

      closeAdminMenu: function () {
        this.state.adminVisible = false;
      },

      showMoreActions: function () {
        this.state.collapsed = false;
      },

      like: function () {
        var _this2 = this;

        var attrs = this.attrs;
        if (attrs.liked) {
          return this.sendWidgetAction('toggleLike');
        }

        var $heart = $('[data-post-id=' + attrs.id + '] .fa-heart');
        $heart.closest('button').addClass('has-like');

        var scale = [1.0, 1.5];
        return new Ember.RSVP.Promise(function (resolve) {
          animateHeart($heart, scale[0], scale[1], function () {
            animateHeart($heart, scale[1], scale[0], function () {
              _this2.sendWidgetAction('toggleLike').then(function () {
                return resolve();
              });
            });
          });
        });
      },

      refreshLikes: function () {
        if (this.state.likedUsers.length) {
          return this.getWhoLiked();
        }
      },

      getWhoLiked: function () {
        var attrs = this.attrs;
        var state = this.state;

        return this.store.find('post-action-user', { id: attrs.id, post_action_type_id: LIKE_ACTION }).then(function (users) {
          state.likedUsers = users.map(avatarAtts);
        });
      },

      toggleWhoLiked: function () {
        var state = this.state;
        if (state.likedUsers.length) {
          state.likedUsers = [];
        } else {
          return this.getWhoLiked();
        }
      }
    });
  });
define("discourse/widgets/post-placeholder", 
  ["discourse/widgets/widget","virtual-dom","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var h = __dependency2__.h;

    __exports__["default"] = createWidget('post-placeholder', {
      tagName: 'article.placeholder',

      html: function () {
        return h('div.row', [h('div.topic-avatar', h('div.placeholder-avatar')), h('div.topic-body', [h('div.placeholder-text'), h('div.placeholder-text'), h('div.placeholder-text')])]);
      }
    });
  });
define("discourse/widgets/post-small-action", 
  ["discourse/widgets/widget","discourse/widgets/raw-html","discourse/helpers/fa-icon","virtual-dom","discourse/components/small-action","discourse/widgets/post","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var RawHtml = __dependency2__["default"];
    var iconNode = __dependency3__.iconNode;
    var h = __dependency4__.h;
    var actionDescriptionHtml = __dependency5__.actionDescriptionHtml;
    var avatarFor = __dependency6__.avatarFor;

    var icons = {
      'closed.enabled': 'lock',
      'closed.disabled': 'unlock-alt',
      'autoclosed.enabled': 'lock',
      'autoclosed.disabled': 'unlock-alt',
      'archived.enabled': 'folder',
      'archived.disabled': 'folder-open',
      'pinned.enabled': 'thumb-tack',
      'pinned.disabled': 'thumb-tack unpinned',
      'pinned_globally.enabled': 'thumb-tack',
      'pinned_globally.disabled': 'thumb-tack unpinned',
      'visible.enabled': 'eye',
      'visible.disabled': 'eye-slash',
      'split_topic': 'sign-out',
      'invited_user': 'plus-circle',
      'removed_user': 'minus-circle',
      'public_topic': 'comment',
      'private_topic': 'envelope'
    };

    __exports__["default"] = createWidget('post-small-action', {
      buildKey: function (attrs) {
        return 'post-small-act-' + attrs.id;
      },
      tagName: 'div.small-action.onscreen-post.clearfix',

      buildId: function (attrs) {
        return 'post_' + attrs.post_number;
      },

      buildClasses: function (attrs) {
        if (attrs.deleted) {
          return 'deleted';
        }
      },

      html: function (attrs) {
        var contents = [];

        if (attrs.canDelete) {
          contents.push(this.attach('button', {
            icon: 'times',
            action: 'deletePost',
            title: 'post.controls.delete'
          }));
        }

        if (attrs.canEdit) {
          contents.push(this.attach('button', {
            icon: 'pencil',
            action: 'editPost',
            title: 'post.controls.edit'
          }));
        }

        contents.push(avatarFor.call(this, 'small', {
          template: attrs.avatar_template,
          username: attrs.avatar,
          url: attrs.usernameUrl
        }));

        var description = actionDescriptionHtml(attrs.actionCode, attrs.created_at, attrs.actionCodeWho);
        contents.push(new RawHtml({ html: '<p>' + description + '</p>' }));

        if (attrs.cooked) {
          contents.push(new RawHtml({ html: '<div class=\'custom-message\'>' + attrs.cooked + '</div>' }));
        }

        return [h('div.topic-avatar', iconNode(icons[attrs.actionCode] || 'exclamation')), h('div.small-action-desc', contents)];
      }
    });
  });
define("discourse/widgets/post-stream", 
  ["discourse/widgets/widget","discourse/lib/transform-post","discourse/lib/posts-with-placeholders","discourse/components/mount-widget","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    __exports__.preventCloak = preventCloak;
    __exports__.cloak = cloak;
    __exports__.uncloak = uncloak;
    var createWidget = __dependency1__.createWidget;
    var transformPost = __dependency2__["default"];
    var Placeholder = __dependency3__.Placeholder;
    var addWidgetCleanCallback = __dependency4__.addWidgetCleanCallback;

    var CLOAKING_ENABLED = !window.inTestEnv;
    var DAY = 1000 * 60 * 60 * 24;

    var _dontCloak = {};
    var _cloaked = {};

    function preventCloak(postId) {
      _dontCloak[postId] = true;
    }

    function cloak(post, component) {
      if (!CLOAKING_ENABLED || _cloaked[post.id] || _dontCloak[post.id]) {
        return;
      }

      var $post = $('#post_' + post.post_number);
      _cloaked[post.id] = $post.outerHeight();
      Ember.run.debounce(component, 'queueRerender', 1000);
    }

    function uncloak(post, component) {
      if (!CLOAKING_ENABLED || !_cloaked[post.id]) {
        return;
      }
      _cloaked[post.id] = null;
      component.queueRerender();
    }

    addWidgetCleanCallback('post-stream', function () {
      return _cloaked = {};
    });

    __exports__["default"] = createWidget('post-stream', {
      tagName: 'div.post-stream',

      html: function (attrs) {
        var posts = attrs.posts || [];
        var postArray = posts.toArray();

        var result = [];

        var before = attrs.gaps && attrs.gaps.before ? attrs.gaps.before : {};
        var after = attrs.gaps && attrs.gaps.after ? attrs.gaps.after : {};

        var prevPost = undefined;
        var prevDate = undefined;

        var mobileView = this.site.mobileView;
        for (var i = 0; i < postArray.length; i++) {
          var post = postArray[i];

          if (post instanceof Placeholder) {
            result.push(this.attach('post-placeholder'));
            continue;
          }

          var nextPost = i < postArray.length - 1 ? postArray[i + 1] : null;

          var transformed = transformPost(this.currentUser, this.site, post, prevPost, nextPost);
          transformed.canCreatePost = attrs.canCreatePost;
          transformed.mobileView = mobileView;

          if (transformed.canManage) {
            transformed.multiSelect = attrs.multiSelect;

            if (attrs.multiSelect) {
              transformed.selected = attrs.selectedQuery(post);
              transformed.selectedPostsCount = attrs.selectedPostsCount;
            }
          }

          if (attrs.searchService) {
            transformed.highlightTerm = attrs.searchService.highlightTerm;
          }

          // Post gap - before
          var beforeGap = before[post.id];
          if (beforeGap) {
            result.push(this.attach('post-gap', { pos: 'before', postId: post.id, gap: beforeGap }, { model: post }));
          }

          // Handle time gaps
          var curTime = new Date(transformed.created_at).getTime();
          if (prevDate) {
            var daysSince = Math.floor((curTime - prevDate) / DAY);
            if (daysSince > this.siteSettings.show_time_gap_days) {
              result.push(this.attach('time-gap', { daysSince: daysSince }));
            }
          }
          prevDate = curTime;

          var height = _cloaked[post.id];
          if (height) {
            transformed.cloaked = true;
            transformed.height = height;
          }

          if (transformed.isSmallAction) {
            result.push(this.attach('post-small-action', transformed, { model: post }));
          } else {
            result.push(this.attach('post', transformed, { model: post }));
          }

          // Post gap - after
          var afterGap = after[post.id];
          if (afterGap) {
            result.push(this.attach('post-gap', { pos: 'after', postId: post.id, gap: afterGap }, { model: post }));
          }

          prevPost = post;
        }
        return result;
      }
    });
  });
define("discourse/widgets/post", 
  ["discourse/widgets/post-cooked","discourse/widgets/decorator-helper","discourse/widgets/widget","discourse/helpers/fa-icon","discourse/lib/transform-post","virtual-dom","discourse/lib/url","discourse/helpers/node","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __exports__) {
    "use strict";
    __exports__.avatarImg = avatarImg;
    __exports__.avatarFor = avatarFor;
    var PostCooked = __dependency1__["default"];
    var DecoratorHelper = __dependency2__["default"];
    var createWidget = __dependency3__.createWidget;
    var applyDecorators = __dependency3__.applyDecorators;
    var iconNode = __dependency4__.iconNode;
    var transformBasicPost = __dependency5__.transformBasicPost;
    var h = __dependency6__.h;
    var DiscourseURL = __dependency7__["default"];
    var dateNode = __dependency8__.dateNode;

    function avatarImg(wanted, attrs) {
      var size = Discourse.Utilities.translateSize(wanted);
      var url = Discourse.Utilities.avatarUrl(attrs.template, size);

      // We won't render an invalid url
      if (!url || url.length === 0) {
        return;
      }
      var title = attrs.username;

      var properties = {
        attributes: { alt: '', width: size, height: size, src: Discourse.getURLWithCDN(url), title: title },
        className: 'avatar'
      };

      return h('img', properties);
    }

    function avatarFor(wanted, attrs) {
      return h('a', {
        className: 'trigger-user-card ' + (attrs.className || ''),
        attributes: { href: attrs.url, 'data-user-card': attrs.username }
      }, avatarImg(wanted, attrs));
    }

    createWidget('select-post', {
      tagName: 'div.select-posts',

      html: function (attrs) {
        var buttons = [];

        if (attrs.replyCount > 0 && !attrs.selected) {
          buttons.push(this.attach('button', { label: 'topic.multi_select.select_replies', action: 'selectReplies' }));
        }

        var selectPostKey = attrs.selected ? 'topic.multi_select.selected' : 'topic.multi_select.select';
        buttons.push(this.attach('button', { className: 'select-post',
          label: selectPostKey,
          labelOptions: { count: attrs.selectedPostsCount },
          action: 'selectPost' }));
        return buttons;
      }
    });

    createWidget('reply-to-tab', {
      tagName: 'a.reply-to-tab',
      buildKey: function (attrs) {
        return 'reply-to-tab-' + attrs.id;
      },

      defaultState: function () {
        return { loading: false };
      },

      html: function (attrs, state) {
        if (state.loading) {
          return I18n.t('loading');
        }

        return [iconNode('mail-forward'), ' ', avatarImg('small', {
          template: attrs.replyToAvatarTemplate,
          username: attrs.replyToUsername
        }), ' ', h('span', attrs.replyToUsername)];
      },

      click: function () {
        var _this = this;

        this.state.loading = true;
        this.sendWidgetAction('toggleReplyAbove').then(function () {
          return _this.state.loading = false;
        });
      }
    });

    createWidget('post-avatar', {
      tagName: 'div.topic-avatar',

      settings: {
        size: 'large'
      },

      html: function (attrs) {
        var body = undefined;
        if (!attrs.user_id) {
          body = h('i', { className: 'fa fa-trash-o deleted-user-avatar' });
        } else {
          body = avatarFor.call(this, this.settings.size, {
            template: attrs.avatar_template,
            username: attrs.username,
            url: attrs.usernameUrl,
            className: 'main-avatar'
          });
        }

        return [body, h('div.poster-avatar-extra')];
      }
    });

    createWidget('wiki-edit-button', {
      tagName: 'div.post-info.wiki',
      title: 'post.wiki.about',

      html: function () {
        return iconNode('pencil-square-o');
      },

      click: function () {
        this.sendWidgetAction('editPost');
      }
    });

    createWidget('post-email-indicator', {
      tagName: 'div.post-info.via-email',

      title: function (attrs) {
        return attrs.isAutoGenerated ? I18n.t('post.via_auto_generated_email') : I18n.t('post.via_email');
      },

      buildClasses: function (attrs) {
        return attrs.canViewRawEmail ? 'raw-email' : null;
      },

      html: function (attrs) {
        return attrs.isAutoGenerated ? iconNode('envelope') : iconNode('envelope-o');
      },

      click: function () {
        if (this.attrs.canViewRawEmail) {
          this.sendWidgetAction('showRawEmail');
        }
      }
    });

    function showReplyTab(attrs, siteSettings) {
      return attrs.replyToUsername && (!attrs.replyDirectlyAbove || !siteSettings.suppress_reply_directly_above);
    }

    createWidget('post-meta-data', {
      tagName: 'div.topic-meta-data',
      html: function (attrs) {
        var result = [this.attach('poster-name', attrs)];

        if (attrs.isWhisper) {
          result.push(h('div.post-info.whisper', {
            attributes: { title: I18n.t('post.whisper') }
          }, iconNode('eye-slash')));
        }

        var createdAt = new Date(attrs.created_at);
        if (createdAt) {
          result.push(h('div.post-info', h('a.post-date', {
            attributes: {
              href: attrs.shareUrl,
              'data-share-url': attrs.shareUrl,
              'data-post-number': attrs.post_number
            }
          }, dateNode(createdAt))));
        }

        if (attrs.via_email) {
          result.push(this.attach('post-email-indicator', attrs));
        }

        if (attrs.version > 1) {
          result.push(this.attach('post-edits-indicator', attrs));
        }

        if (attrs.wiki) {
          result.push(this.attach('wiki-edit-button', attrs));
        }

        if (attrs.multiSelect) {
          result.push(this.attach('select-post', attrs));
        }

        if (showReplyTab(attrs, this.siteSettings)) {
          result.push(this.attach('reply-to-tab', attrs));
        }

        result.push(h('div.read-state', {
          className: attrs.read ? 'read' : null,
          attributes: {
            title: I18n.t('post.unread')
          }
        }, iconNode('circle')));

        return result;
      }
    });

    createWidget('expand-hidden', {
      tagName: 'a.expand-hidden',

      html: function () {
        return I18n.t('post.show_hidden');
      },

      click: function () {
        this.sendWidgetAction('expandHidden');
      }
    });

    createWidget('expand-post-button', {
      tagName: 'button.btn.expand-post',
      buildKey: function (attrs) {
        return 'expand-post-button-' + attrs.id;
      },

      defaultState: function () {
        return { loadingExpanded: false };
      },

      html: function (attrs, state) {
        if (state.loadingExpanded) {
          return I18n.t('loading');
        } else {
          return [I18n.t('post.show_full'), "..."];
        }
      },

      click: function () {
        this.state.loadingExpanded = true;
        this.sendWidgetAction('expandFirstPost');
      }
    });

    createWidget('post-contents', {
      buildKey: function (attrs) {
        return 'post-contents-' + attrs.id;
      },

      defaultState: function () {
        return { expandedFirstPost: false, repliesBelow: [] };
      },

      buildClasses: function (attrs) {
        var classes = ['regular'];
        if (!this.state.repliesShown) {
          classes.push('contents');
        }
        if (showReplyTab(attrs, this.siteSettings)) {
          classes.push('avoid-tab');
        }
        return classes;
      },

      html: function (attrs, state) {
        var _this2 = this;

        var result = [new PostCooked(attrs, new DecoratorHelper(this))];
        result = result.concat(applyDecorators(this, 'after-cooked', attrs, state));

        if (attrs.cooked_hidden) {
          result.push(this.attach('expand-hidden', attrs));
        }

        if (!state.expandedFirstPost && attrs.expandablePost) {
          result.push(this.attach('expand-post-button', attrs));
        }

        var extraState = { state: { repliesShown: !!state.repliesBelow.length } };
        result.push(this.attach('post-menu', attrs, extraState));

        var repliesBelow = state.repliesBelow;
        if (repliesBelow.length) {
          result.push(h('section.embedded-posts.bottom', repliesBelow.map(function (p) {
            return _this2.attach('embedded-post', p);
          })));
        }

        return result;
      },

      toggleRepliesBelow: function () {
        var _this3 = this;

        if (this.state.repliesBelow.length) {
          this.state.repliesBelow = [];
          return;
        }

        var post = this.findAncestorModel();
        var topicUrl = post ? post.get('topic.url') : null;
        return this.store.find('post-reply', { postId: this.attrs.id }).then(function (posts) {
          _this3.state.repliesBelow = posts.map(function (p) {
            p.shareUrl = topicUrl + '/' + p.post_number;
            return transformBasicPost(p);
          });
        });
      },

      expandFirstPost: function () {
        var _this4 = this;

        var post = this.findAncestorModel();
        return post.expand().then(function () {
          return _this4.state.expandedFirstPost = true;
        });
      }
    });

    createWidget('post-body', {
      tagName: 'div.topic-body',

      html: function (attrs) {
        var postContents = this.attach('post-contents', attrs);
        var result = [this.attach('post-meta-data', attrs), postContents];

        result.push(this.attach('actions-summary', attrs));
        if (attrs.showTopicMap) {
          result.push(this.attach('topic-map', attrs));
        }

        return result;
      }
    });

    createWidget('post-article', {
      tagName: 'article.boxed.onscreen-post',
      buildKey: function (attrs) {
        return 'post-article-' + attrs.id;
      },

      defaultState: function () {
        return { repliesAbove: [] };
      },

      buildId: function (attrs) {
        return 'post_' + attrs.post_number;
      },

      buildClasses: function (attrs) {
        var classNames = [];
        if (attrs.via_email) {
          classNames.push('via-email');
        }
        if (attrs.isAutoGenerated) {
          classNames.push('is-auto-generated');
        }
        return classNames;
      },

      buildAttributes: function (attrs) {
        return { 'data-post-id': attrs.id, 'data-user-id': attrs.user_id };
      },

      html: function (attrs, state) {
        var _this5 = this;

        var rows = [h('a.tabLoc', { attributes: { href: '' } })];
        if (state.repliesAbove.length) {
          var replies = state.repliesAbove.map(function (p) {
            return _this5.attach('embedded-post', p, { state: { above: true } });
          });
          rows.push(h('div.row', h('section.embedded-posts.top.topic-body.offset2', replies)));
        }

        rows.push(h('div.row', [this.attach('post-avatar', attrs), this.attach('post-body', attrs), this.attach('post-gutter', attrs)]));
        return rows;
      },

      _getTopicUrl: function () {
        var post = this.findAncestorModel();
        return post ? post.get('topic.url') : null;
      },

      toggleReplyAbove: function () {
        var _this6 = this;

        var replyPostNumber = this.attrs.reply_to_post_number;

        // jump directly on mobile
        if (this.attrs.mobileView) {
          var topicUrl = this._getTopicUrl();
          if (topicUrl) {
            DiscourseURL.routeTo(topicUrl + '/' + replyPostNumber);
          }
          return Ember.RSVP.Promise.resolve();
        }

        if (this.state.repliesAbove.length) {
          this.state.repliesAbove = [];
          return Ember.RSVP.Promise.resolve();
        } else {
          var _ret = (function () {
            var topicUrl = _this6._getTopicUrl();
            return {
              v: _this6.store.find('post-reply-history', { postId: _this6.attrs.id }).then(function (posts) {
                _this6.state.repliesAbove = posts.map(function (p) {
                  p.shareUrl = topicUrl + '/' + p.post_number;
                  return transformBasicPost(p);
                });
              })
            };
          })();

          if (typeof _ret === 'object') return _ret.v;
        }
      }

    });

    __exports__["default"] = createWidget('post', {
      buildKey: function (attrs) {
        return 'post-' + attrs.id;
      },
      shadowTree: true,

      buildAttributes: function (attrs) {
        return attrs.cloaked ? { style: 'height: ' + attrs.height + 'px' } : undefined;
      },

      buildId: function (attrs) {
        return attrs.cloaked ? 'post_' + attrs.post_number : undefined;
      },

      buildClasses: function (attrs) {
        if (attrs.cloaked) {
          return 'cloaked-post';
        }
        var classNames = ['topic-post', 'clearfix'];

        if (attrs.selected) {
          classNames.push('selected');
        }
        if (attrs.topicOwner) {
          classNames.push('topic-owner');
        }
        if (attrs.hidden) {
          classNames.push('post-hidden');
        }
        if (attrs.deleted) {
          classNames.push('deleted');
        }
        if (attrs.primary_group_name) {
          classNames.push('group-' + attrs.primary_group_name);
        }
        if (attrs.wiki) {
          classNames.push('wiki');
        }
        if (attrs.isWhisper) {
          classNames.push('whisper');
        }
        if (attrs.isModeratorAction || attrs.isWarning && attrs.firstPost) {
          classNames.push('moderator');
        } else {
          classNames.push('regular');
        }
        return classNames;
      },

      html: function (attrs) {
        if (attrs.cloaked) {
          return '';
        }

        return this.attach('post-article', attrs);
      },

      toggleLike: function () {
        var _this7 = this;

        var post = this.model;
        var likeAction = post.get('likeAction');

        if (likeAction && likeAction.get('canToggle')) {
          return likeAction.togglePromise(post).then(function (result) {
            return _this7._warnIfClose(result);
          });
        }
      },

      _warnIfClose: function (result) {
        if (!result || !result.acted) {
          return;
        }

        var kvs = this.keyValueStore;
        var lastWarnedLikes = kvs.get('lastWarnedLikes');

        // only warn once per day
        var yesterday = new Date().getTime() - 1000 * 60 * 60 * 24;
        if (lastWarnedLikes && parseInt(lastWarnedLikes) > yesterday) {
          return;
        }

        var remaining = result.remaining;
        var max = result.max;

        var threshold = Math.ceil(max * 0.1);
        if (remaining === threshold) {
          bootbox.alert(I18n.t('post.few_likes_left'));
          kvs.set({ key: 'lastWarnedLikes', value: new Date().getTime() });
        }
      },

      undoPostAction: function (typeId) {
        var post = this.model;
        return post.get('actions_summary').findProperty('id', typeId).undo(post);
      },

      deferPostActionFlags: function (typeId) {
        var post = this.model;
        return post.get('actions_summary').findProperty('id', typeId).deferFlags(post);
      }
    });
  });
define("discourse/widgets/poster-name", 
  ["discourse/helpers/fa-icon","discourse/widgets/widget","virtual-dom","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var iconNode = __dependency1__.iconNode;
    var createWidget = __dependency2__.createWidget;
    var h = __dependency3__.h;

    function sanitizeName(name) {
      return name.toLowerCase().replace(/[\s_-]/g, '');
    }

    __exports__["default"] = createWidget('poster-name', {
      tagName: 'div.names.trigger-user-card',

      // TODO: Allow extensibility
      posterGlyph: function (attrs) {
        if (attrs.moderator) {
          return iconNode('shield', { title: I18n.t('user.moderator_tooltip') });
        }
      },

      userLink: function (attrs, text) {
        return h('a', { attributes: {
            href: attrs.usernameUrl,
            'data-auto-route': true,
            'data-user-card': attrs.username
          } }, text);
      },

      html: function (attrs) {
        var username = attrs.username;
        var classNames = ['username'];

        if (attrs.staff) {
          classNames.push('staff');
        }
        if (attrs.admin) {
          classNames.push('admin');
        }
        if (attrs.moderator) {
          classNames.push('moderator');
        }
        if (attrs.new_user) {
          classNames.push('new-user');
        }

        var primaryGroupName = attrs.primary_group_name;
        if (primaryGroupName && primaryGroupName.length) {
          classNames.push(primaryGroupName);
        }
        var nameContents = [this.userLink(attrs, attrs.username)];
        var glyph = this.posterGlyph(attrs);
        if (glyph) {
          nameContents.push(glyph);
        }

        var contents = [h('span', { className: classNames.join(' ') }, nameContents)];
        var name = attrs.name;
        if (name && this.siteSettings.display_name_on_posts && sanitizeName(name) !== sanitizeName(username)) {
          contents.push(h('span.full-name', this.userLink(attrs, name)));
        }
        var title = attrs.user_title;
        if (title && title.length) {
          var titleContents = title;
          if (primaryGroupName) {
            var href = Discourse.getURL('/groups/' + primaryGroupName);
            titleContents = h('a.user-group', { attributes: { href: href } }, title);
          }
          contents.push(h('span.user-title', titleContents));
        }

        return contents;
      }
    });
  });
define("discourse/widgets/private-message-map", 
  ["discourse/helpers/fa-icon","discourse/widgets/widget","virtual-dom","discourse/widgets/post","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var iconNode = __dependency1__.iconNode;
    var createWidget = __dependency2__.createWidget;
    var h = __dependency3__.h;
    var avatarFor = __dependency4__.avatarFor;

    createWidget('pm-map-user-group', {
      tagName: 'div.user.group',

      html: function (attrs) {
        var link = h('a', { attributes: { href: Discourse.getURL('/groups/' + attrs.name) } }, attrs.name);
        return [iconNode('users'), ' ', link];
      }
    });

    createWidget('pm-remove-link', {
      tagName: 'a.remove-invited',

      html: function () {
        return iconNode('times');
      },

      click: function () {
        var _this = this;

        bootbox.confirm(I18n.t("private_message_info.remove_allowed_user", { name: this.attrs.username }), function (confirmed) {
          if (confirmed) {
            _this.sendWidgetAction('removeAllowedUser', _this.attrs);
          }
        });
      }
    });

    createWidget('pm-map-user', {
      tagName: 'div.user',

      html: function (attrs) {
        var user = attrs.user;
        var avatar = avatarFor('small', { template: user.avatar_template, username: user.username });
        var link = h('a', { attributes: { href: user.get('path') } }, [avatar, ' ', user.username]);

        var result = [link];
        if (attrs.canRemoveAllowedUsers) {
          result.push(' ');
          result.push(this.attach('pm-remove-link', user));
        }

        return result;
      }
    });

    __exports__["default"] = createWidget('private-message-map', {
      tagName: 'section.information.private-message-map',

      html: function (attrs) {
        var _this2 = this;

        var participants = [];

        if (attrs.allowedGroups.length) {
          participants.push(attrs.allowedGroups.map(function (ag) {
            return _this2.attach('pm-map-user-group', ag);
          }));
        }

        if (attrs.allowedUsers.length) {
          participants.push(attrs.allowedUsers.map(function (ag) {
            return _this2.attach('pm-map-user', { user: ag, canRemoveAllowedUsers: attrs.canRemoveAllowedUsers });
          }));
        }

        var result = [h('h3', [iconNode('envelope'), ' ', I18n.t('private_message_info.title')]), h('div.participants.clearfix', participants)];

        if (attrs.canInvite) {
          result.push(h('div.controls', this.attach('button', {
            action: 'showInvite',
            label: 'private_message_info.invite',
            className: 'btn'
          })));
        }

        return result;
      }
    });
  });
define("discourse/widgets/raw-html", 
  ["exports"],
  function(__exports__) {
    "use strict";
    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    var RawHtml = (function () {
      function RawHtml(attrs) {
        _classCallCheck(this, RawHtml);

        this.html = attrs.html;
      }

      _createClass(RawHtml, [{
        key: 'init',
        value: function init() {
          var $html = $(this.html);
          this.decorate($html);
          return $html[0];
        }
      }, {
        key: 'decorate',
        value: function decorate() {}
      }, {
        key: 'update',
        value: function update(prev) {
          if (prev.html === this.html) {
            return;
          }
          return this.init();
        }
      }, {
        key: 'destroy',
        value: function destroy() {}
      }]);

      return RawHtml;
    })();

    __exports__["default"] = RawHtml;

    RawHtml.prototype.type = 'Widget';
  });
define("discourse/widgets/search-menu-controls", 
  ["discourse/lib/search","virtual-dom","discourse/widgets/widget"],
  function(__dependency1__, __dependency2__, __dependency3__) {
    "use strict";
    var searchContextDescription = __dependency1__.searchContextDescription;
    var h = __dependency2__.h;
    var createWidget = __dependency3__.createWidget;

    createWidget('search-term', {
      tagName: 'input',
      buildId: function () {
        return 'search-term';
      },

      buildAttributes: function (attrs) {
        return { type: 'text',
          value: attrs.value || '',
          placeholder: attrs.contextEnabled ? "" : I18n.t('search.title') };
      },

      keyUp: function (e) {
        if (e.which === 13) {
          return this.sendWidgetAction('fullSearch');
        }

        var val = this.attrs.value;
        var newVal = $('#' + this.buildId()).val();

        if (newVal !== val) {
          this.sendWidgetAction('searchTermChanged', newVal);
        }
      }
    });

    createWidget('search-context', {
      tagName: 'div.search-context',

      html: function (attrs) {
        var service = this.container.lookup('search-service:main');
        var ctx = service.get('searchContext');

        var result = [];
        if (ctx) {
          var description = searchContextDescription(Ember.get(ctx, 'type'), Ember.get(ctx, 'user.username') || Ember.get(ctx, 'category.name'));
          result.push(h('label', [h('input', { type: 'checkbox', checked: attrs.contextEnabled }), ' ', description]));
        }

        result.push(this.attach('link', { action: 'showSearchHelp',
          label: 'show_help',
          className: 'show-help' }));
        result.push(h('div.clearfix'));
        return result;
      },

      click: function () {
        var val = $('.search-context input').is(':checked');
        if (val !== this.attrs.contextEnabled) {
          this.sendWidgetAction('searchContextChanged', val);
        }
      }
    });
  });
define("discourse/widgets/search-menu-results", 
  ["discourse/widgets/post","discourse/helpers/node","discourse/widgets/raw-html","discourse/widgets/widget","virtual-dom","discourse/helpers/fa-icon"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__) {
    "use strict";
    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var avatarImg = __dependency1__.avatarImg;
    var dateNode = __dependency2__.dateNode;
    var RawHtml = __dependency3__["default"];
    var createWidget = __dependency4__.createWidget;
    var h = __dependency5__.h;
    var iconNode = __dependency6__.iconNode;

    var Highlighted = (function (_RawHtml) {
      _inherits(Highlighted, _RawHtml);

      function Highlighted(html, term) {
        _classCallCheck(this, Highlighted);

        _get(Object.getPrototypeOf(Highlighted.prototype), 'constructor', this).call(this, { html: '<span>' + html + '</span>' });
        this.term = term;
      }

      _createClass(Highlighted, [{
        key: 'decorate',
        value: function decorate($html) {
          if (this.term) {
            $html.highlight(this.term.split(/\s+/), { className: 'search-highlight' });
          }
        }
      }]);

      return Highlighted;
    })(RawHtml);

    function createSearchResult(type, linkField, fn) {
      return createWidget('search-result-' + type, {
        html: function (attrs) {
          var _this = this;

          return attrs.results.map(function (r) {
            return h('li', _this.attach('link', {
              href: r.get(linkField),
              contents: function () {
                return fn.call(_this, r, attrs.term);
              },
              className: 'search-link'
            }));
          });
        }
      });
    }

    function postResult(result, link, term) {
      var html = [link];

      if (!this.site.mobileView) {
        html.push(h('span.blurb', [dateNode(result.created_at), ' - ', new Highlighted(result.blurb, term)]));
      }

      return html;
    }

    createSearchResult('user', 'path', function (u) {
      return [avatarImg('small', { template: u.avatar_template, username: u.username }), ' ', u.username];
    });

    createSearchResult('topic', 'url', function (result, term) {
      var topic = result.topic;
      var link = h('span.topic', [this.attach('topic-status', { topic: topic, disableActions: true }), h('span.topic-title', new Highlighted(topic.get('fancyTitle'), term)), this.attach('category-link', { category: topic.get('category'), link: false })]);

      return postResult.call(this, result, link, term);
    });

    createSearchResult('post', 'url', function (result, term) {
      return postResult.call(this, result, I18n.t('search.post_format', result), term);
    });

    createSearchResult('category', 'url', function (c) {
      return this.attach('category-link', { category: c, link: false });
    });

    createWidget('search-menu-results', {
      tagName: 'div.results',

      html: function (attrs) {
        var _this2 = this;

        if (attrs.noResults) {
          return h('div.no-results', I18n.t('search.no_results'));
        }

        var results = attrs.results;
        var resultTypes = results.resultTypes || [];
        return resultTypes.map(function (rt) {
          var more = [];

          var moreArgs = {
            className: 'filter',
            contents: function () {
              return [I18n.t('show_more'), ' ', iconNode('chevron-down')];
            }
          };

          if (rt.moreUrl) {
            more.push(_this2.attach('link', $.extend(moreArgs, { href: rt.moreUrl })));
          } else if (rt.more) {
            more.push(_this2.attach('link', $.extend(moreArgs, { action: "moreOfType",
              actionParam: rt.type,
              className: "filter filter-type" })));
          }

          return [h('ul', _this2.attach(rt.componentName, { results: rt.results, term: attrs.term })), h('div.no-results', more)];
        });
      }
    });
  });
define("discourse/widgets/search-menu", 
  ["discourse/lib/search","discourse/widgets/widget","virtual-dom","discourse/lib/url","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var searchForTerm = __dependency1__.searchForTerm;
    var isValidSearchTerm = __dependency1__.isValidSearchTerm;
    var createWidget = __dependency2__.createWidget;
    var h = __dependency3__.h;
    var DiscourseURL = __dependency4__["default"];

    // Helps with debouncing and cancelling promises
    var SearchHelper = {
      _activeSearch: null,
      _cancelSearch: null,

      // for cancelling debounced search
      cancel: function () {
        var _this = this;

        if (this._activeSearch) {
          this._activeSearch.abort();
        }

        this._cancelSearch = true;
        Ember.run.later(function () {
          return _this._cancelSearch = false;
        }, 400);
      },

      perform: function (widget) {
        var _this2 = this;

        if (this._cancelSearch) {
          this._cancelSearch = null;
          return;
        }

        if (this._activeSearch) {
          this._activeSearch.abort();
          this._activeSearch = null;
        }

        var state = widget.state;
        var term = state.term;
        var typeFilter = state.typeFilter;
        var contextEnabled = state.contextEnabled;

        var searchContext = contextEnabled ? widget.searchContext() : null;
        var fullSearchUrl = widget.fullSearchUrl();

        if (!isValidSearchTerm(term)) {
          state.noResults = true;
          state.results = [];
          state.loading = false;
          widget.scheduleRerender();
        } else {
          this._activeSearch = searchForTerm(term, { typeFilter: typeFilter, searchContext: searchContext, fullSearchUrl: fullSearchUrl });
          this._activeSearch.then(function (content) {
            state.noResults = content.resultTypes.length === 0;
            state.results = content;
          }).finally(function () {
            state.loading = false;
            widget.scheduleRerender();
            _this2._activeSearch = null;
          });
        }
      }
    };

    __exports__["default"] = createWidget('search-menu', {
      tagName: 'div.search-menu',
      buildKey: function () {
        return 'search-menu';
      },

      defaultState: function () {
        return { loading: false,
          results: {},
          noResults: false,
          term: null,
          typeFilter: null };
      },

      fullSearchUrl: function () {
        var state = this.state;
        var contextEnabled = state.contextEnabled;

        var ctx = contextEnabled ? this.searchContext() : null;
        var type = Ember.get(ctx, 'type');

        if (contextEnabled && type === 'topic') {
          return;
        }

        var url = '/search?q=' + encodeURIComponent(state.term);
        if (contextEnabled) {
          if (ctx.id.toString().toLowerCase() === this.currentUser.username_lower && type === "private_messages") {
            url += ' in:private';
          } else {
            url += encodeURIComponent(" " + type + ":" + ctx.id);
          }
        }

        return Discourse.getURL(url);
      },

      panelContents: function () {
        var state = this.state;

        var contextEnabled = state.contextEnabled;

        var results = [this.attach('search-term', { value: state.term, contextEnabled: contextEnabled }), this.attach('search-context', { contextEnabled: contextEnabled })];

        if (state.loading) {
          results.push(h('div.searching', h('div.spinner')));
        } else {
          results.push(this.attach('search-menu-results', { term: state.term,
            noResults: state.noResults,
            results: state.results }));
        }

        return results;
      },

      searchService: function () {
        if (!this._searchService) {
          this._searchService = this.container.lookup('search-service:main');
        }
        return this._searchService;
      },

      searchContext: function () {
        if (!this._searchContext) {
          this._searchContext = this.searchService().get('searchContext');
        }
        return this._searchContext;
      },

      html: function (attrs, state) {
        var _this3 = this;

        state.contextEnabled = attrs.contextEnabled;

        return this.attach('menu-panel', { maxWidth: 500, contents: function () {
            return _this3.panelContents();
          } });
      },

      clickOutside: function () {
        this.sendWidgetAction('toggleSearchMenu');
      },

      triggerSearch: function () {
        var state = this.state;

        state.noResults = false;
        if (isValidSearchTerm(state.term)) {
          this.searchService().set('highlightTerm', state.term);
          state.loading = true;
          Ember.run.debounce(SearchHelper, SearchHelper.perform, this, 400);
        } else {
          state.results = [];
        }
      },

      moreOfType: function (type) {
        this.state.typeFilter = type;
        this.triggerSearch();
      },

      searchContextChanged: function (enabled) {
        this.state.typeFilter = null;
        this.sendWidgetAction('searchMenuContextChanged', enabled);
        this.state.contextEnabled = enabled;
        this.triggerSearch();
      },

      searchTermChanged: function (term) {
        this.state.typeFilter = null;
        this.state.term = term;
        this.triggerSearch();
      },

      fullSearch: function () {
        if (!isValidSearchTerm(this.state.term)) {
          return;
        }

        SearchHelper.cancel();
        var url = this.fullSearchUrl();
        if (url) {
          this.sendWidgetEvent('linkClicked');
          DiscourseURL.routeTo(url);
        }
      }
    });
  });
define("discourse/widgets/time-gap", 
  ["discourse/widgets/widget","virtual-dom","discourse/helpers/fa-icon","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var h = __dependency2__.h;
    var iconNode = __dependency3__.iconNode;

    function description(attrs) {
      var daysSince = attrs.daysSince;

      if (daysSince < 30) {
        return I18n.t('dates.later.x_days', { count: daysSince });
      } else if (daysSince < 365) {
        var gapMonths = Math.floor(daysSince / 30);
        return I18n.t('dates.later.x_months', { count: gapMonths });
      } else {
        var gapYears = Math.floor(daysSince / 365);
        return I18n.t('dates.later.x_years', { count: gapYears });
      }
    }

    __exports__["default"] = createWidget('time-gap', {
      tagName: 'div.time-gap.small-action.clearfix',

      html: function (attrs) {
        return [h('div.topic-avatar', iconNode('clock-o')), h('div.small-action-desc', description(attrs))];
      }
    });
  });
define("discourse/widgets/toggle-topic-summary", 
  ["discourse/widgets/raw-html","discourse/widgets/widget","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var RawHtml = __dependency1__["default"];
    var createWidget = __dependency2__.createWidget;

    createWidget('toggle-summary-description', {
      description: function (attrs) {
        if (attrs.topicSummaryEnabled) {
          return I18n.t('summary.enabled_description');
        }

        if (attrs.topicWordCount) {
          var readingTime = Math.floor(attrs.topicWordCount / this.siteSettings.read_time_word_count);
          return I18n.t('summary.description_time', { replyCount: attrs.topicReplyCount, readingTime: readingTime });
        }
        return I18n.t('summary.description', { replyCount: attrs.topicReplyCount });
      },

      html: function (attrs) {
        // vdom makes putting html in the i18n difficult
        return new RawHtml({ html: '<p>' + this.description(attrs) + '</p>' });
      }
    });

    __exports__["default"] = createWidget('toggle-topic-summary', {
      tagName: 'section.information.toggle-summary',
      html: function (attrs) {
        return [this.attach('toggle-summary-description', attrs), this.attach('button', {
          className: 'btn btn-primary',
          label: attrs.topicSummaryEnabled ? 'summary.disable' : 'summary.enable',
          action: 'toggleSummary'
        })];
      }
    });
  });
define("discourse/widgets/topic-map", 
  ["discourse/widgets/widget","virtual-dom","discourse/widgets/post","discourse/helpers/node","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var h = __dependency2__.h;
    var avatarImg = __dependency3__.avatarImg;
    var avatarFor = __dependency3__.avatarFor;
    var dateNode = __dependency4__.dateNode;
    var numberNode = __dependency4__.numberNode;

    var LINKS_SHOWN = 5;

    function renderParticipants(userFilters, participants) {
      var _this = this;

      if (!participants) {
        return;
      }

      userFilters = userFilters || [];
      return participants.map(function (p) {
        return _this.attach('topic-participant', p, { state: { toggled: userFilters.contains(p.username) } });
      });
    }

    createWidget('topic-map-show-links', {
      tagName: 'div.link-summary',
      html: function (attrs) {
        return h('a', I18n.t('topic_map.links_shown', { totalLinks: attrs.totalLinks }));
      },

      click: function () {
        this.sendWidgetAction('showAllLinks');
      }
    });

    createWidget('topic-participant', {
      html: function (attrs, state) {
        var linkContents = [avatarImg('medium', { username: attrs.username, template: attrs.avatar_template })];

        if (attrs.post_count > 2) {
          linkContents.push(h('span.post-count', attrs.post_count.toString()));
        }

        return h('a.poster.trigger-user-card', {
          className: state.toggled ? 'toggled' : null,
          attributes: { title: attrs.username, 'data-user-card': attrs.username }
        }, linkContents);
      }
    });

    createWidget('topic-map-summary', {
      tagName: 'section.map',

      buildClasses: function (attrs, state) {
        if (state.collapsed) {
          return 'map-collapsed';
        }
      },

      html: function (attrs, state) {
        var contents = [];
        contents.push(h('li', [h('h4', I18n.t('created_lowercase')), avatarFor('tiny', { username: attrs.createdByUsername, template: attrs.createdByAvatarTemplate }), dateNode(attrs.topicCreatedAt)]));
        contents.push(h('li', h('a', { attributes: { href: attrs.lastPostUrl } }, [h('h4', I18n.t('last_reply_lowercase')), avatarFor('tiny', { username: attrs.lastPostUsername, template: attrs.lastPostAvatarTemplate }), dateNode(attrs.lastPostAt)])));
        contents.push(h('li', [numberNode(attrs.topicReplyCount), h('h4', I18n.t('replies_lowercase', { count: attrs.topicReplyCount }))]));
        contents.push(h('li.secondary', [numberNode(attrs.topicViews, { className: attrs.topicViewsHeat }), h('h4', I18n.t('views_lowercase', { count: attrs.topicViews }))]));
        contents.push(h('li.secondary', [numberNode(attrs.participantCount), h('h4', I18n.t('users_lowercase', { count: attrs.participantCount }))]));

        if (attrs.topicLikeCount) {
          contents.push(h('li.secondary', [numberNode(attrs.topicLikeCount), h('h4', I18n.t('likes_lowercase', { count: attrs.topicLikeCount }))]));
        }

        if (attrs.topicLinkLength > 0) {
          contents.push(h('li.secondary', [numberNode(attrs.topicLinkLength), h('h4', I18n.t('links_lowercase', { count: attrs.topicLinkLength }))]));
        }

        if (state.collapsed && attrs.topicPostsCount > 2 && attrs.participants.length > 0) {
          var participants = renderParticipants.call(this, attrs.userFilters, attrs.participants.slice(0, 3));
          contents.push(h('li.avatars', participants));
        }

        return h('ul.clearfix', contents);
      }
    });

    createWidget('topic-map-link', {
      tagName: 'a.topic-link.track-link',

      buildClasses: function (attrs) {
        if (attrs.attachment) {
          return 'attachment';
        }
      },

      buildAttributes: function (attrs) {
        return { href: attrs.url,
          target: "_blank",
          'data-user-id': attrs.user_id,
          'data-ignore-post-id': 'true',
          title: attrs.url };
      },

      html: function (attrs) {
        if (attrs.title) {
          return attrs.title;
        }
        return attrs.url;
      }
    });

    createWidget('topic-map-expanded', {
      tagName: 'section.topic-map-expanded',
      buildKey: function (attrs) {
        return 'topic-map-expanded-' + attrs.id;
      },

      defaultState: function () {
        return { allLinksShown: false };
      },

      html: function (attrs, state) {
        var _this2 = this;

        var avatars = h('section.avatars.clearfix', [h('h3', I18n.t('topic_map.participants_title')), renderParticipants.call(this, attrs.userFilters, attrs.participants)]);

        var result = [avatars];
        if (attrs.topicLinks) {

          var toShow = state.allLinksShown ? attrs.topicLinks : attrs.topicLinks.slice(0, LINKS_SHOWN);
          var links = toShow.map(function (l) {

            var host = '';
            if (l.title && l.title.length) {
              var domain = l.domain;
              if (domain && domain.length) {
                var s = domain.split('.');
                host = h('span.domain', s[s.length - 2] + "." + s[s.length - 1]);
              }
            }

            return h('tr', [h('td', h('span.badge.badge-notification.clicks', {
              attributes: { title: I18n.t('topic_map.clicks', { count: l.clicks }) }
            }, l.clicks.toString())), h('td', [_this2.attach('topic-map-link', l), ' ', host])]);
          });

          var showAllLinksContent = [h('h3', I18n.t('topic_map.links_title')), h('table.topic-links', links)];

          if (!state.allLinksShown && links.length < attrs.topicLinks.length) {
            showAllLinksContent.push(this.attach('topic-map-show-links', { totalLinks: attrs.topicLinks.length }));
          }

          var section = h('section.links', showAllLinksContent);
          result.push(section);
        }
        return result;
      },

      showAllLinks: function () {
        this.state.allLinksShown = true;
      }
    });

    __exports__["default"] = createWidget('topic-map', {
      tagName: 'div.topic-map',
      buildKey: function (attrs) {
        return 'topic-map-' + attrs.id;
      },

      defaultState: function (attrs) {
        return { collapsed: !attrs.hasTopicSummary };
      },

      html: function (attrs, state) {
        var nav = h('nav.buttons', this.attach('button', {
          title: 'topic.toggle_information',
          icon: state.collapsed ? 'chevron-down' : 'chevron-up',
          action: 'toggleMap',
          className: 'btn'
        }));

        var contents = [nav, this.attach('topic-map-summary', attrs, { state: state })];

        if (!state.collapsed) {
          contents.push(this.attach('topic-map-expanded', attrs));
        }

        if (attrs.hasTopicSummary) {
          contents.push(this.attach('toggle-topic-summary', attrs));
        }

        if (attrs.showPMMap) {
          contents.push(this.attach('private-message-map', attrs));
        }
        return contents;
      },

      toggleMap: function () {
        this.state.collapsed = !this.state.collapsed;
      }
    });
  });
define("discourse/widgets/topic-status", 
  ["discourse/widgets/widget","discourse/helpers/fa-icon","virtual-dom","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var iconNode = __dependency2__.iconNode;
    var h = __dependency3__.h;

    function renderIcon(name, key, canAct) {
      var iconArgs = key === 'unpinned' ? { 'class': 'unpinned' } : null,
          icon = iconNode(name, iconArgs);

      var attributes = { title: Discourse.Utilities.escapeExpression(I18n.t('topic_statuses.' + key + '.help')) };
      return h((canAct ? 'a' : 'span') + '.topic-status', attributes, icon);
    }

    __exports__["default"] = createWidget('topic-status', {
      tagName: 'div.topic-statuses',

      html: function (attrs) {
        var topic = attrs.topic;
        var canAct = this.currentUser && !attrs.disableActions;

        var result = [];
        var renderIconIf = function (conditionProp, name, key) {
          if (!topic.get(conditionProp)) {
            return;
          }
          result.push(renderIcon(name, key, canAct));
        };

        renderIconIf('is_warning', 'envelope', 'warning');

        if (topic.get('closed') && topic.get('archived')) {
          renderIcon('lock', 'locked_and_archived');
        } else {
          renderIconIf('closed', 'lock', 'locked');
          renderIconIf('archived', 'lock', 'archived');
        }

        renderIconIf('pinned', 'thumb-tack', 'pinned');
        renderIconIf('unpinned', 'thumb-tack', 'unpinned');
        renderIconIf('invisible', 'eye-slash', 'invisible');

        return result;
      }
    });
  });
define("discourse/widgets/user-menu", 
  ["discourse/widgets/widget","virtual-dom","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var h = __dependency2__.h;

    createWidget('user-menu-links', {
      tagName: 'div.menu-links-header',

      html: function (attrs) {
        var _this = this;

        var currentUser = this.currentUser;
        var siteSettings = this.siteSettings;

        var isAnon = currentUser.is_anonymous;
        var allowAnon = siteSettings.allow_anonymous_posting && currentUser.trust_level >= siteSettings.anonymous_posting_min_trust_level || isAnon;

        var path = attrs.path;
        var glyphs = [{ label: 'user.bookmarks',
          className: 'user-bookmarks-link',
          icon: 'bookmark',
          href: path + '/activity/bookmarks' }];

        if (siteSettings.enable_private_messages) {
          glyphs.push({ label: 'user.private_messages',
            className: 'user-pms-link',
            icon: 'envelope',
            href: path + '/messages' });
        }

        var profileLink = {
          route: 'user',
          model: currentUser,
          className: 'user-activity-link',
          icon: 'user',
          rawLabel: currentUser.username
        };

        if (currentUser.is_anonymous) {
          profileLink.label = 'user.profile';
          profileLink.rawLabel = null;
        }

        var links = [profileLink];
        if (allowAnon) {
          if (!isAnon) {
            glyphs.push({ action: 'toggleAnonymous',
              label: 'switch_to_anon',
              className: 'enable-anonymous',
              icon: 'user-secret' });
          } else {
            links.push({ className: 'disable-anonymous',
              action: 'toggleAnonymous',
              label: 'switch_from_anon' });
          }
        }

        // preferences always goes last
        glyphs.push({ label: 'user.preferences',
          className: 'user-preferences-link',
          icon: 'gear',
          href: path + '/preferences' });

        return h('ul.menu-links-row', [links.map(function (l) {
          return h('li', _this.attach('link', l));
        }), h('li.glyphs', glyphs.map(function (l) {
          return _this.attach('link', $.extend(l, { hideLabel: true }));
        }))]);
      }
    });

    __exports__["default"] = createWidget('user-menu', {
      tagName: 'div.user-menu',

      panelContents: function () {
        var path = this.currentUser.get('path');

        return [this.attach('user-menu-links', { path: path }), this.attach('user-notifications', { path: path }), h('div.logout-link', [h('hr'), h('ul.menu-links', h('li', this.attach('link', { action: 'logout',
          className: 'logout',
          icon: 'sign-out',
          label: 'user.log_out' })))])];
      },

      html: function () {
        var _this2 = this;

        return this.attach('menu-panel', { contents: function () {
            return _this2.panelContents();
          } });
      },

      clickOutside: function () {
        this.sendWidgetAction('toggleUserMenu');
      }
    });
  });
define("discourse/widgets/user-notifications-large", 
  ["discourse/widgets/widget","virtual-dom","discourse/helpers/node","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var h = __dependency2__.h;
    var dateNode = __dependency3__.dateNode;

    createWidget('large-notification-item', {
      buildClasses: function (attrs) {
        var result = ['item', 'notification'];
        if (!attrs.get('read')) {
          result.push('unread');
        }
        return result;
      },

      html: function (attrs) {
        return [this.attach('notification-item', attrs), h('span.time', dateNode(attrs.created_at))];
      }
    });

    __exports__["default"] = createWidget('user-notifications-large', {
      html: function (attrs) {
        var _this = this;

        var notifications = attrs.notifications;
        return notifications.map(function (n) {
          return _this.attach('large-notification-item', n);
        });
      }
    });
  });
define("discourse/widgets/user-notifications", 
  ["discourse/widgets/widget","discourse/components/site-header","virtual-dom","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var createWidget = __dependency1__.createWidget;
    var headerHeight = __dependency2__.headerHeight;
    var h = __dependency3__.h;

    __exports__["default"] = createWidget('user-notifications', {
      tagName: 'div.notifications',
      buildKey: function () {
        return 'user-notifications';
      },

      defaultState: function () {
        return { notifications: [], loading: false };
      },

      notificationsChanged: function () {
        this.refreshNotifications(this.state);
      },

      refreshNotifications: function (state) {
        var _this = this;

        if (this.loading) {
          return;
        }

        // estimate (poorly) the amount of notifications to return
        var limit = Math.round(($(window).height() - headerHeight()) / 55);
        // we REALLY don't want to be asking for negative counts of notifications
        // less than 5 is also not that useful
        if (limit < 5) {
          limit = 5;
        }
        if (limit > 40) {
          limit = 40;
        }

        var stale = this.store.findStale('notification', { recent: true, limit: limit }, { cacheKey: 'recent-notifications' });

        if (stale.hasResults) {
          var results = stale.results;
          var content = results.get('content');

          // we have to truncate to limit, otherwise we will render too much
          if (content && content.length > limit) {
            content = content.splice(0, limit);
            results.set('content', content);
            results.set('totalRows', limit);
          }

          state.notifications = results;
        } else {
          state.loading = true;
        }

        stale.refresh().then(function (notifications) {
          _this.currentUser.set('unread_notifications', 0);
          state.notifications = notifications;
        }).catch(function () {
          state.notifications = [];
        }).finally(function () {
          state.loading = false;
          _this.scheduleRerender();
        });
      },

      html: function (attrs, state) {
        var _this2 = this;

        if (!state.notifications.length) {
          this.refreshNotifications(state);
        }

        var result = [];
        if (state.loading) {
          result.push(h('div.spinner-container', h('div.spinner')));
        } else if (state.notifications.length) {

          var notificationItems = state.notifications.map(function (n) {
            return _this2.attach('notification-item', n);
          });
          var href = attrs.path + '/notifications';

          result.push(h('hr'));
          result.push(h('ul', [notificationItems, h('li.read.last.heading', h('a', { attributes: { href: href } }, [I18n.t('notifications.more'), '...']))]));
        }

        return result;
      }
    });
  });
define("discourse/widgets/widget", 
  ["discourse/widgets/hooks","virtual-dom","discourse/widgets/decorator-helper","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

    __exports__.keyDirty = keyDirty;
    __exports__.renderedKey = renderedKey;
    __exports__.queryRegistry = queryRegistry;
    __exports__.decorateWidget = decorateWidget;
    __exports__.applyDecorators = applyDecorators;
    __exports__.changeSetting = changeSetting;
    __exports__.createWidget = createWidget;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

    var WidgetClickHook = __dependency1__.WidgetClickHook;
    var WidgetClickOutsideHook = __dependency1__.WidgetClickOutsideHook;
    var WidgetKeyUpHook = __dependency1__.WidgetKeyUpHook;
    var h = __dependency2__.h;
    var DecoratorHelper = __dependency3__["default"];

    function emptyContent() {}

    var _registry = {};
    var _dirty = {};

    function keyDirty(key, options) {
      _dirty[key] = options || {};
    }

    function renderedKey(key) {
      delete _dirty[key];
    }

    function queryRegistry(name) {
      return _registry[name];
    }

    var _decorators = {};

    function decorateWidget(widgetName, cb) {
      _decorators[widgetName] = _decorators[widgetName] || [];
      _decorators[widgetName].push(cb);
    }

    function applyDecorators(widget, type, attrs, state) {
      var decorators = _decorators[widget.name + ':' + type] || [];

      if (decorators.length) {
        var _ret = (function () {
          var helper = new DecoratorHelper(widget, attrs, state);
          return {
            v: decorators.map(function (d) {
              return d(helper);
            })
          };
        })();

        if (typeof _ret === 'object') return _ret.v;
      }

      return [];
    }

    var _customSettings = {};

    function changeSetting(widgetName, settingName, newValue) {
      _customSettings[widgetName] = _customSettings[widgetName] || {};
      _customSettings[widgetName][settingName] = newValue;
    }

    function drawWidget(builder, attrs, state) {
      var properties = {};

      if (this.buildClasses) {
        var classes = this.buildClasses(attrs, state) || [];
        if (!Array.isArray(classes)) {
          classes = [classes];
        }

        var customClasses = applyDecorators(this, 'classNames', attrs, state);
        if (customClasses && customClasses.length) {
          classes = classes.concat(customClasses);
        }

        if (classes.length) {
          properties.className = classes.join(' ');
        }
      }
      if (this.buildId) {
        properties.id = this.buildId(attrs);
      }

      if (this.buildAttributes) {
        properties.attributes = this.buildAttributes(attrs);
      }

      if (this.keyUp) {
        properties['widget-key-up'] = new WidgetKeyUpHook(this);
      }

      if (this.clickOutside) {
        properties['widget-click-outside'] = new WidgetClickOutsideHook(this);
      }
      if (this.click) {
        properties['widget-click'] = new WidgetClickHook(this);
      }

      var attributes = properties['attributes'] || {};
      properties.attributes = attributes;

      if (this.title) {
        if (typeof this.title === 'function') {
          attributes.title = this.title(attrs, state);
        } else {
          attributes.title = I18n.t(this.title);
        }
      }

      var contents = this.html(attrs, state);
      if (this.name) {
        var beforeContents = applyDecorators(this, 'before', attrs, state) || [];
        var afterContents = applyDecorators(this, 'after', attrs, state) || [];
        contents = beforeContents.concat(contents).concat(afterContents);
      }

      return h(this.tagName || 'div', properties, contents);
    }

    function createWidget(name, opts) {
      var result = (function (_Widget) {
        _inherits(CustomWidget, _Widget);

        function CustomWidget() {
          _classCallCheck(this, CustomWidget);

          _get(Object.getPrototypeOf(CustomWidget.prototype), 'constructor', this).apply(this, arguments);
        }

        return CustomWidget;
      })(Widget);

      if (name) {
        _registry[name] = result;
      }

      opts.name = name;
      opts.html = opts.html || emptyContent;
      opts.draw = drawWidget;

      Object.keys(opts).forEach(function (k) {
        return result.prototype[k] = opts[k];
      });
      return result;
    }

    var Widget = (function () {
      function Widget(attrs, container, opts) {
        var _this = this;

        _classCallCheck(this, Widget);

        opts = opts || {};
        this.attrs = attrs || {};
        this.mergeState = opts.state;
        this.container = container;
        this.model = opts.model;

        this.key = this.buildKey ? this.buildKey(attrs) : null;

        // Helps debug widgets
        if (Ember.testing) {
          var ds = this.defaultState(attrs);
          if (typeof ds !== "object") {
            Ember.warn('defaultState must return an object');
          } else if (Object.keys(ds).length > 0 && !this.key) {
            Ember.warn('you need a key when using state ' + this.name);
          }
        }

        this.site = container.lookup('site:main');
        this.siteSettings = container.lookup('site-settings:main');
        this.currentUser = container.lookup('current-user:main');
        this.capabilities = container.lookup('capabilities:main');
        this.store = container.lookup('store:main');
        this.appEvents = container.lookup('app-events:main');
        this.keyValueStore = container.lookup('key-value-store:main');

        if (this.name) {
          (function () {
            var custom = _customSettings[_this.name];
            if (custom) {
              Object.keys(custom).forEach(function (k) {
                return _this.settings[k] = custom[k];
              });
            }
          })();
        }
      }

      _createClass(Widget, [{
        key: 'defaultState',
        value: function defaultState() {
          return {};
        }
      }, {
        key: 'destroy',
        value: function destroy() {
          console.log('destroy called');
        }
      }, {
        key: 'render',
        value: function render(prev) {
          if (prev && prev.key && prev.key === this.key) {
            this.state = prev.state;
          } else {
            this.state = this.defaultState(this.attrs, this.state);
          }

          // Sometimes we pass state down from the parent
          if (this.mergeState) {
            this.state = _.merge(this.state, this.mergeState);
          }

          if (prev) {
            var dirtyOpts = _dirty[prev.key] || {};
            if (prev.shadowTree) {
              this.shadowTree = true;
              if (!dirtyOpts && !_dirty['*']) {
                return prev.vnode;
              }
            }
            renderedKey(prev.key);

            var refreshAction = dirtyOpts.onRefresh;
            if (refreshAction) {
              this.sendWidgetAction(refreshAction, dirtyOpts.refreshArg);
            }
          }

          return this.draw(h, this.attrs, this.state);
        }
      }, {
        key: '_findAncestorWithProperty',
        value: function _findAncestorWithProperty(property) {
          var widget = this;
          while (widget) {
            var value = widget[property];
            if (value) {
              return widget;
            }
            widget = widget.parentWidget;
          }
        }
      }, {
        key: '_findView',
        value: function _findView() {
          var widget = this._findAncestorWithProperty('_emberView');
          if (widget) {
            return widget._emberView;
          }
        }
      }, {
        key: 'attach',
        value: function attach(widgetName, attrs, opts) {
          var WidgetClass = _registry[widgetName];

          if (!WidgetClass) {
            if (!this.container) {
              console.error("couldn't find container");
              return;
            }
            WidgetClass = this.container.lookupFactory('widget:' + widgetName);
          }

          if (WidgetClass) {
            var result = new WidgetClass(attrs, this.container, opts);
            result.parentWidget = this;
            return result;
          } else {
            throw 'Couldn\'t find ' + widgetName + ' factory';
          }
        }
      }, {
        key: 'scheduleRerender',
        value: function scheduleRerender() {
          var widget = this;
          while (widget) {
            if (widget.shadowTree) {
              keyDirty(widget.key);
            }

            var emberView = widget._emberView;
            if (emberView) {
              return emberView.queueRerender();
            }
            widget = widget.parentWidget;
          }
        }
      }, {
        key: '_sendComponentAction',
        value: function _sendComponentAction(name, param) {
          var view = this._findAncestorWithProperty('_emberView');

          var promise = undefined;
          if (view) {
            // Peek into ember internals to allow us to return promises from actions
            var ev = view._emberView;
            var target = ev.get('targetObject');

            var actionName = ev.get(name);
            if (!actionName) {
              Ember.warn(name + ' not found');
              return;
            }

            if (target) {
              // TODO: Use ember closure actions
              var actions = target._actions || target.actionHooks || {};
              var method = actions[actionName];
              if (method) {
                promise = method.call(target, param);
                if (!promise || !promise.then) {
                  promise = Ember.RSVP.resolve(promise);
                }
              } else {
                return ev.sendAction(name, param);
              }
            }
          }

          return this.rerenderResult(function () {
            return promise;
          });
        }
      }, {
        key: 'findAncestorModel',
        value: function findAncestorModel() {
          var modelWidget = this._findAncestorWithProperty('model');
          if (modelWidget) {
            return modelWidget.model;
          }
        }
      }, {
        key: 'rerenderResult',
        value: function rerenderResult(fn) {
          var _this2 = this;

          this.scheduleRerender();
          var result = fn();
          // re-render after any promises complete, too!
          if (result && result.then) {
            return result.then(function () {
              return _this2.scheduleRerender();
            });
          }
          return result;
        }
      }, {
        key: 'sendWidgetEvent',
        value: function sendWidgetEvent(name) {
          var _this3 = this;

          var methodName = name + 'Event';
          return this.rerenderResult(function () {
            var widget = _this3._findAncestorWithProperty(methodName);
            if (widget) {
              return widget[methodName]();
            }
          });
        }
      }, {
        key: 'sendWidgetAction',
        value: function sendWidgetAction(name, param) {
          var _this4 = this;

          return this.rerenderResult(function () {
            var widget = _this4._findAncestorWithProperty(name);
            if (widget) {
              return widget[name](param);
            }

            return _this4._sendComponentAction(name, param || _this4.findAncestorModel());
          });
        }
      }]);

      return Widget;
    })();

    __exports__["default"] = Widget;

    Widget.prototype.type = 'Thunk';
  });



// Stuff we need to load first








































































































;
(function(document, $) {

  // cf. http://mths.be/details
  var hasNativeSupport = (function(doc) {
    var fake, el = doc.createElement("details");
    // fail-fast
    if (!("open" in el)) { return false; }
    // figure out a root node
    var root = doc.body || (function() {
      var de = doc.documentElement;
      fake = true;
      return de.insertBefore(doc.createElement("body"), de.firstElementChild || de.firstChild);
    })();
    // setup test element
    el.innerHTML = "<summary>a</summary>b";
    el.style.display = "block";
    // add test element to the root node
    root.appendChild(el);
    // can we open it?
    var diff = el.offsetHeight;
    el.open = true;
    diff = diff !== el.offsetHeight;
    // cleanup
    root.removeChild(el);
    if (fake) { root.parentNode.removeChild(root); }
    // return the result
    return diff;
  })(document);

  function toggleOpen($details) {
    $details.toggleClass("open");
  }

  $.fn.details = function() {
    if (hasNativeSupport) { return this; }

    return this.each(function() {
      var $details = $(this),
          $firstSummary = $("summary", $details).first();

      $firstSummary.prop("tabIndex", 0);

      $firstSummary.on("keydown", function(event) {
        if (event.keyCode === 32 /* SPACE */ || event.keyCode === 13 /* ENTER */) {
          toggleOpen($details);
          return false;
        }
      });

      $firstSummary.on("click", function() {
        $firstSummary.focus();
        toggleOpen($details);
      });

    });
  };

})(document, jQuery);
(function() {

  function insertDetails(_, summary, details) {
    return "<details><summary>" + summary + "</summary>" + details + "</details>";
  }

  // replace all [details] BBCode with HTML 5.1 equivalent
  function replaceDetails(text) {
    text = text || "";

    while (text !== (text = text.replace(/\[details=([^\]]+)\]((?:(?!\[details=[^\]]+\]|\[\/details\])[\S\s])*)\[\/details\]/ig, insertDetails)));

    // add new lines to make sure we *always* have a <p> element after </summary> and around </details>
    // otherwise we can't hide the content since we can't target text nodes via CSS
    return text.replace(/<\/summary>/ig, "</summary>\n\n")
               .replace(/<\/details>/ig, "\n\n</details>\n\n");
  }

  Discourse.Dialect.addPreProcessor(function(text) {
    if (Discourse.SiteSettings.details_enabled) {
      text = replaceDetails(text);
    }
    return text;
  });

  Discourse.Markdown.whiteListTag("details", "class", "elided");

})();
(function($) {

  var isIE = /*@cc_on!@*/false || document.documentMode,
      globalIdCounter = 0,
      DEFAULTS = {
        max: { text: 10, link: 10, image: 20 },
        partial: { text: 5, link: 5, image: 6},
        none: { text: 0, link: 0, image: 0}
      };

  // handle lazyYT onebox
  function blurLazyYT($spoiler) {
    $("div.lazyYT", $spoiler).each(function(index) {
      $(this).replaceWith("<p>https://youtube.com/watch?v=" + $(this).data('youtube-id') + "</p>");
    });
  };

  function blurText($spoiler, radius) {
    // spoiler text is gray so as to maintain plugin compatibility with both light and dark theme sites.
    var textShadow = "gray 0 0 " + radius + "px";
    if (isIE) { textShadow = radius <= 0 ? "0 0 0 0 gray" : "0 0 " + radius + "px .1px gray"; }

    $spoiler.css("background-color", "transparent")
            .css("color", "rgba(0,0,0,0)")
            .css("text-shadow", textShadow);
  };

  function blurLink($spoiler, radius) {
    $("a", $spoiler).each(function(index, link) {
      var value = radius > 0 ? "blur(" + radius + "px)" : "";
      if (isIE) {
        $(link).css("-ms-filter", "progid:DXImageTransform.Microsoft.Blur(pixelradius="+radius+")");
      } else {
        $(link).css("filter", value)
               .css("-webkit-filter", value);
      }
    });
  };

  function blurImage($spoiler, radius) {
    // on the first pass, transform images into SVG
    $("img", $spoiler).each(function(index, image) {
      var isEmoji = $(this).hasClass('emoji');
      var transform = function() {
        var w = isEmoji ? 20 : image.width,
            h = isEmoji ? 20 : image.height,
            id = ++globalIdCounter;
        var svg = "<svg data-spoiler-id='" + id + "' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' width='" + w + "' height='" + h + "'>" +
                  "<defs><filter id='blur-" + id + "'><feGaussianBlur id='gaussian-" + id + "' stdDeviation='" + radius + "'></feGaussianBlur></filter></defs>" +
                  "<image xlink:href='" + image.src + "' filter='url(#blur-" + id + ")' style='filter: url(#blur-" + id + ")' width='" + w + "' height='" + h + "'></image>" +
                  "</svg>";
        $(image).replaceWith(svg);
      };
      // do we need to wait for the image to load?
      if (image.naturalWidth === 0 || image.naturalHeight === 0) {
        image.onload = transform;
      } else {
        transform();
      }
    });

    // change the blur radius
    $("svg", $spoiler).each(function(index, svg) {
      var id = svg.getAttribute("data-spoiler-id");
      var element = svg.getElementById("gaussian-" + id);
      if (element) { element.setAttribute("stdDeviation", radius); }
    });
  };

  var applyBlur = function($spoiler, option) {
    blurLazyYT($spoiler);
    blurText($spoiler, option.text);
    blurLink($spoiler, option.link);
    blurImage($spoiler, option.image);
  };

  var applySpoilers = function($spoiler, options) {
    var maxBlur = options.max,
        partialBlur = options.partial,
        noBlur = options.none;

    $spoiler.data("spoiler-state", "blurred");

    applyBlur($spoiler, maxBlur);

    $spoiler.on("mouseover", function() {
      $spoiler.css("cursor", "pointer");
      if ($spoiler.data("spoiler-state") === "blurred") { applyBlur($spoiler, partialBlur); }
    }).on("mouseout", function() {
      if ($spoiler.data("spoiler-state") === "blurred") { applyBlur($spoiler, maxBlur); }
    }).on("click", function(e) {
      if ($spoiler.data("spoiler-state") === "blurred") {
        $spoiler.data("spoiler-state", "revealed").css("cursor", "auto");
        applyBlur($spoiler, noBlur);
      } else {
        $spoiler.data("spoiler-state", "blurred").css("cursor", "pointer");
        applyBlur($spoiler, partialBlur);
      }
      e.preventDefault();
    });

  };

  $.fn.spoil = function(options) {
    var opts = $.extend(DEFAULTS, options || {});
    return this.each(function () {
      applySpoilers($(this), opts);
    });
  };

})(jQuery);
(function() {

  var CONTAINS_BLOCK_REGEX = /\n|<img|!\[[^\]]*\][(\[]/;

  function insertSpoiler(_, spoiler) {
    var element = CONTAINS_BLOCK_REGEX.test(spoiler) ? "div" : "span";
    return "<" + element + " class='spoiler'>" + spoiler + "</" + element + ">";
  }

  function replaceSpoilers(text) {
    text = text || "";
    while (text !== (text = text.replace(/\[spoiler\]((?:(?!\[spoiler\]|\[\/spoiler\])[\S\s])*)\[\/spoiler\]/ig, insertSpoiler)));
    return text;
  }

  Discourse.Dialect.addPreProcessor(function(text) {
    if (Discourse.SiteSettings.spoiler_enabled) {
      text = replaceSpoilers(text);
    }
    return text;
  });

  Discourse.Markdown.whiteListTag('span', 'class', 'spoiler');
  Discourse.Markdown.whiteListTag('div', 'class', 'spoiler');
})();
/*!
* lazyYT (lazy load YouTube videos)
* v1.0.1 - 2014-12-30
* (CC) This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.
* http://creativecommons.org/licenses/by-sa/4.0/
* Contributors: https://github.com/tylerpearson/lazyYT/graphs/contributors || https://github.com/daugilas/lazyYT/graphs/contributors
*
* Usage: <div class="lazyYT" data-youtube-id="laknj093n" data-parameters="rel=0">loading...</div>
*
* Note: Discourse has forked this from the original, beware when updating the file.
*
*/


(function ($) {
  'use strict';

  function setUp($el, settings) {
    var width = $el.data('width'),
    height = $el.data('height'),
    ratio = ($el.data('ratio')) ? $el.data('ratio') : settings.default_ratio,
    id = $el.data('youtube-id'),
    title = $el.data('youtube-title'),
    padding_bottom,
    innerHtml = [],
    $thumb,
    thumb_img,
    youtube_parameters = $el.data('parameters') || '';

    ratio = ratio.split(":");

    // width and height might override default_ratio value
    if (typeof width === 'number' && typeof height === 'number') {
      $el.width(width);
      padding_bottom = height + 'px';
    } else if (typeof width === 'number') {
      $el.width(width);
      padding_bottom = (width * ratio[1] / ratio[0]) + 'px';
    } else {
      width = $el.width();

      // no width means that container is fluid and will be the size of its parent
      if (width === 0) {
        width = $el.parent().width();
      }

      padding_bottom = (ratio[1] / ratio[0] * 100) + '%';
    }

    //
    // This HTML will be placed inside 'lazyYT' container

    innerHtml.push('<div class="ytp-thumbnail">');

    // Play button from YouTube (exactly as it is in YouTube)
    innerHtml.push('<div class="ytp-large-play-button"');
    if (width <= 640) innerHtml.push(' style="transform: scale(0.563888888888889);"');
    innerHtml.push('>');
    innerHtml.push('<svg>');
    innerHtml.push('<path fill-rule="evenodd" clip-rule="evenodd" fill="#1F1F1F" class="ytp-large-play-button-svg" d="M84.15,26.4v6.35c0,2.833-0.15,5.967-0.45,9.4c-0.133,1.7-0.267,3.117-0.4,4.25l-0.15,0.95c-0.167,0.767-0.367,1.517-0.6,2.25c-0.667,2.367-1.533,4.083-2.6,5.15c-1.367,1.4-2.967,2.383-4.8,2.95c-0.633,0.2-1.316,0.333-2.05,0.4c-0.767,0.1-1.3,0.167-1.6,0.2c-4.9,0.367-11.283,0.617-19.15,0.75c-2.434,0.034-4.883,0.067-7.35,0.1h-2.95C38.417,59.117,34.5,59.067,30.3,59c-8.433-0.167-14.05-0.383-16.85-0.65c-0.067-0.033-0.667-0.117-1.8-0.25c-0.9-0.133-1.683-0.283-2.35-0.45c-2.066-0.533-3.783-1.5-5.15-2.9c-1.033-1.067-1.9-2.783-2.6-5.15C1.317,48.867,1.133,48.117,1,47.35L0.8,46.4c-0.133-1.133-0.267-2.55-0.4-4.25C0.133,38.717,0,35.583,0,32.75V26.4c0-2.833,0.133-5.95,0.4-9.35l0.4-4.25c0.167-0.966,0.417-2.05,0.75-3.25c0.7-2.333,1.567-4.033,2.6-5.1c1.367-1.434,2.967-2.434,4.8-3c0.633-0.167,1.333-0.3,2.1-0.4c0.4-0.066,0.917-0.133,1.55-0.2c4.9-0.333,11.283-0.567,19.15-0.7C35.65,0.05,39.083,0,42.05,0L45,0.05c2.467,0,4.933,0.034,7.4,0.1c7.833,0.133,14.2,0.367,19.1,0.7c0.3,0.033,0.833,0.1,1.6,0.2c0.733,0.1,1.417,0.233,2.05,0.4c1.833,0.566,3.434,1.566,4.8,3c1.066,1.066,1.933,2.767,2.6,5.1c0.367,1.2,0.617,2.284,0.75,3.25l0.4,4.25C84,20.45,84.15,23.567,84.15,26.4z M33.3,41.4L56,29.6L33.3,17.75V41.4z"></path>');
    innerHtml.push('<polygon fill-rule="evenodd" clip-rule="evenodd" fill="#FFFFFF" points="33.3,41.4 33.3,17.75 56,29.6"></polygon>');
    innerHtml.push('</svg>');
    innerHtml.push('</div>'); // end of .ytp-large-play-button

    innerHtml.push('</div>'); // end of .ytp-thumbnail

    // Video title (info bar)
    innerHtml.push('<div class="html5-info-bar">');
    innerHtml.push('<div class="html5-title">');
    innerHtml.push('<div class="html5-title-text-wrapper">');
    innerHtml.push('<a class="html5-title-text" target="_blank" tabindex="3100" href="https://www.youtube.com/watch?v=', id, '">');
    if (title === undefined || title === null || title === '') {
      innerHtml.push('youtube.com/watch?v=' + id);
    } else {
      innerHtml.push(title);
    }
    innerHtml.push('</a>');
    innerHtml.push('</div>'); // .html5-title
    innerHtml.push('</div>'); // .html5-title-text-wrapper
    innerHtml.push('</div>'); // end of Video title .html5-info-bar

    $el.css({
      'padding-bottom': padding_bottom
    })
    .html(innerHtml.join(''));

    if (width > 640) {
      thumb_img = 'maxresdefault.jpg';
    } else if (width > 480) {
      thumb_img = 'sddefault.jpg';
    } else if (width > 320) {
      thumb_img = 'hqdefault.jpg';
    } else if (width > 120) {
      thumb_img = 'mqdefault.jpg';
    } else if (width === 0) { // sometimes it fails on fluid layout
      thumb_img = 'hqdefault.jpg';
    } else {
      thumb_img = 'default.jpg';
    }

    $thumb = $el.find('.ytp-thumbnail').css({
      'background-image': ['url(//img.youtube.com/vi/', id, '/', thumb_img, ')'].join('')
    })
    .addClass('lazyYT-image-loaded')
    .on('click', function (e) {
      e.preventDefault();

      if (!$el.hasClass('lazyYT-video-loaded') && $thumb.hasClass('lazyYT-image-loaded')) {
        $el.html('<iframe src="//www.youtube.com/embed/' + id + '?autoplay=1&' + youtube_parameters + '" frameborder="0" allowfullscreen></iframe>')
        .addClass('lazyYT-video-loaded');
      }

      if (settings.onPlay) {
        settings.onPlay(e, $el);
      }
    });

  }

  $.fn.lazyYT = function (newSettings) {
    var defaultSettings = {
      default_ratio: '16:9',
      callback: null, // ToDO execute callback if given
      container_class: 'lazyYT-container'
    };
    var settings = $.extend(defaultSettings, newSettings);

    return this.each(function () {
      var $el = $(this).addClass(settings.container_class);
      setUp($el, settings);
    });
  };

})(jQuery);
/*global md5 */


(function() {

  var DATA_PREFIX = "data-poll-";
  var DEFAULT_POLL_NAME = "poll";

  var WHITELISTED_ATTRIBUTES = ["type", "name", "min", "max", "step", "order", "status"];

  var ATTRIBUTES_REGEX = new RegExp("(" + WHITELISTED_ATTRIBUTES.join("|") + ")=['\"]?[^\\s\\]]+['\"]?", "g");

  Discourse.Dialect.replaceBlock({
    start: /\[poll((?:\s+\w+=[^\s\]]+)*)\]([\s\S]*)/igm,
    stop: /\[\/poll\]/igm,

    emitter: function(blockContents, matches) {
      var o, contents = [];

      // post-process inside block contents
      if (blockContents.length) {
        var self = this, b;

        var postProcess = function(bc) {
          if (typeof bc === "string" || bc instanceof String) {
            var processed = self.processInline(String(bc));
            if (processed.length) {
              contents.push(["p"].concat(processed));
            }
          } else {
            contents.push(bc);
          }
        };

        while ((b = blockContents.shift()) !== undefined) {
          this.processBlock(b, blockContents).forEach(postProcess);
        }
      }

      // Disable dialect when poll plugin is disabled
      if (!Discourse.SiteSettings.poll_enabled) { return ["div"].concat(contents); }

      // default poll attributes
      var attributes = { "class": "poll" };
      attributes[DATA_PREFIX + "status"] = "open";
      attributes[DATA_PREFIX + "name"] = DEFAULT_POLL_NAME;

      // extract poll attributes
      (matches[1].match(ATTRIBUTES_REGEX) || []).forEach(function(m) {
        var attr = m.split("="), name = attr[0], value = attr[1];
        value = Handlebars.Utils.escapeExpression(value.replace(/["']/g, ""));
        attributes[DATA_PREFIX + name] = value;
      });

      // we might need these values later...
      var min = parseInt(attributes[DATA_PREFIX + "min"], 10),
          max = parseInt(attributes[DATA_PREFIX + "max"], 10),
          step = parseInt(attributes[DATA_PREFIX + "step"], 10);

      // generate the options when the type is "number"
      if (attributes[DATA_PREFIX + "type"] === "number") {
        // default values
        if (isNaN(min)) { min = 1; }
        if (isNaN(max)) { max = Discourse.SiteSettings.poll_maximum_options; }
        if (isNaN(step)) { step = 1; }
        // dynamically generate options
        contents.push(["bulletlist"]);
        for (o = min; o <= max; o += step) {
          contents[0].push(["listitem", String(o)]);
        }
      }

      // make sure there's only 1 child and it's a list with at least 1 option
      if (contents.length !== 1 || contents[0].length <= 1 || (contents[0][0] !== "numberlist" && contents[0][0] !== "bulletlist")) {
        return ["div"].concat(contents);
      }

      // make sure there's only options in the list
      for (o = 1; o < contents[0].length; o++) {
        if (contents[0][o][0] !== "listitem") {
          return ["div"].concat(contents);
        }
      }

      // TODO: remove non whitelisted content

      // add option id (hash)
      for (o = 1; o < contents[0].length; o++) {
        var attr = {};
        // compute md5 hash of the content of the option
        attr[DATA_PREFIX + "option-id"] = md5(JSON.stringify(contents[0][o].slice(1)));
        // store options attributes
        contents[0][o].splice(1, 0, attr);
      }

      var result = ["div", attributes],
          poll = ["div"];

      // 1 - POLL CONTAINER
      var container = ["div", { "class": "poll-container" }].concat(contents);
      poll.push(container);

      // 2 - POLL INFO
      var info = ["div", { "class": "poll-info" }];

      // # of voters
      info.push(["p",
                  ["span", { "class": "info-number" }, "0"],
                  ["span", { "class": "info-text"}, I18n.t("poll.voters", { count: 0 })]
                ]);

      // multiple help text
      if (attributes[DATA_PREFIX + "type"] === "multiple") {
        var optionCount = contents[0].length - 1;

        // default values
        if (isNaN(min) || min < 1) { min = 1; }
        if (isNaN(max) || max > optionCount) { max = optionCount; }

        // add some help text
        var help;

        if (max > 0) {
          if (min === max) {
            if (min > 1) {
              help = I18n.t("poll.multiple.help.x_options", { count: min });
            }
          } else if (min > 1) {
            if (max < optionCount) {
              help = I18n.t("poll.multiple.help.between_min_and_max_options", { min: min, max: max });
            } else {
              help = I18n.t("poll.multiple.help.at_least_min_options", { count: min });
            }
          } else if (max <= optionCount) {
            help = I18n.t("poll.multiple.help.up_to_max_options", { count: max });
          }
        }

        if (help) { info.push(["p", help]); }
      }

      poll.push(info);

      // 3 - BUTTONS
      var buttons = ["div", { "class": "poll-buttons" }];

      // add "cast-votes" button
      if (attributes[DATA_PREFIX + "type"] === "multiple") {
        buttons.push(["a", { "class": "button cast-votes", "title": I18n.t("poll.cast-votes.title") }, I18n.t("poll.cast-votes.label")]);
      }

      // add "toggle-results" button
      buttons.push(["a", { "class": "button toggle-results", "title": I18n.t("poll.show-results.title") }, I18n.t("poll.show-results.label")]);

      // 4 - MIX IT ALL UP
      result.push(poll);
      result.push(buttons);

      return result;
    }
  });

  Discourse.Markdown.whiteListTag("div", "class", "poll");
  Discourse.Markdown.whiteListTag("div", "class", /^poll-(info|container|buttons)/);
  Discourse.Markdown.whiteListTag("div", "data-*");

  Discourse.Markdown.whiteListTag("span", "class", /^info-(number|text)/);

  Discourse.Markdown.whiteListTag("a", "class", /^button (cast-votes|toggle-results)/);

  Discourse.Markdown.whiteListTag("li", "data-*");
})();
define("discourse/plugins/customer-flair/initializers/add-customer-site-top-post", 
  ["discourse/lib/plugin-api","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var withPluginApi = __dependency1__.withPluginApi;

    __exports__["default"] = {
      name: 'add-customer-site-to-post',
      initialize: function () {
        withPluginApi('0.1', function (api) {
          api.addPosterIcon(function (cfs) {
            var siteUrl = cfs.customer_site_url;
            if (!siteUrl) {
              return;
            }

            var enterprise = cfs.customer_enterprise;
            var trial = cfs.customer_trial;
            var forumId = cfs.customer_forum_id;

            var titles = [];
            if (trial === 'true') {
              titles.push('trial');
            }
            if (enterprise === 'true') {
              titles.push('enterprise');
            }
            titles.push('customer');
            titles.push(siteUrl);

            return { emoji: 'moneybag',
              className: 'customer',
              title: titles.join(' '),
              url: 'https://api.discourse.org/admin/forums/' + forumId };
          });
        });
      }
    };
  });
define("discourse/plugins/discourse-akismet/admin/models/akismet-queue", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      confirmSpam: function (post) {
        return Discourse.ajax("/admin/plugins/akismet/confirm_spam", {
          type: "POST",
          data: {
            post_id: post.get("id")
          }
        });
      },

      allow: function (post) {
        return Discourse.ajax("/admin/plugins/akismet/allow", {
          type: "POST",
          data: {
            post_id: post.get("id")
          }
        });
      },

      dismiss: function (post) {
        return Discourse.ajax("/admin/plugins/akismet/dismiss", {
          type: "POST",
          data: {
            post_id: post.get("id")
          }
        });
      },

      deleteUser: function (post) {
        return Discourse.ajax("/admin/plugins/akismet/delete_user", {
          type: "DELETE",
          data: {
            user_id: post.get("user_id"),
            post_id: post.get("id")
          }
        });
      },

      findAll: function () {
        return Discourse.ajax("/admin/plugins/akismet/index.json").then(function (result) {
          result.posts = result.posts.map(function (p) {
            return Discourse.Post.create(p);
          });
          return result;
        });
      }
    };
  });
define("discourse/plugins/discourse-akismet/discourse/akismet-route-map", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      resource: 'admin.adminPlugins',
      path: '/plugins',
      map: function () {
        this.route('akismet');
      }
    };
  });
define("discourse/plugins/discourse-akismet/discourse/controllers/admin-plugins-akismet", 
  ["discourse/plugins/discourse-akismet/admin/models/akismet-queue","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var AkismetQueue = __dependency1__["default"];

    function genericError() {
      bootbox.alert(I18n.t('generic_error'));
    }

    __exports__["default"] = Ember.ArrayController.extend({
      sortProperties: ["id"],
      sortAscending: true,
      enabled: false,
      performingAction: false,

      actions: {
        refresh: function () {
          var self = this;
          self.set('performingAction', true);
          AkismetQueue.findAll().then(function (result) {
            self.set('stats', result.stats);
            self.set('model', result.posts);
          }).catch(genericError).finally(function () {
            self.set('performingAction', false);
          });
        },

        confirmSpamPost: function (post) {
          var self = this;
          self.set('performingAction', true);
          AkismetQueue.confirmSpam(post).then(function () {
            self.removeObject(post);
            self.incrementProperty('stats.confirmed_spam');
            self.decrementProperty('stats.needs_review');
          }).catch(genericError).finally(function () {
            self.set('performingAction', false);
          });
        },

        allowPost: function (post) {
          var self = this;
          self.set('performingAction', true);
          AkismetQueue.allow(post).then(function () {
            self.incrementProperty('stats.confirmed_ham');
            self.decrementProperty('stats.needs_review');
            self.removeObject(post);
          }).catch(genericError).finally(function () {
            self.set('performingAction', false);
          });
        },

        deleteUser: function (post) {
          var self = this;
          bootbox.confirm(I18n.t('akismet.delete_prompt', { username: post.get('username') }), function (result) {
            if (result === true) {
              self.set('performingAction', true);
              AkismetQueue.deleteUser(post).then(function () {
                self.removeObject(post);
                self.incrementProperty('stats.confirmed_spam');
                self.decrementProperty('stats.needs_review');
              }).catch(genericError).finally(function () {
                self.set('performingAction', false);
              });
            }
          });
        },

        dismiss: function (post) {
          var _this = this;

          this.set('performingAction', true);
          AkismetQueue.dismiss(post).then(function () {
            _this.removeObject(post);
          }).catch(genericError).finally(function () {
            _this.set('performingAction', false);
          });
        }

      }
    });
  });
define("discourse/plugins/discourse-akismet/discourse/initializers/rewire-plugin-outlets", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      name: 'rewrite-plugin-outlets',

      initialize: function () {
        // TODO: Once `rewire` is in stable replace this with a regular `import`
        var outletModule = require('discourse/helpers/plugin-outlet');
        if (outletModule && outletModule.rewire) {
          outletModule.rewire('akismet-review', 'site-map-links', 'hamburger-admin');
        }
      }
    };
  });
define("discourse/plugins/discourse-akismet/discourse/initializers/add-akismet-count", 
  ["discourse/lib/plugin-api","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var withPluginApi = __dependency1__.withPluginApi;

    __exports__["default"] = {
      name: 'add-akismet-count',
      before: 'register-discourse-location',
      after: 'inject-objects',

      initialize: function (container) {
        var user = container.lookup('current-user:main');

        if (user && user.get('staff')) {

          var added = false;
          withPluginApi('0.4', function (api) {
            api.addFlagProperty('currentUser.akismet_review_count');
            added = true;

            api.decorateWidget('hamburger-menu:admin-links', function (dec) {
              return dec.attach('link', {
                route: 'adminPlugins.akismet',
                label: 'akismet.title',
                badgeCount: 'akismet_review_count',
                badgeClass: 'flagged-posts'
              });
            });
          });

          // if the api didn't activate, try the module way
          if (!added) {
            var headerMod = require('discourse/controllers/header');
            if (headerMod && headerMod.addFlagProperty) {
              headerMod.addFlagProperty('currentUser.akismet_review_count');
            }
          }

          var messageBus = container.lookup('message-bus:main');
          messageBus.subscribe("/akismet_counts", function (result) {
            if (result) {
              user.set('akismet_review_count', result.akismet_review_count || 0);
            }
          });
        }
      }
    };
  });
define("discourse/plugins/discourse-akismet/discourse/routes/admin-plugins-akismet", 
  ["discourse/plugins/discourse-akismet/admin/models/akismet-queue","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var AkismetQueue = __dependency1__["default"];

    __exports__["default"] = Discourse.Route.extend({
      _enabled: false,
      _stats: null,

      model: function () {
        var self = this;
        return AkismetQueue.findAll().then(function (result) {
          self._enabled = result.enabled;
          self._stats = result.stats;
          return result.posts;
        });
      },

      setupController: function (controller, model) {
        controller.setProperties({
          model: model,
          enabled: this._enabled,
          stats: this._stats
        });
      }
    });
  });
Ember.TEMPLATES["javascripts/connectors/site-map-links/akismet-review"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","badge-notification flagged-posts");
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
            content(env, morph0, context, "currentUser.akismet_review_count");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(fragment,3,3,contextualElement);
          dom.insertBoundary(fragment, null);
          inline(env, morph0, context, "i18n", ["akismet.title"], {});
          block(env, morph1, context, "if", [get(env, context, "currentUser.akismet_review_count")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "link-to", ["adminPlugins.akismet"], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "currentUser.staff")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/admin/plugins-akismet"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("table");
          dom.setAttribute(el1,"class","tbl spam-stats");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("tr");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("th");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("th");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("th");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("th");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("tr");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("td");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("td");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("td");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("td");
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element4 = dom.childAt(fragment, [1]);
          var element5 = dom.childAt(element4, [1]);
          var element6 = dom.childAt(element4, [3]);
          var morph0 = dom.createMorphAt(dom.childAt(element5, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(element5, [3]),0,0);
          var morph2 = dom.createMorphAt(dom.childAt(element5, [5]),0,0);
          var morph3 = dom.createMorphAt(dom.childAt(element5, [7]),0,0);
          var morph4 = dom.createMorphAt(dom.childAt(element6, [1]),0,0);
          var morph5 = dom.createMorphAt(dom.childAt(element6, [3]),0,0);
          var morph6 = dom.createMorphAt(dom.childAt(element6, [5]),0,0);
          var morph7 = dom.createMorphAt(dom.childAt(element6, [7]),0,0);
          inline(env, morph0, context, "i18n", ["akismet.stats.scanned"], {});
          inline(env, morph1, context, "i18n", ["akismet.stats.needs_review"], {});
          inline(env, morph2, context, "i18n", ["akismet.stats.confirmed_spam"], {});
          inline(env, morph3, context, "i18n", ["akismet.stats.confirmed_ham"], {});
          content(env, morph4, context, "stats.scanned");
          content(env, morph5, context, "stats.needs_review");
          content(env, morph6, context, "stats.confirmed_spam");
          content(env, morph7, context, "stats.confirmed_ham");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"label": "admin.plugins.change_settings", "icon": "gear", "class": "settings-button", "action": "showSettings"});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode(" ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              inline(env, morph0, context, "avatar", [get(env, context, "post")], {"imageSize": "small"});
              content(env, morph1, context, "post.username");
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("                  ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-button", [], {"action": "deleteUser", "actionParam": get(env, context, "post"), "icon": "trash-o", "class": "btn-danger", "label": "akismet.confirm_delete", "disabled": get(env, context, "performingAction")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 1,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("tr");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createElement("td");
            dom.setAttribute(el2,"class","cooked");
            var el3 = dom.createTextNode("\n\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            dom.setAttribute(el3,"class","post-info");
            var el4 = dom.createTextNode("\n                ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n                ");
            dom.appendChild(el3, el4);
            var el4 = dom.createElement("a");
            dom.setAttribute(el4,"target","_blank");
            dom.setAttribute(el4,"class","post-link");
            var el5 = dom.createTextNode("#");
            dom.appendChild(el4, el5);
            var el5 = dom.createComment("");
            dom.appendChild(el4, el5);
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n              ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createComment("");
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n              ");
            dom.appendChild(el2, el3);
            var el3 = dom.createElement("div");
            dom.setAttribute(el3,"class","queue-actions");
            var el4 = dom.createTextNode("\n                ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n\n                ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n\n                ");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("\n\n\n");
            dom.appendChild(el3, el4);
            var el4 = dom.createComment("");
            dom.appendChild(el3, el4);
            var el4 = dom.createTextNode("              ");
            dom.appendChild(el3, el4);
            dom.appendChild(el2, el3);
            var el3 = dom.createTextNode("\n            ");
            dom.appendChild(el2, el3);
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement, blockArguments) {
            var dom = env.dom;
            var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block, attribute = hooks.attribute, content = hooks.content, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element0 = dom.childAt(fragment, [1, 1]);
            var element1 = dom.childAt(element0, [1]);
            var element2 = dom.childAt(element1, [3]);
            var element3 = dom.childAt(element0, [5]);
            var morph0 = dom.createMorphAt(element1,1,1);
            var morph1 = dom.createMorphAt(element2,1,1);
            var attrMorph0 = dom.createAttrMorph(element2, 'href');
            var morph2 = dom.createUnsafeMorphAt(element0,3,3);
            var morph3 = dom.createMorphAt(element3,1,1);
            var morph4 = dom.createMorphAt(element3,3,3);
            var morph5 = dom.createMorphAt(element3,5,5);
            var morph6 = dom.createMorphAt(element3,7,7);
            set(env, context, "post", blockArguments[0]);
            block(env, morph0, context, "link-to", ["adminUser", get(env, context, "post.user_id"), get(env, context, "post.username")], {}, child0, null);
            attribute(env, attrMorph0, element2, "href", get(env, context, "post.url"));
            content(env, morph1, context, "post.id");
            content(env, morph2, context, "post.cooked");
            inline(env, morph3, context, "d-button", [], {"action": "confirmSpamPost", "actionParam": get(env, context, "post"), "icon": "check", "class": "btn-primary", "label": "akismet.confirm_spam", "disabled": get(env, context, "performingAction")});
            inline(env, morph4, context, "d-button", [], {"action": "allowPost", "actionParam": get(env, context, "post"), "icon": "thumbs-o-up", "label": "akismet.not_spam", "disabled": get(env, context, "performingAction")});
            inline(env, morph5, context, "d-button", [], {"action": "dismiss", "actionParam": get(env, context, "post"), "icon": "times", "label": "akismet.dismiss", "disabled": get(env, context, "performingAction")});
            block(env, morph6, context, "if", [get(env, context, "post.user_id")], {}, child1, null);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("h3");
          dom.setAttribute(el1,"class","review-queue");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","row");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("table");
          dom.setAttribute(el2,"class","akismet-queue");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createElement("tbody");
          var el4 = dom.createTextNode("\n");
          dom.appendChild(el3, el4);
          var el4 = dom.createComment("");
          dom.appendChild(el3, el4);
          var el4 = dom.createTextNode("        ");
          dom.appendChild(el3, el4);
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(fragment, [3, 1, 1]),1,1);
          inline(env, morph0, context, "i18n", ["akismet.posts_to_review"], {});
          block(env, morph1, context, "each", [get(env, context, "model")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
        var morph2 = dom.createMorphAt(fragment,4,4,contextualElement);
        var morph3 = dom.createMorphAt(fragment,6,6,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "stats")], {}, child0, null);
        block(env, morph1, context, "if", [get(env, context, "currentUser.admin")], {}, child1, null);
        inline(env, morph2, context, "d-button", [], {"action": "refresh", "icon": "refresh", "class": "btn-primary", "label": "akismet.refresh", "disabled": get(env, context, "performingAction")});
        block(env, morph3, context, "if", [get(env, context, "length")], {}, child2, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"label": "akismet.change_settings", "icon": "gear", "class": "settings-button", "action": "showSettings"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        var morph1 = dom.createUnsafeMorphAt(fragment,2,2,contextualElement);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "currentUser.admin")], {}, child0, null);
        inline(env, morph1, context, "i18n", ["akismet.not_enabled"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "enabled")], {}, child0, child1);
      return fragment;
    }
  };
}()));
define("discourse/plugins/discourse-data-explorer/admin/adapters/query", 
  ["admin/adapters/build-plugin","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var buildPluginAdapter = __dependency1__["default"];

    __exports__["default"] = buildPluginAdapter('explorer').extend({});
  });
define("discourse/plugins/discourse-data-explorer/discourse/lib/binary-search", 
  ["exports"],
  function(__exports__) {
    "use strict";


    __exports__["default"] = binarySearch;
    // The binarySearch() function is licensed under the UNLICENSE
    // https://github.com/Olical/binary-search

    // Modified for use in Discourse

    function binarySearch(list, target, keyProp) {
      var min = 0;
      var max = list.length - 1;
      var guess;
      var keyProperty = keyProp || "id";

      while (min <= max) {
        guess = Math.floor((min + max) / 2);

        if (Em.get(list[guess], keyProperty) === target) {
          return guess;
        } else {
          if (Em.get(list[guess], keyProperty) < target) {
            min = guess + 1;
          } else {
            max = guess - 1;
          }
        }
      }

      return -1;
    }
  });
define("discourse/plugins/discourse-data-explorer/discourse/models/query", 
  ["discourse/models/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestModel = __dependency1__["default"];

    var Query = RestModel.extend({
      dirty: false,
      params: {},
      results: null,

      _init: (function () {
        this._super();
        this.set('dirty', false);
      }).on('init'),

      _initParams: (function () {
        this.resetParams();
      }).on('init').observes('param_info'),

      markDirty: (function () {
        this.set('dirty', true);
      }).observes('name', 'description', 'sql'),

      markNotDirty: function () {
        this.set('dirty', false);
      },

      hasParams: (function () {
        return this.get('param_info.length') > 0;
      }).property('param_info'),

      resetParams: function () {
        var newParams = {};
        var oldParams = this.get('params');
        var paramInfo = this.get('param_info') || [];
        paramInfo.forEach(function (pinfo) {
          var name = pinfo.identifier;
          if (oldParams[pinfo.identifier]) {
            newParams[name] = oldParams[name];
          } else if (pinfo['default'] !== null) {
            if (pinfo['default'] === false) {
              debugger;
            }
            newParams[name] = pinfo['default'];
          } else if (pinfo['type'] === 'boolean') {
            newParams[name] = 'false';
          } else {
            newParams[name] = '';
          }
        });
        this.set('params', newParams);
      },

      downloadUrl: (function () {
        // TODO - can we change this to use the store/adapter?
        return Discourse.getURL("/admin/plugins/explorer/queries/" + this.get('id') + ".json?export=1");
      }).property('id'),

      listName: (function () {
        var name = this.get('name');
        if (this.get('dirty')) {
          name += " (*)";
        }
        if (this.get('destroyed')) {
          name += " (deleted)";
        }
        return name;
      }).property('name', 'dirty', 'destroyed'),

      createProperties: function () {
        if (this.get('sql')) {
          // Importing
          return this.updateProperties();
        }
        return this.getProperties("name");
      },

      updateProperties: function () {
        var props = this.getProperties(Query.updatePropertyNames);
        if (this.get('destroyed')) {
          props.id = this.get('id');
        }
        return props;
      }
    });

    Query.reopenClass({
      updatePropertyNames: ["name", "description", "sql"]
    });

    __exports__["default"] = Query;
  });
define("discourse/plugins/discourse-data-explorer/discourse/views/import-query", 
  ["discourse/views/modal-body","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var ModalBodyView = __dependency1__["default"];

    __exports__["default"] = ModalBodyView.extend({
      templateName: 'modal/import-query',
      title: I18n.t('explorer.import.modal')
    });
  });
define("discourse/plugins/discourse-data-explorer/discourse/views/admin-plugins-explorer", 
  ["exports"],
  function(__exports__) {
    "use strict";

    __exports__["default"] = Ember.View.extend({

      _onHideSchema: (function () {
        Em.Logger.log('resizing');
        this.appEvents.trigger('ace:resize');
      }).observes('controller.hideSchema'),

      _onInsertEditor: (function () {
        var self = this;
        Em.run.schedule('afterRender', this, function () {
          self.trigger('didInsertEditor');
        });
      }).observes('controller.everEditing'),

      _bindGrippie: (function () {
        if (this._state !== "inDOM") {
          return;
        }
        var $editPane = this.$().find('.query-editor');
        if (!$editPane.length) {
          return;
        }
        var oldGrippie = this.get('grippie');
        if (oldGrippie) {
          oldGrippie.off('mousedown mousemove mouseup');
          $editPane.off('mousemove mouseup');
        }

        var $grippie = $editPane.find('.grippie');
        var $targets = $editPane.find('.ace-wrapper,.grippie-target');
        var $body = $('body');
        var self = this;

        this.set('grippie', $grippie);

        var mousemove = function (e) {
          var diff = self.get('startY') - e.screenY;
          var newHeight = self.get('startSize') - diff;
          //Em.Logger.debug("new height", newHeight);
          $targets.height(newHeight);
          self.appEvents.trigger('ace:resize');
        };

        var mouseup = undefined;
        mouseup = function (e) {
          mousemove(e);
          $body.off('mousemove', mousemove);
          $body.off('mouseup', mouseup);
          self.set('startY', null);
          self.set('startSize', null);
        };

        $grippie.on('mousedown', function (e) {
          self.set('startY', e.screenY);
          self.set('startSize', $targets.height());

          $body.on('mousemove', mousemove);
          $body.on('mouseup', mouseup);
          e.preventDefault();
        });
      }).on('didInsertElement', 'didInsertEditor'),

      _cleanup: (function () {
        if (this.get('controller.everEditing')) {
          this.get('grippie').off('mousedown');
          this.set('grippie', null);
        }
      }).on('willDestroyElement')
    });
  });
define("discourse/plugins/discourse-data-explorer/discourse/components/explorer-schema", 
  ["discourse/lib/debounce","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var debounce = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend({

      actions: {
        expandSchema: function () {
          this.set('hideSchema', false);
        },
        collapseSchema: function () {
          this.set('hideSchema', true);
        }
      },

      transformedSchema: (function () {
        var schema = this.get('schema');

        for (var key in schema) {
          if (!schema.hasOwnProperty(key)) {
            continue;
          }

          schema[key].forEach(function (col) {
            var notes_components = [];
            if (col.primary) {
              notes_components.push("primary key");
            }
            if (col.is_nullable) {
              notes_components.push("null");
            }
            if (col.column_default) {
              notes_components.push("default " + col.column_default);
            }
            if (col.fkey_info) {
              notes_components.push("fkey " + col.fkey_info);
            }
            if (col.denormal) {
              notes_components.push("denormal " + col.denormal);
            }
            var notes = notes_components.join(", ");

            if (notes) {
              col.notes = notes;
            }

            if (col.enum || col.column_desc) {
              col.havepopup = true;
            }

            col.havetypeinfo = !!(col.notes || col.enum || col.column_desc);
          });
        }
        return schema;
      }).property('schema'),

      rfilter: (function () {
        if (!Em.isBlank(this.get('filter'))) {
          return new RegExp(this.get('filter'));
        }
      }).property('filter'),

      filterTables: function (schema) {
        var tables = [];
        var filter = this.get('rfilter'),
            haveFilter = !!filter;

        for (var key in schema) {
          if (!schema.hasOwnProperty(key)) {
            continue;
          }
          if (!haveFilter) {
            tables.push({
              name: key,
              columns: schema[key],
              open: false
            });
            continue;
          }

          // Check the table name vs the filter
          if (filter.source == key || filter.source + "s" == key) {
            tables.unshift({
              name: key,
              columns: schema[key],
              open: haveFilter
            });
          } else if (filter.test(key)) {
            // whole table matches
            tables.push({
              name: key,
              columns: schema[key],
              open: haveFilter
            });
          } else {
            (function () {
              // filter the columns
              var filterCols = [];
              schema[key].forEach(function (col) {
                if (filter.source == col.column_name) {
                  filterCols.unshift(col);
                } else if (filter.test(col.column_name)) {
                  filterCols.push(col);
                }
              });
              if (!Em.isEmpty(filterCols)) {
                tables.push({
                  name: key,
                  columns: filterCols,
                  open: haveFilter
                });
              }
            })();
          }
        }
        return tables;
      },

      triggerFilter: debounce(function () {
        this.set('filteredTables', this.filterTables(this.get('transformedSchema')));
        this.set('loading', false);
      }, 500).observes('filter'),

      setLoading: (function () {
        this.set('loading', true);
      }).observes('filter'),

      tables: (function () {
        if (!this.get('filteredTables')) {
          this.set('loading', true);
          this.triggerFilter();
          return [];
        }
        return this.get('filteredTables');
      }).property('transformedSchema', 'filteredTables')
    });
  });
define("discourse/plugins/discourse-data-explorer/discourse/components/param-field", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.TextField.extend({
      value: (function (key, value, previousValue) {
        if (arguments.length > 1) {
          this.get('params')[this.get('pname')] = value;
        }
        return this.get('params')[this.get('pname')];
      }).property('params', 'pname')
    });
  });
define("discourse/plugins/discourse-data-explorer/discourse/components/explorer-schema-enuminfo", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      tagName: 'ol',

      enuminfo: (function () {
        var hash = this.get('col.enum');
        var result = [];
        for (var key in hash) {
          if (!hash.hasOwnProperty(key)) {
            continue;
          }
          result.push({ value: key, name: hash[key] });
        }
        return result;
      }).property('col.enum')
    });
  });
define("discourse/plugins/discourse-data-explorer/discourse/components/explorer-schema-onetable", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Ember.Component.extend({
      classNameBindings: [':schema-table', 'open'],
      tagName: 'li',

      open: Em.computed.alias('table.open'),

      _bindClicks: (function () {
        var self = this;
        this.$().find('.schema-table-name').click(function (e) {
          self.set('open', !self.get('open'));
          e.preventDefault();
        });
      }).on('didInsertElement'),

      _cleanup: (function () {
        this.$().find('.schema-table-name').off('click');
      }).on('willDestroyElement')
    });
  });
define("discourse/plugins/discourse-data-explorer/discourse/components/hljs-code-view", 
  ["discourse/lib/debounce","discourse/lib/highlight-syntax","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var debounce = __dependency1__["default"];
    var highlightSyntax = __dependency2__["default"];

    __exports__["default"] = Ember.Component.extend({
      render: function (buffer) {
        buffer.push("<pre><code class='" + this.get('codeClass') + "'>");
        buffer.push(Handlebars.Utils.escapeExpression(this.get('value')));
        buffer.push("</code></pre>");
      },

      _refreshHighlight: debounce(function () {
        this.rerender();
      }, 50).observes('value'),

      _applyHighlight: (function () {
        highlightSyntax(this.$());
      }).on('didInsertElement')
    });
  });
define("discourse/plugins/discourse-data-explorer/discourse/components/query-result", 
  ["discourse/models/badge","exports"],
  function(__dependency1__, __exports__) {
    "use strict";

    var Badge = __dependency1__["default"];

    function randomIdShort() {
      return 'xxxxxxxx'.replace(/[xy]/g, function () {
        /*eslint-disable*/
        return (Math.random() * 16 | 0).toString(16);
        /*eslint-enable*/
      });
    }

    function transformedRelTable(table, modelClass) {
      var result = {};
      table.forEach(function (item) {
        if (modelClass) {
          result[item.id] = modelClass.create(item);
        } else {
          result[item.id] = item;
        }
      });
      return result;
    }

    var QueryResultComponent = Ember.Component.extend({
      layoutName: 'explorer-query-result',

      rows: Em.computed.alias('content.rows'),
      columns: Em.computed.alias('content.columns'),
      params: Em.computed.alias('content.params'),
      explainText: Em.computed.alias('content.explain'),

      hasExplain: Em.computed.notEmpty('content.explain'),
      colCount: (function () {
        return this.get('content.columns').length;
      }).property('content.columns.length'),

      duration: (function () {
        return I18n.t('explorer.run_time', { value: I18n.toNumber(this.get('content.duration'), { precision: 1 }) });
      }).property('content.duration'),

      parameterAry: (function () {
        var arr = [];
        var params = this.get('params');
        for (var key in params) {
          if (params.hasOwnProperty(key)) {
            arr.push({ key: key, value: params[key] });
          }
        }
        return arr;
      }).property('params.@each'),

      columnDispNames: (function () {
        if (!this.get('columns')) {
          return [];
        }
        return this.get('columns').map(function (colName) {
          if (colName.endsWith("_id")) {
            return colName.slice(0, -3);
          }
          var dIdx = colName.indexOf('$');
          if (dIdx >= 0) {
            return colName.substring(dIdx + 1);
          }
          return colName;
        });
      }).property('content', 'columns.@each'),

      fallbackTemplate: (function () {
        return this.container.lookup('template:explorer/text.raw');
      }).property(),

      columnTemplates: (function () {
        var self = this;
        if (!this.get('columns')) {
          return [];
        }
        return this.get('columns').map(function (colName, idx) {
          var viewName = "text";
          if (self.get('content.colrender')[idx]) {
            viewName = self.get('content.colrender')[idx];
          }
          return { name: viewName, template: self.container.lookup('template:explorer/' + viewName + '.raw') };
        });
      }).property('content', 'columns.@each'),

      transformedUserTable: (function () {
        return transformedRelTable(this.get('content.relations.user'));
      }).property('content.relations.user'),
      transformedBadgeTable: (function () {
        return transformedRelTable(this.get('content.relations.badge'), Badge);
      }).property('content.relations.badge'),
      transformedPostTable: (function () {
        return transformedRelTable(this.get('content.relations.post'));
      }).property('content.relations.post'),
      transformedTopicTable: (function () {
        return transformedRelTable(this.get('content.relations.topic'));
      }).property('content.relations.topic'),

      transformedGroupTable: (function () {
        return transformedRelTable(this.get('site.groups'));
      }).property('site.groups'),

      lookupUser: function (id) {
        return this.get('transformedUserTable')[id];
      },
      lookupBadge: function (id) {
        return this.get('transformedBadgeTable')[id];
      },
      lookupPost: function (id) {
        return this.get('transformedPostTable')[id];
      },
      lookupTopic: function (id) {
        return this.get('transformedTopicTable')[id];
      },
      lookupGroup: function (id) {
        return this.get('transformedGroupTable')[id];
      },

      lookupCategory: function (id) {
        return this.site.get('categoriesById')[id];
      },

      downloadResult: function (format) {
        // Create a frame to submit the form in (?)
        // to avoid leaving an about:blank behind
        var windowName = randomIdShort();
        var newWindowContents = "<style>body{font-size:36px;display:flex;justify-content:center;align-items:center;}</style><body>Click anywhere to close this window once the download finishes.<script>window.onclick=function(){window.close()};</script>";

        window.open('data:text/html;base64,' + btoa(newWindowContents), windowName);

        var form = document.createElement("form");
        form.setAttribute('id', 'query-download-result');
        form.setAttribute('method', 'post');
        form.setAttribute('action', Discourse.getURL('/admin/plugins/explorer/queries/' + this.get('query.id') + '/run.' + format + '?download=1'));
        form.setAttribute('target', windowName);
        form.setAttribute('style', 'display:none;');

        function addInput(name, value) {
          var field = undefined;
          field = document.createElement('input');
          field.setAttribute('name', name);
          field.setAttribute('value', value);
          form.appendChild(field);
        }

        addInput('params', JSON.stringify(this.get('params')));
        addInput('explain', this.get('hasExplain'));
        addInput('limit', '1000000');

        Discourse.ajax('/session/csrf.json').then(function (csrf) {
          addInput('authenticity_token', csrf.csrf);

          document.body.appendChild(form);
          form.submit();
          Em.run.next('afterRender', function () {
            document.body.removeChild(form);
          });
        });
      },

      actions: {
        downloadResultJson: function () {
          this.downloadResult('json');
        },
        downloadResultCsv: function () {
          this.downloadResult('csv');
        }
      },

      parent: (function () {
        return this;
      }).property()

    });

    __exports__["default"] = QueryResultComponent;
  });
define("discourse/plugins/discourse-data-explorer/discourse/components/query-row-content", 
  ["discourse/helpers/category-link","discourse/lib/formatter","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";


    var categoryLinkHTML = __dependency1__.categoryLinkHTML;
    var autoUpdatingRelativeAge = __dependency2__.autoUpdatingRelativeAge;

    function icon_or_image_replacement(str, ctx) {
      str = Ember.get(ctx.contexts[0], str);
      if (Ember.isEmpty(str)) {
        return "";
      }

      if (str.indexOf('fa-') === 0) {
        return new Handlebars.SafeString("<i class='fa " + str + "'></i>");
      } else {
        return new Handlebars.SafeString("<img src='" + str + "'>");
      }
    }

    function category_badge_replacement(str, ctx) {
      var category = Ember.get(ctx.contexts[0], str);
      return categoryLinkHTML(category, {
        allowUncategorized: true
      });
    }

    function bound_date_replacement(str, ctx) {
      var value = Ember.get(ctx.contexts[0], str);
      return new Handlebars.SafeString(autoUpdatingRelativeAge(new Date(value), { title: true }));
    }

    var esc = Handlebars.Utils.escapeExpression;

    var QueryRowContentComponent = Ember.Component.extend({
      tagName: "tr",

      render: function (buffer) {
        var self = this;
        var row = this.get('row');
        var parent = self.get('parent');
        var fallback = parent.get('fallbackTemplate');
        var helpers = {
          "icon-or-image": icon_or_image_replacement,
          "category-link": category_badge_replacement,
          "reltime": bound_date_replacement
        };

        var parts = this.get('columnTemplates').map(function (t, idx) {
          var value = row[idx],
              id = parseInt(value);

          var ctx = { value: value, id: id, baseuri: Discourse.BaseUri === '/' ? '' : Discourse.BaseUri };
          var params = {};

          if (row[idx] === null) {
            return "NULL";
          } else if (t.name === "text") {
            return esc(row[idx]);
          }

          var lookupFunc = parent['lookup' + t.name.capitalize()];
          if (lookupFunc) {
            ctx[t.name] = parent['lookup' + t.name.capitalize()](id);
          }

          if (t.name === "category" || t.name === "badge" || t.name === "reltime") {
            // only replace helpers if needed
            params.helpers = helpers;
          }

          try {
            return new Handlebars.SafeString((t.template || fallback)(ctx, params));
          } catch (e) {
            console.error(e);
            debugger;
            return "error";
          }
        });

        buffer.push("<td>" + parts.join("</td><td>") + "</td>");
      }
    });

    __exports__["default"] = QueryRowContentComponent;
  });
define("discourse/plugins/discourse-data-explorer/discourse/components/param-input", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // import Category from 'discourse/models/category';
    var Category = Discourse.Category;

    var layoutMap = {
      int: 'int',
      bigint: 'int',
      boolean: 'boolean',
      string: 'generic',
      time: 'generic',
      date: 'generic',
      datetime: 'generic',
      double: 'string',
      user_id: 'user_id',
      post_id: 'string',
      topic_id: 'generic',
      category_id: 'generic',
      group_id: 'generic',
      badge_id: 'generic',
      int_list: 'generic',
      string_list: 'generic',
      user_list: 'user_list'
    };

    function allowsInputTypeTime() {
      try {
        var inp = document.createElement('input');
        inp.attributes.type = 'time';
        inp.attributes.type = 'date';
        return true;
      } catch (e) {
        return false;
      }
    }

    __exports__["default"] = Ember.Component.extend({

      classNameBindings: ['valid:valid:invalid', ':param'],

      boolTypes: [{ name: I18n.t('explorer.types.bool.true'), id: 'Y' }, { name: I18n.t('explorer.types.bool.false'), id: 'N' }, { name: I18n.t('explorer.types.bool.null_'), id: '#null' }],

      value: (function (key, value, previousValue) {
        if (arguments.length > 1) {
          this.get('params')[this.get('info.identifier')] = value.toString();
        }
        return this.get('params')[this.get('info.identifier')];
      }).property('params', 'info.identifier'),

      valueBool: (function (key, value, previousValue) {
        if (arguments.length > 1) {
          this.get('params')[this.get('info.identifier')] = (!!value).toString();
        }
        return this.get('params')[this.get('info.identifier')] !== 'false';
      }).property('params', 'info.identifier'),

      valid: (function () {
        var type = this.get('info.type'),
            value = this.get('value');

        if (Em.isEmpty(this.get('value'))) {
          return this.get('info.nullable');
        }

        function matches(regex) {
          return regex.test(value);
        }

        var intVal = parseInt(value, 10);
        var intValid = !isNaN(intVal) && intVal < 2147483648 && intVal > -2147483649;
        var isPositiveInt = /^\d+$/.test(value);
        switch (type) {
          case 'int':
            return (/^-?\d+$/.test(value) && intValid
            );
          case 'bigint':
            return (/^-?\d+$/.test(value) && !isNaN(intVal)
            );
          case 'boolean':
            return (/^Y|N|#null|true|false/.test(value)
            );
          case 'double':
            return !isNaN(parseFloat(value)) || /^(-?)Inf(inity)?$/i.test(value) || /^(-?)NaN$/i.test(value);
          case 'int_list':
            return value.split(',').every(function (i) {
              return (/^(-?\d+|null)$/.test(i.trim())
              );
            });
          case 'post_id':
            return isPositiveInt || /\d+\/\d+(\?u=.*)?$/.test(value);
          case 'category_id':
            if (!isPositiveInt && value !== value.dasherize()) {
              this.set('value', value.dasherize());
            }

            if (isPositiveInt) {
              return !!this.site.categories.find(function (c) {
                return c.get('id') === intVal;
              });
            } else if (/\//.test(value)) {
              var match = /(.*)\/(.*)/.exec(value);
              if (!match) return false;
              var result = Category.findBySlug(match[2].dasherize(), match[1].dasherize());
              return !!result;
            } else {
              return !!Category.findBySlug(value.dasherize());
            }
          case 'group_id':
            var groups = this.site.get('groups');
            if (isPositiveInt) {
              return !!groups.find(function (g) {
                return g.id === intVal;
              });
            } else {
              return !!groups.find(function (g) {
                return g.name === value;
              });
            }
        }
        return true;
      }).property('value', 'info.type', 'info.nullable'),

      layoutType: (function () {
        var type = this.get('info.type');
        if ((type === "time" || type === "date") && !allowsInputTypeTime()) {
          return "string";
        }
        if (layoutMap[type]) {
          return layoutMap[type];
        }
        return 'generic';
      }).property('info.type'),

      layoutName: (function () {
        return "admin/components/q-params/" + this.get('layoutType');
      }).property('layoutType')
    });
  });
define("discourse/plugins/discourse-data-explorer/discourse/controllers/import-query", 
  ["discourse/mixins/modal-functionality","discourse/lib/ajax-error","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    var ModalFunctionality = __dependency1__["default"];
    var popupAjaxError = __dependency2__.popupAjaxError;

    __exports__["default"] = Ember.Controller.extend(ModalFunctionality, {
      notReady: Em.computed.not('ready'),

      needs: ['admin-plugins-explorer'],

      ready: (function () {
        var parsed = undefined;
        try {
          parsed = JSON.parse(this.get('queryFile'));
        } catch (e) {
          return false;
        }

        return !!parsed["query"];
      }).property('queryFile'),

      actions: {
        doImport: function () {
          var self = this;
          var object = JSON.parse(this.get('queryFile')).query;

          // Slight fixup before creating object
          object.id = 0; // 0 means no Id yet

          this.set('loading', true);
          this.store.createRecord('query', object).save().then(function (query) {
            self.send('closeModal');
            self.set('loading', false);

            var parentController = self.get('controllers.admin-plugins-explorer');
            parentController.addCreatedRecord(query.target);
          }).catch(popupAjaxError);
        }
      }

    });
  });
define("discourse/plugins/discourse-data-explorer/discourse/controllers/admin-plugins-explorer", 
  ["discourse/lib/show-modal","discourse/plugins/discourse-data-explorer/discourse/models/query","discourse/lib/ajax-error","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var showModal = __dependency1__["default"];
    var Query = __dependency2__["default"];
    var popupAjaxError = __dependency3__.popupAjaxError;

    var NoQuery = Query.create({ name: "No queries", fake: true });

    __exports__["default"] = Ember.ArrayController.extend({
      queryParams: { selectedQueryId: "id" },
      selectedQueryId: null,
      showResults: false,
      hideSchema: false,
      loading: false,

      explain: false,

      saveDisabled: Ember.computed.not('selectedItem.dirty'),
      runDisabled: Ember.computed.alias('selectedItem.dirty'),
      results: Em.computed.alias('selectedItem.results'),

      editing: false,
      everEditing: false,

      selectedItem: (function () {
        var _id = this.get('selectedQueryId');
        var id = parseInt(_id);
        var item = this.get('content').find(function (q) {
          return q.get('id') === id;
        });
        return item || NoQuery;
      }).property('selectedQueryId'),

      othersDirty: (function () {
        var selected = this.get('selectedItem');
        return !!this.get('content').find(function (q) {
          return q !== selected && q.get('dirty');
        });
      }).property('selectedItem', 'selectedItem.dirty'),

      setEverEditing: (function () {
        if (this.get('editing') && !this.get('everEditing')) {
          this.set('everEditing', true);
        }
      }).observes('editing'),

      addCreatedRecord: function (record) {
        this.pushObject(record);
        this.set('selectedQueryId', Ember.get(record, 'id'));
        this.get('selectedItem').set('dirty', false);
        this.set('showResults', false);
        this.set('results', null);
        this.set('editing', true);
      },

      save: function () {
        var self = this;
        this.set('loading', true);
        return this.get('selectedItem').save().then(function () {
          var query = self.get('selectedItem');
          query.markNotDirty();
          self.set('editing', false);
        }).catch(function (x) {
          popupAjaxError(x);
          throw x;
        }).finally(function () {
          self.set('loading', false);
        });
      },

      actions: {
        dummy: function () {},

        importQuery: function () {
          showModal('import-query');
          this.set('showCreate', false);
        },

        showCreate: function () {
          this.set('showCreate', true);
        },

        editName: function () {
          this.set('editing', true);
        },

        download: function () {
          window.open(this.get('selectedItem.downloadUrl'), "_blank");
        },

        resetParams: function () {
          this.get('selectedItem').resetParams();
        },

        saveDefaults: function () {
          this.get('selectedItem').saveDefaults();
        },

        save: function () {
          this.save();
        },

        saverun: function () {
          var _this = this;

          this.save().then(function () {
            return _this.send('run');
          });
        },

        create: function () {
          var self = this;
          this.set('loading', true);
          this.set('showCreate', false);
          var newQuery = this.store.createRecord('query', { name: this.get('newQueryName') });
          newQuery.save().then(function (result) {
            self.addCreatedRecord(result.target);
          }).catch(popupAjaxError).finally(function () {
            self.set('loading', false);
          });
        },

        discard: function () {
          var self = this;
          this.set('loading', true);
          this.store.find('query', this.get('selectedItem.id')).then(function (result) {
            var query = self.get('selectedItem');
            query.setProperties(result.getProperties(Query.updatePropertyNames));
            query.markNotDirty();
            self.set('editing', false);
          }).catch(popupAjaxError).finally(function () {
            self.set('loading', false);
          });
        },

        destroy: function () {
          var self = this;
          var query = this.get('selectedItem');
          this.set('loading', true);
          this.store.destroyRecord('query', query).then(function () {
            query.set('destroyed', true);
          }).catch(popupAjaxError).finally(function () {
            self.set('loading', false);
          });
        },

        recover: function () {
          var self = this;
          var query = this.get('selectedItem');
          this.set('loading', true);
          query.save().then(function () {
            query.set('destroyed', false);
          }).catch(popupAjaxError).finally(function () {
            self.set('loading', false);
          });
        },

        run: function () {
          var self = this;
          if (this.get('selectedItem.dirty')) {
            return;
          }
          if (this.get('runDisabled')) {
            return;
          }

          this.set('loading', true);
          this.set('showResults', false);
          Discourse.ajax("/admin/plugins/explorer/queries/" + this.get('selectedItem.id') + "/run", {
            type: "POST",
            data: {
              params: JSON.stringify(this.get('selectedItem.params')),
              explain: this.get('explain')
            }
          }).then(function (result) {
            self.set('results', result);
            if (!result.success) {
              self.set('showResults', false);
              return;
            }

            self.set('showResults', true);
          }).catch(function (err) {
            self.set('showResults', false);
            if (err.jqXHR && err.jqXHR.status === 422 && err.jqXHR.responseJSON) {
              self.set('results', err.jqXHR.responseJSON);
            } else {
              popupAjaxError(err);
            }
          }).finally(function () {
            self.set('loading', false);
          });
        }
      }
    });
  });
define("discourse/plugins/discourse-data-explorer/discourse/explorer-route-map", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = {
      resource: 'admin.adminPlugins',
      path: '/plugins',
      map: function () {
        this.route('explorer');
      }
    };
  });
define("discourse/plugins/discourse-data-explorer/discourse/initializers/initialize-data-explorer", 
  ["exports"],
  function(__exports__) {
    "use strict";

    __exports__["default"] = {
      name: 'initialize-data-explorer',
      initialize: function (container) {
        container.lookup('store:main').addPluralization('query', 'queries');

        if (!String.prototype.endsWith) {
          String.prototype.endsWith = function (searchString, position) {
            var subjectString = this.toString();
            if (position === undefined || position > subjectString.length) {
              position = subjectString.length;
            }
            position -= searchString.length;
            var lastIndex = subjectString.indexOf(searchString, position);
            return lastIndex !== -1 && lastIndex === position;
          };
        }

        // load route
        require('discourse/plugins/discourse-data-explorer/discourse/explorer-route-map');
      }
    };
  });
define("discourse/plugins/discourse-data-explorer/discourse/routes/admin-plugins-explorer", 
  ["exports"],
  function(__exports__) {
    "use strict";

    __exports__["default"] = Discourse.Route.extend({
      controllerName: 'admin-plugins-explorer',
      queryParams: { id: { replace: true } },

      model: function () {
        var p1 = this.store.findAll('query');
        var p2 = Discourse.ajax('/admin/plugins/explorer/schema.json', { cache: true });
        return p1.then(function (model) {
          model.forEach(function (query) {
            return query.markNotDirty();
          });

          return p2.then(function (schema) {
            return { model: model, schema: schema };
          });
        }).catch(function () {
          p2.catch(function () {});
          return { model: null, schema: null, disallow: true };
        });
      },

      setupController: function (controller, model) {
        controller.setProperties(model);
      }
    });
  });
Ember.TEMPLATES["javascripts/explorer/post.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "<aside class=\"quote\"\n       data-post=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"post.post_number",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\"\n       data-topic=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"post.topic_id",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">\n  <div class=\"title\" style=\"cursor: pointer;\">\n  <div class=\"quote-controls\">\n    <a href=\"/t/via-quote/"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"post.topic_id",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "/"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"post.post_number",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\"\n         title=\"go to the quoted post\"\n         class=\"quote-other-topic\"></a></div>\n"
    + container.escapeExpression((helpers.avatar || (depth0 && depth0.avatar) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"post",{"name":"avatar","hash":{"imageSize":"tiny"},"hashTypes":{"imageSize":"StringLiteral"},"hashContexts":{"imageSize":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"post.username",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + ":</div>\n<blockquote><p>"
    + ((stack1 = helpers.get.call(depth0 != null ? depth0 : {},"post.excerpt",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "</p></blockquote></aside>";
},"3":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"id",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}));
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"post",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"useData":true});
Ember.TEMPLATES["javascripts/explorer/text.raw"] = Discourse.EmberCompatHandlebars.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"value",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n";
},"useData":true});
Ember.TEMPLATES["javascripts/explorer/group.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "  <a href=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"baseuri",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "/groups/"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"group.name",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"group.name",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"3":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"id",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"group",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"useData":true});
Ember.TEMPLATES["javascripts/explorer/html.raw"] = Discourse.EmberCompatHandlebars.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers.get.call(depth0 != null ? depth0 : {},"value",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "\n";
},"useData":true});
Ember.TEMPLATES["javascripts/explorer/reltime.raw"] = Discourse.EmberCompatHandlebars.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return container.escapeExpression((helpers.reltime || (depth0 && depth0.reltime) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"value",{"name":"reltime","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n";
},"useData":true});
Ember.TEMPLATES["javascripts/explorer/user.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "  <a href=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"baseuri",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "/users/"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"user.username",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "/activity\"\n     data-user-card=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"user.username",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">"
    + container.escapeExpression((helpers.avatar || (depth0 && depth0.avatar) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"user",{"name":"avatar","hash":{"imageSize":"tiny"},"hashTypes":{"imageSize":"StringLiteral"},"hashContexts":{"imageSize":depth0},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + " "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"user.username",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"3":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"id",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"user",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"useData":true});
Ember.TEMPLATES["javascripts/explorer/category.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    return "  "
    + container.escapeExpression((helpers["category-link"] || (depth0 && depth0["category-link"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"category",{"name":"category-link","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n";
},"3":function(container,depth0,helpers,partials,data) {
    return "  <a href=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"baseuri",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "/t/"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"id",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"id",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"category",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"useData":true});
Ember.TEMPLATES["javascripts/explorer/topic.raw"] = Discourse.EmberCompatHandlebars.template({"1":function(container,depth0,helpers,partials,data) {
    var stack1;

  return "  <a href=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"baseuri",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "/t/"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"topic.slug",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "/"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"topic.id",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\"\n          >"
    + ((stack1 = helpers.get.call(depth0 != null ? depth0 : {},"topic.fancy_title",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "")
    + "</a> ("
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"topic.posts_count",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + ")\n";
},"3":function(container,depth0,helpers,partials,data) {
    return "  <a href=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"baseuri",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "/t/"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"id",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"id",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</a>\n";
},"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    var stack1;

  return ((stack1 = helpers["if"].call(depth0 != null ? depth0 : {},"topic",{"name":"if","hash":{},"hashTypes":{},"hashContexts":{},"fn":container.program(1, data, 0),"inverse":container.program(3, data, 0),"types":["PathExpression"],"contexts":[depth0],"data":data})) != null ? stack1 : "");
},"useData":true});
Ember.TEMPLATES["javascripts/explorer/badge.raw"] = Discourse.EmberCompatHandlebars.template({"compiler":[7,">= 4.0.0"],"main":function(container,depth0,helpers,partials,data) {
    return "<a href=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"baseuri",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "/badges/"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"badge.id",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "/"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"badge.name",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\"\n   class=\"user-badge "
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"badge.badgeTypeClassName",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\"\n   title=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"badge.displayDescription",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\"\n   data-badge-name=\""
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"badge.name",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\">"
    + container.escapeExpression((helpers["icon-or-image"] || (depth0 && depth0["icon-or-image"]) || helpers.helperMissing).call(depth0 != null ? depth0 : {},"badge.icon",{"name":"icon-or-image","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "\n<span class=\"badge-display-name\">"
    + container.escapeExpression(helpers.get.call(depth0 != null ? depth0 : {},"badge.displayName",{"name":"get","hash":{},"hashTypes":{},"hashContexts":{},"types":["PathExpression"],"contexts":[depth0],"data":data}))
    + "</span></a>\n";
},"useData":true});
Ember.TEMPLATES["javascripts/explorer-query-result"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("pre");
        var el2 = dom.createElement("code");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n  ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 0]),0,0);
        content(env, morph0, context, "content.explain");
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("th");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        set(env, context, "col", blockArguments[0]);
        content(env, morph0, context, "col");
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        inline(env, morph0, context, "query-row-content", [], {"row": get(env, context, "row"), "columnTemplates": get(env, context, "columnTemplates"), "parent": get(env, context, "controller")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","result-info");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","result-about");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("table");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("thead");
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("tr");
      dom.setAttribute(el3,"class","headers");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("  ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("tbody");
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, inline = hooks.inline, content = hooks.content, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var element1 = dom.childAt(fragment, [3]);
      var morph0 = dom.createMorphAt(element0,1,1);
      var morph1 = dom.createMorphAt(element0,3,3);
      var morph2 = dom.createMorphAt(element0,5,5);
      var morph3 = dom.createMorphAt(dom.childAt(element0, [7]),1,1);
      var morph4 = dom.createMorphAt(fragment,1,1,contextualElement);
      var morph5 = dom.createMorphAt(dom.childAt(element1, [1, 1]),1,1);
      var morph6 = dom.createMorphAt(dom.childAt(element1, [3]),0,0);
      inline(env, morph0, context, "i18n", ["explorer.download"], {});
      inline(env, morph1, context, "d-button", [], {"action": "downloadResultJson", "icon": "download", "label": "explorer.download_json"});
      inline(env, morph2, context, "d-button", [], {"action": "downloadResultCsv", "icon": "download", "label": "explorer.download_csv"});
      content(env, morph3, context, "duration");
      block(env, morph4, context, "if", [get(env, context, "hasExplain")], {}, child0, null);
      block(env, morph5, context, "each", [get(env, context, "columnDispNames")], {}, child1, null);
      block(env, morph6, context, "each", [get(env, context, "rows")], {"keyword": "row"}, child2, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/admin/plugins-explorer"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("h2");
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
        inline(env, morph0, context, "i18n", ["explorer.admins_only"], {});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","query-create");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element8 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element8,1,1);
          var morph1 = dom.createMorphAt(element8,3,3);
          inline(env, morph0, context, "text-field", [], {"value": get(env, context, "newQueryName"), "placeholderKey": "explorer.create_placeholder"});
          inline(env, morph1, context, "d-button", [], {"action": "create", "label": "explorer.create", "icon": "plus", "class": "btn-primary"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          dom.setAttribute(el1,"class","warning");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element7 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(element7,1,1);
          var morph1 = dom.createMorphAt(element7,3,3);
          inline(env, morph0, context, "fa-icon", ["warning"], {});
          inline(env, morph1, context, "i18n", ["explorer.others_dirty"], {});
          return fragment;
        }
      };
    }());
    var child2 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode(" ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("a");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline, element = hooks.element;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element6 = dom.childAt(fragment, [3]);
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          var morph1 = dom.createMorphAt(element6,0,0);
          inline(env, morph0, context, "i18n", ["explorer.no_queries"], {});
          element(env, element6, context, "action", ["showCreate"], {});
          inline(env, morph1, context, "i18n", ["explorer.no_queries_hook"], {});
          return fragment;
        }
      };
    }());
    var child3 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","name");
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n          ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","desc");
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n          ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              var morph1 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
              inline(env, morph0, context, "text-field", [], {"value": get(env, context, "selectedItem.name")});
              inline(env, morph1, context, "textarea", [], {"value": get(env, context, "selectedItem.description")});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","name");
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("h2");
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n          ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","desc");
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n          ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element1 = dom.childAt(fragment, [1]);
              var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
              var morph1 = dom.createMorphAt(element1,3,3);
              var morph2 = dom.createMorphAt(dom.childAt(fragment, [3]),1,1);
              content(env, morph0, context, "selectedItem.name");
              inline(env, morph1, context, "d-button", [], {"action": "editName", "icon": "pencil", "class": "no-text btn-small"});
              content(env, morph2, context, "selectedItem.description");
              return fragment;
            }
          };
        }());
        var child2 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("div");
              dom.setAttribute(el2,"class","right-panel");
              var el3 = dom.createTextNode("\n              ");
              dom.appendChild(el2, el3);
              var el3 = dom.createElement("div");
              dom.setAttribute(el3,"class","schema grippie-target");
              var el4 = dom.createTextNode("\n                ");
              dom.appendChild(el3, el4);
              var el4 = dom.createComment("");
              dom.appendChild(el3, el4);
              var el4 = dom.createTextNode("\n              ");
              dom.appendChild(el3, el4);
              dom.appendChild(el2, el3);
              var el3 = dom.createTextNode("\n            ");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("div");
              dom.setAttribute(el2,"class","editor-panel");
              var el3 = dom.createTextNode("\n              ");
              dom.appendChild(el2, el3);
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              var el3 = dom.createTextNode("\n            ");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("div");
              dom.setAttribute(el2,"class","grippie");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("div");
              dom.setAttribute(el2,"class","clear");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n          ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element0 = dom.childAt(fragment, [1]);
              var attrMorph0 = dom.createAttrMorph(element0, 'class');
              var morph0 = dom.createMorphAt(dom.childAt(element0, [1, 1]),1,1);
              var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
              attribute(env, attrMorph0, element0, "class", concat(env, ["query-editor ", subexpr(env, context, "if", [get(env, context, "hideSchema"), "no-schema"], {})]));
              inline(env, morph0, context, "explorer-schema", [], {"schema": get(env, context, "schema"), "hideSchema": get(env, context, "hideSchema")});
              inline(env, morph1, context, "ace-editor", [], {"content": get(env, context, "selectedItem.sql"), "mode": "sql"});
              return fragment;
            }
          };
        }());
        var child3 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("div");
              dom.setAttribute(el1,"class","sql");
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              var el2 = dom.createComment("");
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n          ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
              inline(env, morph0, context, "hljs-code-view", [], {"value": get(env, context, "selectedItem.sql"), "codeClass": "sql"});
              return fragment;
            }
          };
        }());
        var child4 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-button", [], {"action": "save", "label": "explorer.save", "disabled": get(env, context, "saveDisabled"), "class": "btn-primary"});
              return fragment;
            }
          };
        }());
        var child5 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-button", [], {"action": "editName", "label": "explorer.edit", "icon": "pencil", "class": "btn-primary"});
              return fragment;
            }
          };
        }());
        var child6 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-button", [], {"action": "recover", "class": "", "icon": "undo", "label": "explorer.recover"});
              return fragment;
            }
          };
        }());
        var child7 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("              ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "d-button", [], {"action": "discard", "class": "btn-danger", "icon": "undo", "label": "explorer.undo", "disabled": get(env, context, "saveDisabled")});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
              dom.insertBoundary(fragment, 0);
              block(env, morph0, context, "if", [get(env, context, "everEditing")], {}, child0, null);
              inline(env, morph1, context, "d-button", [], {"action": "destroy", "class": "btn-danger", "icon": "trash", "label": "explorer.delete"});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n\n\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","clear");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","pull-left");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("          ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","pull-right");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","clear");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var element2 = dom.childAt(fragment, [6]);
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            var morph1 = dom.createMorphAt(fragment,2,2,contextualElement);
            var morph2 = dom.createMorphAt(element2,1,1);
            var morph3 = dom.createMorphAt(element2,3,3);
            var morph4 = dom.createMorphAt(dom.childAt(fragment, [8]),1,1);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "editing")], {}, child0, child1);
            block(env, morph1, context, "if", [get(env, context, "everEditing")], {}, child2, child3);
            block(env, morph2, context, "if", [get(env, context, "everEditing")], {}, child4, child5);
            inline(env, morph3, context, "d-button", [], {"action": "download", "label": "explorer.export", "disabled": get(env, context, "runDisabled"), "icon": "download"});
            block(env, morph4, context, "if", [get(env, context, "selectedItem.destroyed")], {}, child6, child7);
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 1,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement, blockArguments) {
              var dom = env.dom;
              var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              set(env, context, "pinfo", blockArguments[0]);
              inline(env, morph0, context, "param-input", [], {"params": get(env, context, "selectedItem.params"), "info": get(env, context, "pinfo")});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","query-params");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("        ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            block(env, morph0, context, "each", [get(env, context, "selectedItem.param_info")], {}, child0, null);
            return fragment;
          }
        };
      }());
      var child2 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-button", [], {"label": "explorer.run", "disabled": "true", "class": "btn-primary"});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "d-button", [], {"action": "saverun", "label": "explorer.saverun"});
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
            dom.insertBoundary(fragment, null);
            dom.insertBoundary(fragment, 0);
            block(env, morph0, context, "if", [get(env, context, "saveDisabled")], {}, child0, child1);
            return fragment;
          }
        };
      }());
      var child3 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("        ");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
            inline(env, morph0, context, "d-button", [], {"action": "run", "label": "explorer.run", "disabled": get(env, context, "runDisabled"), "class": "btn-primary", "type": "submit"});
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("form");
          dom.setAttribute(el1,"class","query-run");
          var el2 = dom.createTextNode("\n");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("label");
          dom.setAttribute(el2,"class","query-plan");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode(" ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n    ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n\n    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("hr");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element3 = dom.childAt(fragment, [1]);
          var element4 = dom.childAt(fragment, [3]);
          var element5 = dom.childAt(element4, [4]);
          var morph0 = dom.createMorphAt(element3,1,1);
          var attrMorph0 = dom.createAttrMorph(element3, 'class');
          var morph1 = dom.createMorphAt(element4,1,1);
          var morph2 = dom.createMorphAt(element4,2,2);
          var morph3 = dom.createMorphAt(element5,0,0);
          var morph4 = dom.createMorphAt(element5,2,2);
          attribute(env, attrMorph0, element3, "class", concat(env, ["query-edit ", subexpr(env, context, "if", [get(env, context, "editName"), "editing"], {})]));
          block(env, morph0, context, "if", [get(env, context, "selectedItem")], {}, child0, null);
          element(env, element4, context, "action", ["run"], {"on": "submit"});
          block(env, morph1, context, "if", [get(env, context, "selectedItem.hasParams")], {}, child1, null);
          block(env, morph2, context, "if", [get(env, context, "runDisabled")], {}, child2, child3);
          inline(env, morph3, context, "input", [], {"type": "checkbox", "checked": get(env, context, "explain"), "name": "explain"});
          inline(env, morph4, context, "i18n", ["explorer.explain_label"], {});
          return fragment;
        }
      };
    }());
    var child4 = (function() {
      var child0 = (function() {
        var child0 = (function() {
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("          ");
              dom.appendChild(el0, el1);
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
              inline(env, morph0, context, "query-result", [], {"query": get(env, context, "selectedItem"), "content": get(env, context, "results")});
              return fragment;
            }
          };
        }());
        var child1 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 1,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("            ");
                dom.appendChild(el0, el1);
                var el1 = dom.createElement("pre");
                dom.setAttribute(el1,"class","query-error");
                var el2 = dom.createElement("code");
                var el3 = dom.createComment("");
                dom.appendChild(el2, el3);
                dom.appendChild(el1, el2);
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement, blockArguments) {
                var dom = env.dom;
                var hooks = env.hooks, set = hooks.set, content = hooks.content;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 0]),0,0);
                set(env, context, "err", blockArguments[0]);
                content(env, morph0, context, "err");
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createComment("");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
              dom.insertBoundary(fragment, null);
              dom.insertBoundary(fragment, 0);
              block(env, morph0, context, "each", [get(env, context, "results.errors")], {}, child0, null);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("      ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("div");
            dom.setAttribute(el1,"class","query-results");
            var el2 = dom.createTextNode("\n");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("      ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
            block(env, morph0, context, "if", [get(env, context, "showResults")], {}, child0, child1);
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, block = hooks.block;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
          dom.insertBoundary(fragment, null);
          dom.insertBoundary(fragment, 0);
          block(env, morph0, context, "if", [get(env, context, "results")], {}, child0, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","query-list");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("hr");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","explorer-pad-bottom");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element9 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element9,1,1);
        var morph1 = dom.createMorphAt(element9,3,3);
        var morph2 = dom.createMorphAt(element9,5,5);
        var morph3 = dom.createMorphAt(fragment,3,3,contextualElement);
        var morph4 = dom.createMorphAt(fragment,5,5,contextualElement);
        var morph5 = dom.createMorphAt(fragment,9,9,contextualElement);
        var morph6 = dom.createMorphAt(fragment,11,11,contextualElement);
        var morph7 = dom.createMorphAt(fragment,13,13,contextualElement);
        inline(env, morph0, context, "combo-box", [], {"valueAttribute": "id", "value": get(env, context, "selectedQueryId"), "nameProperty": "listName", "content": get(env, context, "content"), "castInteger": "true", "nameChanges": "true"});
        inline(env, morph1, context, "d-button", [], {"action": "showCreate", "icon": "plus", "class": "no-text"});
        inline(env, morph2, context, "d-button", [], {"action": "importQuery", "label": "explorer.import.label", "icon": "upload"});
        block(env, morph3, context, "if", [get(env, context, "showCreate")], {}, child0, null);
        block(env, morph4, context, "if", [get(env, context, "othersDirty")], {}, child1, null);
        block(env, morph5, context, "if", [get(env, context, "selectedItem.fake")], {}, child2, child3);
        inline(env, morph6, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")});
        block(env, morph7, context, "unless", [get(env, context, "selectedItem.fake")], {}, child4, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "disallow")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/admin/components/q-params/generic"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("span");
      dom.setAttribute(el1,"class","param-name");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "text-field", [], {"value": get(env, context, "value")});
      content(env, morph1, context, "info.identifier");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/admin/components/q-params/boolean"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "combo-box", [], {"valueAttribute": "id", "value": get(env, context, "value"), "nameProperty": "name", "content": get(env, context, "boolTypes")});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "valueBool")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("span");
      dom.setAttribute(el1,"class","param-name");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [1]),0,0);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "info.nullable")], {}, child0, child1);
      content(env, morph1, context, "info.identifier");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/admin/components/q-params/user_list"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("span");
      dom.setAttribute(el1,"class","param-name");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "user-selector", [], {"usernames": get(env, context, "value")});
      content(env, morph1, context, "info.identifier");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/admin/components/q-params/int"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("span");
      dom.setAttribute(el1,"class","param-name");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "input", [], {"type": "number", "value": get(env, context, "value")});
      content(env, morph1, context, "info.identifier");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/admin/components/q-params/user_id"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("span");
      dom.setAttribute(el1,"class","param-name");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "user-selector", [], {"usernames": get(env, context, "value"), "single": "true"});
      content(env, morph1, context, "info.identifier");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/admin/components/q-params/string"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("span");
      dom.setAttribute(el1,"class","param-name");
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, inline = hooks.inline, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(dom.childAt(fragment, [2]),0,0);
      dom.insertBoundary(fragment, 0);
      inline(env, morph0, context, "text-field", [], {"value": get(env, context, "value"), "type": "text"});
      content(env, morph1, context, "info.identifier");
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/components/explorer-schema-onetable"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("i");
        dom.setAttribute(el1,"class","fa fa-caret-down");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("i");
        dom.setAttribute(el1,"class","fa fa-caret-right");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      var child0 = (function() {
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("i");
            dom.setAttribute(el1,"class","fa fa-warning");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            return fragment;
          }
        };
      }());
      var child1 = (function() {
        var child0 = (function() {
          var child0 = (function() {
            return {
              isHTMLBars: true,
              revision: "Ember@1.12.2",
              blockParams: 0,
              cachedFragment: null,
              hasRendered: false,
              build: function build(dom) {
                var el0 = dom.createDocumentFragment();
                var el1 = dom.createTextNode("                  ");
                dom.appendChild(el0, el1);
                var el1 = dom.createComment("");
                dom.appendChild(el0, el1);
                var el1 = dom.createTextNode("\n");
                dom.appendChild(el0, el1);
                return el0;
              },
              render: function render(context, env, contextualElement) {
                var dom = env.dom;
                var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
                dom.detectNamespace(contextualElement);
                var fragment;
                if (env.useFragmentCache && dom.canClone) {
                  if (this.cachedFragment === null) {
                    fragment = this.build(dom);
                    if (this.hasRendered) {
                      this.cachedFragment = fragment;
                    } else {
                      this.hasRendered = true;
                    }
                  }
                  if (this.cachedFragment) {
                    fragment = dom.cloneNode(this.cachedFragment, true);
                  }
                } else {
                  fragment = this.build(dom);
                }
                var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
                inline(env, morph0, context, "explorer-schema-enuminfo", [], {"col": get(env, context, "col")});
                return fragment;
              }
            };
          }());
          return {
            isHTMLBars: true,
            revision: "Ember@1.12.2",
            blockParams: 0,
            cachedFragment: null,
            hasRendered: false,
            build: function build(dom) {
              var el0 = dom.createDocumentFragment();
              var el1 = dom.createTextNode("            ");
              dom.appendChild(el0, el1);
              var el1 = dom.createElement("i");
              dom.setAttribute(el1,"class","fa fa-info popup-info");
              var el2 = dom.createTextNode("\n              ");
              dom.appendChild(el1, el2);
              var el2 = dom.createElement("div");
              dom.setAttribute(el2,"class","popup");
              var el3 = dom.createTextNode("\n                ");
              dom.appendChild(el2, el3);
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              var el3 = dom.createTextNode("\n");
              dom.appendChild(el2, el3);
              var el3 = dom.createComment("");
              dom.appendChild(el2, el3);
              var el3 = dom.createTextNode("              ");
              dom.appendChild(el2, el3);
              dom.appendChild(el1, el2);
              var el2 = dom.createTextNode("\n            ");
              dom.appendChild(el1, el2);
              dom.appendChild(el0, el1);
              var el1 = dom.createTextNode("\n");
              dom.appendChild(el0, el1);
              return el0;
            },
            render: function render(context, env, contextualElement) {
              var dom = env.dom;
              var hooks = env.hooks, content = hooks.content, get = hooks.get, block = hooks.block;
              dom.detectNamespace(contextualElement);
              var fragment;
              if (env.useFragmentCache && dom.canClone) {
                if (this.cachedFragment === null) {
                  fragment = this.build(dom);
                  if (this.hasRendered) {
                    this.cachedFragment = fragment;
                  } else {
                    this.hasRendered = true;
                  }
                }
                if (this.cachedFragment) {
                  fragment = dom.cloneNode(this.cachedFragment, true);
                }
              } else {
                fragment = this.build(dom);
              }
              var element0 = dom.childAt(fragment, [1, 1]);
              var morph0 = dom.createMorphAt(element0,1,1);
              var morph1 = dom.createMorphAt(element0,3,3);
              content(env, morph0, context, "col.column_desc");
              block(env, morph1, context, "if", [get(env, context, "col.enum")], {}, child0, null);
              return fragment;
            }
          };
        }());
        return {
          isHTMLBars: true,
          revision: "Ember@1.12.2",
          blockParams: 0,
          cachedFragment: null,
          hasRendered: false,
          build: function build(dom) {
            var el0 = dom.createDocumentFragment();
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("br");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            var el1 = dom.createComment("");
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("          ");
            dom.appendChild(el0, el1);
            var el1 = dom.createElement("span");
            dom.setAttribute(el1,"class","schema-typenotes");
            var el2 = dom.createTextNode("\n            ");
            dom.appendChild(el1, el2);
            var el2 = dom.createComment("");
            dom.appendChild(el1, el2);
            var el2 = dom.createTextNode("\n          ");
            dom.appendChild(el1, el2);
            dom.appendChild(el0, el1);
            var el1 = dom.createTextNode("\n");
            dom.appendChild(el0, el1);
            return el0;
          },
          render: function render(context, env, contextualElement) {
            var dom = env.dom;
            var hooks = env.hooks, get = hooks.get, block = hooks.block, content = hooks.content;
            dom.detectNamespace(contextualElement);
            var fragment;
            if (env.useFragmentCache && dom.canClone) {
              if (this.cachedFragment === null) {
                fragment = this.build(dom);
                if (this.hasRendered) {
                  this.cachedFragment = fragment;
                } else {
                  this.hasRendered = true;
                }
              }
              if (this.cachedFragment) {
                fragment = dom.cloneNode(this.cachedFragment, true);
              }
            } else {
              fragment = this.build(dom);
            }
            var morph0 = dom.createMorphAt(fragment,3,3,contextualElement);
            var morph1 = dom.createMorphAt(dom.childAt(fragment, [5]),1,1);
            block(env, morph0, context, "if", [get(env, context, "col.havepopup")], {}, child0, null);
            content(env, morph1, context, "col.notes");
            return fragment;
          }
        };
      }());
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("div");
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("dt");
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("dd");
          var el3 = dom.createTextNode("\n        ");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("\n");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createTextNode("      ");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n      ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, block = hooks.block, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1]);
          var element2 = dom.childAt(element1, [1]);
          var element3 = dom.childAt(element1, [3]);
          var morph0 = dom.createMorphAt(element2,1,1);
          var morph1 = dom.createMorphAt(element2,3,3);
          var attrMorph0 = dom.createAttrMorph(element2, 'class');
          var attrMorph1 = dom.createAttrMorph(element2, 'title');
          var morph2 = dom.createMorphAt(element3,1,1);
          var morph3 = dom.createMorphAt(element3,3,3);
          set(env, context, "col", blockArguments[0]);
          attribute(env, attrMorph0, element2, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "col.sensitive"), "sensitive"], {})]));
          attribute(env, attrMorph1, element2, "title", concat(env, [subexpr(env, context, "if", [get(env, context, "col.sensitive"), subexpr(env, context, "i18n", ["explorer.schema.sensitive"], {})], {})]));
          block(env, morph0, context, "if", [get(env, context, "col.sensitive")], {}, child0, null);
          content(env, morph1, context, "col.column_name");
          content(env, morph2, context, "col.data_type");
          block(env, morph3, context, "if", [get(env, context, "col.havetypeinfo")], {}, child1, null);
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("dl");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "each", [get(env, context, "table.columns")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","schema-table-name");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","schema-table-cols");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element4 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element4,1,1);
      var morph1 = dom.createMorphAt(element4,3,3);
      var morph2 = dom.createMorphAt(dom.childAt(fragment, [2]),1,1);
      block(env, morph0, context, "if", [get(env, context, "table.open")], {}, child0, child1);
      content(env, morph1, context, "table.name");
      block(env, morph2, context, "if", [get(env, context, "table.open")], {}, child2, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/components/explorer-schema"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"action": "expandSchema", "icon": "chevron-left", "class": "no-text unhide"});
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("        ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        set(env, context, "table", blockArguments[0]);
        inline(env, morph0, context, "explorer-schema-onetable", [], {"table": get(env, context, "table")});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","schema-container");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("ul");
      var el4 = dom.createTextNode("\n");
      dom.appendChild(el3, el4);
      var el4 = dom.createComment("");
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, subexpr = hooks.subexpr, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [1]);
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      var morph1 = dom.createMorphAt(element0,1,1);
      var morph2 = dom.createMorphAt(element0,3,3);
      var morph3 = dom.createMorphAt(element0,5,5);
      var attrMorph0 = dom.createAttrMorph(element0, 'class');
      var morph4 = dom.createMorphAt(dom.childAt(element0, [7, 1]),1,1);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "hideSchema")], {}, child0, null);
      attribute(env, attrMorph0, element0, "class", concat(env, [subexpr(env, context, "if", [get(env, context, "hideSchema"), "hidden"], {})]));
      inline(env, morph1, context, "text-field", [], {"value": get(env, context, "filter"), "placeholderKey": "explorer.schema.filter"});
      inline(env, morph2, context, "d-button", [], {"action": "collapseSchema", "icon": "chevron-right", "class": "no-text btn-small"});
      inline(env, morph3, context, "conditional-loading-spinner", [], {"condition": get(env, context, "loading")});
      block(env, morph4, context, "each", [get(env, context, "tables")], {}, child1, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/components/explorer-schema-enuminfo"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var attrMorph0 = dom.createAttrMorph(element0, 'value');
        set(env, context, "enum", blockArguments[0]);
        attribute(env, attrMorph0, element0, "value", concat(env, [get(env, context, "enum.value")]));
        content(env, morph0, context, "enum.name");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "enuminfo")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/modal/import-query"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("form");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-body");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","modal-footer");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, element = hooks.element, get = hooks.get, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),1,1);
      element(env, element0, context, "action", ["dummy"], {"on": "submit"});
      inline(env, morph0, context, "json-file-uploader", [], {"value": get(env, context, "queryFile"), "extension": ".dcquery.json"});
      inline(env, morph1, context, "d-button", [], {"class": "btn-primary", "action": "doImport", "type": "submit", "disabled": get(env, context, "notReady"), "icon": "plus", "label": "explorer.import.label"});
      return fragment;
    }
  };
}()));
define("discourse/plugins/discourse-details/initializers/apply-details", 
  ["discourse/lib/plugin-api","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var withPluginApi = __dependency1__.withPluginApi;

    __exports__["default"] = {
      name: "apply-details",

      initialize: function () {
        withPluginApi('0.1', function (api) {
          api.decorateCooked(function ($elem) {
            return $("details", $elem).details();
          });
        });
      }
    };
  });
define("discourse/plugins/discourse-google-dfp/discourse/components/google-dfp-ad", 
  ["discourse/lib/load-script","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var loadScript = __dependency1__["default"];

    var _loaded = false,
        _promise = null,
        ads = {};

    function loadGoogle(settings) {
      if (_loaded) {
        return Ember.RSVP.resolve();
      }

      if (_promise) {
        return _promise;
      }

      var dfpSrc = ('https:' == document.location.protocol ? 'https:' : 'http:') + '//www.googletagservices.com/tag/js/gpt.js';
      _promise = loadScript(dfpSrc, { scriptTag: true }).then(function () {
        _loaded = true;
        if (window.googletag === undefined) {
          console.log('googletag is undefined!');
        }

        googletag.cmd.push(function () {
          googletag.pubads().enableSingleRequest();
          googletag.pubads().disableInitialLoad(); // we always use refresh() to fetch the ads
          googletag.enableServices();
        });
      });

      return _promise;
    }

    function defineSlot(placement, settings) {

      if (ads[placement]) {
        return ads[placement];
      }

      if (Discourse.Mobile.mobileView) {
        if (placement === 'topic-list-top' && settings.dfp_mobile_show_topic_list_top && settings.dfp_mobile_topic_list_top_code) {
          ads[placement] = googletag.defineSlot('/' + settings.dfp_id + '/' + settings.dfp_mobile_topic_list_top_code, [320, 50], 'div-gpt-ad-topic-list-top').addService(googletag.pubads());
        } else if (placement === 'topic-top' && settings.dfp_mobile_show_topic_top && settings.dfp_mobile_topic_top_code) {
          ads[placement] = googletag.defineSlot('/' + settings.dfp_id + '/' + settings.dfp_mobile_topic_top_code, [320, 50], 'div-gpt-ad-topic-top').addService(googletag.pubads());
        } else if (placement === 'topic-bottom' && settings.dfp_mobile_show_topic_bottom && settings.dfp_mobile_topic_bottom_code) {
          ads[placement] = googletag.defineSlot('/' + settings.dfp_id + '/' + settings.dfp_mobile_topic_bottom_code, [320, 50], 'div-gpt-ad-topic-bottom').addService(googletag.pubads());
        }
      } else {
        if (placement === 'topic-list-top' && settings.dfp_show_topic_list_top && settings.dfp_topic_list_top_code) {
          ads[placement] = googletag.defineSlot('/' + settings.dfp_id + '/' + settings.dfp_topic_list_top_code, [728, 90], 'div-gpt-ad-topic-list-top').addService(googletag.pubads());
        } else if (placement === 'topic-top' && settings.dfp_show_topic_top && settings.dfp_topic_top_code) {
          ads[placement] = googletag.defineSlot('/' + settings.dfp_id + '/' + settings.dfp_topic_top_code, [728, 90], 'div-gpt-ad-topic-top').addService(googletag.pubads());
        } else if (placement === 'topic-bottom' && settings.dfp_show_topic_bottom && settings.dfp_topic_bottom_code) {
          ads[placement] = googletag.defineSlot('/' + settings.dfp_id + '/' + settings.dfp_topic_bottom_code, [728, 90], 'div-gpt-ad-topic-bottom').addService(googletag.pubads());
        }
      }

      return ads[placement];
    }

    __exports__["default"] = Ember.Component.extend({
      classNames: ['google-dfp-ad'],
      loadedGoogletag: false,

      divId: (function () {
        return "div-gpt-ad-" + this.get('placement');
      }).property('placement'),

      fixedSize: (function () {
        if (Discourse.Mobile.mobileView) {
          return new Ember.Handlebars.SafeString('width: 320px; height: 50px;');
        } else {
          return new Ember.Handlebars.SafeString('width: 728px; height: 90px;');
        }
      }).property(),

      refreshAd: (function () {
        var ad = ads[this.get('placement')];
        if (!ad) {
          return;
        }

        if (this.get('loadedGoogletag')) {
          googletag.cmd.push(function () {
            googletag.pubads().refresh([ad]);
          });
        }
      }).observes('refreshOnChange'),

      _initGoogleDFP: (function () {
        var self = this;
        loadGoogle(Discourse.SiteSettings).then(function () {
          self.set('loadedGoogletag', true);
          googletag.cmd.push(function () {
            var ad = defineSlot(self.get('placement'), self.siteSettings);
            if (ad) {
              googletag.display(self.get('divId'));
              googletag.pubads().refresh([ad]);
            }
          });
        });
      }).on('didInsertElement')
    });
  });
Ember.TEMPLATES["javascripts/connectors/topic-above-suggested/discourse-google-dfp"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "google-dfp-ad", [], {"placement": "topic-bottom", "refreshOnChange": get(env, context, "model.id")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "siteSettings.dfp_mobile_show_topic_bottom")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "google-dfp-ad", [], {"placement": "topic-bottom", "refreshOnChange": get(env, context, "model.id")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "siteSettings.dfp_show_topic_bottom")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "site.mobileView")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/connectors/discovery-list-container-top/discourse-google-dfp"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "google-dfp-ad", [], {"placement": "topic-list-top"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "siteSettings.dfp_mobile_show_topic_list_top")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "google-dfp-ad", [], {"placement": "topic-list-top"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "siteSettings.dfp_show_topic_list_top")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "site.mobileView")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/connectors/topic-above-post-stream/discourse-google-dfp"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "google-dfp-ad", [], {"placement": "topic-top", "refreshOnChange": get(env, context, "model.id")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "siteSettings.dfp_mobile_show_topic_top")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "google-dfp-ad", [], {"placement": "topic-top", "refreshOnChange": get(env, context, "model.id")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "siteSettings.dfp_show_topic_top")], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "site.mobileView")], {}, child0, child1);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/components/google-dfp-ad"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","google-dfp-ad-label");
      var el2 = dom.createElement("h2");
      var el3 = dom.createTextNode("ADVERTISEMENT");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","dfp-ad-unit");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element0 = dom.childAt(fragment, [2]);
      var attrMorph0 = dom.createAttrMorph(element0, 'id');
      var attrMorph1 = dom.createAttrMorph(element0, 'style');
      attribute(env, attrMorph0, element0, "id", concat(env, [get(env, context, "divId")]));
      attribute(env, attrMorph1, element0, "style", get(env, context, "fixedSize"));
      return fragment;
    }
  };
}()));
define("discourse/plugins/discourse-solved/discourse/pre-initializers/extend-category-for-solved", 
  ["ember-addons/ember-computed-decorators","discourse/models/category","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var property = __dependency1__["default"];
    var Category = __dependency2__["default"];

    __exports__["default"] = {
      name: 'extend-category-for-solved',
      before: 'inject-discourse-objects',
      initialize: function () {

        Category.reopen(_createDecoratedObject([{
          key: 'enable_accepted_answers',
          decorators: [property('custom_fields.enable_accepted_answers')],
          initializer: function () {
            return {
              get: function (enableField) {
                return enableField === "true";
              },
              set: function (value) {
                value = value ? "true" : "false";
                this.set("custom_fields.enable_accepted_answers", value);
                return value;
              }
            };
          }
        }]));
      }
    };
  });
define("discourse/plugins/discourse-solved/discourse/initializers/extend-for-solved-button", 
  ["discourse/views/post","discourse/components/post-menu","discourse/models/topic","discourse/models/user","discourse/views/topic-status","discourse/lib/ajax-error","discourse/lib/plugin-api","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
    "use strict";
    var PostView = __dependency1__["default"];
    var PostMenuComponent = __dependency2__["default"];
    var Button = __dependency2__.Button;
    var Topic = __dependency3__["default"];
    var User = __dependency4__["default"];
    var TopicStatus = __dependency5__["default"];
    var popupAjaxError = __dependency6__.popupAjaxError;
    var withPluginApi = __dependency7__.withPluginApi;

    function clearAccepted(topic) {
      var posts = topic.get('postStream.posts');
      posts.forEach(function (post) {
        if (post.get('post_number') > 1) {
          post.set('accepted_answer', false);
          post.set('can_accept_answer', true);
          post.set('can_unaccept_answer', false);
        }
      });
    }

    function unacceptPost(post) {
      if (!post.get('can_unaccept_answer')) {
        return;
      }
      var topic = post.topic;

      post.setProperties({
        can_accept_answer: true,
        can_unaccept_answer: false,
        accepted_answer: false
      });
      topic.set('accepted_answer', undefined);

      Discourse.ajax("/solution/unaccept", {
        type: 'POST',
        data: { id: post.get('id') }
      }).catch(popupAjaxError);
    }

    function acceptPost(post) {
      var topic = post.topic;

      clearAccepted(topic);

      post.setProperties({
        can_unaccept_answer: true,
        can_accept_answer: false,
        accepted_answer: true
      });

      topic.set('accepted_answer', {
        username: post.get('username'),
        post_number: post.get('post_number')
      });

      Discourse.ajax("/solution/accept", {
        type: 'POST',
        data: { id: post.get('.id') }
      }).catch(popupAjaxError);
    }

    // Code for older discourse installs for backwards compatibility
    function oldPluginCode() {
      PostView.reopen({
        classNameBindings: ['post.accepted_answer:accepted-answer']
      });

      PostMenuComponent.registerButton(function (visibleButtons) {
        var position = 0;

        var canAccept = this.get('post.can_accept_answer');
        var canUnaccept = this.get('post.can_unaccept_answer');
        var accepted = this.get('post.accepted_answer');
        var isOp = Discourse.User.currentProp("id") === this.get('post.topic.user_id');

        if (!accepted && canAccept && !isOp) {
          // first hidden position
          if (this.get('collapsed')) {
            return;
          }
          position = visibleButtons.length - 2;
        }
        if (canAccept) {
          visibleButtons.splice(position, 0, new Button('acceptAnswer', 'solved.accept_answer', 'check-square-o', { className: 'unaccepted' }));
        }
        if (canUnaccept || accepted) {
          var locale = canUnaccept ? 'solved.unaccept_answer' : 'solved.accepted_answer';
          visibleButtons.splice(position, 0, new Button('unacceptAnswer', locale, 'check-square', { className: 'accepted fade-out', prefixHTML: '<span class="accepted-text">' + I18n.t('solved.solution') + '</span>' }));
        }
      });

      PostMenuComponent.reopen({
        acceptedChanged: (function () {
          this.rerender();
        }).observes('post.accepted_answer'),

        clickUnacceptAnswer: function () {
          unacceptPost(this.get('post'));
        },

        clickAcceptAnswer: function () {
          acceptPost(this.get('post'));
        }
      });
    }

    function initializeWithApi(api) {
      var currentUser = api.getCurrentUser();

      api.includePostAttributes('can_accept_answer', 'can_unaccept_answer', 'accepted_answer');

      api.addPostMenuButton('solved', function (attrs) {
        var canAccept = attrs.can_accept_answer;
        var canUnaccept = attrs.can_unaccept_answer;
        var accepted = attrs.accepted_answer;
        var isOp = currentUser && currentUser.id === attrs.topicCreatedById;
        var position = !accepted && canAccept && !isOp ? 'second-last-hidden' : 'first';

        if (canAccept) {
          return {
            action: 'acceptAnswer',
            icon: 'check-square-o',
            className: 'unaccepted',
            title: 'solved.accept_answer',
            position: position
          };
        } else if (canUnaccept || accepted) {
          var title = canUnaccept ? 'solved.unaccept_answer' : 'solved.accepted_answer';
          return {
            action: 'unacceptAnswer',
            icon: 'check-square',
            title: title,
            className: 'accepted fade-out',
            position: position,
            beforeButton: function (h) {
              return h('span.accepted-text', I18n.t('solved.solution'));
            }
          };
        }
      });

      api.decorateWidget('post-contents:after-cooked', function (dec) {
        if (dec.attrs.post_number === 1) {
          var topic = dec.getModel().get('topic');
          if (topic.get('accepted_answer')) {
            return dec.rawHtml('<p class="solved">' + topic.get('acceptedAnswerHtml') + '</p>');
          }
        }
      });

      api.attachWidgetAction('post', 'acceptAnswer', function () {
        var _this = this;

        var post = this.model;
        var current = post.get('topic.postStream.posts').filter(function (p) {
          return p.get('post_number') === 1 || p.get('accepted_answer');
        });
        acceptPost(post);

        current.forEach(function (p) {
          return _this.appEvents.trigger('post-stream:refresh', { id: p.id });
        });
      });

      api.attachWidgetAction('post', 'unacceptAnswer', function () {
        var post = this.model;
        var op = post.get('topic.postStream.posts').find(function (p) {
          return p.get('post_number') === 1;
        });
        unacceptPost(post);
        this.appEvents.trigger('post-stream:refresh', { id: op.get('id') });
      });
    }

    __exports__["default"] = {
      name: 'extend-for-solved-button',
      initialize: function () {

        Topic.reopen({
          // keeping this here cause there is complex localization
          acceptedAnswerHtml: (function () {
            var username = this.get('accepted_answer.username');
            var postNumber = this.get('accepted_answer.post_number');

            if (!username || !postNumber) {
              return "";
            }

            return I18n.t("solved.accepted_html", {
              username_lower: username.toLowerCase(),
              username: username,
              post_path: this.get('url') + "/" + postNumber,
              post_number: postNumber,
              user_path: User.create({ username: username }).get('path')
            });
          }).property('accepted_answer', 'id')
        });

        TopicStatus.reopen({
          statuses: (function () {
            var results = this._super();
            if (this.topic.has_accepted_answer) {
              results.push({
                openTag: 'span',
                closeTag: 'span',
                title: I18n.t('solved.has_accepted_answer'),
                icon: 'check-square-o'
              });
            }
            return results;
          }).property()
        });

        withPluginApi('0.1', initializeWithApi, { noApi: oldPluginCode });
      }
    };
  });
Ember.TEMPLATES["javascripts/discourse/connectors/topic-after-cooked/solved-panel"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","solved");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [0]),1,1);
        content(env, morph0, context, "topic.acceptedAnswerHtml");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "topic.accepted_answer")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/discourse/connectors/category-custom-settings/solved-settings"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createElement("section");
        dom.setAttribute(el1,"class","field");
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","enable-accepted-answer");
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("label");
        dom.setAttribute(el3,"class","checkbox-label");
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n    ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n  ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [0, 1, 1]);
        var morph0 = dom.createMorphAt(element0,1,1);
        var morph1 = dom.createMorphAt(element0,3,3);
        inline(env, morph0, context, "input", [], {"type": "checkbox", "checked": get(env, context, "category.enable_accepted_answers")});
        inline(env, morph1, context, "i18n", ["solved.allow_accepted_answers"], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "unless", [get(env, context, "siteSettings.allow_solved_on_all_topics")], {}, child0, null);
      return fragment;
    }
  };
}()));
define("discourse/plugins/Spoiler Alert!/initializers/spoiler-alert", 
  ["discourse/lib/plugin-api","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var withPluginApi = __dependency1__.withPluginApi;
    var decorateCooked = __dependency1__.decorateCooked;

    function spoil($elem) {
      $('.spoiler', $elem).removeClass('spoiler').addClass('spoiled').spoil();
    }

    __exports__["default"] = {
      name: "apply-spoilers",
      initialize: function (container) {
        var siteSettings = container.lookup('site-settings:main');
        if (siteSettings.spoiler_enabled) {
          withPluginApi('0.1', function (api) {
            return api.decorateCooked(spoil);
          }, { noApi: function () {
              return decorateCooked(container, spoil);
            } });
        }
      }
    };
  });
define("discourse/plugins/staff-notes/discourse/adapters/staff-note", 
  ["discourse/adapters/rest","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var RestAdapter = __dependency1__["default"];
    var ajax = Discourse.ajax;

    __exports__["default"] = RestAdapter.extend({
      destroyRecord: function (store, type, record) {
        var path = this.pathFor(store, type, record.get('id'));
        var userId = record.get('user_id');
        return ajax(path + '?user_id=' + userId, { method: 'DELETE' });
      }
    });
  });
define("discourse/plugins/staff-notes/discourse/controllers/staff-notes", 
  ["ember-addons/ember-computed-decorators","discourse/lib/ajax-error","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__.default;
    var on = __dependency1__.on;
    var popupAjaxError = __dependency2__.popupAjaxError;

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: 'newNote',
      initializer: function () {
        return null;
      }
    }, {
      key: 'saving',
      initializer: function () {
        return false;
      }
    }, {
      key: 'user',
      initializer: function () {
        return null;
      }
    }, {
      key: 'reset',
      decorators: [on('init')],
      value: function () {
        this.setProperties({ newNote: null, saving: false, callback: null });
      }
    }, {
      key: 'attachDisabled',
      decorators: [computed('newNote', 'saving')],
      value: function (newNote, saving) {
        return saving || !newNote || newNote.length === 0;
      }
    }, {
      key: '_refreshCount',
      value: function () {
        var callback = this.get('callback');
        if (callback) {
          callback(this.get('model.length'));
        }
      }
    }, {
      key: 'actions',
      initializer: function () {
        return {
          attachNote: function () {
            var _this = this;

            var note = this.store.createRecord('staff-note');
            var userId = parseInt(this.get('userId'));

            this.set('saving', true);
            note.save({ raw: this.get('newNote'), user_id: userId }).then(function () {
              _this.set('newNote', '');
              _this.get('model').pushObject(note);
              _this._refreshCount();
            }).catch(popupAjaxError).finally(function () {
              return _this.set('saving', false);
            });
          },

          removeNote: function (note) {
            var _this2 = this;

            bootbox.confirm(I18n.t("staff_notes.delete_confirm"), I18n.t("no_value"), I18n.t("yes_value"), function (result) {
              if (result) {
                note.destroyRecord().then(function () {
                  var notes = _this2.get('model');
                  notes.removeObject(note);
                  _this2._refreshCount();
                }).catch(popupAjaxError);
              }
            });
          }
        };
      }
    }]));
  });
define("discourse/plugins/staff-notes/discourse/initializers/enable-staff-notes", 
  ["discourse/lib/plugin-api","discourse/lib/show-modal","discourse/lib/load-script","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __exports__) {
    "use strict";
    var withPluginApi = __dependency1__.withPluginApi;
    var showModal = __dependency2__["default"];
    var loadScript = __dependency3__["default"];

    __exports__["default"] = {
      name: 'enable-staff-notes',
      initialize: function (container) {
        var siteSettings = container.lookup('site-settings:main');
        var currentUser = container.lookup('current-user:main');
        if (!siteSettings.staff_notes_enabled || !currentUser || !currentUser.staff) {
          return;
        }

        var store = container.lookup('store:main');

        withPluginApi('0.2', function (api) {
          function showStaffNotes(userId, callback) {
            return loadScript('defer/html-sanitizer-bundle').then(function () {
              return store.find('staff-note', { user_id: userId }).then(function (model) {
                var controller = showModal('staff-notes', { model: model, title: 'staff_notes.title' });
                controller.reset();
                controller.set('userId', userId);
                controller.set('callback', callback);
                return controller;
              });
            });
          }

          function widgetShowStaffNotes() {
            var _this = this;

            showStaffNotes(this.attrs.user_id, function (count) {
              _this.sendWidgetAction('refreshStaffNotes', count);
            });
          }

          api.attachWidgetAction('post', 'refreshStaffNotes', function (count) {
            var cfs = this.model.get('user_custom_fields') || {};
            cfs.staff_notes_count = count;
            this.model.set('user_custom_fields', cfs);
          });

          var UserController = container.lookupFactory('controller:user');
          UserController.reopen({
            staffNotesCount: null,

            _modelChanged: (function () {
              this.set('staffNotesCount', this.get('model.custom_fields.staff_notes_count') || 0);
            }).observes('model').on('init'),

            actions: {
              showStaffNotes: function () {
                var _this2 = this;

                var user = this.get('model');
                showStaffNotes(user.get('id'), function (count) {
                  return _this2.set('staffNotesCount', count);
                });
              }
            }
          });

          var mobileView = api.container.lookup('site:main').mobileView;
          var loc = mobileView ? 'before' : 'after';
          api.decorateWidget('poster-name:' + loc, function (dec) {
            var cfs = dec.attrs.userCustomFields || {};
            if (cfs.staff_notes_count > 0) {
              return dec.attach('staff-notes-icon');
            }
          });

          api.decorateWidget('post-admin-menu:after', function (dec) {
            return dec.attach('post-admin-menu-button', {
              icon: 'pencil',
              label: 'staff_notes.attach',
              action: 'showStaffNotes'
            });
          });

          api.attachWidgetAction('post-admin-menu', 'showStaffNotes', widgetShowStaffNotes);

          api.createWidget('staff-notes-icon', {
            tagName: 'span.staff-notes-icon',
            click: widgetShowStaffNotes,

            html: function () {
              return this.attach('emoji', { name: 'pencil' });
            }
          });
        });
      }
    };
  });
Ember.TEMPLATES["javascripts/discourse-staff-notes/templates/connectors/user-profile-controls/show-notes-on-profile"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"href","");
          dom.setAttribute(el2,"class","btn");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline, get = hooks.get;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element1 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element1,0,0);
          var morph1 = dom.createMorphAt(element1,1,1);
          element(env, element1, context, "action", ["showStaffNotes"], {});
          inline(env, morph0, context, "fa-icon", ["pencil"], {});
          inline(env, morph1, context, "i18n", ["staff_notes.show"], {"count": get(env, context, "staffNotesCount")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("    ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("li");
          var el2 = dom.createElement("a");
          dom.setAttribute(el2,"href","");
          dom.setAttribute(el2,"class","btn");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1, 0]);
          var morph0 = dom.createMorphAt(element0,0,0);
          var morph1 = dom.createMorphAt(element0,1,1);
          element(env, element0, context, "action", ["showStaffNotes"], {});
          inline(env, morph0, context, "fa-icon", ["pencil"], {});
          inline(env, morph1, context, "i18n", ["staff_notes.title"], {});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "staffNotesCount")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "currentUser.staff")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/modal/staff-notes"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "avatar", [get(env, context, "n.created_by")], {"imageSize": "small"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("            ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("span");
          dom.setAttribute(el1,"class","controls");
          var el2 = dom.createTextNode("\n              ");
          dom.appendChild(el1, el2);
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n            ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
          inline(env, morph0, context, "d-button", [], {"action": "removeNote", "actionParam": get(env, context, "n"), "icon": "times", "class": "btn-small btn-danger", "title": "staff_notes.remove"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("div");
        dom.setAttribute(el1,"class","staff-note");
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","posted-by");
        var el3 = dom.createTextNode("\n");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","note-contents");
        var el3 = dom.createTextNode("\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","note-info");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("span");
        dom.setAttribute(el4,"class","username");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("span");
        dom.setAttribute(el4,"class","post-date");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n\n");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n\n        ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","cooked");
        var el4 = dom.createTextNode("\n          ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","clearfix");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, get = hooks.get, block = hooks.block, content = hooks.content, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var element1 = dom.childAt(element0, [3]);
        var element2 = dom.childAt(element1, [1]);
        var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),1,1);
        var morph1 = dom.createMorphAt(dom.childAt(element2, [1]),0,0);
        var morph2 = dom.createMorphAt(dom.childAt(element2, [3]),0,0);
        var morph3 = dom.createMorphAt(element2,5,5);
        var morph4 = dom.createMorphAt(dom.childAt(element1, [3]),1,1);
        set(env, context, "n", blockArguments[0]);
        block(env, morph0, context, "user-link", [], {"user": get(env, context, "n.created_by")}, child0, null);
        content(env, morph1, context, "n.created_by.username");
        inline(env, morph2, context, "age-with-tooltip", [get(env, context, "n.created_at")], {});
        block(env, morph3, context, "if", [get(env, context, "n.can_delete")], {}, child1, null);
        inline(env, morph4, context, "cook-text", [get(env, context, "n.raw")], {});
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","modal-body staff-notes-modal");
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element3 = dom.childAt(fragment, [0]);
      var morph0 = dom.createMorphAt(element3,1,1);
      var morph1 = dom.createMorphAt(element3,3,3);
      var morph2 = dom.createMorphAt(element3,5,5);
      block(env, morph0, context, "each", [get(env, context, "model")], {}, child0, null);
      inline(env, morph1, context, "textarea", [], {"value": get(env, context, "newNote")});
      inline(env, morph2, context, "d-button", [], {"action": "attachNote", "label": "staff_notes.attach", "class": "btn-primary", "disabled": get(env, context, "attachDisabled")});
      return fragment;
    }
  };
}()));
define("discourse/plugins/hosted-site/initializers/anon-init", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;

    __exports__["default"] = {
      name: 'apply-anon-init',
      initialize: function (container) {

        var GlobalNoticeComponent = container.lookupFactory('component:global-notice');

        if (GlobalNoticeComponent) {
          GlobalNoticeComponent.reopen(_createDecoratedObject([{
            key: '_hideOtherAlerts',
            decorators: [on('didInsertElement')],
            value: function () {
              Em.run.schedule("afterRender", function () {
                if ($(".alert .trial-expired-message").size() > 0) {
                  $(".alert-read-only").hide();
                  $(".alert-too-few-topics").hide();
                }
              });
            }
          }]));
        }
      }
    };
  });
define("discourse/plugins/hosted-site/discourse/components/hosted-dashboard", 
  ["discourse/lib/show-modal","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var showModal = __dependency1__["default"];

    __exports__["default"] = Ember.Component.extend({
      classNameBindings: [':hosted-dashboard', 'shouldHide:hidden'],

      loading: true,
      shouldHide: true,

      showChangeCreditCard: true,
      changeCreditCardUrl: null,
      startSubscriptionUrl: null,
      showEnableSSLButton: true,
      showCreditCardInfo: false,
      trialActive: false,
      trialExpired: false,
      paid: false,
      paymentDue: false,

      fetchAccountInfo: function () {
        this.set('loading', true);
        var self = this;

        return Discourse.ajax("/admin/hosted_account").then(function (data) {
          if (data.payment_method === 'none') {
            self.set('shouldHide', true);
          } else {
            switch (data.account_status) {
              case 'trial':
                self.set('trialActive', true);break;
              case 'trial_expired':
                self.set('trialExpired', true);break;
              case 'subscriber':
                self.set('paid', true);break;
              case 'payment_due':
                self.set('paymentDue', true);break;
            }
            self.set('changeCreditCardUrl', data.change_credit_card_url);
            self.set('startSubscriptionUrl', data.start_subscription_url);
            self.set('showEnableSSLButton', !data.ssl_requested);
            self.set('billingEmailAddress', data.billing_email_address);
            if (data.cc_last4) {
              self.set('ccBrand', data.cc_brand);
              self.set('ccLast4', data.cc_last4);
              self.set('ccExpMonth', data.cc_exp_month);
              self.set('ccExpYear', data.cc_exp_year);
              self.set('showCreditCardInfo', true);
            } else {
              self.set('showCreditCardInfo', false);
            }
            self.set('loading', false);
            self.set('shouldHide', false);
          }
        }, function () {
          self.set('loading', false);
          self.set('shouldHide', true);
        });
      },

      _initHostedDashboard: (function () {
        this.fetchAccountInfo();
      }).on('didInsertElement'),

      actions: {
        changeBillingEmail: function () {
          showModal('admin-billing-email');
        },

        enableSSL: function () {
          var controller = showModal('admin-enable-ssl');
          controller.set('startSubscriptionUrl', this.get('startSubscriptionUrl'));
        }
      }
    });
  });
Ember.TEMPLATES["javascripts/connectors/admin-dashboard-top/hosted-site"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        content(env, morph0, context, "hosted-dashboard");
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "if", [get(env, context, "currentUser.admin")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/components/hosted-dashboard"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("@discourse");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","hosted-trial-welcome");
        var el2 = dom.createTextNode("Welcome to your free trial of Discourse!");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","hosted-contact");
        var el2 = dom.createTextNode("Feel free to contact us any time if you have questions, by emailing us at ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","mailto:support@discourse.org");
        var el3 = dom.createTextNode("support@discourse.org");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" or by sending a message to ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" here.");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [3]),3,3);
        block(env, morph0, context, "link-to", ["user", "discourse"], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","hosted-trial-expired");
        var el2 = dom.createTextNode("Your free trial has expired. Use the button below to start your subscription.");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","hosted-active-subscription");
        var el2 = dom.createTextNode("You have an active subscription. Thank you!");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","hosted-payment_due");
        var el2 = dom.createElement("strong");
        var el3 = dom.createTextNode("You have an overdue subscription payment.");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","hosted-payment_due");
        var el2 = dom.createTextNode("If you need to change your payment method, please use the button below. We will attempt to collect payment again in the next few days.");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"target","_blank");
        dom.setAttribute(el2,"class","btn");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          Change Credit Card\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element3 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element3,1,1);
        var attrMorph0 = dom.createAttrMorph(element3, 'href');
        attribute(env, attrMorph0, element3, "href", concat(env, [get(env, context, "changeCreditCardUrl")]));
        inline(env, morph0, context, "fa-icon", ["credit-card"], {});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"target","_blank");
        dom.setAttribute(el2,"class","btn");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          Start Subscription\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, concat = hooks.concat, attribute = hooks.attribute, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element2 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element2,1,1);
        var attrMorph0 = dom.createAttrMorph(element2, 'href');
        attribute(env, attrMorph0, element2, "href", concat(env, [get(env, context, "startSubscriptionUrl")]));
        inline(env, morph0, context, "replace-emoji", [":sparkles:"], {});
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n        ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"class","btn");
        var el3 = dom.createTextNode("\n          ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n          Enable SSL\n        ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, element = hooks.element, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element1 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element1,1,1);
        element(env, element1, context, "action", ["enableSSL"], {});
        inline(env, morph0, context, "fa-icon", ["lock"], {});
        return fragment;
      }
    };
  }());
  var child7 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","hosted-current-payment-method");
        var el2 = dom.createTextNode("\n      Current payment method:\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","hosted-cc-info");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode(" ****");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode(" EXP ");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("/");
        dom.appendChild(el2, el3);
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1, 1]);
        var morph0 = dom.createMorphAt(element0,0,0);
        var morph1 = dom.createMorphAt(element0,2,2);
        var morph2 = dom.createMorphAt(element0,4,4);
        var morph3 = dom.createMorphAt(element0,6,6);
        content(env, morph0, context, "ccBrand");
        content(env, morph1, context, "ccLast4");
        content(env, morph2, context, "ccExpMonth");
        content(env, morph3, context, "ccExpYear");
        return fragment;
      }
    };
  }());
  var child8 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","hosted-current-billing-email");
        var el2 = dom.createTextNode("\n      Current billing email address:\n      ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("span");
        dom.setAttribute(el2,"class","hosted-email-value");
        var el3 = dom.createComment("");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, content = hooks.content;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1, 1]),0,0);
        content(env, morph0, context, "billingEmailAddress");
        return fragment;
      }
    };
  }());
  var child9 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("@discourse");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("p");
        dom.setAttribute(el1,"class","hosted-contact");
        var el2 = dom.createTextNode("Feel free to contact us any time if you have questions, by emailing us at ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("a");
        dom.setAttribute(el2,"href","mailto:support@discourse.org");
        var el3 = dom.createTextNode("support@discourse.org");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" or by sending a message to ");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode(" here.");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),3,3);
        block(env, morph0, context, "link-to", ["user", "discourse"], {}, child0, null);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","admin-controls");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("h3");
      var el3 = dom.createTextNode("Account Management");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","admin-container");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("ul");
      dom.setAttribute(el2,"class","hosted-account-links");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("li");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("a");
      dom.setAttribute(el4,"class","btn");
      var el5 = dom.createTextNode("\n        ");
      dom.appendChild(el4, el5);
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      var el5 = dom.createTextNode("\n        Change Billing Email\n      ");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","clearfix");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","clearfix");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, element = hooks.element, inline = hooks.inline;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element4 = dom.childAt(fragment, [2]);
      var element5 = dom.childAt(element4, [7]);
      var element6 = dom.childAt(element5, [3, 1]);
      var morph0 = dom.createMorphAt(element4,1,1);
      var morph1 = dom.createMorphAt(element4,3,3);
      var morph2 = dom.createMorphAt(element4,4,4);
      var morph3 = dom.createMorphAt(element4,5,5);
      var morph4 = dom.createMorphAt(element5,1,1);
      var morph5 = dom.createMorphAt(element6,1,1);
      var morph6 = dom.createMorphAt(element5,5,5);
      var morph7 = dom.createMorphAt(element5,6,6);
      var morph8 = dom.createMorphAt(element4,11,11);
      var morph9 = dom.createMorphAt(element4,13,13);
      var morph10 = dom.createMorphAt(element4,15,15);
      block(env, morph0, context, "if", [get(env, context, "trialActive")], {}, child0, null);
      block(env, morph1, context, "if", [get(env, context, "trialExpired")], {}, child1, null);
      block(env, morph2, context, "if", [get(env, context, "paid")], {}, child2, null);
      block(env, morph3, context, "if", [get(env, context, "paymentDue")], {}, child3, null);
      block(env, morph4, context, "if", [get(env, context, "changeCreditCardUrl")], {}, child4, null);
      element(env, element6, context, "action", ["changeBillingEmail"], {});
      inline(env, morph5, context, "fa-icon", ["envelope-o"], {});
      block(env, morph6, context, "if", [get(env, context, "startSubscriptionUrl")], {}, child5, null);
      block(env, morph7, context, "if", [get(env, context, "showEnableSSLButton")], {}, child6, null);
      block(env, morph8, context, "if", [get(env, context, "showCreditCardInfo")], {}, child7, null);
      block(env, morph9, context, "if", [get(env, context, "billingEmailAddress")], {}, child8, null);
      block(env, morph10, context, "unless", [get(env, context, "trialActive")], {}, child9, null);
      return fragment;
    }
  };
}()));
define("discourse/plugins/lazyYT/initializers/lazyYT", 
  ["discourse/lib/plugin-api","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var withPluginApi = __dependency1__.withPluginApi;

    __exports__["default"] = {
      name: "apply-lazyYT",
      initialize: function () {
        withPluginApi('0.1', function (api) {
          api.decorateCooked(function ($elem) {
            return $('.lazyYT', $elem).lazyYT({
              onPlay: function (e, $el) {
                // don't cloak posts that have playing videos in them
                var postId = parseInt($el.closest('article').data('post-id'));
                if (postId) {
                  api.preventCloak(postId);
                }
              }
            });
          });
        });
      }
    };
  });
define("discourse/plugins/poll/lib/even-round", 
  ["exports"],
  function(__exports__) {
    "use strict";
    // stolen from http://stackoverflow.com/a/13484088/11983
    function sumsUpTo100(percentages) {
      return percentages.map(function (p) {
        return Math.floor(p);
      }).reduce(function (a, b) {
        return a + b;
      }) === 100;
    }

    __exports__["default"] = function (percentages) {
      var sumOfDecimals = Math.ceil(percentages.map(function (a) {
        return a % 1;
      }).reduce(function (a, b) {
        return a + b;
      }));
      // compensate error by adding 1 to the first n "non-zero" items
      for (var i = 0, max = percentages.length; i < sumOfDecimals && i < max; i++) {
        if (percentages[i] > 0) {
          percentages[i] = ++percentages[i];
          // quit early when there is a rounding issue
          if (sumsUpTo100(percentages)) break;
        }
      }
      return percentages.map(function (p) {
        return Math.floor(p);
      });
    }
  });
define("discourse/plugins/poll/views/poll", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var on = __dependency1__.on;

    __exports__["default"] = Em.View.extend(_createDecoratedObject([{
      key: "templateName",
      initializer: function () {
        return "poll";
      }
    }, {
      key: "classNames",
      initializer: function () {
        return ["poll"];
      }
    }, {
      key: "attributeBindings",
      initializer: function () {
        return ["data-poll-type", "data-poll-name", "data-poll-status"];
      }
    }, {
      key: "poll",
      initializer: function () {
        return Em.computed.alias("controller.poll");
      }
    }, {
      key: "data-poll-type",
      initializer: function () {
        return Em.computed.alias("poll.type");
      }
    }, {
      key: "data-poll-name",
      initializer: function () {
        return Em.computed.alias("poll.name");
      }
    }, {
      key: "data-poll-status",
      initializer: function () {
        return Em.computed.alias("poll.status");
      }
    }, {
      key: "_fixPollContainerHeight",
      decorators: [on("didInsertElement")],
      value: function () {
        var pollContainer = this.$(".poll-container");
        pollContainer.height(pollContainer.height());
      }
    }]));
  });
define("discourse/plugins/poll/components/poll-results-number", 
  ["discourse/lib/round","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var round = __dependency1__["default"];

    __exports__["default"] = Em.Component.extend({
      tagName: "span",

      totalScore: (function () {
        return _.reduce(this.get("poll.options"), function (total, o) {
          var value = parseInt(o.get("html"), 10),
              votes = parseInt(o.get("votes"), 10);
          return total + value * votes;
        }, 0);
      }).property("poll.options.@each.{html,votes}"),

      average: (function () {
        var voters = this.get("poll.voters");
        return voters === 0 ? 0 : round(this.get("totalScore") / voters, -2);
      }).property("totalScore", "poll.voters"),

      averageRating: (function () {
        return I18n.t("poll.average_rating", { average: this.get("average") });
      }).property("average")

    });
  });
define("discourse/plugins/poll/components/poll-results-standard", 
  ["discourse/plugins/poll/lib/even-round","ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var evenRound = __dependency1__["default"];
    var computed = __dependency2__["default"];

    __exports__["default"] = Em.Component.extend(_createDecoratedObject([{
      key: "tagName",
      initializer: function () {
        return "ul";
      }
    }, {
      key: "classNames",
      initializer: function () {
        return ["results"];
      }
    }, {
      key: "options",
      decorators: [computed("poll.voters", "poll.type", "poll.options.[]")],
      value: function (voters, type) {
        var options = this.get("poll.options");

        var percentages = voters === 0 ? Array(options.length).fill(0) : _.map(options, function (o) {
          return 100 * o.get("votes") / voters;
        });

        // properly round percentages
        if (type === "multiple") {
          // when the poll is multiple choices, just "round down"
          percentages = percentages.map(function (p) {
            return Math.floor(p);
          });
        } else {
          // when the poll is single choice, adds up to 100%
          percentages = evenRound(percentages);
        }

        options.forEach(function (option, i) {
          var percentage = percentages[i];
          var style = new Handlebars.SafeString("width: " + percentage + "%");

          option.setProperties({
            percentage: percentage,
            style: style,
            title: I18n.t("poll.option_title", { count: option.get("votes") })
          });
        });

        return options;
      }
    }]));
  });
define("discourse/plugins/poll/components/poll-option", 
  ["exports"],
  function(__exports__) {
    "use strict";
    __exports__["default"] = Em.Component.extend({
      tagName: "li",
      attributeBindings: ["data-poll-option-id", "data-poll-selected"],

      "data-poll-option-id": Em.computed.alias("option.id"),

      "data-poll-selected": (function () {
        return this.get("option.selected") ? "selected" : false;
      }).property("option.selected"),

      render: function (buffer) {
        buffer.push(this.get("option.html"));
      },

      click: function (e) {
        // ensure we're not clicking on a link
        if ($(e.target).closest("a").length === 0) {
          this.sendAction("toggle", this.get("option"));
        }
      }
    });
  });
define("discourse/plugins/poll/controllers/poll", 
  ["ember-addons/ember-computed-decorators","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    function _createDecoratedObject(descriptors) { var target = {}; for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = true; descriptor.configurable = true; if ("value" in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === "function") { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator); } } } if (descriptor.initializer) { descriptor.value = descriptor.initializer.call(target); } Object.defineProperty(target, key, descriptor); } return target; }

    var computed = __dependency1__["default"];

    __exports__["default"] = Ember.Controller.extend(_createDecoratedObject([{
      key: "isMultiple",
      initializer: function () {
        return Ember.computed.equal("poll.type", "multiple");
      }
    }, {
      key: "isNumber",
      initializer: function () {
        return Ember.computed.equal("poll.type", "number");
      }
    }, {
      key: "isRandom",
      initializer: function () {
        return Ember.computed.equal("poll.order", "random");
      }
    }, {
      key: "isClosed",
      initializer: function () {
        return Ember.computed.equal("poll.status", "closed");
      }
    }, {
      key: "showingResults",

      // shows the results when
      //   - poll is closed
      //   - topic is archived
      //   - user wants to see the results
      initializer: function () {
        return Em.computed.or("isClosed", "post.topic.archived", "showResults");
      }
    }, {
      key: "showResultsDisabled",
      initializer: function () {
        return Em.computed.equal("poll.voters", 0);
      }
    }, {
      key: "hideResultsDisabled",
      initializer: function () {
        return Em.computed.or("isClosed", "post.topic.archived");
      }
    }, {
      key: "poll",
      decorators: [computed("model", "vote", "model.voters", "model.options", "model.status")],
      value: function (poll, vote) {
        if (poll) {
          var options = _.map(poll.get("options"), function (o) {
            return Em.Object.create(o);
          });

          if (vote) {
            options.forEach(function (o) {
              return o.set("selected", vote.indexOf(o.get("id")) >= 0);
            });
          }

          poll.set("options", options);
        }

        return poll;
      }
    }, {
      key: "selectedOptions",
      decorators: [computed("poll.options.@each.selected")],
      value: function () {
        return _.map(this.get("poll.options").filterBy("selected"), function (o) {
          return o.get("id");
        });
      }
    }, {
      key: "min",
      decorators: [computed("poll.min")],
      value: function (min) {
        min = parseInt(min, 10);
        if (isNaN(min) || min < 1) {
          min = 1;
        }
        return min;
      }
    }, {
      key: "max",
      decorators: [computed("poll.max", "poll.options.length")],
      value: function (max, options) {
        max = parseInt(max, 10);
        if (isNaN(max) || max > options) {
          max = options;
        }
        return max;
      }
    }, {
      key: "votersText",
      decorators: [computed("poll.voters")],
      value: function (count) {
        return I18n.t("poll.voters", { count: count });
      }
    }, {
      key: "totalVotes",
      decorators: [computed("poll.options.@each.votes")],
      value: function () {
        return _.reduce(this.get("poll.options"), function (total, o) {
          return total + parseInt(o.get("votes"), 10);
        }, 0);
      }
    }, {
      key: "totalVotesText",
      decorators: [computed("totalVotes")],
      value: function (count) {
        return I18n.t("poll.total_votes", { count: count });
      }
    }, {
      key: "multipleHelpText",
      decorators: [computed("min", "max", "poll.options.length")],
      value: function (min, max, options) {
        if (max > 0) {
          if (min === max) {
            if (min > 1) {
              return I18n.t("poll.multiple.help.x_options", { count: min });
            }
          } else if (min > 1) {
            if (max < options) {
              return I18n.t("poll.multiple.help.between_min_and_max_options", { min: min, max: max });
            } else {
              return I18n.t("poll.multiple.help.at_least_min_options", { count: min });
            }
          } else if (max <= options) {
            return I18n.t("poll.multiple.help.up_to_max_options", { count: max });
          }
        }
      }
    }, {
      key: "canCastVotes",
      decorators: [computed("isClosed", "showResults", "loading", "isMultiple", "selectedOptions.length", "min", "max")],
      value: function (isClosed, showResults, loading, isMultiple, selectedOptionCount, min, max) {
        if (isClosed || showResults || loading) {
          return false;
        }

        if (isMultiple) {
          return selectedOptionCount >= min && selectedOptionCount <= max;
        } else {
          return selectedOptionCount > 0;
        }
      }
    }, {
      key: "castVotesDisabled",
      initializer: function () {
        return Em.computed.not("canCastVotes");
      }
    }, {
      key: "canToggleStatus",
      decorators: [computed("loading", "post.user_id", "post.topic.archived")],
      value: function (loading, userId, topicArchived) {
        return this.currentUser && (this.currentUser.get("id") === userId || this.currentUser.get("staff")) && !loading && !topicArchived;
      }
    }, {
      key: "actions",
      initializer: function () {
        return {

          toggleOption: function (option) {
            if (this.get("isClosed")) {
              return;
            }
            if (!this.currentUser) {
              return this.send("showLogin");
            }

            var wasSelected = option.get("selected");

            if (!this.get("isMultiple")) {
              this.get("poll.options").forEach(function (o) {
                return o.set("selected", false);
              });
            }

            option.toggleProperty("selected");

            if (!this.get("isMultiple") && !wasSelected) {
              this.send("castVotes");
            }
          },

          castVotes: function () {
            var _this = this;

            if (!this.get("canCastVotes")) {
              return;
            }
            if (!this.currentUser) {
              return this.send("showLogin");
            }

            this.set("loading", true);

            Discourse.ajax("/polls/vote", {
              type: "PUT",
              data: {
                post_id: this.get("post.id"),
                poll_name: this.get("poll.name"),
                options: this.get("selectedOptions")
              }
            }).then(function (results) {
              _this.setProperties({ vote: results.vote, showResults: true });
              _this.set("model", Em.Object.create(results.poll));
            }).catch(function () {
              bootbox.alert(I18n.t("poll.error_while_casting_votes"));
            }).finally(function () {
              _this.set("loading", false);
            });
          },

          toggleResults: function () {
            this.toggleProperty("showResults");
          },

          toggleStatus: function () {
            if (!this.get("canToggleStatus")) {
              return;
            }

            var self = this,
                confirm = this.get("isClosed") ? "poll.open.confirm" : "poll.close.confirm";

            bootbox.confirm(I18n.t(confirm), I18n.t("no_value"), I18n.t("yes_value"), function (confirmed) {
              if (confirmed) {
                self.set("loading", true);

                Discourse.ajax("/polls/toggle_status", {
                  type: "PUT",
                  data: {
                    post_id: self.get("post.id"),
                    poll_name: self.get("poll.name"),
                    status: self.get("isClosed") ? "open" : "closed"
                  }
                }).then(function (results) {
                  self.set("model", Em.Object.create(results.poll));
                }).catch(function () {
                  bootbox.alert(I18n.t("poll.error_while_toggling_status"));
                }).finally(function () {
                  self.set("loading", false);
                });
              }
            });
          }
        };
      }
    }]));
  });
define("discourse/plugins/poll/initializers/extend-for-poll", 
  ["discourse/lib/plugin-api","exports"],
  function(__dependency1__, __exports__) {
    "use strict";
    var withPluginApi = __dependency1__.withPluginApi;

    function createPollView(container, post, poll, vote) {
      var controller = container.lookup("controller:poll", { singleton: false });
      var view = container.lookup("view:poll");

      controller.set("vote", vote);
      controller.setProperties({ model: poll, post: post });
      view.set("controller", controller);

      return view;
    }

    var _pollViews = undefined;

    function initializePolls(api) {

      var TopicController = api.container.lookupFactory('controller:topic');
      TopicController.reopen({
        subscribe: function () {
          var _this = this;

          this._super();
          this.messageBus.subscribe("/polls/" + this.get("model.id"), function (msg) {
            var post = _this.get('model.postStream').findLoadedPost(msg.post_id);
            if (post) {
              post.set('polls', msg.polls);
            }
          });
        },
        unsubscribe: function () {
          this.messageBus.unsubscribe('/polls/*');
          this._super();
        }
      });

      var Post = api.container.lookupFactory('model:post');
      Post.reopen({
        _polls: null,
        pollsObject: null,

        // we need a proper ember object so it is bindable
        pollsChanged: (function () {
          var _this2 = this;

          var polls = this.get("polls");
          if (polls) {
            this._polls = this._polls || {};
            _.map(polls, function (v, k) {
              var existing = _this2._polls[k];
              if (existing) {
                _this2._polls[k].setProperties(v);
              } else {
                _this2._polls[k] = Em.Object.create(v);
              }
            });
            this.set("pollsObject", this._polls);
          }
        }).observes("polls")
      });

      function cleanUpPollViews() {
        if (_pollViews) {
          Object.keys(_pollViews).forEach(function (pollName) {
            return _pollViews[pollName].destroy();
          });
        }
        _pollViews = null;
      }

      function createPollViews($elem, helper) {
        var $polls = $('.poll', $elem);
        if (!$polls.length) {
          return;
        }

        var post = helper.getModel();
        api.preventCloak(post.id);
        var votes = post.get('polls_votes') || {};

        post.pollsChanged();

        var polls = post.get("pollsObject");
        if (!polls) {
          return;
        }

        cleanUpPollViews();
        var postPollViews = {};

        $polls.each(function (idx, pollElem) {
          var $div = $("<div>");
          var $poll = $(pollElem);

          var pollName = $poll.data("poll-name");
          var pollId = pollName + "-" + post.id;
          var pollView = createPollView(helper.container, post, polls[pollName], votes[pollName]);

          $poll.replaceWith($div);
          Em.run.next(function () {
            return pollView.renderer.replaceIn(pollView, $div[0]);
          });
          postPollViews[pollId] = pollView;
        });

        _pollViews = postPollViews;
      }

      api.decorateCooked(createPollViews, { onlyStream: true });
      api.cleanupStream(cleanUpPollViews);
    }

    __exports__["default"] = {
      name: "extend-for-poll",

      initialize: function () {
        withPluginApi('0.1', initializePolls);
      }
    };
  });
Ember.TEMPLATES["javascripts/poll"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "poll-results-number", [], {"poll": get(env, context, "poll")});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "poll-results-standard", [], {"poll": get(env, context, "poll")});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "isNumber")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child1 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 1,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("          ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement, blockArguments) {
          var dom = env.dom;
          var hooks = env.hooks, set = hooks.set, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          set(env, context, "option", blockArguments[0]);
          inline(env, morph0, context, "poll-option", [], {"option": get(env, context, "option"), "toggle": "toggleOption"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("      ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("ul");
        var el2 = dom.createTextNode("\n");
        dom.appendChild(el1, el2);
        var el2 = dom.createComment("");
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("      ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(dom.childAt(fragment, [1]),1,1);
        block(env, morph0, context, "each", [get(env, context, "poll.options")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child2 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("span");
          dom.setAttribute(el2,"class","info-number");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n          ");
          dom.appendChild(el1, el2);
          var el2 = dom.createElement("span");
          dom.setAttribute(el2,"class","info-text");
          var el3 = dom.createComment("");
          dom.appendChild(el2, el3);
          dom.appendChild(el1, el2);
          var el2 = dom.createTextNode("\n        ");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var element0 = dom.childAt(fragment, [1]);
          var morph0 = dom.createMorphAt(dom.childAt(element0, [1]),0,0);
          var morph1 = dom.createMorphAt(dom.childAt(element0, [3]),0,0);
          content(env, morph0, context, "totalVotes");
          content(env, morph1, context, "totalVotesText");
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("        ");
          dom.appendChild(el0, el1);
          var el1 = dom.createElement("p");
          var el2 = dom.createComment("");
          dom.appendChild(el1, el2);
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, content = hooks.content;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createUnsafeMorphAt(dom.childAt(fragment, [1]),0,0);
          content(env, morph0, context, "multipleHelpText");
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "showingResults")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  var child3 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"class": "cast-votes", "title": "poll.cast-votes.title", "label": "poll.cast-votes.label", "disabled": get(env, context, "castVotesDisabled"), "action": "castVotes"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "unless", [get(env, context, "hideResultsDisabled")], {}, child0, null);
        return fragment;
      }
    };
  }());
  var child4 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"class": "toggle-results", "title": "poll.hide-results.title", "label": "poll.hide-results.label", "icon": "eye-slash", "disabled": get(env, context, "hideResultsDisabled"), "action": "toggleResults"});
        return fragment;
      }
    };
  }());
  var child5 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("    ");
        dom.appendChild(el0, el1);
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, inline = hooks.inline;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
        inline(env, morph0, context, "d-button", [], {"class": "toggle-results", "title": "poll.show-results.title", "label": "poll.show-results.label", "icon": "eye", "disabled": get(env, context, "showResultsDisabled"), "action": "toggleResults"});
        return fragment;
      }
    };
  }());
  var child6 = (function() {
    var child0 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"class": "toggle-status", "title": "poll.open.title", "label": "poll.open.label", "icon": "unlock-alt", "action": "toggleStatus"});
          return fragment;
        }
      };
    }());
    var child1 = (function() {
      return {
        isHTMLBars: true,
        revision: "Ember@1.12.2",
        blockParams: 0,
        cachedFragment: null,
        hasRendered: false,
        build: function build(dom) {
          var el0 = dom.createDocumentFragment();
          var el1 = dom.createTextNode("      ");
          dom.appendChild(el0, el1);
          var el1 = dom.createComment("");
          dom.appendChild(el0, el1);
          var el1 = dom.createTextNode("\n");
          dom.appendChild(el0, el1);
          return el0;
        },
        render: function render(context, env, contextualElement) {
          var dom = env.dom;
          var hooks = env.hooks, inline = hooks.inline;
          dom.detectNamespace(contextualElement);
          var fragment;
          if (env.useFragmentCache && dom.canClone) {
            if (this.cachedFragment === null) {
              fragment = this.build(dom);
              if (this.hasRendered) {
                this.cachedFragment = fragment;
              } else {
                this.hasRendered = true;
              }
            }
            if (this.cachedFragment) {
              fragment = dom.cloneNode(this.cachedFragment, true);
            }
          } else {
            fragment = this.build(dom);
          }
          var morph0 = dom.createMorphAt(fragment,1,1,contextualElement);
          inline(env, morph0, context, "d-button", [], {"class": "toggle-status btn-danger", "title": "poll.close.title", "label": "poll.close.label", "icon": "lock", "action": "toggleStatus"});
          return fragment;
        }
      };
    }());
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 0,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createComment("");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement) {
        var dom = env.dom;
        var hooks = env.hooks, get = hooks.get, block = hooks.block;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
        dom.insertBoundary(fragment, null);
        dom.insertBoundary(fragment, 0);
        block(env, morph0, context, "if", [get(env, context, "isClosed")], {}, child0, child1);
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createElement("div");
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","poll-container");
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n  ");
      dom.appendChild(el1, el2);
      var el2 = dom.createElement("div");
      dom.setAttribute(el2,"class","poll-info");
      var el3 = dom.createTextNode("\n    ");
      dom.appendChild(el2, el3);
      var el3 = dom.createElement("p");
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("span");
      dom.setAttribute(el4,"class","info-number");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n      ");
      dom.appendChild(el3, el4);
      var el4 = dom.createElement("span");
      dom.setAttribute(el4,"class","info-text");
      var el5 = dom.createComment("");
      dom.appendChild(el4, el5);
      dom.appendChild(el3, el4);
      var el4 = dom.createTextNode("\n    ");
      dom.appendChild(el3, el4);
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("\n");
      dom.appendChild(el2, el3);
      var el3 = dom.createComment("");
      dom.appendChild(el2, el3);
      var el3 = dom.createTextNode("  ");
      dom.appendChild(el2, el3);
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n\n");
      dom.appendChild(el0, el1);
      var el1 = dom.createElement("div");
      dom.setAttribute(el1,"class","poll-buttons");
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      var el2 = dom.createTextNode("\n");
      dom.appendChild(el1, el2);
      var el2 = dom.createComment("");
      dom.appendChild(el1, el2);
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var element1 = dom.childAt(fragment, [0]);
      var element2 = dom.childAt(element1, [3]);
      var element3 = dom.childAt(element2, [1]);
      var element4 = dom.childAt(fragment, [2]);
      var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),1,1);
      var morph1 = dom.createMorphAt(dom.childAt(element3, [1]),0,0);
      var morph2 = dom.createMorphAt(dom.childAt(element3, [3]),0,0);
      var morph3 = dom.createMorphAt(element2,3,3);
      var morph4 = dom.createMorphAt(element4,1,1);
      var morph5 = dom.createMorphAt(element4,3,3);
      var morph6 = dom.createMorphAt(element4,5,5);
      block(env, morph0, context, "if", [get(env, context, "showingResults")], {}, child0, child1);
      content(env, morph1, context, "poll.voters");
      content(env, morph2, context, "votersText");
      block(env, morph3, context, "if", [get(env, context, "isMultiple")], {}, child2, null);
      block(env, morph4, context, "if", [get(env, context, "isMultiple")], {}, child3, null);
      block(env, morph5, context, "if", [get(env, context, "showingResults")], {}, child4, child5);
      block(env, morph6, context, "if", [get(env, context, "canToggleStatus")], {}, child6, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/components/poll-results-standard"] = Ember.HTMLBars.template((function() {
  var child0 = (function() {
    return {
      isHTMLBars: true,
      revision: "Ember@1.12.2",
      blockParams: 1,
      cachedFragment: null,
      hasRendered: false,
      build: function build(dom) {
        var el0 = dom.createDocumentFragment();
        var el1 = dom.createTextNode("  ");
        dom.appendChild(el0, el1);
        var el1 = dom.createElement("li");
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","option");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("p");
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createElement("span");
        dom.setAttribute(el4,"class","percentage");
        var el5 = dom.createComment("");
        dom.appendChild(el4, el5);
        var el5 = dom.createTextNode("%");
        dom.appendChild(el4, el5);
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n        ");
        dom.appendChild(el3, el4);
        var el4 = dom.createComment("");
        dom.appendChild(el3, el4);
        var el4 = dom.createTextNode("\n      ");
        dom.appendChild(el3, el4);
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n    ");
        dom.appendChild(el1, el2);
        var el2 = dom.createElement("div");
        dom.setAttribute(el2,"class","bar-back");
        var el3 = dom.createTextNode("\n      ");
        dom.appendChild(el2, el3);
        var el3 = dom.createElement("div");
        dom.setAttribute(el3,"class","bar");
        dom.appendChild(el2, el3);
        var el3 = dom.createTextNode("\n    ");
        dom.appendChild(el2, el3);
        dom.appendChild(el1, el2);
        var el2 = dom.createTextNode("\n  ");
        dom.appendChild(el1, el2);
        dom.appendChild(el0, el1);
        var el1 = dom.createTextNode("\n");
        dom.appendChild(el0, el1);
        return el0;
      },
      render: function render(context, env, contextualElement, blockArguments) {
        var dom = env.dom;
        var hooks = env.hooks, set = hooks.set, content = hooks.content, get = hooks.get, attribute = hooks.attribute;
        dom.detectNamespace(contextualElement);
        var fragment;
        if (env.useFragmentCache && dom.canClone) {
          if (this.cachedFragment === null) {
            fragment = this.build(dom);
            if (this.hasRendered) {
              this.cachedFragment = fragment;
            } else {
              this.hasRendered = true;
            }
          }
          if (this.cachedFragment) {
            fragment = dom.cloneNode(this.cachedFragment, true);
          }
        } else {
          fragment = this.build(dom);
        }
        var element0 = dom.childAt(fragment, [1]);
        var element1 = dom.childAt(element0, [1, 1]);
        var element2 = dom.childAt(element0, [3, 1]);
        var morph0 = dom.createMorphAt(dom.childAt(element1, [1]),0,0);
        var morph1 = dom.createUnsafeMorphAt(element1,3,3);
        var attrMorph0 = dom.createAttrMorph(element2, 'style');
        set(env, context, "option", blockArguments[0]);
        content(env, morph0, context, "option.percentage");
        content(env, morph1, context, "option.html");
        attribute(env, attrMorph0, element2, "style", get(env, context, "option.style"));
        return fragment;
      }
    };
  }());
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, get = hooks.get, block = hooks.block;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, null);
      dom.insertBoundary(fragment, 0);
      block(env, morph0, context, "each", [get(env, context, "options")], {}, child0, null);
      return fragment;
    }
  };
}()));
Ember.TEMPLATES["javascripts/components/poll-results-number"] = Ember.HTMLBars.template((function() {
  return {
    isHTMLBars: true,
    revision: "Ember@1.12.2",
    blockParams: 0,
    cachedFragment: null,
    hasRendered: false,
    build: function build(dom) {
      var el0 = dom.createDocumentFragment();
      var el1 = dom.createComment("");
      dom.appendChild(el0, el1);
      var el1 = dom.createTextNode("\n");
      dom.appendChild(el0, el1);
      return el0;
    },
    render: function render(context, env, contextualElement) {
      var dom = env.dom;
      var hooks = env.hooks, content = hooks.content;
      dom.detectNamespace(contextualElement);
      var fragment;
      if (env.useFragmentCache && dom.canClone) {
        if (this.cachedFragment === null) {
          fragment = this.build(dom);
          if (this.hasRendered) {
            this.cachedFragment = fragment;
          } else {
            this.hasRendered = true;
          }
        }
        if (this.cachedFragment) {
          fragment = dom.cloneNode(this.cachedFragment, true);
        }
      } else {
        fragment = this.build(dom);
      }
      var morph0 = dom.createUnsafeMorphAt(fragment,0,0,contextualElement);
      dom.insertBoundary(fragment, 0);
      content(env, morph0, context, "averageRating");
      return fragment;
    }
  };
}()));

